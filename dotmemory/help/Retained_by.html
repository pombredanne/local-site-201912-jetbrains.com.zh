<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta charset="UTF-8"><title>按支配者分组-帮助|帮助点内存</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Retained_by" data-disqus-id="Retained_by_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected="">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Retained_by.xml" data-toc="Retained_by">按统治者分组</h1>    <p id="955687cc"><span class="control">通过“按主导者分组”</span>视图，您可以了解如何在应用程序中保留内存。例如，您知道应用程序中的大部分内存被字符串占用。但是，最有可能的是，优化的主题不是这些字符串本身，而是存储它们的数据结构。“ <span class="control">按主宰者分组</span> ”视图回答了“谁保留内存”的问题，这在分析无效的内存使用情况时非常重要。为了正确回答这个问题，您应该熟悉<i id="f05abe40">主导者</i>的概念。</p>    <div class="chapter"><h2 id="what-is-a-dominator" data-toc="Retained_by#what-is-a-dominator">什么是支配者？</h2>        <p id="e0c49e0f">对象A <i id="a8f9b7fd">占主导地位</i>的对象B，如果从应用程序的根乙每一条路径经过A.换句话说，对象B被保留在存储器中仅通过对象A：如果A是垃圾收集，B也垃圾收集。例如，数组是其元素的主导者（如果没有其他对数组元素的引用）。</p><figure><img alt="对象保留示例" title="对象保留示例" src="/help/img/dotnet/2019.2/retained_by_1.png" id="f9b55aae" width="517" height="232"></figure>如果从应用程序的根目录到对象的路径不止一个，则将其视为非主导对象或非<span class="emphasis">专有保留</span>对象。例如，如果对象C被对象A和B保留，而A被垃圾回收，则C将保留在内存中（因为B仍引用该对象）。这就是为什么理解<span class="emphasis">控制路径</span> （路径上的任何对象只能由一个其他对象<span class="emphasis">保留</span> ）和<span class="emphasis">保留路径</span> （路径上的一个对象可以由任意数量的其他对象保留）之间的区别很重要的原因。<p id="fc48d324">“ <span class="control">按主导者分组”</span>视图包括两个部分：</p>        <ul class="list _ul"><li class="list__item" id="7d64df6c"><p>左侧的支配者<a href="#tree">树列表</a> 。</p></li><li class="list__item" id="ba772e09"><p>                右边的<a href="#sunburst-chart">森伯斯特图</a> ：树形列表的图形表示。</p></li></ul>    </div>    <div class="chapter"><h2 id="tree" data-toc="Retained_by#tree">统治者树</h2>        <p id="aaae6f34">右侧的树显示了所选对象集的<i id="009e17d3">支配者</i>树。</p>        <p id="f683f8c8">该树可以在两种模式下工作，可以通过树头中的相应按钮进行选择：</p><ul class="list _ul"><li class="list__item" id="d5a1f3a5"><p>                    <span class="control">树</span> ：显示所有支配者节点。<b id="d79358fd">粗体</b>显示了参与所选树节点的支配路径的支配者。</p></li><li class="list__item" id="415f3172"><p>                    <span class="control">路径</span> ：仅显示参与所选树节点的支配路径的支配者。</p></li></ul>                <p id="f5c3e109">支配者列表由以下几列组成：</p>        <div class="table-wrapper"><table width="100%" id="71995984"><thead><tr id="8d571b8e" class="ijRowHead"><th id="1377feb3"><p>名称</p></th><th id="24546217"><p>描述</p></th></tr></thead><tbody><tr id="da85fcaa" class="ijRowOdd"><td id="322cd4f5">                    <span class="control">类型</span>                </td><td id="7259dd04"><p>输入名称。<br>类型名称左边的数字表示该类型保留了多少个该类型的对象。例如，某些整数数组A的元素以完全相同的方式保留（A-&gt;元素），但是整数数组B的元素具有另一个保留路径（B-&gt;元素）。</p></td></tr><tr id="9cb70b23" class="ijRowEven"><td id="ad951bf6">                    <span class="control">保留字节</span>                </td><td id="31f91cca"><p>独占保留对象的总大小（以字节为单位）。</p></td></tr><tr id="eae50209" class="ijRowOdd"><td id="68ff79a4">                    <span class="control">保留物</span>                </td><td id="db589b5e"><p>支配者支配的对象数。</p></td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="sunburst-chart" data-toc="Retained_by#sunburst-chart">朝阳图</h2>        <p id="b36520c5">左侧的森伯斯特图表是支配者树的图形表示。支配者保留的内存越多，中心角越大。</p>        <p id="40f20354">由于必须扩展其节点并解释“ <span class="control">保留字节数”</span>列中的数字，因此对控制树的分析可能会非常复杂。相比之下，只要看一眼朝阳图就可以确定应用程序中的主要支配者和最大的结构。单击您感兴趣的支配者将在树中显示其支配路径。</p>        <p id="a8f86b80">考虑下面的<a href="#example">示例，</a>以更好地了解朝阳图如何显示来自主导者树的数据。</p>        <div class="chapter"><h3 id="zooming-in-and-out">放大和缩小</h3>            <p id="ce112b95">如果您想更详细地了解某个支配者子树，则可以更改图表的比例。</p>            <section class="procedure-steps"><h3 id="47c324e3">放大统治者</h3><ul class="list "><li class="list__item" id="058a6df6">                    <p id="68c336b6">请执行以下任一操作：</p>                    <ul class="list _ul"><li class="list__item" id="c5146ea0"><p>双击图表中的相应弧，或从上下文菜单中选择“ <span class="control">放大”</span> 。</p></li><li class="list__item" id="1eb5c470"><p>双击树中的主导者或选择树，然后按Enter。</p></li></ul>                    <p id="29388b92">支配者将成为图表的根源。</p>                </li></ul></section>            <section class="procedure-steps"><h3 id="6ff6afbc">缩小</h3><ul class="list "><li class="list__item" id="eb544334"><p>单击图表的中心。</p></li></ul></section>                    </div>    </div>    <div class="chapter"><h2 id="example" data-toc="Retained_by#example">例</h2>        <aside class="note " rel="example" id="4b8d3039" data-title="">            <p id="07a4c77b">为方便起见，当一组控制者太小而无法在当前比例尺中显示时，图表将它们显示为一个<img alt="较小的物体" title="较小的物体" src="/help/img/dotnet/2019.2/icicles_8.png" id="f99ab61d" width="13" height="18" class="inline-icon-13"> <i id="e4dee25c">较小的物体是</i>弧形的。</p>        </aside>        <figure><img alt="按统治者分组示例" title="按统治者分组示例" src="/help/img/dotnet/2019.2/retained_by_3.png" id="3f32a266" width="695" height="580"></figure>    </div>            <div class="chapter"><h2 id="filtering-objects" data-toc="Retained_by#filtering-objects">过滤对象</h2>            <p id="4ebed2ce">您可以过滤出与分析无关的对象。</p>            <section class="procedure-steps"><h3 id="26d34d47">缩小清单</h3><ul class="list "><li class="list__item" id="1517696c">开始在“ <span class="control">过滤器”</span>字段中键入所需的类型名称。<p id="f999cafb">dotMemory将排除所有与模式不匹配的实例。</p>                </li></ul></section>            <p id="filtering_rules">您可以使用以下提示来提高搜索效率：</p><ul class="list _ul"><li class="list__item" id="6b307384"><p>使用<span class="emphasis">CamelHumps</span> 。例如， <code class="code">fo</code>将返回两个<code class="code">System.对象<code class="code">System.画画。Font</code>和<code class="code">MS.Utility.FrugalObjectList</code>类型。</p></li><li class="list__item" id="99c7b9ed"><p>使用<span class="emphasis">特殊符号</span> ，例如通配符和其他<span class="emphasis">符号</span> 。完整列表如下表所示。</p></li></ul>                        <div class="table-wrapper"><table class=" wide" width="100%" id="7e1a66fc"><thead><tr id="c2950028" class="ijRowHead"><th id="84f53bd4"><p>符号</p></th><th id="2b9e21b2"><p>描述</p></th><th id="9b280ed7"><p>例</p></th></tr></thead><tbody><tr id="ea66c38f" class="ijRowOdd"><td id="8e44e0c6" rowspan="3">                        <code class="code">*</code>                    </td><td id="10940ecd" rowspan="3"><p>通配符</p></td><td id="d527889c"><p>                        <code class="code">*</code> <br>集合中的所有对象</p></td></tr><tr id="81f41fb4" class="ijRowEven"><td id="64e6c0c1"><p>                        <code class="code">sys。*。数据</code> <br>与模式匹配的所有类型和名称空间。例如<code class="code">System.Data</code> ， <code class="code">System.视窗。控件。Datagrid</code>和<code class="code">System.视窗。数据。Binding</code> 。</p></td></tr><tr id="634974e8" class="ijRowOdd"><td id="5f2aba3f"><p>                        <code class="code">sys。*。数据。</code> <br>仅匹配模式的名称空间。例如<code class="code">系统。视窗。数据。Binding</code>但<span class="emphasis">不</span> Binding</code> <code class="code">System.视窗。控件。Datagrid</code> 。</p></td></tr><tr id="33f41cba" class="ijRowEven"><td id="7aca8ae9" colspan="3">                        <span class="emphasis">数组</span>                    </td></tr><tr id="bd36bbb9" class="ijRowOdd"><td id="d5d864a5"><p>[]</p></td><td id="231e412e"><p>只保留数组</p></td><td id="77449764"><p>                        <code class="code">str []</code> <br>数组，其类型或名称空间中包含<code class="code">str</code> 。例如<code class="code">String[]</code> 。</p></td></tr><tr id="5aa054ef" class="ijRowEven"><td id="28493763" rowspan="2"><p>                        <code class="code">[，</code> <br>                        <code class="code">[,,</code> <br>                        <code class="code">...</code> <br>要么<br>                        <code class="code">[，]</code> <br>                        <code class="code">[,,]</code> <br>                        <code class="code">...</code>                    </p></td><td id="6c03bd2a" rowspan="2"><p>仅保留指定或更高尺寸的数组（如果未关闭方括号）</p></td><td id="3102b86f"><p>                        <code class="code">str [,,</code> <br>维度为3或更高的数组，其类型或名称空间中包含<code class="code">str</code> 。例如<code class="code">String[,,]</code>和<code class="code">String[,,,]</code> 。</p></td></tr><tr id="6936c459" class="ijRowOdd"><td id="b7bc1696"><p>                        <code class="code">str [,,]</code> <br>在其类型或名称空间中包含<code class="code">str</code>的三维数组。例如<code class="code">String[,,]</code> 。</p></td></tr><tr id="18de9a75" class="ijRowEven"><td id="ee0bdce8">                        <code class="code">！一种</code>                    </td><td id="8ba93e9a"><p>从结果中排除数组</p></td><td id="2a866739"><p>                        <code class="code">！一个str</code> <br>在其类型或名称空间中包含<code class="code">str</code>对象（不包括数组）。例如<code class="code">String</code>但<span class="emphasis">不是</span> <code class="code">String[]</code> 。</p></td></tr><tr id="d69d115b" class="ijRowOdd"><td id="7ef64e62" colspan="3">                        <span class="emphasis">泛型类型参数</span>                    </td></tr><tr id="2d13fc21" class="ijRowEven"><td id="a11c8040" rowspan="2">                        <code class="code">&lt;</code>                    </td><td id="fff830d0" rowspan="2"><p>仅保留具有通用类型参数的类型</p></td><td id="d6458e89"><p>                        <code class="code">str &lt;</code> <br>仅对象的类型或名称空间中包含<code class="code">str</code>并具有泛型类型参数的对象。例如<code class="code">FileStreamStorage&lt;Char&gt;</code>但<span class="emphasis">不是</span> <code class="code">List&lt;String&gt;</code> 。</p></td></tr><tr id="b461d724" class="ijRowOdd"><td id="e1d75248"><p>                        <code class="code">&lt;str</code> <br>仅在其通用类型参数中包含<code class="code">str</code>对象。例如<code class="code">List&lt;String&gt;</code>但<span class="emphasis">不是</span> <code class="code">FileStreamStorage&lt;Char&gt;</code> 。</p></td></tr><tr id="a4366b54" class="ijRowEven"><td id="c8607e6f" rowspan="2"><p>                        <code class="code">&lt;，</code> <br>                        <code class="code">&lt;,,</code> <br>                        <code class="code">...</code> <br>要么<br>                        <code class="code">&lt;，&gt;</code> <br>                        <code class="code">&lt;,,&gt;</code> <br>                        <code class="code">...</code> <br>                    </p></td><td id="c7d2a3ca" rowspan="2"><p>仅保留具有指定数量的泛型类型参数的对象</p></td><td id="df95ee13"><p>                        <code class="code">有趣&lt;,,&gt;</code> <br>对象的类型或名称空间中包含<code class="code">fun</code>并且具有三个泛型类型参数。例如<code class="code">Func&lt;String, Object, Object&gt;</code> 。</p></td></tr><tr id="8002a13f" class="ijRowOdd"><td id="af3bc9a5"><p>                        <code class="code">fun &lt;str ,, task</code> <br>对象的类型或名称空间中包含<code class="code">fun</code> ，并且具有与模式匹配的三个或通用类型参数。例如<code class="code">Func&lt;Stream, IAsyncResult, TaskResult, EventArgs&gt;</code> 。</p></td></tr><tr id="e3feead5" class="ijRowEven"><td id="4cd984ac">                        <code class="code">！G</code>                    </td><td id="c5003526"><p>从搜索范围中排除泛型类型参数</p></td><td id="08faa416"><p>                        <code class="code">！str</code> <br>在类型或名称空间中包含<code class="code">str</code>对象（不具有通用类型参数）。例如<code class="code">String</code>但<span class="emphasis">不是</span> <code class="code">List&lt;String&gt;</code> 。</p></td></tr></tbody></table></div>        </div>        <div class="chapter"><h2 id="selecting-objects-for-further-an" data-toc="Retained_by#selecting-objects-for-further-an">选择对象进行进一步分析</h2>        <p id="ee754c7f">在“ <span class="control">按主宰者分组”</span>视图中，可以选择以下主题进行进一步分析：</p>        <ul class="list _ul"><li class="list__item" id="0ff91ef4"><p>                <a href="#retained">由特定控制者保留的对象</a> ;</p></li><li class="list__item" id="c62f7608"><p>                <a href="#dominator">支配者</a> 。</p></li><li class="list__item" id="9c5febfb"><p>                                    <a href="#set">由整个对象集专有保留（控制）的对象</a> 。</p></li></ul>        <section class="procedure-steps"><h3 id="retained">打开特定控制者保留的对象</h3><ul class="list "><li class="list__item" id="f172b768">                <p id="f83e7686">请执行以下任一操作：</p>                <ul class="list _ul"><li class="list__item" id="79f94f2a"><p>按住<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt</span></kbd>并单击树或图表上的主控器。</p></li><li class="list__item" id="178090e4"><p>右键单击该支配器，然后在上下文菜单中选择“ <span class="control">打开通过此支配路径保留的对象”</span> 。</p></li></ul>                <p id="82369be8">此后，将<span class="control">通过[type_name]</span>主题<span class="control">保留</span>的<span class="control">对象</span>添加到“ <a href="First_Look_at_the_dotMemory_s_User_Interface.html#ui">分析路径”，</a>并且所需对象的列表将显示在“ <a href="Type_List.html">按类型分组”</a>视图中。</p>            </li></ul></section>        <section class="procedure-steps"><h3 id="dominator">打开支配者对象集</h3><ul class="list "><li class="list__item" id="579c94eb">                <p id="68a7a340">请执行以下任一操作：</p>                <ul class="list _ul"><li class="list__item" id="865a3b04"><p>按住<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Shift键</span></kbd> ，然后在树中或图表上单击支配者。</p></li><li class="list__item" id="19e98513"><p>右键单击控制项，然后在上下文菜单中选择“ <span class="control">打开此对象集</span> ”。</p></li></ul>                <p id="67523db1">此后， <span class="control">[type_name]</span>主题的“ <span class="control">主宰者”</span>将被添加到“ <a href="First_Look_at_the_dotMemory_s_User_Interface.html#ui">分析路径”，</a>并且所需对象的列表将显示在“ <a href="Type_List.html">按类型分组”</a>视图中。</p>            </li></ul></section>                    <section class="procedure-steps"><h3 id="set">选择分析对象集专有保留的对象</h3><ul class="list "><li class="list__item" id="fb755a9b">                    <p id="5666ee5f">点击<img alt="打开保留的对象" title="打开保留的对象" src="/help/img/dotnet/2019.2/open_retained_objects_button.png" id="9ca9e8ad" width="25" height="23" class="inline-icon-25"> <span class="control">打开此设置</span>按钮<span class="control">保留的对象</span> 。</p>                    <p id="3a328f8f">此后，“ <span class="control">专有保留的对象”</span>主题将添加到“ <a href="First_Look_at_the_dotMemory_s_User_Interface.html#ui">分析路径”，</a>并且所需对象的列表将显示在“ <a href="Type_List.html">按类型分组”</a>视图中。</p>                </li></ul></section>            </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Type_List.html">按类型</a> <a class="navigation-links__next" href="Similar_Retention.html">分组按相似保留分组</a></div><section class="seealso" data-skip-index="skip"><div class="seealso__header"><h2>也可以看看</h2></div><div class="seealso__content"><div class="seealso__col" data-skip-index="skip"><h3>参考：</h3><ul class="list"><li class="list__item"><a href="Reference__Views_Legend.html">图示</a></li><li class="list__item"><a href="Type_List.html">按类型分组</a></li><li class="list__item"><a href="Similar_Retention.html">按类似保留率分组</a></li><li class="list__item"><a href="Shortest_Path.html">按最短路径分组</a></li><li class="list__item"><a href="Creation_Stack_Trace.html">按创建堆栈跟踪分组</a></li><li class="list__item"><a href="Generations.html">按世代分组</a></li><li class="list__item"><a href="Instances.html">按实例分组</a></li></ul></div></div></section></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>