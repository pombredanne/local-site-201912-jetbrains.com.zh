<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        .NET memory issues, automatic check memory issue, find C# memory leak,&#xA;        WPF issues&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Automatic Inspections - Help | dotMemory</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Inspections" data-disqus-id="Inspections_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Inspections" id="Inspections.xml">Automatic Inspections</h1>            <p id="c79c3696">dotMemory automatically detects the following memory issues.</p>    <div class="chapter"><h2 id="strings_leak" data-toc="Inspections#strings_leak">String duplicates</h2>    <p id="4a4c36f2">        Repeatedly creating strings with the same value instead of reusing the existing one wastes memory. dotMemory        detects duplicated strings and shows how much memory is wasted.    </p>    <section class="procedure-steps"><h3 id="59b0d43e">To analyze the objects</h3><ul class="list "><li class="list__item" id="754ef1e7"><p>Click the link in the inspection header or double-click a particular object set in the list.</p></li></ul></section>    <section class="procedure-steps"><h3 id="96f54e52">To fix the issue</h3><ul class="list "><li class="list__item" id="365d108a"><p>            If strings with the same value waste huge amount of memory or generate significant traffic            (for example, if your app parses text input) consider implementing            <a href="http://blog.jetbrains.com/dotnet/2015/02/12/string-interning-effective-memory-management-with-dotmemory/" data-external="true" target="_blank" rel="noopener noreferrer">string interning</a>.        </p></li></ul></section>    </div>    <div class="chapter"><h2 id="sparse_arrays" data-toc="Inspections#sparse_arrays">Sparse arrays</h2>        <p id="67b44717">Sparse arrays are arrays which are mostly filled with zero elements. Sparse arrays are inefficient            from the perspective of performance and memory usage.            dotMemory automatically finds sparse arrays and shows you how much memory is lost (occupied by            zero values) because of them.                    </p>        <section class="procedure-steps"><h3 id="d279e423">To analyze sparse arrays</h3><ul class="list "><li class="list__item" id="c6e7b7e6"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>    </div>    <div class="chapter"><h2 id="finalized_objects" data-toc="Inspections#finalized_objects">Finalizable objects</h2>        <p id="eac48d4c">            Finalizable objects are the objects that use the            <code class="code">Finalize()</code>            method to release unmanaged resources. The problem of            using this pattern is, first, that the lifetime of finalizable objects is extended by at least one more GC            cycle            and, second, that the finalization thread (that executes the            <code class="code">Finalize()</code>            method) is run unpredictably. This may cause problems in case you want to reclaim the released resources            as quickly as possible and may lead to sudden performance drops.            dotMemory detects and shows all objects queued for finalization and <b id="7b3dbcc5">objects finalized since the previous            snapshot</b>.        </p>        <section class="procedure-steps"><h3 id="4034285b">To analyze finalizable objects</h3><ol class="list _decimal"><li class="list__item" id="2b7b5eec"><p>Click the link in the inspection header or double-click any type in the list.</p></li><li class="list__item" id="57cd3253"><p>                To leave only types that implement <code class="code">IDisposable</code>, type <code class="code">#d</code> in                the <a href="Type_List.html#filtering_rules">Filter</a> field. Note                that all disposable types are marked with the <img alt="disposable icon" title="disposable icon" src="/help/img/dotnet/2019.2/disposable_icon.png" id="0c4e13c2" width="15" height="14" class="inline-icon-15"> icon.            </p></li><li class="list__item" id="e91e6b3a"><p>                To leave only types that do <span class="emphasis">not</span> implement <code class="code">IDisposable</code>,                type <code class="code">!d</code> in                the <a href="Type_List.html#filtering_rules">Filter</a> field.            </p></li></ol></section>        <section class="procedure-steps"><h3 id="40b109ae">To fix the issue</h3><ul class="list "><li class="list__item" id="0250abf3"><p>Implement the                <code class="code">IDisposable</code>                interface for the type that causes issues and release all unmanaged resources                via its <code class="code">Dispose()</code> method. For more details on the dispose pattern, refer to                <a href="https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx" data-external="true" target="_blank" rel="noopener noreferrer">MSDN</a>.            </p></li></ul></section>    </div>    <div class="chapter"><h2 id="event_handlers_leak" data-toc="Inspections#event_handlers_leak">Event handlers leak</h2>        <p id="03a79edb">This type of leak occurs when subscribing an object (let's call it listener) to an event of some other object            (let's call it source). For example:            <code class="code">Timer1.Tick += OnTimer;</code>            During subscription, the source object gets a reference to the event handler of the listener object. If you            delete the listener, this reference will prevent it from being garbage collected. dotMemory automatically            finds            objects that are referenced in event handlers but are never unsubscribed from corresponding events.                    </p>        <section class="procedure-steps"><h3 id="1322c98b">To analyze the objects</h3><ul class="list "><li class="list__item" id="c36bbd2f"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>        <section class="procedure-steps"><h3 id="796e2a38">To fix the issue</h3><ul class="list "><li class="list__item" id="1cd70d75"><p>Unsubscribe the listener from the event when it is no longer needed.                For example:                <code class="code">Timer1.Tick -= OnTimer;</code>            </p></li></ul></section>    </div>    <div class="chapter"><h2 id="wpf_binding_leak" data-toc="Inspections#wpf_binding_leak">WPF binding leak</h2>        <p id="3b8707ce">            Breaking WPF data binding patterns also can cause a memory leak. After you perform data binding to            some property of a source object, the binding target object starts to listen for property change            notifications.            If the property is not a            <code class="code">DependencyProperty</code>            object and the target object does not implement the            <code class="code">INotifyPropertyChanged</code>            interface, a memory leak in source object and in every object            to which source object refers may occur.            dotMemory detects such binding pattern violations and shows you the list of objects that may            potentially cause this leak type.            <aside class="note " data-title="" rel="a042385b" id="a5892dcd"><p>The leak will not take place in case the OneTime binding mode is used to update the target.</p></aside>                    </p>        <section class="procedure-steps"><h3 id="b8a5cdbe">To analyze the objects</h3><ul class="list "><li class="list__item" id="178c5f67"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>        <section class="procedure-steps"><h3 id="bf3f2736">To fix the issue</h3><ul class="list "><li class="list__item" id="4a317cf8"><p>Make the source object implement the                <code class="code">INotifyPropertyChanged</code>                interface or remove binding when it is no longer needed using the                <code class="code">ClearBinding</code>                method.            </p></li></ul></section>    </div>    <div class="chapter"><h2 id="wpf_collection_binding_leak" data-toc="Inspections#wpf_collection_binding_leak">WPF collection binding leak</h2>        <p id="5229b12c">This leak is similar to the WPF binding leak described above. If there is binding to a collection that does            not            implement the <code class="code">INotifyCollectionChanged</code> interface, WPF creates a strong reference to this            collection. As a result, it stays in memory for the entire application lifetime. dotMemory detects and shows            you such objects.                    </p>        <section class="procedure-steps"><h3 id="71d4178b">To analyze the objects</h3><ul class="list "><li class="list__item" id="ebc7bacf"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>        <section class="procedure-steps"><h3 id="ae0f0478">To fix the issue</h3><ul class="list "><li class="list__item" id="a1b0e321"><p>Make the source collection implement the                <code class="code">INotifyCollectionChanged</code>                interface. Another way is to use the                <code class="code">ObservableCollection</code>                collection as it already implements the <code class="code">INotifyCollectionChanged</code> interface.            </p></li></ul></section>    </div>    <div class="chapter"><h2 id="dependency_property_leak" data-toc="Inspections#dependency_property_leak">Dependency property leak</h2>                                                                            <p id="0eeb3cdb">        This leak occurs due to quite the same reasons as the event handlers leak.        GC will not collect objects subscribed on        <code class="code">DependencyProperty</code>        changes through the <code class="code">AddValueChanged</code> method until they are        unsubscribed using the <code class="code">RemoveValueChanged</code> method.        dotMemory detects and shows you all such A objects.            </p>    <section class="procedure-steps"><h3 id="261ccaef">To analyze the objects</h3><ul class="list "><li class="list__item" id="fd58af99"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>    <section class="procedure-steps"><h3 id="5fa775e4">To fix the issue</h3><ul class="list "><li class="list__item" id="84b32f4d"><p>When the lifetime of a subscribed object is over, take care of unsubscribing it using the            <code class="code">RemoveValueChanged</code>            method.        </p></li></ul></section>    </div>    <div class="chapter"><h2 id="xname" data-toc="Inspections#xname">x:Name WPF leak</h2>        <p id="4883b3ff">This leak takes place because of the following WPF peculiarity: WPF creates a strong global reference to the            UI element that is declared in XAML and uses the x:Name directive. For example:            <code class="code">&lt; XNameTest:UserControl1 Grid.Row="0" x:Name="myControl1"/&gt;</code>            Thus, if you dynamically remove the element declared in such a way, it will still be in memory.                    </p>        <section class="procedure-steps"><h3 id="620d29c8">To analyze the objects</h3><ul class="list "><li class="list__item" id="e5eebc9f"><p>Click the link in the inspection header or double-click a particular object in the list.</p></li></ul></section>        <section class="procedure-steps"><h3 id="e3ab760f">To fix the issue</h3><ul class="list "><li class="list__item" id="75d5d71c"><p>One way to remove the leak is to declare the UI element in the C# code instead of XAML.                Another way is to call the <code class="code">UnregisterName</code> method of the parent control when you want                to remove the UI element. For example:                <code class="code">this.UnregisterName("myControl1");</code>            </p></li></ul></section>    </div><div class="last-modified" data-skip-index="skip">Last modified: 8 August 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Snapshot_View.html">Inspections View</a><a class="navigation-links__next" href="Heap_Fragmentation.html">Heap Fragmentation</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>