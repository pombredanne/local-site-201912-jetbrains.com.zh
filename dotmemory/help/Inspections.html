<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        .NET memory issues, automatic check memory issue, find C# memory leak,
        WPF issues
    " data-skip-index="skip"><meta charset="UTF-8"><title>自动检查-帮助|点内存</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Inspections" data-disqus-id="Inspections_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected="">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Inspections.xml" data-toc="Inspections">自动检查</h1>            <p id="c79c3696">dotMemory将自动检测以下内存问题。</p>    <div class="chapter"><h2 id="strings_leak" data-toc="Inspections#strings_leak">字符串重复</h2>    <p id="4a4c36f2">重复创建具有相同值的字符串而不是重用现有的字符串会浪费内存。 dotMemory检测重复的字符串，并显示浪费了多少内存。</p>    <section class="procedure-steps"><h3 id="59b0d43e">分析对象</h3><ul class="list "><li class="list__item" id="754ef1e7"><p>单击检查标题中的链接，或双击列表中的特定对象集。</p></li></ul></section>    <section class="procedure-steps"><h3 id="96f54e52">解决问题</h3><ul class="list "><li class="list__item" id="365d108a"><p>如果具有相同值的字符串浪费大量内存或产生大量流量（例如，如果您的应用解析文本输入），请考虑实现<a href="http://blog.jetbrains.com/dotnet/2015/02/12/string-interning-effective-memory-management-with-dotmemory/" rel="noopener noreferrer" data-external="true" target="_blank">字符串实习</a> 。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="sparse_arrays" data-toc="Inspections#sparse_arrays">稀疏数组</h2>        <p id="67b44717">稀疏数组是大多数用零元素填充的数组。从性能和内存使用的角度来看，稀疏阵列效率低下。 dotMemory会自动查找稀疏数组，并向您显示由于它们而导致的内存丢失（由零值占用）。</p>        <section class="procedure-steps"><h3 id="d279e423">分析稀疏数组</h3><ul class="list "><li class="list__item" id="c6e7b7e6"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="finalized_objects" data-toc="Inspections#finalized_objects">可终结对象</h2>        <p id="eac48d4c"><code class="code">Finalize()</code>对象是使用<code class="code">Finalize()</code>方法释放非托管资源的对象。使用此模式的问题是，首先，可终结对象的生存期至少延长了一个GC周期，其次，终结线程（执行<code class="code">Finalize()</code>方法）无法正常运行。如果您想尽快回收释放的资源，这可能会引起问题，并可能导致突然的性能下降。 dotMemory检测并显示排队的所有对象以进行<b id="7b3dbcc5">最后</b>确定，以及<b id="7b3dbcc5">自上次快照以来已</b>完成的<b id="7b3dbcc5">对象</b> 。</p>        <section class="procedure-steps"><h3 id="4034285b">分析可终结对象</h3><ol class="list _decimal"><li class="list__item" id="2b7b5eec"><p>单击检查标题中的链接，或双击列表中的任何类型。</p></li><li class="list__item" id="57cd3253"><p>要仅保留实现<code class="code">IDisposable</code>类型， <code class="code">#d</code>在“ <a href="Type_List.html#filtering_rules">过滤器”</a>字段中键入<code class="code">#d</code> 。请注意，所有一次性类型均标有<img alt="一次性图标" title="一次性图标" src="/help/img/dotnet/2019.2/disposable_icon.png" id="0c4e13c2" width="15" height="14" class="inline-icon-15">图标。</p></li><li class="list__item" id="e91e6b3a"><p>要仅保留<span class="emphasis">未</span>实现<code class="code">IDisposable</code>类型，请输入<code class="code">!d</code>在<a href="Type_List.html#filtering_rules">过滤器</a>字段中。</p></li></ol></section>        <section class="procedure-steps"><h3 id="40b109ae">解决问题</h3><ul class="list "><li class="list__item" id="0250abf3"><p>为引起问题的类型实现<code class="code">IDisposable</code>接口，并通过其<code class="code">Dispose()</code>方法释放所有非托管资源。有关处置模式的更多详细信息，请参阅<a href="https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.110).aspx" rel="noopener noreferrer" data-external="true" target="_blank">MSDN</a> 。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="event_handlers_leak" data-toc="Inspections#event_handlers_leak">事件处理程序泄漏</h2>        <p id="03a79edb">当将一个对象（我们称为侦听器）订阅某个其他对象（我们称为源）的事件时，会发生这种类型的泄漏。例如： <code class="code">Timer1.Tick += OnTimer;</code>在订阅期间，源对象获取对侦听器对象的事件处理程序的引用。如果删除侦听器，则此引用将防止垃圾回收。 dotMemory会自动查找事件处理程序中引用的对象，但不会从相应的事件中取消订阅该对象。</p>        <section class="procedure-steps"><h3 id="1322c98b">分析对象</h3><ul class="list "><li class="list__item" id="c36bbd2f"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>        <section class="procedure-steps"><h3 id="796e2a38">解决问题</h3><ul class="list "><li class="list__item" id="1cd70d75"><p>当不再需要事件时，请取消订阅该事件的侦听器。例如： <code class="code">Timer1.勾选-= OnTimer;</code>            </p></li></ul></section>    </div>    <div class="chapter"><h2 id="wpf_binding_leak" data-toc="Inspections#wpf_binding_leak">WPF绑定泄漏</h2>        <p id="3b8707ce">破坏WPF数据绑定模式也可能导致内存泄漏。在对源对象的某些属性执行数据绑定之后，绑定目标对象开始侦听属性更改通知。如果该属性不是<code class="code">DependencyProperty</code>对象，并且目标对象未实现<code class="code">INotifyPropertyChanged</code>接口，则可能在源对象以及源对象引用的每个对象中发生内存泄漏。 dotMemory检测到此类绑定模式违规，并向您显示可能导致此泄漏类型的对象列表。</p><aside class="note " rel="a042385b" id="a5892dcd" data-title=""><p>如果使用OneTime绑定模式更新目标，则不会发生泄漏。</p></aside>                            <section class="procedure-steps"><h3 id="b8a5cdbe">分析对象</h3><ul class="list "><li class="list__item" id="178c5f67"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>        <section class="procedure-steps"><h3 id="bf3f2736">解决问题</h3><ul class="list "><li class="list__item" id="4a317cf8"><p>使源对象实现<code class="code">INotifyPropertyChanged</code>接口，或者在不再需要使用<code class="code">ClearBinding</code>方法的时候删除绑定。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="wpf_collection_binding_leak" data-toc="Inspections#wpf_collection_binding_leak">WPF集合绑定泄漏</h2>        <p id="5229b12c">此泄漏类似于上述WPF绑定泄漏。如果绑定到未实现<code class="code">INotifyCollectionChanged</code>接口的集合，则WPF将创建对此集合的强引用。结果，它在整个应用程序生存期内都保留在内存中。 dotMemory会检测并显示此类对象。</p>        <section class="procedure-steps"><h3 id="71d4178b">分析对象</h3><ul class="list "><li class="list__item" id="ebc7bacf"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>        <section class="procedure-steps"><h3 id="ae0f0478">解决问题</h3><ul class="list "><li class="list__item" id="a1b0e321"><p>使源集合实现<code class="code">INotifyCollectionChanged</code>接口。另一种方法是使用<code class="code">ObservableCollection</code>集合，因为它已经实现了<code class="code">INotifyCollectionChanged</code>接口。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="dependency_property_leak" data-toc="Inspections#dependency_property_leak">依赖属性泄漏</h2>                                                                            <p id="0eeb3cdb">发生此泄漏的原因与事件处理程序泄漏的原因完全相同。GC不会通过<code class="code">AddValueChanged</code>方法收集通过<code class="code">DependencyProperty</code>更改订阅的对象，直到使用<code class="code">RemoveValueChanged</code>方法取消订阅的对象<code class="code">RemoveValueChanged</code> 。 dotMemory会检测并显示所有此类A对象。</p>    <section class="procedure-steps"><h3 id="261ccaef">分析对象</h3><ul class="list "><li class="list__item" id="fd58af99"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>    <section class="procedure-steps"><h3 id="5fa775e4">解决问题</h3><ul class="list "><li class="list__item" id="84b32f4d"><p>当订阅对象的生命周期结束时，请使用<code class="code">RemoveValueChanged</code>方法取消订阅该<code class="code">RemoveValueChanged</code> 。</p></li></ul></section>    </div>    <div class="chapter"><h2 id="xname" data-toc="Inspections#xname">x：名称WPF泄漏</h2>        <p id="4883b3ff">由于以下WPF的特殊性而发生此泄漏：WPF创建对XAML中声明的UI元素的强大全局引用，并使用x：Name指令。例如： <code class="code">&lt; XNameTest:UserControl1 Grid.Row="0" x:Name="myControl1"/&gt;</code>因此，如果以这种方式动态删除声明的元素，则该元素仍将保留在内存中。</p>        <section class="procedure-steps"><h3 id="620d29c8">分析对象</h3><ul class="list "><li class="list__item" id="e5eebc9f"><p>单击检查标题中的链接，或双击列表中的特定对象。</p></li></ul></section>        <section class="procedure-steps"><h3 id="e3ab760f">解决问题</h3><ul class="list "><li class="list__item" id="75d5d71c"><p>消除泄漏的一种方法是在C＃代码而不是XAML中声明UI元素。另一种方法是在要删除UI元素时调用父控件的<code class="code">UnregisterName</code>方法。例如： <code class="code">this.UnregisterName（“ myControl1”）;</code>            </p></li></ul></section>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Snapshot_View.html">检查查看</a> <a class="navigation-links__next" href="Heap_Fragmentation.html">堆碎片</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>