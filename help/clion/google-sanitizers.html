<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Google Sanitizers-帮助|里昂</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Google_Sanitizers" data-breadcrumbs="Profiling_Tools.xml|Dynamic Code Analysis/Google_Sanitizers.xml|Google Sanitizers" data-main-title="Google Sanitizers" data-article-props="
                {
                
            " seeals=":[=" titl=":=" web="" resource=",=" link=":=" ur=":" https:="" ="" devnet.jetbrains.com="" community="" clio="," tex=":" developer="" communit="}="><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索CLion帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>CLion 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default_for_windows" data-group="primary" selected>Windows的默认设置</option><option value="primary_default_for_macos" data-group="primary">macOS的默认设置</option><option value="primary_intellij_idea_classic_macos" data-group="primary">IntelliJ IDEA经典版（macOS）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_macos" data-group="primary">Eclipse（macOS）</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_sublime_text" data-group="primary">崇高文字</option><option value="primary_sublime_text_macos" data-group="primary">崇高文字（macOS）</option><option value="primary_xcode" data-group="primary">Xcode</option><option value="primary_resharper" data-group="primary">锐化器</option><option value="primary_resharper_macos" data-group="primary">ReSharper（macOS）</option><option value="secondary_default_for_windows" data-group="secondary">Windows的默认设置</option><option value="secondary_default_for_macos" data-group="secondary">macOS的默认设置</option><option value="secondary_intellij_idea_classic" data-group="secondary">IntelliJ IDEA经典版</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_macos" data-group="secondary">Eclipse（macOS）</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_sublime_text" data-group="secondary">崇高文字</option><option value="secondary_sublime_text_macos" data-group="secondary">崇高文字（macOS）</option><option value="secondary_xcode" data-group="secondary">Xcode</option><option value="secondary_resharper" data-group="secondary">锐化器</option><option value="secondary_resharper_macos" data-group="secondary">ReSharper（macOS）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Google_Sanitizers.xml" data-toc="Google_Sanitizers">Google消毒剂</h1>                <p id="General">                    <a href="https://github.com/google/sanitizers" rel="noopener noreferrer" data-external="true" target="_blank">消毒剂</a>是Google设计的用于动态代码分析的开源工具。CLion集成了以下消毒剂：</p><ul class="list _bullet"><li class="list__item" id="ffca2966"><p>地址消毒剂（ASan）</p></li><li class="list__item" id="cc3a6251"><p>泄漏消毒剂（LSan）</p></li><li class="list__item" id="0bc6951e"><p>ThreadSanitizer（TSan）</p></li><li class="list__item" id="6a1ce8a6"><p>UndefinedBehaviorSanitizer（UBSsan）</p></li><li class="list__item" id="0a44ff0d"><p>MemorySanitizer（MSan）</p></li></ul>                <p></p>            <aside class="prompt" rel="General" id="ea76b985" data-type="tip" data-title=""><p id="749d4718">有用的链接： <a href="https://github.com/google/sanitizers" rel="noopener noreferrer" data-external="true" target="_blank">官方文档</a> ， <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation" rel="noopener noreferrer" data-external="true" target="_blank">Clang</a>中的<a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html" rel="noopener noreferrer" data-external="true" target="_blank">消毒剂，GCC中“程序工具选项”中的消毒剂</a> 。</p>            </aside>                <p id="6bdbc21f">消毒剂是从Clang从3.1开始和GCC从4.8开始实现的，并在Linux x86_64计算机上受支持。macOS上也提供了AddressSanitizer和UndefinedBehaviorSanitizer。</p>            <p id="0bff3246">消毒剂基于编译器工具，因此需要重新构建才能使用这些工具。</p>        <div class="chapter"><h2 id="Configuration" data-toc="Google_Sanitizers#Configuration">在CLion中配置消毒剂</h2>                        <section class="procedure-steps"><h3 id="CompilerFlags">在CMakeLists.txt中指定编译器标志</h3><ul class="list "><li class="list__item" id="6772a5bf"><p id="4074e26a">                                </p><div class="code-block" data-lang="bash">set（CMAKE_CXX_FLAGS“ $ {CMAKE_CXX_FLAGS} -fsanitize = [sanitizer_name] [additional_options] [-g] [-OX]”）</div><p></p>                                <aside class="prompt" rel="4074e26a" id="9ec7dff6" data-type="note" data-title=""><p>使用<code class="code">CMAKE_C_FLAGS</code>代替<code class="code">CMAKE_CXX_FLAGS</code>用于C项目。</p></aside>                                <p id="c2640533">对于<code class="code">[sanitizer_name]</code>使用以下之一：</p>                                <ul class="list _bullet"><li class="list__item" id="d9cd3062"><p>AddressSanitizer的<i id="eb4f4f83">地址</i></p></li><li class="list__item" id="1d574cac"><p>LeakSanitizer <i id="584b3275">泄漏</i></p></li><li class="list__item" id="04eeedeb"><p><i id="939f4ba9">螺纹</i> ThreadSanitizer</p></li><li class="list__item" id="753023f1"><p><i id="62a1bd68">未定义</i> UndefinedBehaviorSanitizer（其他选项也可以，看到<a href="#UbSanChapter">UBSan节</a> ）</p></li><li class="list__item" id="3ca22ff8"><p>MemorySanitizer的<i id="cd842779">内存</i></p></li></ul>                            <p id="48dfd5ce">                                <code class="code">[Additional_flags]</code>其他编译标志，例如<code class="code">-fno-omit-frame-pointer</code> ， <code class="code">fsanitize-recover/fno-sanitize-recover</code> ， <code class="code">-fsanitize-blacklist</code>等</p>                            <p id="2a129823">使用<code class="code">[-g]</code>在警告消息中包含文件名和行号。</p>                            <p id="9a4d03d5">添加优化级别<code class="code">[-OX]</code>以获得合理的性能（请参阅特定消毒剂文档中的建议）。</p>                                </li></ul></section>                        <section class="procedure-steps"><h3 id="SanitizersSettings">配置消毒剂设置</h3><ul class="list "><li class="list__item" id="2a033ff8">                            <p id="4f622e24">导航到<span class="menupath" data-skip-index="skip">设置/首选项|构建，执行，部署|动态分析工具|消毒剂</span>并设置以下内容：</p>                            <ul class="list _ul"><li class="list__item" id="RTflags"><p>                                    <span class="control">运行时标志</span><br>在本节中，为每个Sanitizer指定运行时选项。您可以手动执行此操作，也可以单击“ <span class="control">从现有环境变量导入标志”</span>按钮执行此操作（如果变量<code class="code">ASAN/MSAN/LSAN/TSAN_OPTIONS</code>呈现）。请参阅<a href="https://github.com/google/sanitizers/wiki/SanitizerCommonFlags" rel="noopener noreferrer" data-external="true" target="_blank">消毒剂通用标志</a> 。</p></li><li class="list__item" id="aac7c81f">                                    <p id="b382fbb9">                                    <span class="control">对消毒剂的输出使用视觉表示</span><br>将此复选框设置为具有预览编辑器和框架信息的树状视图输出：</p><figure><img alt="CLion消毒器视觉输出" title="CLion消毒器视觉输出" src="/help/img/idea/2019.3/cl_sanitizers_visualoutput.png" id="39bd09d5" width="800" height="527"></figure>为了提供可视化输出，请至少切换到Clang 3.8.0或GCC至少5.0.0（有关如何在CLion中更改编译器的详细信息，请参阅此<a href="how-to-switch-compilers-in-clion.html">说明</a> ）。<p></p>                                    <p id="2079d280">如果清除此复选框，或者编译器不符合要求，则以纯文本形式显示消毒剂输出：</p><figure><img alt="CLion消毒剂普通输出" title="CLion消毒剂普通输出" src="/help/img/idea/2019.3/cl_sanitizers_freetext.png" id="a31afe7c" width="800" height="612"></figure>                                    <p></p>                                </li></ul>                           </li></ul></section>                        <section class="procedure-steps"><h3 id="LLVMSymbolizerPath">提供llvm-symbolizer的路径</h3><ul class="list "><li class="list__item" id="649bc3df">                                <p id="cc74ade7">为了使Sanitizers将地址转换为源代码位置并使堆栈跟踪易于理解，请确保<span class="filepath">PATH</span>或<span class="filepath">* SAN_SYMBOLIZER_PATH</span>环境变量包含<a href="https://llvm.org/docs/CommandGuide/llvm-symbolizer.html" rel="noopener noreferrer" data-external="true" target="_blank">llvm-symbolizer</a>的位置。</p>                                <p id="6d6226ab">请注意， <span class="filepath">PATH</span>应该指向<span class="control">llvm-symbolizer</span>的目录（例如<span class="filepath">/ usr / bin /</span> ），而<span class="filepath">* SAN_SYMBOLIZER_PATH</span>应该指向特定的二进制文件（例如<span class="filepath">/ usr / dir / llvm-symbolizer</span> ）。</p>                                <p id="42c16754">如果使用Clang编译器，如果<span class="filepath">PATH</span>或<span class="filepath">* SAN_SYMBOLIZER_PATH</span>变量<span class="filepath">均未</span>指向<span class="control">llvm-symbolizer</span> ，则您将从CLion收到通知：</p><figure><img alt="cl消毒剂symbolizerwarning" title="cl消毒剂symbolizerwarning" src="/help/img/idea/2019.3/cl_sanitizer_symbolizerwarning.png" id="78b6ac6a" width="978" height="197"></figure>                                <p></p>                            </li></ul></section>        </div>    <div class="chapter"><h2 id="AsanChapter" data-toc="Google_Sanitizers#AsanChapter">地址消毒剂</h2>    <p id="ASan">    <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" rel="noopener noreferrer" data-external="true" target="_blank">AddressSanitizer（ASan）</a>是一个内存损坏检测器，能够发现以下类型的错误：</p><ul class="list _ul"><li class="list__item" id="d4793b11"><p>堆，堆栈和全局缓冲区溢出</p></li><li class="list__item" id="fa3f1cfa"><p>释放后使用（悬空指针取消引用）</p></li><li class="list__item" id="92b1f0b8"><p>范围后使用<code class="code">-fsanitize-address-use-after-scope</code></p></li><li class="list__item" id="da88bd51"><p>退货后使用（通过<code class="code">detect_stack_use_after_return=1</code>至<code class="code">ASAN_OPTIONS</code> ）</p></li><li class="list__item" id="2424595c"><p>双重免费，无效免费</p></li><li class="list__item" id="2ae55ad2"><p>初始化订单错误</p></li></ul>    <p></p><aside class="prompt" rel="ASan" id="a19043f9" data-type="tip" data-title=""><p>ASan的详细信息： <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#faq" rel="noopener noreferrer" data-external="true" target="_blank">常见问题解答</a> ， <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags" rel="noopener noreferrer" data-external="true" target="_blank">标志列表</a> ， <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAndDebugger" rel="noopener noreferrer" data-external="true" target="_blank">如何在GDB中使用ASan</a> ， <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#turning-off-instrumentation" rel="noopener noreferrer" data-external="true" target="_blank">关闭ASan工具</a> ， <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" rel="noopener noreferrer" data-external="true" target="_blank">ASan算法</a> ， <a href="http://clang.llvm.org/docs/AddressSanitizer.html" rel="noopener noreferrer" data-external="true" target="_blank">Clang中的ASan</a> 。</p></aside>        <p id="207f4f1b">例如，请考虑以下代码片段：</p><div class="code-block" data-lang="cpp">int global_array [100] = {-1}; int main（int argc，char ** argv）{return global_array [argc + 100]; //全局缓冲区溢出}</div>    <p></p>    <p id="cacce2c1">使用时<code class="code">-fsanitize=address -fno-omit-frame-pointer -O1</code>标志，由于AddressSanitizer检测到<span class="emphasis">全局缓冲区溢出</span> ，该程序将以非零代码退出：</p><figure><img alt="地址消毒剂" title="地址消毒剂" src="/help/img/idea/2019.3/cl_sanitizers_asan.png" id="152fb4f2" width="900" height="529"></figure>        <p></p>            <p id="a7ed01b1">        <span class="control">请注意</span> ，ASan在检测到的第一个错误上暂停。要更改此行为并使ASan在报告第一个错误后继续运行，请添加<code class="code">-fsanitize-recover=address</code>编译器标志和<code class="code">halt_on_error=false</code>至<code class="code">ASAN_OPTIONS</code> 。</p></div>    <div class="chapter"><h2 id="LSanChapter" data-toc="Google_Sanitizers#LSanChapter">泄漏消毒剂</h2>        <p id="LSan">            <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer" rel="noopener noreferrer" data-external="true" target="_blank">LeakSanitizer（LSan）</a>是内存泄漏检测器。在独立模式下，此Sanitizer是一种运行时工具，不需要编译器检测。但是，LSan还集成到AddressSanitizer中，因此您可以将它们组合在一起以获取内存错误和泄漏检测。</p><aside class="prompt" rel="LSan" id="472e4b20" data-type="tip" data-title=""><p>了解有关LSan的更多信息： <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizerDesignDocument" rel="noopener noreferrer" data-external="true" target="_blank">设计文档</a> ， <a href="https://clang.llvm.org/docs/LeakSanitizer.html" rel="noopener noreferrer" data-external="true" target="_blank">Clang中的LSan</a> 。</p></aside>                <p id="5bb96b03">要将LeakSanitizer启用为AddressSanitizer的一部分，请通过<code class="code">detect_leaks=1</code>到<code class="code">ASAN_OPTIONS</code>变量。要运行没有泄漏检测的ASan仪器程序，请设置<code class="code">detect_leaks=0</code> 。</p>         <p id="e4d66fdf">要仅运行LSan（并避免ASan的速度降低），请使用<code class="code">-fsanitize=leak</code>代替<code class="code">-fsanitize=address</code> 。</p>        <p id="b5796873">以下代码由于不删除堆分配的对象而导致内存泄漏：</p><div class="code-block" data-lang="cpp">int main（）{int * x = new int（10）;返回0; }</div>        <p></p>        <p id="18ee94e5">LSan检测并报告问题：</p><figure><img alt="泄漏消毒剂" title="泄漏消毒剂" src="/help/img/idea/2019.3/cl_sanitizers_lsan.png" id="eff91602" width="800" height="462"></figure>        <p></p>    </div>    <div class="chapter"><h2 id="TSanChapter" data-toc="Google_Sanitizers#TSanChapter">线程消毒剂</h2>    <p id="TSan">        <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual" rel="noopener noreferrer" data-external="true" target="_blank">ThreadSanitizer（TSan）</a>是一个数据竞争检测器。当多个线程在不同步的情况下访问同一内存并且至少一次访问是写操作时，就会发生数据争用。</p><aside class="prompt" rel="TSan" id="9c664263" data-type="tip" data-title="">TSan深度：<ul class="list _ul"><li class="list__item" id="dae2d6ef"><a href="https://static.googleusercontent.com/media/research.google.com/ru//pubs/archive/37278.pdf" rel="noopener noreferrer" data-external="true" target="_blank">使用LLVM编译器的动态竞赛检测[pdf]</a></li><li class="list__item" id="24800d6e"><a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces" rel="noopener noreferrer" data-external="true" target="_blank">一些最受欢迎的数据竞赛的描述</a></li><li class="list__item" id="911a4b51"><a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerDetectableBugs" rel="noopener noreferrer" data-external="true" target="_blank">TSan可检测的错误</a></li><li class="list__item" id="2abfded6"><a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags" rel="noopener noreferrer" data-external="true" target="_blank">TSan标志</a></li><li class="list__item" id="c23f28cf"><a href="http://clang.llvm.org/docs/ThreadSanitizer.html" rel="noopener noreferrer" data-external="true" target="_blank">Clang TSan</a></li></ul>        </aside>                <p id="8a0276b4">看一下下面的代码会产生数据争用：</p><div class="code-block" data-lang="cpp">#include <pthread.h>#include <stdio.h>int Global; void * Thread1（void * x）{Global ++;返回NULL; } void * Thread2（void * x）{全局-;返回NULL; } int main（）{pthread_t t [2]; pthread_create（＆t [0]，NULL，Thread1，NULL）; pthread_create（＆t [1]，NULL，Thread2，NULL）; pthread_join（t [0]，NULL）; pthread_join（t [1]，NULL）; }</stdio.h></pthread.h></div>            <p></p>        <p id="4bf424cf">当您运行该程序时，使用<code class="code">-fsanitize=thread -fPIE -pie -g</code> ，TSan打印数据竞争的报告（有关输出格式的详细信息，请参阅<a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat" rel="noopener noreferrer" data-external="true" target="_blank">ThreadSanitizerReportFormat</a> ）：</p><figure><img alt="线程消毒剂" title="线程消毒剂" src="/help/img/idea/2019.3/cl_sanitizers_tsan.png" id="faa8a4d4" width="1150" height="712"></figure>            <p></p>    </div>    <div class="chapter"><h2 id="UbSanChapter" data-toc="Google_Sanitizers#UbSanChapter">UndefinedBehaviourSanitizer</h2>    <p id="1568ec13">        <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" rel="noopener noreferrer" data-external="true" target="_blank">UndefinedBehaviorSanitizer（UBSan）</a>是未定义行为的运行时检查器，该行为是未指定语义的任何操作的结果，例如，除以零，空指针取消引用或使用未初始化的非静态变量。</p>        <p id="aa14a6a8">UBSan捕获各种未定义的行为，请参阅<a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#ubsan-checks" rel="noopener noreferrer" data-external="true" target="_blank">clang.llvm.org</a>的完整列表。您可以将检查一一打开，或将标志用于检查组<code class="code">-fsanitize=undefined</code> ， <code class="code">-fsanitize=integer</code>和<code class="code">-fsanitize=nullability</code> 。</p>        <p id="1d13330a">以下代码说明了移位操作未定义结果的情况：</p><div class="code-block" data-lang="cpp">int main（）{int i = 2048;我<< = 28;返回0; }</div>        <p></p>        <p id="d4d7b57c">如果您使用<code class="code">-fsanitize=undefined</code>标记（或者，使用<code class="code">-fsanitize=shift</code> ）并启动，尽管有UBSan警告，该程序仍将成功完成：</p><figure><img alt="UndefinedBehaviorSanitizer" title="UndefinedBehaviorSanitizer" src="/help/img/idea/2019.3/cl_sanitizer_ubsan.png" id="ea5f8b1d" width="900" height="367"></figure>        <p></p>        <p id="71141869">要使程序由于UBSan的诊断而退出，请使用<code class="code">-fno-sanitize-recover</code>选项。</p>    </div>    <div class="chapter"><h2 id="MSanChapter" data-toc="Google_Sanitizers#MSanChapter">内存消毒剂</h2>    <p id="MSan">        <a href="https://github.com/google/sanitizers/wiki/MemorySanitizer" rel="noopener noreferrer" data-external="true" target="_blank">MemorySanitizer（MSan）</a>是未初始化的内存读取的检测器。该Sanitizer查找在写入之前已读取堆栈或堆分配的内存的情况。MSan还能够跟踪位域中的未初始化位。</p><aside class="prompt" rel="MSan" id="74300af1" data-type="note" data-title=""><p>MSan仅在Clang中可用于Linux x86_64目标。</p></aside>                <p id="e47180a2">MSan可以将未初始化值的来源追溯到创建它的位置，并报告此信息。通过<code class="code">-fsanitize-memory-track-origins</code>标志以启用此功能。</p>        <p id="06b79313">为了有效地使用MSan，请使用<code class="code">-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g</code> ，添加<code class="code">-fno-optimize-sibling-calls</code>和<code class="code">-O1</code>或更高版本。</p><p id="290e7835">在下面找到未初始化读取和相应的MSan输出的代码示例：</p><div class="code-block" data-lang="cpp">int main（int argc，char ** argv）{int * a = new int [10]; a [5] = 0;如果（a [argc]）std :: cout << a [3];返回0; }</div><p></p>        <p id="8c603b7b">         </p><figure><img alt="内存消毒剂" title="内存消毒剂" src="/help/img/idea/2019.3/cl_sanitizers_msan.png" id="846d58b2" width="900" height="543"></figure>    <p></p>    </div>            <div class="last-modified" data-skip-index="skip">上次修改时间：2019年12月1日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="profiling-tools.html">动态代码分析</a> <a class="navigation-links__next" href="memory-profiling-with-valgrind.html">Valgrind Memcheck</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>