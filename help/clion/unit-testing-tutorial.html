<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>单元测试教程-帮助|帮助里昂</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Unit_Testing_Tutorial" data-breadcrumbs="Testing/Unit_Testing_Tutorial.xml|Unit Testing Tutorial" data-main-title="Unit Testing Tutorial"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索CLion帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>CLion 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default_for_windows" data-group="primary" selected>Windows的默认设置</option><option value="primary_default_for_macos" data-group="primary">macOS的默认设置</option><option value="primary_intellij_idea_classic_macos" data-group="primary">IntelliJ IDEA经典版（macOS）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_macos" data-group="primary">Eclipse（macOS）</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_sublime_text" data-group="primary">崇高文字</option><option value="primary_sublime_text_macos" data-group="primary">崇高文字（macOS）</option><option value="primary_xcode" data-group="primary">Xcode</option><option value="primary_resharper" data-group="primary">锐化器</option><option value="primary_resharper_macos" data-group="primary">ReSharper（macOS）</option><option value="secondary_default_for_windows" data-group="secondary">Windows的默认设置</option><option value="secondary_default_for_macos" data-group="secondary">macOS的默认设置</option><option value="secondary_intellij_idea_classic" data-group="secondary">IntelliJ IDEA经典版</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_macos" data-group="secondary">Eclipse（macOS）</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_sublime_text" data-group="secondary">崇高文字</option><option value="secondary_sublime_text_macos" data-group="secondary">崇高文字（macOS）</option><option value="secondary_xcode" data-group="secondary">Xcode</option><option value="secondary_resharper" data-group="secondary">锐化器</option><option value="secondary_resharper_macos" data-group="secondary">ReSharper（macOS）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Unit_Testing_Tutorial.xml" data-toc="Unit_Testing_Tutorial">单元测试教程</h1>   <p id="3618ae66"><span class="emphasis">本教程<a href="#basics">概述</a>了单元测试方法，并讨论了CLion支持的三个<a href="#frameworks">框架</a> ：Google Test，Boost。测试并捕获2。<a href="#clion-integrations">CLion中</a>的<a href="#clion-integrations">单元测试</a>部分将指导您完成将这些框架纳入项目的过程，并描述CLion提供的可帮助您进行单元测试的工具。</span></p>   <div class="chapter"><h2 id="basics" data-toc="Unit_Testing_Tutorial#basics">单元测试的基础</h2>              <p id="intro">单元测试旨在分别检查源代码的各个单元。此处的<i id="d7727e6e">单元</i>是可以隔离进行测试的代码的最小部分，例如，自由函数或类方法。</p>       <p id="7f129277">单元测试有助于：</p><ul class="list _ul"><li class="list__item" id="63e7118d">                   <p id="30840d61"><span class="control">模块化您的代码</span></p>                   <p id="14b4e2d3">由于代码的可测试性取决于其设计，因此单元测试有助于将其分解为易于测试的专用部分。</p>               </li><li class="list__item" id="d32a1277"><p id="568c7bca"><span class="control">避免回归</span></p>                   <p id="ff01f41f">如果拥有一套单元测试，则可以迭代地运行它，以确保每次添加新功能或进行更改时，一切都能<a href="https://en.wikipedia.org/wiki/Regression_testing" rel="noopener noreferrer" data-external="true" target="_blank">正常工作</a> 。</p>               </li><li class="list__item" id="4d775d66">                   <p id="98e15bb7"><span class="control">记录您的代码</span></p>                   <p id="e7d010f3">运行，调试甚至只是阅读测试都可以提供许多有关原始代码如何工作的信息，因此您可以将它们用作隐式文档。</p>               </li></ul>       <p></p>       <p id="1f8a9cf9"><span class="control">单个单元测试</span>是一种检查某些特定功能并具有明确的通过/失败标准的方法。单个测试的通用结构如下所示：</p><div class="code-block" data-lang="none">测试（TestGroupName，TestName）{1-设置块2-运行被测功能3-检查结果（断言块）}</div>    <p></p>              <p id="83f18da3">单元测试的<span class="control">良好做法</span>包括：</p>       <ul class="list _bullet"><li class="list__item" id="d8656517"><p>为所有公开公开的功能（包括类构造函数和运算符）创建测试。</p></li><li class="list__item" id="b7dc7ff4"><p>覆盖所有代码路径，并检查琐碎的情况和边缘情况，包括那些输入数据不正确的情况（请参见<a href="https://en.wikipedia.org/wiki/Negative_testing" rel="noopener noreferrer" data-external="true" target="_blank">否定测试</a> ）。</p></li><li class="list__item" id="e93328aa"><p>确保每个测试独立运行，并且不会阻止其他测试的执行。</p></li><li class="list__item" id="addbc833"><p>以不影响测试顺序的方式组织测试。</p></li></ul>       <p id="fefd029e">将测试用例逻辑连接或使用相同的数据时，对它们进行分组很有用。<span class="control">套件</span>将测试与通用功能结合在一起（例如，对同一功能执行不同案例时）。<span class="control">夹具</span>类有助于组织用于多个测试的共享资源。它们用于为组内的每个测试设置和清理环境，从而避免代码重复。</p>               <p id="7eca0234">单元测试通常与<a href="https://en.wikipedia.org/wiki/Mock_object" rel="noopener noreferrer" data-external="true" target="_blank">模拟</a>结合在一起。模拟对象是测试目标的轻量级实现，在被测功能包含复杂的依赖关系且难以使用实际对象构造可行的测试用例时使用。</p>   </div>   <div class="chapter"><h2 id="frameworks" data-toc="Unit_Testing_Tutorial#frameworks">构架</h2>       <p id="45b52737">手动单元测试涉及许多例程：编写存根测试代码，实现<code class="code">main()</code> ，输出输出消息等。单元测试框架不仅有助于自动化这些操作，还使您从以下方面受益：</p>       <ul class="list _bullets"><li class="list__item" id="6f9e0397"> <p id="a4d5c507"><span class="control">可管理的断言行为</span></p>        <p id="2f8d78ad">使用框架，您可以指定单项检查失败是否应取消整个测试执行：以及常规<code class="code">ASSERT</code> ，框架提供<code class="code">EXPECT/CHECK</code>宏不会在失败时中断您的测试程序。</p>    </li><li class="list__item" id="2e202417">        <p id="1b7d93f8"><span class="control">各种检查器</span></p>        <p id="c7c2e6ea">Checkers是用于比较预期结果和实际结果的宏。测试框架提供的检查程序通常具有可配置的严重性（警告，定期期望或要求）。此外，它们还可以包括浮点比较的容差，甚至可以包括在某些情况下检查异常引发的预先实现的异常处理程序。</p>    </li><li class="list__item" id="02e5a81c">        <p id="e6fe4139"><span class="control">测试组织</span></p>        <p id="27d60610">使用框架，可以轻松创建和运行按通用功能（套件）或共享数据（夹具）分组的测试子集。另外，现代框架会自动注册新测试，因此您无需手动进行。</p>    </li><li class="list__item" id="0ee58f19">        <p id="dfac8e9f"><span class="control">可自定义的消息</span></p>        <p id="ee56c9ae">框架负责测试输出：它们可以显示详细的描述性输出，用户定义的消息或仅简短的<span class="emphasis">通过/失败</span>结果（后者对于回归测试特别方便）。</p>    </li><li class="list__item" id="4b6619e1">        <p id="a7ff43e2"><span class="control">XML报告</span></p>        <p id="6519f1a9">大多数测试框架都以XML格式提供导出结果。当您需要将结果进一步传递给持续集成系统（例如<a href="/teamcity/" rel="noopener noreferrer" data-external="true" target="_blank">TeamCity</a>或<a href="https://jenkins.io/" rel="noopener noreferrer" data-external="true" target="_blank">Jenkins）</a>时，这很有用。</p>    </li></ul>       <p id="33af40f1">有许多<a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C.2B.2B" rel="noopener noreferrer" data-external="true" target="_blank">C ++的</a>单元测试<a href="https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#C.2B.2B" rel="noopener noreferrer" data-external="true" target="_blank">框架</a> 。接下来，我们将重点介绍一些最受欢迎的工具： <span class="control">Google Test</span> ， <span class="control">Boost。测试</span>和<span class="control">捕获2</span> 。这三个都集成在CLion中，但是在我们深入介绍集成细节之前，让我们简要介绍每个框架的要点。</p>       <div class="chapter"><h3 id="google-test-framework" data-toc="Unit_Testing_Tutorial#google-test-framework">谷歌测试</h3>       <p id="google-test-description">           <a href="https://github.com/google/googletest" rel="noopener noreferrer" data-external="true" target="_blank">Google Test</a>和<a href="https://github.com/google/googlemock" rel="noopener noreferrer" data-external="true" target="_blank">Google Mock</a>是一对强大的单元测试工具：该框架具有可移植性，它包含一组致命的和非致命的断言，提供用于创建装置和测试组的工具，提供信息性消息并将结果导出到XML。可能唯一的缺点是需要在项目中构建<i id="87c8ceaa">gtest / gmock</i>才能使用它。</p>        <div class="chapter"><h4 id="assertions-google">断言</h4>        <p id="b2388d1e">在Google Test中，检查条件是否为真的语句称为<a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md#assertions" rel="noopener noreferrer" data-external="true" target="_blank">断言</a> 。非致命断言具有<code class="code">EXPECT_</code>在其名称中添加前缀，以及导致致命故障并中止执行的断言以下列开头<code class="code">ASSERT_</code> 。例如：</p><div class="code-block" data-lang="cpp">TEST（SquareTest / *测试套件名称* /，PosZeroNeg / *测试名称* /）{EXPECT_EQ（9.0，（3.0 * 2.0））; //失败，测试继续ASSERT_EQ（0.0，（0.0））; //成功ASSERT_EQ（9，（3）*（-3.0））; //失败，测试中断ASSERT_EQ（-9，（-3）*（-3.0））; //由于先前的assert未被执行}</div>            <p></p>           <p id="00f5fb3b">以下列出了Google测试中可用的一些断言（在此表中， <code class="code">ASSERT_</code>以示例为例，可以通过<code class="code">EXPECT_</code> ）：</p>           <div class="table-wrapper"><table width="100%" id="cfea550b"><thead><tr id="27a39e0b" class="ijRowHead"></tr></thead><tbody><tr id="7f00cd47" class="ijRowOdd"><td id="04a633d7" width="30%"><p>逻辑上</p></td><td id="7b959502"><code class="code">ASSERT_TRUE(condition)</code><br><code class="code">ASSERT_FALSE(condition)</code></td></tr><tr id="81a3daa2" class="ijRowEven"><td id="1e61c7c9"><p>一般比较</p></td><td id="a30ed188"><code class="code">ASSERT_EQ(expected, actual) / ASSERT_NE(val1, val2)</code><br><code class="code">ASSERT_LT(val1, val2) / ASSERT_LE(val1, val2)</code><br><code class="code">ASSERT_GT(val1, val2) / ASSERT_GE(val1, val2)</code></td></tr><tr id="40e770f6" class="ijRowOdd"><td id="bdef5c24"><p>浮点比较</p></td><td id="a6b1662c"><code class="code">ASSERT_FLOAT_EQ(expected, actual)</code><br><code class="code">ASSERT_DOUBLE_EQ(expected, actual)</code><br><code class="code">ASSERT_NEAR(val1, val2, abs_error)</code></td></tr><tr id="0adc1322" class="ijRowEven"><td id="23536b11"><p>字符串比较</p></td><td id="e1458eca"><code class="code">ASSERT_STREQ(expected_str, actual_str) / ASSERT_STRNE(str1, str2)</code><br><code class="code">ASSERT_STRCASEEQ(expected_str, actual_str) / ASSERT_STRCASENE(str1, str2)</code></td></tr><tr id="4995f442" class="ijRowOdd"><td id="db230ddb"><p>异常检查</p></td><td id="83f66ae9"><code class="code">ASSERT_THROW(statement, exception_type)</code><br><code class="code">ASSERT_ANY_THROW(statement)</code><br><code class="code">ASSERT_NO_THROW(statement)</code></td></tr></tbody></table></div>           <p id="45b9c19b">此外，Google Test支持<a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#predicate-assertions-for-better-error-messages" rel="noopener noreferrer" data-external="true" target="_blank">谓词断言</a> ，有助于使输出消息更具信息性。例如，代替<code class="code">EXPECT_EQ(a, b)</code>您可以使用谓词功能来检查<code class="code">a</code>和<code class="code">b</code>等效，并返回布尔结果。如果失败，则断言将打印函数参数的值：</p>            <div class="table-wrapper"><table class="  _layout-fixed" width="100%" id="87f7cc99"><thead><tr id="2e44a26a" class="ijRowHead"></tr></thead><tbody><tr id="06cc6352" class="ijRowOdd"><td id="ba4fc5a3">                        <p id="f8752807"><span class="control">谓词断言示例</span></p>                        <div class="code-block" data-lang="cpp">bool IsEq（int a，int b）{如果（a == b）返回true;否则返回假； } TEST（BasicChecks，TestEq）{int a = 0; int b = 1; EXPECT_EQ（a，b）; EXPECT_PRED2（IsEq，a，b）; }</div>                    </td><td id="44105f94">                        <p id="7097ebaf"><span class="control">输出量</span></p>                        <div class="code-block" data-lang="bash">失败值：b实际值：1预期值：a这是：0失败IsEq（a，b）的计算结果为false，其中a的计算结果为0 b的计算结果为1</div>                    </td></tr></tbody></table></div>            <p id="9e8fb19d">在<code class="code">EXPECT_PRED2</code>上面， <i id="9e45a559">predN</i>是带有N个参数的谓词函数。Google测试目前支持最多5个谓词的断言。</p>           </div>           <div class="chapter"><h4 id="fixtures-google">治具</h4>       <p id="af46294c">可以将共享通用对象或子例程的Google测试分组为固定装置。这是通用夹具的外观：</p><div class="code-block" data-lang="cpp">class myTestFixture：public :: testing :: test {public：myTestFixture（）{//初始化； // //也可以在SetUp（）中完成} void SetUp（）{//初始化或在每个测试之前运行的某些代码} void TearDown（）{//在每个测试之后运行的代码； //可以代替析构函数使用，//但只能在此函数中处理异常}〜myTestFixture（）{//资源清除，不允许有异常} //共享用户数据};</div>       <p></p>        <p id="for-tip">当用于固定装置时， <code class="code">TEST()</code>宏应替换为<code class="code">TEST_F()</code>允许测试访问灯具的成员和功能：</p><div class="code-block" data-lang="cpp">TEST_F（myTestFixture，TestName）{/ * ...* /}</div>        <p></p>           </div>           <div class="chapter"><h4 id="google-set-up">配置</h4>               <p id="a6385de3">将Google Test添加到CMake项目时，您可以选择以下<a href="https://github.com/google/googletest/tree/master/googletest#incorporating-into-an-existing-cmake-project" rel="noopener noreferrer" data-external="true" target="_blank">几个选项</a> ：</p><ul class="list _ul"><li class="list__item" id="27756169"><p id="d19f0537">下载源并将其复制到项目结构中。</p>                       <p id="0d1d6b4c">这可能是开始使用该框架的最快方法，但是不会与Google Test存储库自动同步，因此您必须注意使源保持最新。</p>                        <p id="d6cdd826">您可以在下面的<a href="#google-add-fw">示例项目</a>中找到使用此方法的<a href="#google-add-fw">示例</a> 。</p>                   </li><li class="list__item" id="c12adfff">                       <p id="7f5603b6">如果您正在使用git，则可以将<span class="emphasis">gtest</span>添加为项目的<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener noreferrer" data-external="true" target="_blank">git子模块</a> 。</p>                       </li><li class="list__item" id="7d52e642">                       <p id="85570041">另一种选择是使用CMake作为构建配置步骤的一部分下载<span class="emphasis">gtest</span> 。</p>                   </li></ul>               <p></p>           </div>             <p id="234f1544">要了解有关Google测试的更多信息，请浏览框架存储库中的<a href="https://github.com/google/googletest/blob/master/googletest/docs/samples.md" rel="noopener noreferrer" data-external="true" target="_blank">示例</a> 。另外，请查看“ <a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#advanced-googletest-topics" rel="noopener noreferrer" data-external="true" target="_blank">高级”选项</a> ，以获取其他其他值得注意的Google测试功能的详细信息，例如<a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests" rel="noopener noreferrer" data-external="true" target="_blank">值参数化测试</a>和<a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#type-parameterized-tests" rel="noopener noreferrer" data-external="true" target="_blank">类型参数化测试</a> 。</p>       </div>       <div class="chapter"><h3 id="boost-test-framework" data-toc="Unit_Testing_Tutorial#boost-test-framework">促进。测试</h3>       <p id="boost-test-description">           <a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/index.html" rel="noopener noreferrer" data-external="true" target="_blank">提升单元测试框架（Boost。测试）</a>是<a href="https://www.boost.org/" rel="noopener noreferrer" data-external="true" target="_blank">Boost</a>库的一部分。它是一个功能齐全且可扩展的框架，具有各种断言宏，XML输出和其他功能。促进。测试本身缺乏模拟功能，但可以与独立的模拟框架（例如<a href="https://github.com/google/googlemock" rel="noopener noreferrer" data-external="true" target="_blank">gmock）</a>结合使用。</p>                                 <div class="chapter"><h4 id="checkers-boost">跳棋</h4>               <p id="b297c884">对于大多数Boost。测试检查器，您可以设置严重性级别：</p><ul class="list _ul"><li class="list__item" id="8ff796b6"><p>如果检查失败， <span class="control">WARN</span>会生成一条警告消息，但是错误计数器不会增加，并且测试用例会继续。</p></li><li class="list__item" id="a2f6c232"><p>当检查失败时， <span class="control">CHECK</span>报告错误并增加错误计数器，但测试用例仍在继续。</p></li><li class="list__item" id="4088a9ef"><p>当应该终止测试用例的执行时， <span class="control">REQUIRE</span>用于报告致命错误（例如，检查是否成功创建了稍后使用的对象）。</p></li></ul>               <p></p>               <p id="d18fa75a">这样，Boost检查器通常是<code class="code">BOOST_[level]_[checkname]</code>带有一个或几个参数的格式。基本宏是<code class="code">BOOST_WARN</code> ， <code class="code">BOOST_CHECK</code>和<code class="code">BOOST_REQUIRE</code> 。他们使用表达式的一个参数来检查，例如：</p><div class="code-block" data-lang="cpp">BOOST_WARN（sizeof（int）== sizeof（long））; BOOST_CHECK（i == 1）; BOOST_REQUIRE（j> 5）;</div>               <p></p>               <p id="6b4322a7">其他检查器的一些示例如下：</p>               <div class="table-wrapper"><table class="  _layout-fixed" width="100%" id="832a1ad7"><thead><tr id="8b62a113" class="ijRowHead"></tr></thead><tbody><tr id="008c43c6" class="ijRowOdd"><td id="df63f2b2" width="20%"><p>一般比较</p></td><td id="acaf0e1f" width="80%">                           <p id="f88f4f9c">                          <code class="code">BOOST_[level]_EQUAL</code> ， <code class="code">BOOST_[level]_NE</code> ， <code class="code">BOOST_[level]_GT</code>                            </p>                           <p id="28a83d0e">万一发生故障，这些宏不仅会给出<i id="f8f33eeb">测试失败的</i>消息，还会显示预期值和实际值：</p><div class="code-block" data-lang="cpp">int i = 2; int j = 1; BOOST_CHECK（i == j）; //仅报告失败的事实：“检查i == j失败” BOOST_CHECK_EQUAL（i，j）; //报告“检查i == j失败[2！= 1]“</div>                           <p></p>                       </td></tr><tr id="64166c81" class="ijRowEven"><td id="84807e6e"><p>浮点比较</p></td><td id="490210c4"><p>                           <code class="code">BOOST_[level]_CLOSE</code> / <code class="code">BOOST_[level]_CLOSE_FRACTION</code> / <code class="code">BOOST_[level]_SMALL</code>                       </p></td></tr><tr id="8410b462" class="ijRowOdd"><td id="347cffd3"><p>异常检查</p></td><td id="c88fb19e"><p>                           <code class="code">BOOST_[level]_THROW</code> / <code class="code">BOOST_[level]_NO_THROW</code> / <code class="code">BOOST_[level]_EXCEPTION</code>                       </p></td></tr></tbody></table></div>           </div>       <div class="chapter"><h4 id="suites-boost">套房</h4>           <p id="c59490dc">您可以使用一对将Boost测试组织到<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/tests_organization/test_tree/test_suite.html" rel="noopener noreferrer" data-external="true" target="_blank">套件</a>中<code class="code">BOOST_AUTO_TEST_SUITE(suite_name)</code>和<code class="code">BOOST_AUTO_TEST_SUITE_END()</code>宏。一个简单的测试套件如下所示：</p><div class="code-block" data-lang="cpp">#define BOOST_TEST_MODULE Suite_example #include <boost test="" unit_test.hpp="">BOOST_AUTO_TEST_SUITE（TwoTwoFour_suite）BOOST_AUTO_TEST_CASE（testPlus）{BOOST_CHECK_EQUAL（2 + 2，4）; } BOOST_AUTO_TEST_CASE（testMult）{BOOST_CHECK_EQUAL（2 * 2，4）; } BOOST_AUTO_TEST_SUITE_END（）</boost></div>       <p></p>       </div>           <div class="chapter"><h4 id="fixtures-boost">治具</h4>               <p id="094db77b">要使用Boost编写灯具，可以使用在灯具类声明之后编写的<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/tests_organization/fixtures.html" rel="noopener noreferrer" data-external="true" target="_blank">常规BOOST_AUTO_TEST_CASE宏</a> ，也可以使用特殊的<code class="code">BOOST_FIXTURE_TEST_CASE</code>巨集：</p><div class="code-block" data-lang="cpp">struct SampleF {SampleF（）：i（1）{}〜SampleF（）{} int i; }; BOOST_FIXTURE_TEST_CASE（SampleF_test，SampleF）{//直接从SampleF访问i BOOST_CHECK_EQUAL（i，1）; BOOST_CHECK_EQUAL（i，2）; BOOST_CHECK_EQUAL（i，3）; }</div>             <p></p>           </div>    <div class="chapter"><h4 id="boost-set-up">配置</h4>        <p id="aaeb41d9">您可以在框架的三种<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/usage_variants.html" rel="noopener noreferrer" data-external="true" target="_blank">用法变体</a>之间进行选择：仅标头，静态库或共享库。选择最合适的选项时，请记住使用Boost。仅用作标头的测试可能需要大量的编译时间。</p>        <p id="7d44d70f">在下面的<a href="#google-add-fw">示例项目</a>中找到<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/usage_variants.html#boost_test.usage_variants.shared_lib" rel="noopener noreferrer" data-external="true" target="_blank">共享库用法变体</a>的<a href="#google-add-fw">示例</a> （切换到<span class="control">Boost。测试</span>标签）。</p>    </div>       </div>       <div class="chapter"><h3 id="catch-framework" data-toc="Unit_Testing_Tutorial#catch-framework">渔获2</h3>           <p id="catch2-test-description">Google和Boost的<a href="https://github.com/catchorg/Catch2" rel="noopener noreferrer" data-external="true" target="_blank">Catch2</a>的主要区别在于它是<span class="control">仅标头的</span>测试系统：要使用Catch2创建测试，只需下载并仅包含一个标头文件<span class="filepath">catch.hpp即可</span> 。框架的名称代表<i id="933c19d3">Headers（第二版）中的C ++自动测试用例</i> 。CLion支持Catch版本1.7.2和更高版本。</p>           <p id="c4edca6c">以及助推器。测试，Catch2不提供模拟功能。但是，您可以将其与独立的<a href="http://hippomocks.com/Main_Page" rel="noopener noreferrer" data-external="true" target="_blank">模拟</a>框架（例如<a href="http://hippomocks.com/Main_Page" rel="noopener noreferrer" data-external="true" target="_blank">Hippomocks</a> ， <a href="https://github.com/eranpeer/FakeIt" rel="noopener noreferrer" data-external="true" target="_blank">FakeIt</a>或<a href="https://github.com/rollbear/trompeloeil" rel="noopener noreferrer" data-external="true" target="_blank">Trompeloeil）结合使用</a> 。</p>       <div class="chapter"><h4 id="sample-catch">样品测试</h4>       <p id="4f1a60ec">以下示例显示了一个用Catch2编写的简单测试：</p>           <div class="code-block" data-lang="cpp">#define CATCH_CONFIG_MAIN //提供main（）;仅在一个.cpp文件中此行是必需的#include“ catch.hpp” int theAnswer（）{返回6 * 9; } //要测试的函数TEST_CASE（“生命，宇宙和万物”，“ [42] [theAnswer]”）{要求（theAnswer（）== 42）; }</div>           <p id="d6cd9fbf">在以上示例中， <code class="code">Life, the universe and everything</code>是自由格式的测试名称，必须唯一。第二个论点<code class="code">TEST_CASE</code>宏是两个标签的组合， <code class="code">[42]</code>和<code class="code">[theAnswer]</code> 。测试名称和标签都是常规字符串，不限于有效的C ++标识符。您可以通过指定通配测试名称或标记表达式来运行测试集合。</p>           <p id="cbd44eca">注意断言行<code class="code">REQUIRE(theAnswer() == 42)</code> 。与其他框架不同，Catch2没有用于捕获各种条件形式的断言集合。相反，它解析条件表达式的实际C / C ++代码，并使用它来描述结果：</p><div class="code-block" data-lang="bash">...失败：REQUIRE（theAnswer（）== 42）扩展为：54 == 42</div>       <p></p>           <p id="4d9d9ab4">的<code class="code">REQUIRE</code>宏会中止失败的测试，而替代方法<code class="code">CHECK</code>宏仅报告失败并让测试继续进行。在这两个宏中，您可以使用所有C ++比较运算符并以任何顺序传递参数。</p>       </div>           <div class="chapter"><h4 id="sections-catch">栏目</h4>           <p id="26ae0ef5">Catch2的另一个重要功能是在<a href="https://github.com/catchorg/Catch2/blob/master/docs/tutorial.md#test-cases-and-sections" rel="noopener noreferrer" data-external="true" target="_blank">案例和部分中</a>组织测试的方式（同时也<a href="https://github.com/catchorg/Catch2/blob/master/docs/test-fixtures.md" rel="noopener noreferrer" data-external="true" target="_blank">支持</a>基于类的夹具机制）。从文档中看这个例子：</p><div class="code-block" data-lang="cpp">TEST_CASE（“ vectors可以调整大小和大小”，“ [vector]”）{//为每个段执行的初始化块std :: vector <int>v（5）; REQUIRE（v.size（）== 5）; REQUIRE（v.capacity（）> = 5）; //初始化块SECTION（“调整较大的更改大小和容量”的结尾）{v.resize（10）; REQUIRE（v.size（）== 10）; REQUIRE（v.capacity（）> = 10）; } SECTION（“调整较小的更改大小，但不调整容量”）{v.resize（0）; REQUIRE（v.size（）== 0）; REQUIRE（v.capacity（）> = 5）; }}</int></div>           <p></p>               <p id="ec7e9c74">在以上代码段中， <code class="code">TEST_CASE</code>从头开始执行<code class="code">SECTION</code> 。二<code class="code">REQUIRE</code>顶部的语句<code class="code">TEST_CASE</code>强制执行<code class="code">size</code>是5并且<code class="code">capacity</code>每个部分的条目至少为5。这样，共享库就可以在堆栈上分配，而无需为它们创建固定类。每次运行一次<code class="code">TEST_CASE</code> ，Catch2执行一个部分，并跳过其他部分。下次，它将执行第二部分，依此类推。</p>               <p id="52fdd1e2">可以嵌套各节以创建一系列检查操作。每个叶节（内部没有嵌套节的节）执行一次。当父节失败时，它将阻止子节运行。例如：</p><div class="code-block" data-lang="cpp">SECTION（“保留较大的更改容量，但不保留大小”）{v.reserve（10）; REQUIRE（v.size（）== 5）; REQUIRE（v.capacity（）> = 10）; //验证尝试保留较小的容量不会更改任何内容SECTION（“再次保留较小的容量不会更改容量”）{v.reserve（7）; REQUIRE（v.capacity（）> = 10）; }}</div>               <p></p>               <p id="b005b683">Catch2还支持用于测试用例和部分的替代<a href="https://github.com/catchorg/Catch2/blob/master/docs/test-cases-and-sections.md#bdd-style-test-cases" rel="noopener noreferrer" data-external="true" target="_blank">BDD样式语法</a> 。</p>           </div>           <div class="chapter"><h4 id="catch-set-up">配置</h4>               <p id="9d7d8405">要开始使用Catch2，请使用<a href="https://github.com/catchorg/Catch2" rel="noopener noreferrer" data-external="true" target="_blank">文档中</a>的链接下载<span class="filepath">catch.hpp</span>标头，并将其复制到您的项目树中。请参阅下面的<a href="#google-add-fw">示例项目</a>中的<a href="#google-add-fw">示例</a> （切换到<span class="control">Catch2</span>选项卡）。</p>           </div>       </div>   </div>   <div class="chapter"><h2 id="clion-integrations" data-toc="Unit_Testing_Tutorial#clion-integrations">CLion中的单元测试</h2>        <p id="6d82d07c">CLion集成了Google Test，Boost。测试和Catch2包括对框架库的完整代码见解，专用的运行/调试配置，用于运行或调试测试/套件/装置并检查其状态的装订线图标，专门的测试运行程序以及用于测试和装置类的代码生成（可用用于Google测试）。</p>       <div class="chapter"><h3 id="adding-framework" data-toc="Unit_Testing_Tutorial#adding-framework">为您的项目建立测试框架</h3>       <p id="0d17b217">在本章中，我们将讨论如何添加Google Test Boost。测试和Catch2框架到CLion中的项目，以及如何编写一组简单的测试。</p>           <p id="15de644b">例如，我们将使用您可以从<a href="https://github.com/MarinaKalashina/DateConverter" rel="noopener noreferrer" data-external="true" target="_blank">github repo</a>克隆的<span class="control">DateConverter</span>项目。该程序计算公历格式的日期的绝对值，并将其转换为儒略历日期。最初，该项目不包含任何测试-我们将逐步添加它们。要查看框架之间的差异，我们将使用这三个框架执行相同的测试。您可以在<a href="https://github.com/MarinaKalashina/DateConverter_withTests" rel="noopener noreferrer" data-external="true" target="_blank">DateConverter_withTests</a>存储库中找到项目的最终版本。以下是项目结构的转换方式：</p><figure><img alt="有和没有测试的示例项目" title="有和没有测试的示例项目" src="/help/img/idea/2019.3/cl_UTturorial_sampleproject_transform.png" id="17f2e151" width="472" height="736"></figure>           <p></p>           <p id="c8440672">            <span class="emphasis">对于每个框架</span> ，我们将执行以下操作：</p><ol class="list _decimal"><li class="list__item" id="680cac8b"><p>将框架添加到<span class="control">DateConverter</span>项目。</p></li><li class="list__item" id="8fb6d86c"><p>创建两个测试文件<span class="filepath">AbsoluteDateTest.cpp</span>和<span class="filepath">ConverterTests.cpp</span> 。这些文件将为每个框架类似地命名，并且它们将包含使用特定框架的语法编写的测试代码。</p></li></ol>        <p></p>            <p id="160b78cf">现在，让我们打开克隆的<span class="control">DateConverter</span>项目，并按照以下选项卡中的说明进行操作：</p>           <div class="tabs" id="0b81cb35"><div class="tabs__content" id="917e09d2" data-title="Google Test">             <section class="procedure-steps"><h3 id="google-add-fw">包括Google测试框架</h3><ol class="list _decimal"><li class="list__item" id="5ad99269"><p id="6eae0344">在<span class="control">DateConverter</span>项目根目录下为Google Tests创建一个文件夹。在其中，为框架的文件创建另一个文件夹。在我们的示例中，分别是<span class="filepath">Google_tests</span>和<span class="filepath">Google_tests / lib</span>文件夹。</p>                 </li><li class="list__item" id="google-step2"><p id="c3dba79d">从官方<a href="https://github.com/google/googletest" rel="noopener noreferrer" data-external="true" target="_blank">存储库</a>下载Google Test。将<span class="control">googletest-master</span>文件夹的内容提取到<span class="filepath">Google_tests / lib中</span> 。</p>                                                           </li><li class="list__item" id="95a7172f">                     <p id="d27e2754">将<span class="filepath">CMakeLists.txt</span>文件添加到<span class="control">Google_tests</span>文件夹（在项目树中右键单击它，然后选择<span class="menupath" data-skip-index="skip">New | CMakeLists.txt</span> ）。添加以下行：</p>                     <div class="code-block" data-lang="makefile">项目（Google_tests）add_subdirectory（lib）include_directories（$ {gtest_SOURCE_DIR} / include $ {gtest_SOURCE_DIR}）</div>                 </li><li class="list__item" id="1cee4783"><p id="4f3a488f">在<span class="filepath">CMakeLists.txt</span> <span class="control">根</span>脚本中，添加<code class="code">add_subdirectory(Google_tests)</code>在最后一行，然后重新加载项目。</p>                                      </li></ol></section>               <section class="procedure-steps"><h3 id="google-add-tests">添加Google测试</h3><ol class="list _decimal"><li class="list__item" id="b818654e">                     <p id="df2cb02b">单击项目树中的<span class="filepath">Google_tests</span>文件夹，然后选择<span class="menupath" data-skip-index="skip">新建| C / C ++源文件</span> ，将其称为<span class="control">AbsoluteDateTest.cpp</span> 。</p>                     <p id="ebe47797">CLion提示将此文件添加到现有目标。我们不需要这样做，因为下一步将为此文件创建一个新目标。</p>                     <p id="03a50d0b">对<span class="control">ConverterTests.cpp</span>重复此步骤。</p>                 </li><li class="list__item" id="52baa1f8">                     <p id="1f824288">添加两个源文件后，我们可以为它们创建一个测试目标并将其与<code class="code">DateConverter_lib</code>图书馆。</p>                     <p id="add1cad3"><span class="filepath">将以下行</span>添加到<span class="filepath">Google_tests / CMakeLists.txt中</span> ：</p>                      <div class="code-block" data-lang="makefile">＃添加Google_Tests_run目标add_executable（Google_Tests_run ConverterTests.cpp AbsoluteDateTest.cpp）＃将Google_Tests_run与将要测试的DateConverter_lib链接target_link_libraries（Google_Tests_run DateConverter_lib）target_link_libraries（Google_Tests_run gtest gtest</div>                   </li><li class="list__item" id="f62435d2">                     <p id="deeac37c">将我们的支票的Google测试版本从<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Google_tests/AbsoluteDateTest.cpp" rel="noopener noreferrer" data-external="true" target="_blank">AbsoluteDateTest.cpp</a>和<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Google_tests/ConverterTests.cpp" rel="noopener noreferrer" data-external="true" target="_blank">ConverterTests.cpp</a>复制到您的<span class="filepath">AbsoluteDateTest.cpp</span>和<span class="filepath">ConverterTests.cpp</span>文件。</p>                     <p id="753d500b">现在可以开始<a href="#run-from-gutter">运行</a>测试了。例如，让我们点击<img class="inline-icon-12" src="/help/img/idea/2019.3/icons.runConfigurations.testState.run_run@2x.png" width="12" alt="图标runConfigurations testState运行运行">在左侧装订线旁边<code class="code">DateConverterFixture</code>在<span class="filepath">ConverterTests.cpp中</span>声明，然后选择<span class="control">Run ...。</span>我们将得到以下结果：</p>                     <figure><img alt="Google测试结果" title="Google测试结果" src="/help/img/idea/2019.3/cl_UTtutorial_simpletestGoogle.png" id="982ec782" width="650" height="854"></figure>                 </li></ol></section>           </div><div class="tabs__content" id="92e4f5e3" data-title="Boost.Test">               <section class="procedure-steps"><h3 id="boost-add-fw">包括助推器。测试框架</h3><ol class="list _decimal"><li class="list__item" id="0a8849be"><p>按照以下<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/adv_scenarios/build_utf.html" rel="noopener noreferrer" data-external="true" target="_blank">说明</a>安装和构建Boost Testing Framework（在测试中，我们将使用<a href="https://www.boost.org/doc/libs/1_71_0/libs/test/doc/html/boost_test/usage_variants.html#boost_test.usage_variants.shared_lib" rel="noopener noreferrer" data-external="true" target="_blank">共享库的使用方式</a>来链接该框架）。</p></li><li class="list__item" id="a7e8bcf5"><p>在<span class="control">DateConverter</span>项目根目录下为Boost测试创建一个文件夹。在我们的示例中，它称为<span class="filepath">Boost_tests</span> 。</p></li><li class="list__item" id="e95f6979"><p>将一个<span class="filepath">CMakeLists.txt</span>文件添加到<span class="control">Boost_tests</span>文件夹中（在项目树中右键单击它，然后选择<span class="menupath" data-skip-index="skip">New | CMakeLists.txt</span> ）。添加以下行：</p><div class="code-block" data-lang="makefile">设置（Boost_USE_STATIC_LIBS OFF）find_package（Boost必需组件unit_test_framework）include_directories（$ {Boost_INCLUDE_DIRS}）</div>                   <p></p></li><li class="list__item" id="55510ef5"><p id="283e4a04">在<span class="filepath">CMakeLists.txt</span> <span class="control">根</span>脚本中，添加<code class="code">add_subdirectory(Boost_tests)</code>在最后一行，然后重新加载项目。</p>                                          </li></ol></section>               <section class="procedure-steps"><h3 id="boost-add-tests">添加Boost测试</h3><ol class="list _decimal"><li class="list__item" id="5207e133">                       <p id="8d59a75e">单击项目树中的<span class="filepath">Boost_tests</span> ，然后选择“ <span class="menupath" data-skip-index="skip">新建” |“新建”。 C / C ++源文件</span> ，将其称为<span class="control">AbsoluteDateTest.cpp</span> 。</p>                       <p id="84441553">CLion将提示将此文件添加到现有目标。我们不需要这样做，因为下一步将为此文件创建一个新目标。</p>                       <p id="63e8314c">对<span class="control">ConverterTests.cpp</span>重复此步骤。</p>                   </li><li class="list__item" id="fec227c4">                       <p id="18abe1ba">添加两个源文件后，我们可以为它们创建一个测试目标并将其与<code class="code">DateConverter_lib</code>图书馆。<span class="filepath">将以下行</span>添加到<span class="filepath">Boost_tests / CMakeLists.txt</span> ：</p>                       <div class="code-block" data-lang="makefile">add_executable（Boost_Tests_run ConverterTests.cpp AbsoluteDateTest.cpp）target_link_libraries（Boost_Tests_run $ {Boost_LIBRARIES}）target_link_libraries（Boost_Tests_run DateConverter_lib）</div>                       <p id="89832513">重新加载项目。</p>                   </li><li class="list__item" id="6dd455a4">                       <p id="d30ab1f1">复制Boost。测试从<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Boost_tests/AbsoluteDateTest.cpp" rel="noopener noreferrer" data-external="true" target="_blank">AbsoluteDateTest.cpp</a>和<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Boost_tests/ConverterTests.cpp" rel="noopener noreferrer" data-external="true" target="_blank">ConverterTests.cpp</a>到您项目中相应源文件的检查版本。</p>                                              <p id="e075be30">现在可以开始<a href="#run-from-gutter">运行</a>测试了。例如，让我们点击<img class="inline-icon-12" src="/help/img/idea/2019.3/icons.runConfigurations.testState.run_run@2x.png" width="12" alt="图标runConfigurations testState运行运行">在旁边的左装订线<code class="code">BOOST_AUTO_TEST_SUITE(AbsoluteDateCheckSuite)</code>在<span class="filepath">AbsoluteDateTest.cpp中，</span>然后选择<span class="control">Run ...。</span>我们将得到以下结果：</p><figure><img alt="提升测试结果" title="提升测试结果" src="/help/img/idea/2019.3/cl_UTtutorial_simpletestBoost.png" id="8c07cebe" width="643" height="861"></figure>                       <p></p>                   </li></ol></section>           </div><div class="tabs__content" id="0179bdcf" data-title="Catch2">               <section class="procedure-steps"><h3 id="catch-add-fw">包括Catch2框架</h3><ol class="list _decimal"><li class="list__item" id="201ce146"><p>创建用于<span class="control">DateConverter</span>项目的根目录下Catch2测试的文件夹。在我们的示例中，它称为<span class="filepath">Catch_tests</span> 。</p></li><li class="list__item" id="2e251d4a"><p>使用<a href="https://github.com/catchorg/Catch2" rel="noopener noreferrer" data-external="true" target="_blank">文档中</a>的链接下载<span class="filepath">catch.hpp</span>标头，并将其放在<span class="filepath">Catch_tests</span>文件夹中。</p></li></ol></section>               <section class="procedure-steps"><h3 id="catch-add-tests">添加Catch2测试</h3><ol class="list _decimal"><li class="list__item" id="9c29255e">                       <p id="54827017">单击项目树中的<span class="filepath">Catch_tests</span> ，然后选择“ <span class="menupath" data-skip-index="skip">新建” |“新建”。 C / C ++源文件</span> ，将其称为<span class="control">AbsoluteDateTest.cpp</span> 。</p>                       <p id="abb1a197">CLion将提示将此文件添加到现有目标。我们不需要这样做，因为下一步将为此文件创建一个新目标。</p>                       <p id="36a3945c">对<span class="control">ConverterTests.cpp</span>重复此步骤。</p>                   </li><li class="list__item" id="235914bc"><p>将<span class="filepath">CMakeLists.txt</span>文件添加到<span class="control">Catch_tests</span>文件夹（在项目树中的文件夹上单击鼠标右键，然后选择<span class="menupath" data-skip-index="skip">New | CMakeLists.txt</span> ）。添加以下行：</p><div class="code-block" data-lang="makefile">add_executable（Catch_tests_run ConverterTests.cpp AbsoluteDateTest.cpp）target_link_libraries（Catch_tests_run DateConverter_lib）</div>                   <p></p></li><li class="list__item" id="02781917"><p id="db6d1892">在<span class="control">根</span> <span class="filepath">CMakeLists.txt中</span> ，添加<code class="code">add_subdirectory(Catch_tests)</code>最后，重新加载项目。</p>                   </li><li class="list__item" id="4d0e5048">                        <p id="096f0f8b">将我们的检查的Catch2版本从<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Catch_tests/AbsoluteDateTest.cpp" rel="noopener noreferrer" data-external="true" target="_blank">AbsoluteDateTest.cpp</a>和<a href="https://github.com/MarinaKalashina/DateConverter_withTests/blob/master/Catch_tests/ConverterTests.cpp" rel="noopener noreferrer" data-external="true" target="_blank">ConverterTests.cpp</a>复制到项目中的相应源文件。</p>                   <p id="f28d2e57">现在可以开始<a href="#run-from-gutter">运行</a>测试了。例如，让我们点击<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.actions.execute@2x.png" width="16" alt="图标动作执行">在旁边的左装订线<code class="code">TEST_CASE( "Check various dates", "[DateConverterTests]" )</code>在<span class="filepath">ConverterTests.cpp中，</span>然后选择<span class="control">Run ...。</span>我们将得到以下结果：</p><figure><img alt="捕获测试结果" title="捕获测试结果" src="/help/img/idea/2019.3/cl_UTtutorial_simpletestCatch.png" id="2e719f7b" width="650" height="934"></figure>                   <p></p>                  </li></ol></section>           </div></div>       </div><div class="chapter"><h3 id="test-configurations" data-toc="Unit_Testing_Tutorial#test-configurations">运行/调试测试配置</h3>    <p id="5cdec7b8">测试框架提供了<code class="code">main()</code>输入测试程序，因此可以在CLion中将它们作为常规应用程序运行。但是，我们建议对Google Test，Boost使用专用的运行/调试配置。测试并捕获2。这些配置包括与测试相关的设置，并使您从内置的测试运行程序中受益（如果您将测试作为常规应用程序运行，则该功能不可用）。</p>    <section class="procedure-steps"><h3 id="create-tests-config">创建测试的运行/调试配置</h3><ul class="list "><li class="list__item" id="b9a51fcf"><p id="a38aaabd">去<span class="control">运行|编辑配置</span> ，单击<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.general.add@2x.png" width="16" alt="图标一般添加">并选择框架特定的模板之一：</p><figure><img alt="测试运行/调试配置模板" title="测试运行/调试配置模板" src="/help/img/idea/2019.3/cl_UTtutorial_configs.png" id="d465ed78" width="239" height="434"></figure>        <p></p>        </li></ul><aside class="prompt" rel="b9a51fcf" id="b316ab7c" data-type="note" data-title=""><p>如果您的CMake目标与<span class="emphasis">gtest</span>或<span class="emphasis">gmock</span>链接，则CLion会为此目标自动创建Google Test配置。</p></aside></section>    <section class="procedure-steps"><h3 id="settings-test-configs">设置您的配置</h3><ul class="list "><li class="list__item" id="5187ca1c">            <p id="80f31df9">根据框架，指定测试<span class="control">模式</span> ， <span class="control">suite</span>或<span class="control">标签</span> （对于Catch2）。字段中提供了自动完成功能，可帮助您快速填写它们：</p><figure><img alt="配置字段中的自动完成" title="配置字段中的自动完成" src="/help/img/idea/2019.3/cl_UTtutorial_config_completion.png" id="e82dc2fb" width="517" height="288"></figure>            <p></p>        </li><li class="list__item" id="5c24861e">            <p id="39fb4934">指定测试模式时，可以使用通配符。例如，将以下模式设置为仅运行<code class="code">PlusOneDiff</code>和<code class="code">PlusFour_Leap</code>示例项目的测试：</p><figure><img alt="在测试模式中使用通配符" title="在测试模式中使用通配符" src="/help/img/idea/2019.3/cl_UTtutorial_configs_pattern.png" id="9d6dd81c" width="395" height="256"></figure>            <p></p>        </li><li class="list__item" id="fa1e8e1a">            <p id="d27ce136">在配置设置的其他字段中，可以设置环境变量或命令行选项。例如，在“ <span class="control">程序参数”</span>字段中，您可以设置<code class="code">-s</code>使Catch2测试强制通过测试以显示完整输出，或者<code class="code">--gtest_repeat</code>多次运行Google测试：</p>            <div class="table-wrapper"><table class="  _layout-fixed" width="100%" id="39077dad"><thead><tr id="3144eec5" class="ijRowHead"></tr></thead><tbody><tr id="e047fa38" class="ijRowOdd"><td id="cf5a9147" width="60%">                        <figure><img alt="程序参数中的标志" title="程序参数中的标志" src="/help/img/idea/2019.3/cl_UTtutorial_configs_flags.png" id="f6e64def" width="516" height="451"></figure>                    </td><td id="58c18818"><p id="5c085288">输出将是：</p><div class="code-block" data-lang="bash">重复所有测试（迭代1）。 。 。重复所有测试（迭代2）。 。 。重复所有测试（迭代3）。 。 。
    </div>                    <p></p>                    </td></tr></tbody></table></div>        </li></ul><aside class="prompt" rel="fa1e8e1a" id="a88f61ea" data-type="note" data-title=""><p>您可以<span class="control">修改模板本身</span> ，而不是分别编辑每个配置：在默认情况下，将基于该模板在新配置中使用设置。</p></aside></section></div><div class="chapter"><h3 id="run-from-gutter" data-toc="Unit_Testing_Tutorial#run-from-gutter">测试的装订线图标</h3>    <p id="57994ad7">在CLion中，有<a href="performing-tests.html#RunTest">几种方法</a>可以启动测试的运行/调试会话，其中一种方法是使用特殊的装订线图标。这些图标有助于快速运行或调试单个测试或整个套件/夹具：</p><figure><img alt="测试的装订线图标" title="测试的装订线图标" src="/help/img/idea/2019.3/cl_UTtutorial_guttericons.png" id="53876073" width="429" height="219"></figure>    <p></p>       <p id="f5bb39dc">装订线图标还显示测试结果（如果可用）：成功<img class="inline-icon-12" src="/help/img/idea/2019.3/icons.runConfigurations.testState.green2@2x.png" width="12" alt="图标runConfigurations testState green2">或失败<img class="inline-icon-12" src="/help/img/idea/2019.3/icons.runConfigurations.testState.red2@2x.png" width="12" alt="图标runConfigurations testState red2"> 。</p>    <p id="b67eaa48">当使用装订线图标运行测试/套件/装置时，CLion将创建相应类型的<a href="creating-and-saving-temporary-run-debug-configurations.html">临时运行/调试配置</a> 。您可以在列表中看到这些配置为灰色。要保存临时配置，请在“ <span class="menupath" data-skip-index="skip">编辑配置”</span>对话框中选择它，然后按<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.actions.menu-saveall@2x.png" width="16" alt="图标操作菜单saveall"> ：</p><figure><img alt="保存临时测试配置" title="保存临时测试配置" src="/help/img/idea/2019.3/cl_UTturorial_temporaryconfigs_save.png" id="aa6f0cbd" width="507" height="343"></figure>       <p></p></div><div class="chapter"><h3 id="test-runner" data-toc="Unit_Testing_Tutorial#test-runner">测试跑步者</h3>    <p id="69a9e5b0">运行测试配置时，结果（和过程）显示在“测试运行器”窗口中，该窗口包括：</p><ul class="list _ul"><li class="list__item" id="548146a5"><p><span class="control">进度条</span> ，显示到目前为止已执行的测试百分比，</p></li><li class="list__item" id="2ae2aff8"><p>所有正在运行的测试及其状态和持续时间的<span class="control">树状视图</span> ，</p></li><li class="list__item" id="608a4438"><p>测试的<span class="control">输出</span>流，</p></li><li class="list__item" id="c39f158e"><p>带有重新运行选项的<span class="control">工具栏</span>失败<img class="inline-icon-12" src="/help/img/idea/2019.3/icons.runConfigurations.testState.red2@2x.png" width="12" alt="图标runConfigurations testState red2">测试，出口<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.toolbarDecorator.export@2x.png" width="16" alt="图标工具栏装饰器导出">或打开自动保存的先前结果<img class="inline-icon-16" src="/help/img/idea/2019.3/artwork.studio.icons.profiler.toolbar.clock@2x.png" width="16" alt="艺术品工作室图标探查器工具栏时钟"> ，按字母顺序对测试进行排序<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.objectBrowser.sorted@2x.png" width="16" alt="图标objectBrowser排序">轻松找到特定的测试，或按持续时间对其进行排序<img class="inline-icon-16" src="/help/img/idea/2019.3/icons.runConfigurations.sortbyDuration@2x.png" width="16" alt="图标runConfigurations sortbyDuration">了解哪个测试比其他测试运行时间更长。</p></li></ul>    <p></p>    <p id="9e863084">例如，如果我们有意破坏示例项目中的某些<a href="#catch-add-tests">Catch2测试</a> ，则这是测试运行器窗口的外观：</p><figure><img alt="测试选手" title="测试选手" src="/help/img/idea/2019.3/cl_UTtutorial_testrunner.png" id="6c4f2878" width="850" height="467"></figure>    <p></p></div><div class="chapter"><h3 id="tests-codegen" data-toc="Unit_Testing_Tutorial#tests-codegen">Google测试的代码生成</h3>    <p>如果您使用的是Google Test框架，CLion的<span class="control">Generate</span>菜单可以帮助您节省编写测试代码的时间。在您拥有的测试文件中<code class="code">gtest</code>包括在内，按<kbd data-primary_default_for_windows="Alt+Insert" data-primary_default_for_macos="⌘+N" data-primary_intellij_idea_classic_macos="Ctrl+N" data-primary_emacs="Alt+Insert" data-primary_visual_studio="Ctrl+N" data-primary_default_for_xwin="Alt+Insert" data-primary_default_for_gnome="Alt+Insert" data-primary_default_for_kde="Alt+Insert" data-primary_eclipse="Alt+Insert" data-primary_eclipse_macos="⌘+N" data-primary_netbeans="Alt+Insert" data-primary_sublime_text="Alt+Insert" data-primary_sublime_text_macos="⌘+N" data-primary_xcode="⌘+N" data-primary_resharper="⌘+Enter" data-primary_resharper_macos="Alt+⌘+Enter" data-secondary_default_for_windows="N/A" data-secondary_default_for_macos="⌘N" data-secondary_intellij_idea_classic="⌃N" data-secondary_emacs="N/A" data-secondary_visual_studio="⌃N" data-secondary_default_for_xwin="N/A" data-secondary_default_for_gnome="N/A" data-secondary_default_for_kde="N/A" data-secondary_eclipse="N/A" data-secondary_eclipse_macos="⌘N" data-secondary_netbeans="N/A" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="⌘N" data-secondary_xcode="⌘N" data-secondary_resharper="⌘⏎" data-secondary_resharper_macos="⌥⌘⏎">Alt+Insert</kbd>查看代码生成选项。</p><p id="233decde">从灯具调用时，菜单还包括<span class="control"><i id="45f0f22d">SetUp方法</i></span>和<span class="control"><i id="8523c704">TearDown方法</i></span> ：</p><figure><img alt="生成测试菜单" title="生成测试菜单" src="/help/img/idea/2019.3/cl_UTtutorial_generatemenu.png" id="e794a147" width="392" height="756"></figure>    <p></p><p>对于夹具测试，代码生成转换<code class="code">TEST()</code>宏放入适当的<code class="code">TEST_F()</code> ， <code class="code">TEST_P()</code> ， <code class="code">TYPED_TEST()</code> ， 要么<code class="code">TYPED_TEST_P()</code> （请参阅<a href="https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#typed-tests" rel="noopener noreferrer" data-external="true" target="_blank">类型化测试</a> ）。</p>    </div><div class="chapter"><h3 id="other-features" data-toc="Unit_Testing_Tutorial#other-features">其它功能</h3>    <div class="chapter"><h4 id="quick-doc-for-macros">测试宏的快速文档</h4>    <p id="be95aef0">为了帮助您探索测试框架提供的宏，“ <a href="viewing-inline-documentation.html">快速文档”弹出窗口</a>显示了最终的宏替换并正确设置了其格式。它还突出显示了结果替换中使用的字符串和关键字：</p><figure><img alt="快速文档弹出窗口中的格式化宏扩展" title="快速文档弹出窗口中的格式化宏扩展" src="/help/img/idea/2019.3/cl_UTtutorial_quickdoc_catchmacro.png" id="ccfea181" width="750" height="701"></figure>    <p></p>    </div>          <div class="chapter"><h4 id="show-test-list">显示测试清单</h4>    <p id="8f40d188">为了减少初始索引编制的时间，CLion使用了惰性测试检测。这意味着在打开某些测试文件或运行/调试测试配置之前，测试将从索引中排除。要检查当前为您的项目检测到的<span class="control"><i id="a24b1b31">测试</i></span> ，请从“ <span class="menupath" data-skip-index="skip">帮助” |“</span> <span class="control"><i id="a24b1b31">显示”中单击“显示测试列表”</i></span> <span class="menupath" data-skip-index="skip">。查找动作</span> 。请注意，调用此操作不会触发索引。</p>               </div></div>   </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年12月1日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__next" href="boost-test-support.html">促进。测试支持</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>