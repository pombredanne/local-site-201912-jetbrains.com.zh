<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        dotCover tutorial, how to run and cover tests in continuous integration, coverage on CI server&#xA;    " name="description" data-skip-index="skip"><title>Set up Coverage on JetBrains TeamCity - Help | dotCover</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity" data-article-props="&#xA;                {&#xA;                &#xA;            &#34;seeAlso&#34;:{&#xA;                                             &#xA;                &#34;&#34;: [&#xA;                &#xA;                ],                                 &#xA;                &#34;Concepts&#34;: [&#xA;                &#xA;        {&#34;href&#34;:&#34;dotCover__Basic_Concepts.html&#34;,&#34;title&#34;:&#34;Basic Terms&#34;}&#xA;        {&#34;href&#34;:&#34;Running_Coverage_Analysis_from_the_Command_LIne.html&#34;,&#34;title&#34;:&#34;Coverage Analysis from the Command Line&#34;}&#xA;        {&#34;href&#34;:&#34;dotCover__Console_Runner_Commands.html&#34;,&#34;title&#34;:&#34;Console Runner Commands&#34;}&#xA;        {&#34;href&#34;:&#34;dotCover__Console_Runner_Configuration.html&#34;,&#34;title&#34;:&#34;Console Runner Configuration&#34;}&#xA;                ],                                 &#xA;                &#34;Procedures&#34;: [&#xA;                &#xA;        {&#34;href&#34;:&#34;&#34;,&#34;title&#34;:&#34;Set up Coverage on JetBrains TeamCity&#34;}&#xA;        {&#34;href&#34;:&#34;dotCover__Analyzing_Test_Coverage.html&#34;,&#34;title&#34;:&#34;Working with Coverage Results&#34;}&#xA;                ]&#xA;            }&#xA;        &#xA;                }&#xA;            " data-disqus-id="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity_dcv"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotCover Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotCover 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity" id="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity.xml">Set up Coverage on JetBrains TeamCity</h1>            <p id="7fe0071c">        Normally, a continuous integration (CI) build of a .NET solution consist of a series of tasks that        involve compilation and running of tests. In terms of <a href="http://www.jetbrains.com/teamcity/" data-external="true" target="_blank" rel="noopener noreferrer">JetBrains TeamCity</a> CI server, these tasks are called build steps. As TeamCity        comes bundled with <a href="Running_Coverage_Analysis_from_the_Command_LIne.html">dotCover Console Runner</a>,        you can collect code coverage data by just enabling the corresponding build step option.        TeamCity-collected coverage results can be viewed as a report inside TeamCity or downloaded as a        <a href="What_is_Coverage_Snapshot.html">coverage snapshot</a>        and viewed inside Visual Studio.    </p>    <p id="82e172b7">        For example, we have a simple solution that consists of two projects: one stands for the application and        the other one for the test assembly. Our task is to set up continuous integration build that compiles the        application, runs tests, and collects tests coverage statistics. Note that the workflow differs depending on the        unit test runner you use:        <ul class="list _ul"><li class="list__item" id="46d3f0bd"><p>                <a href="#nunit">MSTest / NUnit</a>,            </p></li><li class="list__item" id="dafa3cbe"><p>                <a href="#xunit">xUnit</a>,            </p></li><li class="list__item" id="96927fbb"><p>                <a href="#mspec">MSpec</a>.            </p></li></ul>    </p>    <div class="chapter"><h2 id="nunit" data-toc="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity#nunit">MSTest/NUnit</h2>        <p id="ce3e43b8">            The MSTest and NUnit test runners are provided by TeamCity out of the box, so, generally, all            you need is to add a build step with the corresponding runner.        </p>        <section class="procedure-steps"><h3 id="d68b08f0">To set up coverage analysis of MSTest/NUnit tests in TeamCity</h3><ol class="list _decimal"><li class="list__item" id="251829b7"><p>                In TeamCity, create a <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new build project</a> and setup the VCS root. We then add a new Build Step:                Create a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new project</a>                and a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Build+Configurations" data-external="true" target="_blank" rel="noopener noreferrer">new build configuration</a>                inside the project.            </p></li><li class="list__item" id="693f0e4c"><p>                Add a first build step, that will build the application. In our particular example, we use                the <span class="control">Visual Studio (sln)</span> runner (requires Visual Studio to be installed                on a build agent), but you have a number of other options on how to build:                directly run MSBuild, run batch file, etc.                <figure><img alt="tc build step1 compile" title="tc build step1 compile" src="/help/img/dotnet/2019.2/tc_build_step1_compile.png" id="30642bbe" width="801" height="718"></figure>                Notice that all we are doing here is building the solution. No coverage settings yet.            </p></li><li class="list__item" id="17880abf">                Add a build step that runs the tests. If you use MSTest tests, select                <span class="control">Visual Studio Tests</span>                in <span class="control">Runner type</span>.                Our sample solution uses                <a href="https://confluence.jetbrains.com/display/TCD10/NUnit" data-external="true" target="_blank" rel="noopener noreferrer">NUnit</a>                tests, therefore, we choose                <span class="control">NUnit</span>. Here we also specify the                NUnit version, .NET runtime parameters and path                to the tests assembly.                <aside class="note " data-title="" rel="3da9dc7b" id="df4f979a">                    <p id="9c7f5598">In case of                        <a href="https://confluence.jetbrains.com/display/TCD10/Visual+Studio+Tests" data-external="true" target="_blank" rel="noopener noreferrer">Visual Studio Tests</a>                        the parameters look similar: you specify a MSTest/VSTest version and test file names.                    </p>                </aside>                <figure><img alt="tc build step2 run tests" title="tc build step2 run tests" src="/help/img/dotnet/2019.2/tc_build_step2_run_tests.png" id="bc22f452" width="792" height="412"></figure>            </li><li class="list__item" id="9f566fd6"><p>                Now, it's time to set up coverage.                In the <span class="control">.NET coverage tool</span>, choose <span class="control">JetBrains dotCover</span>.                <figure><img alt="tc build step2 coverage" title="tc build step2 coverage" src="/help/img/dotnet/2019.2/tc_build_step2_coverage.png" id="b6a8bc73" width="742" height="273"></figure>            </p></li><li class="list__item" id="ad964a77">                In <span class="control">Assembly Filters</span>, add the assemblies you want coverage                for (just the name of the assembly) prefixing them with                <code class="code">+:</code>                and filter out those you do not want coverage                for with <code class="code">–:</code>. In our example, we exclude the                <code class="code">MainTests</code>                assembly that contains running tests.                <aside class="note " data-title="" rel="9052fb9a" id="dcaf25c9">                    <p id="cd9e8914">                        Additionally, you can use <a href="https://confluence.jetbrains.com/display/TCD10/JetBrains+dotCover" data-external="true" target="_blank" rel="noopener noreferrer">Attribute Filters</a> to exclude code that is marked with a specific attribute (e.g., <code class="code">ObsoleteAttribute</code>)                        from coverage statistics.                    </p>                </aside>            </li><li class="list__item" id="af3bcb50"><p>                Save the configuration and run it to see how it works.                <figure><img alt="tc run conf" title="tc run conf" src="/help/img/dotnet/2019.2/tc_run_conf.png" id="d1cba864" width="700" height="231"></figure>            </p></li><li class="list__item" id="49401754"><p>                Once the build is finished, the <span class="control">Overview</span> tab will contain a short report                on code coverage.                <figure><img alt="tc overview" title="tc overview" src="/help/img/dotnet/2019.2/tc_overview.png" id="1c1562fe" width="641" height="577"></figure>                To see the details, switch to the <span class="control">Code Coverage</span> tab.                Here you can view the detailed statistics on how much of class/methods were covered by tests.                <figure><img alt="tc code coverage" title="tc code coverage" src="/help/img/dotnet/2019.2/tc_code_coverage.png" id="9b051250" width="923" height="407"></figure>                Or even drill down into individual classes and examine the code coverage.                <figure><img alt="tc source code" title="tc source code" src="/help/img/dotnet/2019.2/tc_source_code.png" id="2714d48c" width="917" height="565"></figure>                Build artifacts now contain coverage files zipped up.                <figure><img alt="tc artifacts" title="tc artifacts" src="/help/img/dotnet/2019.2/tc_artifacts.png" id="5026f69e" width="584" height="339"></figure>            </p></li><li class="list__item" id="8f3f72b0"><p>                Please note that in a real-life environment, you may have two different build configurations:                one that builds binaries and the other one that collects code coverage. In that case, you should                use snapshot dependency in order the second build configuration could find source files. Otherwise,                you will see the <code class="code">Source code is not available</code> message when trying to view source code.                <figure><img alt="tc no code" title="tc no code" src="/help/img/dotnet/2019.2/tc_no_code.png" id="f18b43fe" width="915" height="278"></figure>                To solve the issue, please follow the instructions from the <a href="https://confluence.jetbrains.com/display/TCD10/JetBrains+dotCover" data-external="true" target="_blank" rel="noopener noreferrer">TeamCity documentation</a>.            </p></li></ol></section>    </div>    <div class="chapter"><h2 id="xunit" data-toc="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity#xunit">xUnit</h2>        <p id="ebc22ac4">            The main problem with running and getting coverage of xUnit tests is that xUnit is not supported            by TeamCity out of the box. This creates two issues that must be solved:            <ul class="list _alpha-lower"><li class="list__item" id="6e2fdc67"><p>                    xUnit packages must be provided to build a solution.                    <br>                    Committing binary libraries to VCS                    is not a good practice, so, restoring the packages must be a separate build step before                    the compilation stage.                </p></li><li class="list__item" id="4802892b">                    xUnit test runner must be provided and run manually.                    <br>                    The good news:                    <ul class="list _ul"><li class="list__item" id="5fc711b5"><p>                            The runner is distributed as a NuGet package, so, it can be referenced right in your                            solution and then restored during a build (see a).                        </p></li><li class="list__item" id="3aba40d9"><p>                            There are no additional actions required to get tests results as the runner                            provides the results in the format of TeamCity service messages.                        </p></li></ul>                </li></ul>        </p>        <section class="procedure-steps"><h3 id="a2d1bb72">To set up coverage analysis of xUnit tests in TeamCity</h3><ol class="list _decimal"><li class="list__item" id="4a9105cc"><p>                In Visual Studio, open your solution. In the tests project, add a reference to the                <code class="code">xunit.runner.console</code>                NuGet package.                <figure><img alt="install xunit console" title="install xunit console" src="/help/img/dotnet/2019.2/install_xunit_console.png" id="710f3473" width="512" height="277"></figure>            </p></li><li class="list__item" id="53969804"><p>                In TeamCity, create a <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new build project</a> and setup the VCS root. Then add a new Build Step:                Create a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new project</a>                and a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Build+Configurations" data-external="true" target="_blank" rel="noopener noreferrer">new build configuration</a>                inside the project.            </p></li><li class="list__item" id="e854201f"><p>                Make sure, TeamCity is configured as a NuGet server:                in <span data-skip-index="skip" class="menupath">Administration | Tools</span> find the <span class="control">NuGet.exe</span> table                and check whether it contains the required NuGet version. If there is no such a table, add                the NuGet to TeamCity by clicking the <span class="control">Install Tool...</span> button and following                the required steps.                <figure><img alt="tc xunit nuget server" title="tc xunit nuget server" src="/help/img/dotnet/2019.2/tc_xunit_nuget_server.png" id="978cd6f9" width="534" height="148"></figure>            </p></li><li class="list__item" id="177b19dc"><p>                Add a build step, that restores NuGet packages referenced by the solution. Use                <span class="control">NuGet Installer</span>                as the <span class="control">Runner type</span>.                <figure><img alt="tc nuget installer step" title="tc nuget installer step" src="/help/img/dotnet/2019.2/tc_nuget_installer_step.png" id="e7ee0e00" width="666" height="350"></figure>            </p></li><li class="list__item" id="dea4c9d1"><p>                Add a build step, that will build the application. In our particular example, we use                the <span class="control">Visual Studio (sln)</span> runner (requires Visual Studio to be installed                on a build agent), but you have a number of other options on how to build:                directly run MSBuild, run batch file, etc.                <figure><img alt="tc build step1 compile" title="tc build step1 compile" src="/help/img/dotnet/2019.2/tc_build_step1_compile.png" id="76d82e63" width="801" height="718"></figure>                Notice that all we are doing here is building the solution. No coverage settings yet.            </p></li><li class="list__item" id="ed4663aa">                Add a build step that runs the tests:                <ul class="list _ul"><li class="list__item" id="e49895c1"><p>                        As the xUnit runner will be executed as a simple                        <code class="code">.exe</code>                        file, select <span class="control">.NET Process</span> in the <span class="control">Runner type</span>.                    </p></li><li class="list__item" id="827f356e"><p>                        As the runner is provided as a package inside the solution, you can specify its path                        relatively to the solution working directory, e.g. <br>                        <code class="code">%system.teamcity.build.workingDir%SimpleTestsProject\packages\xunit.runner.console.2.3.1\tools\net452\xunit.console.exe</code>                    </p></li><li class="list__item" id="61d39f1b"><p>                        The <span class="control">Command line parameters</span> field must contain the path                        to the compiled test assembly.                    </p></li></ul>                <figure><img alt="tc xunit run cover step" title="tc xunit run cover step" src="/help/img/dotnet/2019.2/tc_xunit_run_cover_step.png" id="e48998b9" width="664" height="420"></figure>            </li><li class="list__item" id="5999c3e0"><p>                Now, it's time to set up coverage.                In the <span class="control">.NET coverage tool</span>, choose <span class="control">JetBrains dotCover</span>.                <figure><img alt="tc xunit coverage step" title="tc xunit coverage step" src="/help/img/dotnet/2019.2/tc_xunit_coverage_step.png" id="b9048678" width="655" height="361"></figure>            </p></li><li class="list__item" id="27f7754a">                In <span class="control">Assembly Filters</span>, add the assemblies you want coverage                for (just the name of the assembly) prefixing them with                <code class="code">+:</code>                and filter out those you do not want coverage                for with <code class="code">–:</code>. In our example, we exclude the                <code class="code">MainTests</code>                assembly that contains running tests and everything related to xUnit assemblies.                <aside class="note " data-title="" rel="81b80290" id="f9073e9a">                    <p id="74af5b91">                        Additionally, you can use <a href="https://confluence.jetbrains.com/display/TCD10/JetBrains+dotCover" data-external="true" target="_blank" rel="noopener noreferrer">Attribute Filters</a> to exclude code that is marked with a specific attribute (e.g., <code class="code">ObsoleteAttribute</code>)                        from coverage statistics.                    </p>                </aside>            </li><li class="list__item" id="6df45d7b"><p>                Save the configuration and run it to see how it works.            </p></li><li class="list__item" id="2d13780a"><p>                Once the build is finished, the <span class="control">Overview</span> tab will contain a short report                on test results and code coverage.                <figure><img alt="tc xunit overview" title="tc xunit overview" src="/help/img/dotnet/2019.2/tc_xunit_overview.png" id="3954bfaa" width="577" height="531"></figure>                To see the details, switch to the <span class="control">Code Coverage</span> tab.                Here you can view the detailed statistics on how much of class/methods were covered by tests.                <figure><img alt="tc xunit coverage stats" title="tc xunit coverage stats" src="/help/img/dotnet/2019.2/tc_xunit_coverage_stats.png" id="56c4c5dc" width="911" height="350"></figure>                Or even drill down into individual classes and examine the code coverage.                <figure><img alt="tc xunit coverage source code" title="tc xunit coverage source code" src="/help/img/dotnet/2019.2/tc_xunit_coverage_source_code.png" id="9ff4eead" width="578" height="620"></figure>                Build artifacts now contain coverage files zipped up.            </p></li></ol></section>    </div>    <div class="chapter"><h2 id="mspec" data-toc="dotCover__Setting_up_Coverage_Analysis_JetBrains_TeamCity#mspec">MSpec</h2>        <p id="b4adf078">            MSpec is partly supported by TeamCity out of the box: it has a corresponding build step runner, but            MSpec test runner is not in the bundle and must be installed to TeamCity agents manually.            Fortunately, the runner is distributed as a NuGet package, so, it can be referenced right in your            solution and then restored during a build.        </p>        <section class="procedure-steps"><h3 id="4a741048">To set up coverage analysis of MSpec tests in TeamCity</h3><ol class="list _decimal"><li class="list__item" id="e4e5bc34"><p>                In Visual Studio, open your solution. In the tests project, add a reference to the                <code class="code">Machine.Specifications.Runner.Console</code>                NuGet package.                <figure><img alt="tc mspec nuget" title="tc mspec nuget" src="/help/img/dotnet/2019.2/tc_mspec_nuget.png" id="225cb699" width="610" height="277"></figure>            </p></li><li class="list__item" id="9336de24"><p>                In TeamCity, create a <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new build project</a> and setup the VCS root. Then add a new Build Step:                Create a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Projects" data-external="true" target="_blank" rel="noopener noreferrer">new project</a>                and a                <a href="https://confluence.jetbrains.com/display/TCD10/Creating+and+Editing+Build+Configurations" data-external="true" target="_blank" rel="noopener noreferrer">new build configuration</a>                inside the project.            </p></li><li class="list__item" id="aa891148"><p>                Make sure, TeamCity is configured as a NuGet server:                in <span data-skip-index="skip" class="menupath">Administration | Tools</span> find the <span class="control">NuGet.exe</span> table                and check whether it contains the required NuGet version. If there is no such a table, add                the NuGet to TeamCity by clicking the <span class="control">Install Tool...</span> button and following                the required steps.                <figure><img alt="tc xunit nuget server" title="tc xunit nuget server" src="/help/img/dotnet/2019.2/tc_xunit_nuget_server.png" id="7953c672" width="534" height="148"></figure>            </p></li><li class="list__item" id="7c0a006d"><p>                Add a build step, that restores NuGet packages referenced by the solution. Use                <span class="control">NuGet Installer</span>                as the <span class="control">Runner type</span>.                <figure><img alt="tc nuget installer step" title="tc nuget installer step" src="/help/img/dotnet/2019.2/tc_nuget_installer_step.png" id="c3dd4c78" width="666" height="350"></figure>            </p></li><li class="list__item" id="84c21f5c"><p>                Add a build step, that will build the application. In our particular example, we use                the <span class="control">Visual Studio (sln)</span> runner (requires Visual Studio to be installed                on a build agent), but you have a number of other options on how to build:                directly run MSBuild, run batch file, etc.                <figure><img alt="tc build step1 compile" title="tc build step1 compile" src="/help/img/dotnet/2019.2/tc_build_step1_compile.png" id="1c555c46" width="801" height="718"></figure>                Notice that all we are doing here is building the solution. No coverage settings yet.            </p></li><li class="list__item" id="56e0e2a1">                Add a build step that runs the tests:                <ul class="list _ul"><li class="list__item" id="caa686f2"><p>                        Select <span class="control">MSpec</span> in the <span class="control">Runner type</span>.                    </p></li><li class="list__item" id="188c7043"><p>                        As the runner is provided as a package inside the solution, you can specify its path                        relatively to the solution working directory, e.g. <br>                        <code class="code">%system.teamcity.build.workingDir%SimpleTestsProject\packages\Machine.Specifications.Runner.Console.0.9.3\tools\mspec-clr4.exe</code> <br>                        Make sure you use the runner version that corresponds the project's targeted .NET Framework                        version.                    </p></li><li class="list__item" id="ced57296"><p>                        In <span class="control">Run tests from</span>, specify the path                        to the compiled test assembly.                    </p></li><li class="list__item" id="4071018c"><p>                        If needed, specify what specifications must be included/excluded in                        <span class="control">Include specifications</span> and <span class="control">Exclude specifications</span>.                    </p></li></ul>                <figure><img alt="tc mspec runner step" title="tc mspec runner step" src="/help/img/dotnet/2019.2/tc_mspec_runner_step.png" id="757c5bc1" width="660" height="562"></figure>            </li><li class="list__item" id="954097a4"><p>                Now, it's time to set up coverage.                In the <span class="control">.NET coverage tool</span>, choose <span class="control">JetBrains dotCover</span>.                <figure><img alt="tc mspec coverage step" title="tc mspec coverage step" src="/help/img/dotnet/2019.2/tc_mspec_coverage_step.png" id="c28f2a91" width="658" height="315"></figure>            </p></li><li class="list__item" id="89603bcb">                In <span class="control">Assembly Filters</span>, add the assemblies you want coverage                for (just the name of the assembly) prefixing them with                <code class="code">+:</code>                and filter out those you do not want coverage                for with <code class="code">–:</code>. In our example, we exclude the                <code class="code">MSpecTests</code>                assembly that contains running tests and everything related to MSpec assemblies.                <aside class="note " data-title="" rel="30506c7f" id="850ec382">                    <p id="e5e25001">                        Additionally, you can use <a href="https://confluence.jetbrains.com/display/TCD10/JetBrains+dotCover" data-external="true" target="_blank" rel="noopener noreferrer">Attribute Filters</a> to exclude code that is marked with a specific attribute (e.g., <code class="code">ObsoleteAttribute</code>)                        from coverage statistics.                    </p>                </aside>            </li><li class="list__item" id="0beabcdb"><p>                Save the configuration and run it to see how it works.            </p></li><li class="list__item" id="24e80dd2"><p>                Once the build is finished, the <span class="control">Overview</span> tab will contain a short report                on test results and code coverage.                <figure><img alt="tc mspec overview" title="tc mspec overview" src="/help/img/dotnet/2019.2/tc_mspec_overview.png" id="2979f302" width="559" height="532"></figure>                To see the details, switch to the <span class="control">Code Coverage</span> tab.                Here you can view the detailed statistics on how much of class/methods were covered by tests.                <figure><img alt="tc mspec coverage stats" title="tc mspec coverage stats" src="/help/img/dotnet/2019.2/tc_mspec_coverage_stats.png" id="84abe72b" width="631" height="433"></figure>                Or even drill down into individual classes and examine the code coverage.                <figure><img alt="tc mspec coverage source code" title="tc mspec coverage source code" src="/help/img/dotnet/2019.2/tc_mspec_coverage_source_code.png" id="3094f2cb" width="632" height="610"></figure>                Build artifacts now contain coverage files zipped up.            </p></li></ol></section>    </div>    <div class="last-modified" data-skip-index="skip">Last modified: 30 September 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="dotCover__Server_Test_Coverage.html">Analyze Coverage on a Server</a><a class="navigation-links__next" href="dotCover__Coverage_Analysis_on_Third-Party_Server.html">Set up Coverage on a Third-Party CI Server</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>