<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>迁移到Java 8-帮助|帮助IntelliJ IDEA</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Migrating_to_Java_8" data-breadcrumbs="Language and framework-specific guidelines/Java_SE.xml|Java SE/Migrating_to_Java_8.xml|Migrating to Java 8" data-main-title="Migrating to Java 8"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索IntelliJ IDEA帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default_for_windows" data-group="primary" selected>Windows的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_sublime_text" data-group="primary">崇高文字</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_macos" data-group="secondary">苹果系统</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_macos" data-group="secondary">Eclipse（macOS）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_intellij_idea_classic" data-group="secondary">IntelliJ IDEA经典版</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_sublime_text" data-group="secondary">崇高文字</option><option value="secondary_sublime_text_macos" data-group="secondary">崇高文字（macOS）</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Migrating_to_Java_8.xml" data-toc="Migrating_to_Java_8">迁移至Java 8</h1>    <p id="f38454ff">使用最新版本的语言和库使代码保持最新是一项艰巨的任务。幸运的是，IntelliJ IDEA可以通过检查以指导您的工作，自动修复和常用的重构工具使此操作变得更容易。</p>    <p id="d930440e">        <a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" rel="noopener noreferrer" data-external="true" target="_blank">Java SE 8</a>为该语言带来了全新的概念，例如lambda表达式，并为开发人员多年来舒适使用的类添加了新方法。此外，还有许多新的处理方法，包括新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" rel="noopener noreferrer" data-external="true" target="_blank">Date and Time API</a>和一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener noreferrer" data-external="true" target="_blank">Optional</a>类型，以帮助实现null安全。</p>    <p id="6327132b">在本教程中，我们将通过代码示例显示IntelliJ IDEA如何帮助您将代码从Java 6（或7）过渡到Java 8，以及显示什么可用的帮助以及何时使用或不使用选择的帮助。新的功能。</p>    <p id="189fa1d2">本教程假定满足以下先决条件：</p><ul class="list _bullet"><li class="list__item" id="a14e75f4"><p>您已经有一个用于现有代码库的IntelliJ IDEA项目。</p></li></ul>    <p></p>    <p id="ba7d609b">在此页：</p>    <ul class="list" data-skip-index="skip"><li class="list__item"><a href="#3ed4379e">解决问题</a></li><li class="list__item"><a href="#80944bd4">初始设置</a></li><li class="list__item"><a href="#2a4ccf96">配置和运行语言级别迁移检查</a></li><li class="list__item"><a href="#9d7a88ec">Lambda表达式</a></li><li class="list__item"><a href="#c8031520">应用lambda表达式的影响</a></li><li class="list__item"><a href="#4feecb4d">新的收集方法</a></li><li class="list__item"><a href="#e0f6166e">流API-foreach</a></li><li class="list__item"><a href="#d0864fd6">流API-收集</a></li><li class="list__item"><a href="#8f6efd7a">用Streams替换foreach的影响</a></li><li class="list__item"><a href="#ca58b222">新的日期和时间API</a></li><li class="list__item"><a href="#20fc38e9">迁移到新的日期和时间API的影响</a></li><li class="list__item"><a href="#86f4c8c8">使用可选</a></li><li class="list__item"><a href="#c0a42c4c">迁移到可选的影响</a></li><li class="list__item"><a href="#92f446e6">摘要</a></li></ul>    <section class="procedure-steps"><h3 id="3ed4379e">解决问题</h3><p id="90be7a77">IntelliJ IDEA可用的大量选项和功能可能令人不知所措，尤其是在解决像试图将整个代码库（甚至只是模块或包）迁移到新版本这样大的问题时。与大多数软件开发问题一样，以迭代方式解决此问题也很有意义。</p><ol class="list _decimal"><li class="list__item" id="2bcfb722"><p>选择少量更改以实施。</p></li><li class="list__item" id="69e942fd"><p>选择一部分代码库以将其应用于。</p></li><li class="list__item" id="8c6f93c4"><p>批量应用更改，频繁运行项目测试，并在测试呈绿色时检入VCS系统。</p></li></ol><p id="e30c2322">为此，本教程将更改分为几部分，而不是采用大爆炸方法。</p></section>    <section class="procedure-steps"><h3 id="80944bd4">初始设置</h3><ol class="list _decimal"><li class="list__item" id="22f2da2f"><p>确保使用Java 8 SDK进行编译。如果不是，请将您的SDK更改为Java 8的最新版本。</p></li><li class="list__item" id="87482927"><p>在<a href="project-page.html">项目设置中</a> ，您应该将语言级别设置为“ 8.0-Lambdas，键入注释”。</p></li></ol><p id="9905f06d">如果要在CI环境中编译代码，则需要确保在那里也使用Java 8编译新代码。配置此功能超出了本教程的范围。</p></section>    <section class="procedure-steps"><h3 id="2a4ccf96">配置和运行语言级别迁移检查</h3><p id="24a87f24">您的项目可能已经利用检查来鼓励代码中的一定程度的一致性和质量。为了仅专注于进行与升级到Java 8有关的更改，我们将创建一个新的检查配置文件。</p><ol class="list _decimal"><li class="list__item" id="36210953"><p>导航到<a href="code-inspection.html#access-inspections-and-settings">检查设置</a> 。</p></li><li class="list__item" id="48ae08e8"><p>            <a href="customizing-profiles.html">创建一个</a>名为“ Java8” <a href="customizing-profiles.html">的新检查配置文件</a> 。</p></li><li class="list__item" id="c1c149c5"><p>作为此配置文件的起点，请使用“重置为空”按钮取消选择所有内容<img alt="resetProfile.png" title="resetProfile.png" src="/help/img/idea/2019.3/resetProfile.png" id="97ffd724" width="20" height="22" class="inline-icon-20"> 。</p></li><li class="list__item" id="a1479803">我们将选择一组语言迁移检查，以指出我们可能要更新的代码部分：<figure><img alt="ij Java 8迁移检查" title="ij Java 8迁移检查" src="/help/img/idea/2019.3/ij_java_8_migration_inspections.png" id="9b8efb47" width="513" height="514"></figure>这些检查将向我们展示您的代码中可以使用以下Java 8功能的区域：<ul class="list _ul"><li class="list__item" id="6633a2ca">                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener noreferrer" data-external="true" target="_blank">Lambda表达式</a>                </li><li class="list__item" id="bdab02e4">                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" rel="noopener noreferrer" data-external="true" target="_blank">方法参考</a>                </li><li class="list__item" id="fad66b9a"><p>新的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener noreferrer" data-external="true" target="_blank">收集</a>方法</p></li><li class="list__item" id="1e5755aa">                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener noreferrer" data-external="true" target="_blank">流API</a>                </li></ul>        </li><li class="list__item" id="90e15e9b"><p>单击“确定”将这些设置保存到“ Java8”配置文件，然后关闭设置窗口。</p></li><li class="list__item" id="580703d1"><p><a href="running-inspections.html">运行检查</a> ，选择“ Java8”概要文件和合并范围以运行检查。如果您的项目很小，则可能是整个代码库，但您更有可能希望选择一个模块或软件包。</p></li></ol><p id="fe9dc3ca"><span class="control">分析代码</span>运行完毕后，您将在<a href="inspection-results-tool-window.html">检验结果工具窗口中</a>看到一组结果。</p></section>    <section class="procedure-steps"><h3 id="9d7a88ec">Lambda表达式</h3><p id="d6873c80">检查将向您显示可以自动转换代码以使用lambda表达式的位置。您通常可以在现有代码中发现很多地方，例如，当您为以下内容创建匿名内部类时：</p><ul class="list _ul"><li class="list__item" id="1197868c"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" rel="noopener noreferrer" data-external="true" target="_blank">可运行</a> ， <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" rel="noopener noreferrer" data-external="true" target="_blank">可赎回</a>                    </p></li><li class="list__item" id="01443eb5">                        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" rel="noopener noreferrer" data-external="true" target="_blank">比较器</a>                    </li><li class="list__item" id="0f71afc9"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileFilter.html" rel="noopener noreferrer" data-external="true" target="_blank">文件</a> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html" rel="noopener noreferrer" data-external="true" target="_blank">过滤器</a>                    </p></li><li class="list__item" id="2ad97018">                        <a href="http://docs.oracle.com/javase/8/javafx/api/toc.htm" rel="noopener noreferrer" data-external="true" target="_blank">事件处理程序</a>                    </li><li class="list__item" id="e7c6a69f"><p>第三方接口（例如<a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicate.html" rel="noopener noreferrer" data-external="true" target="_blank">Guava的谓词）</a>                    </p></li></ul>            <p></p><ol class="list _decimal"><li class="list__item" id="b5e98c64"><p>在“ <a href="inspection-results-tool-window.html">检查结果工具”窗口中</a> ，您应该看到在“ Java语言级迁移帮助”下分组的结果。在此标题下，您可能会看到“匿名类型可以用lambda代替”。打开此标题，查看IntelliJ IDEA检测到可以使用lambda的代码的所有部分。您可能会看到以下内容：</p><figure><img alt="ij java 8检查结果迁移可运行" title="ij java 8检查结果迁移可运行" src="/help/img/idea/2019.3/ij_java_8_inspection_results_migration_runnable.png" id="7bf28528" width="1012" height="282"></figure>        <p></p></li><li class="list__item" id="3ee6cd97"><p>例如，您可能会遇到<code class="code">Runnable</code>匿名内部类：</p><div class="code-block" data-lang="java">executorService.scheduleAtFixedRate（new Runnable（）{@Override public void run（）{getDs（）。save（new CappedPic（title））;}}，0，500，MILLISECONDS）;</div>        <p></p></li><li class="list__item" id="50f83762">许多检查都建议可以应用此修复程序，并且“可以用lambda代替匿名类型”确实具有建议的解决方案。要应用此修复程序，请执行以下任一操作：<ul class="list _ul"><li class="list__item" id="dcd6f4f9"><p>单击检查窗口右侧的<span class="control">问题解决方案</span> ，在我们的情况下，这是<span class="control">用lambda替换</span> 。</p></li><li class="list__item" id="fd5c6223"><p>或按<kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd>在编辑器中的灰色代码上，然后选择<span class="control">替换为lambda</span> 。</p></li></ul>        </li><li class="list__item" id="da982193"><p>IntelliJ IDEA随后将自动更改上面的代码以使用lambda表达式：</p><div class="code-block" data-lang="java">executorService.scheduleAtFixedRate（（）-> getDs（）。save（new CappedPic（title）），0，500，MILLISECONDS）;</div>        <p></p></li></ol><p id="132d7cf3">您会注意到，就类型信息而言，lambda表达式的状态很少。在这里，这个lambda代表了<code class="code">Runnable</code>几乎消失了。IntelliJ IDEA将通过左侧装订线中的lambda图标为您提供有关lambda表达式类型的信息：</p><figure><img alt="ij java 8 lambda gutter图标" title="ij java 8 lambda gutter图标" src="/help/img/idea/2019.3/ij_java_8_lambda_gutter_icon.png" id="3c238da3" width="914" height="70"></figure>将鼠标悬停在上面将告诉您类型，然后单击以导航到声明。<p></p></section>    <div class="chapter"><h2 id="c8031520">应用lambda表达式的影响</h2>        <p id="9bec3af5">您应该能够自动将此修补程序应用于在代码库中找到匿名内部类的所有位置，而不会影响系统的功能。应用更改通常也会提高代码的可读性，就像上面的示例一样，删除样板行。</p>        <p id="81941d22">但是，您可能希望检查每个单独的更改，例如：</p><ul class="list _ul"><li class="list__item" id="c4bdad31"><p>较大的匿名内部类以lambda形式可能不太可读。</p></li><li class="list__item" id="5f6b1fbf"><p>您可以进行其他更改和改进。</p></li></ul>        <p></p>        <p id="77601735">让我们用一个例子解决这两点。</p>        <p id="818b3694">我们可能正在使用<code class="code">Runnable</code>在测试中对一组特定的断言进行分组：</p><div class="code-block" data-lang="java">Runnable runnable = new Runnable（）{@Override public void run（）{datastoreProvider.register（database）; Assert.assertNull（database.find（User.class，“ id”，1）.get（））; Assert.assertNull（database.find（User.class，“ id”，3）.get（））;用户foundUser = database.find（User.class，“ id”，2）.get（）; Assert.assertNotNull（foundUser）; Assert.assertNotNull（database.find（User.class，“ id”，4）.get（））; Assert.assertEquals（“应该找到1个朋友”，1，foundUser.friends.size（））; Assert.assertEquals（“应该找到合适的朋友”，4，foundUser.friends.get（0）.id）; };</div>        <p></p>        <p id="a439a7d6">将其转换为lambda会导致：</p><div class="code-block" data-lang="java">Runnable runnable =（）-> {datastoreProvider.register（database）; Assert.assertNull（database.find（User.class，“ id”，1）.get（））; Assert.assertNull（database.find（User.class，“ id”，3）.get（））;用户foundUser = database.find（User.class，“ id”，2）.get（）; Assert.assertNotNull（foundUser）; Assert.assertNotNull（database.find（User.class，“ id”，4）.get（））; Assert.assertEquals（“应该找到1个朋友”，1，foundUser.friends.size（））; Assert.assertEquals（“应该找到合适的朋友”，4，foundUser.friends.get（0）.id）; };</div>这不是很短，也不会对可读性产生太大影响。<p></p>        <p id="2fc1280d">在这种情况下，您可以选择使用IntelliJ IDEA的extract方法将这些行拉入单个方法中：</p><div class="code-block" data-lang="java">Runnable runnable =（）-> {assertUserMatchesSpecification（database，datastoreProvider）; };</div>        <p></p>        <p id="40621238">检查所有lambda转换的第二个原因是可以进一步简化某些lambda。最后一个示例就是其中之一-IntelliJ IDEA将以灰色显示花括号，然后按<kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd>将光标放在花括号上将弹出建议的更改<span class="control">语句lambda可以用表达式lambda代替</span> ：</p>        <p id="632738db"></p><figure><img alt="ij java 8语句lambda可以替换" title="ij java 8语句lambda可以替换" src="/help/img/idea/2019.3/ij_java_8_statement_lambda_can_be_replaced.png" id="71c77cbc" width="536" height="62"></figure><p></p>        <p id="84c262aa">接受此更改将导致：</p><div class="code-block" data-lang="java">Runnable runnable =（）-> assertUserMatchesSpecification（database，datastoreProvider）;</div>        <p></p>        <p id="7355b8e7">在将匿名内部类更改为lambda并进行了可能要进行的任何手动调整（例如提取方法或重新格式化代码）之后，请运行所有测试以确保一切仍然正常。如果是这样，请将这些更改提交给VCS。完成此操作后，您将准备好进行下一步。</p>    </div>    <section class="procedure-steps"><h3 id="4feecb4d">新的收集方法</h3><p id="d44343ba">Java 8通过Streams API引入了一种处理数据集合的新方法。鲜为人知的是，许多<code class="code">Collection</code>我们习惯使用的类在其上具有不通过Streams API的新方法。例如， <code class="code">java.util.Iterable</code>有个<code class="code">forEach</code>允许您传入表示要在每个元素上运行的操作的lambda的方法。IntelliJ IDEA的检查将重点介绍可以使用此方法和其他新方法的区域。</p><ol class="list _decimal"><li class="list__item" id="620117d0"><p>返回“ <a href="inspection-results-tool-window.html">检查结果工具”窗口中</a> ，您将在“ Java语言级迁移帮助”下看到“可以使用流api折叠foreach”。您可能不知道何时进行所有检查，但是并非所有这些修复程序都将使用Streams API（稍后将在Streams上进行介绍）。例如：</p><div class="code-block" data-lang="java">对于（类<!--? extends="" annotation=""-->注释：INTERESTING_ANNOTATIONS）{addAnnotation（annotation）; }<!--?--></div>IntelliJ IDEA建议“可以用foreach调用代替”。应用此检查可以使我们：<div class="code-block" data-lang="java">INTERESTING_ANNOTATIONS.forEach（this :: addAnnotation）;</div>请注意，IntelliJ IDEA已应用了所有可能的简化方式，甚至可以使用<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" rel="noopener noreferrer" data-external="true" target="_blank">方法参考</a>而不是lambda。方法引用是Java 8中的另一个新功能，通常可以在lambda表达式通常调用单个方法的地方使用。<p></p></li><li class="list__item" id="2ae5a1b9"><p>方法引用需要一段时间才能习惯，因此您可能更喜欢将其扩展为lambda以查看lambda版本：</p><figure><img alt="ij java 8用lambda替换方法参考" title="ij java 8用lambda替换方法参考" src="/help/img/idea/2019.3/ij_java_8_replace_method_reference_with_lambda.png" id="2bfa45d1" width="616" height="82"></figure>按<kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd>在方法参考上，然后单击<span class="control">以lambda替换方法参考</span> 。当您习惯所有新语法时，此功能特别有用。以lambda形式，它看起来像：<div class="code-block" data-lang="java">INTERESTING_ANNOTATIONS.forEach（（注释）-> addAnnotation（注释））;</div>        <p></p></li></ol><p id="6ecd2b15">两种新形式的功能都与原始代码完全相同-对于<code class="code">INTERESTING_ANNOTATIONS</code>清单，它调用<code class="code">addAnnotation</code>与项目。</p></section>    <section class="procedure-steps"><h3 id="e0f6166e">流API-foreach</h3><p id="5a0c22b1">IntelliJ IDEA的检查将建议使用<code class="code">forEach</code>上<code class="code">Iterable</code>在适当的情况下，但新的Streams API也是一个更好的选择。</p><p id="aab65150"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener noreferrer" data-external="true" target="_blank">Streams API</a>是用于查询和处理数据的强大工具，使用它可以显着更改和简化您编写的代码。在本教程中，我们将介绍一些最简单的用例以帮助您入门。一旦您对使用这种样式的编码感到更加自在，则可能需要进一步使用其功能。</p><ol class="list _decimal"><li class="list__item" id="83812ba9"><p>Streams API给我们带来了什么，我们无法简单地从使用<code class="code">forEach</code>方法？让我们看一个示例，它的for循环比上一个稍微复杂一些：</p><div class="code-block" data-lang="java">public void addAllBooksToLibrary（Set <book>books）{for（Book book：books）{if（book.isInPrint（））{library.add（book）; }}}</book></div>首先，循环主体检查某些条件，然后对通过该条件的项目进行处理。<p></p></li><li class="list__item" id="ac1e6e1c"><p>选择修复程序<span class="control">替换为forEach</span>将使用Streams API进行相同的操作：</p><div class="code-block" data-lang="java">公共无效addAllBooksToLibrary（设置<book>书籍）{books.stream（）.filter（book-> book.isInPrint（））.forEach（library :: add）; }</book></div>在这种情况下，IntelliJ IDEA已为<code class="code">forEach</code>参数。对于过滤器，IntelliJ IDEA使用了lambda，但会在编辑器中建议此特定示例可以使用方法参考：<figure><img alt="ij java 8可以替换为方法ref" title="ij java 8可以替换为方法ref" src="/help/img/idea/2019.3/ij_java_8_can_be_replaced_with_method_ref.png" id="e7b775f2" width="535" height="102"></figure>        <p></p></li><li class="list__item" id="c4c07873"><p>应用此修复程序可以得出：</p><div class="code-block" data-lang="java">books.stream（）.filter（Book :: isInPrint）.forEach（library :: add）;</div>        <p></p></li></ol></section>    <section class="procedure-steps"><h3 id="d0864fd6">流API-收集</h3><p id="3607f9ef">代替“可以用foreach代替”调用，您可能会看到“可以用collect调用代替”。这与上面的示例非常相似，但是没有调用<code class="code">forEach</code>方法在流的末尾并执行一些操作，这将使用流的collect方法将流操作的所有结果放入新的<code class="code">Collection</code> 。看到一个<code class="code">for</code>循环访问某些集合，执行某种过滤或操作，然后将结果输出到新的集合中，这就是该检查将识别并使用Streams API迁移到的代码。</p><ol class="list _decimal"><li class="list__item" id="e0f3463c"><p>在“ <a href="inspection-results-tool-window.html">检查结果工具”窗口中</a> ，您应该在“ Java语言级迁移辅助工具”下看到“ foreach可以被collect调用代替”。选择这些检查结果之一将显示一个for循环，可能类似于：</p><div class="code-block" data-lang="java">列表<key>键= ...列表<key.id>objIds = new ArrayList <key.id>（）;对于（Key key：keys）{objIds.add（key.getId（））; }</key.id></key.id></key></div>在这里，我们遍历了Key对象的列表，从这些对象中的每个对象获取ID，并将它们全部放入单独的objIds集合中。<p></p></li><li class="list__item" id="7866a8aa"><p>应用“ <span class="control">替换为收集”</span>修复程序将此代码转换为：</p><div class="code-block" data-lang="java">列表<key.id>objIds = keys.stream（）。map（Key :: getId）.collect（Collectors.toList（））;</key.id></div>        <p></p></li><li class="list__item" id="bcc6690a"><p>重新格式化此代码，以便您可以更清楚地看到所有Stream操作：</p><div class="code-block" data-lang="java">列出<key.id>objIds = keys.stream（）.map（Key :: getId）.collect（Collectors.toList（））;</key.id></div>这和原始代码所做的完全一样-收集了<code class="code">Key</code> s，每个“映射” <code class="code">Key</code>对其<code class="code">Id</code> ，并将它们收集到新列表中， <code class="code">objIds</code> 。<p></p></li></ol><p id="5a09a4f7">如<code class="code">forEach</code>例如，如果需要将过滤器应用于collect语句和映射，则IntelliJ IDEA可以解决问题，因此可以将许多复杂的循环巧妙地转换为一组Stream操作。</p></section>    <div class="chapter"><h2 id="8f6efd7a">用Streams替换foreach的影响</h2>        <p id="cb289cca">运行这些检查并仅自动应用所有修复程序可能很诱人。当涉及到将代码转换为在Collection或Streams上使用新方法时，应多加注意。IDE将确保您的代码按以前的方式工作，但是在应用更改后，您需要检查代码是否保持可读性和可理解性。如果您和您的团队是第一次使用Java 8功能，那么其中一些新代码将非常陌生，甚至可能不清楚。请花一些时间分别查看每个更改，并在继续之前检查一下自己是否了解新代码，这很高兴。</p>        <p id="1e96e8dc">与lambda一样，一个好的经验法则是从一小段代码开始-缩写为转换为两个或更少流操作的循环，最好是单行lambda。随着对方法的熟悉，您可能需要处理更复杂的代码。</p>        <p id="cae4d772">让我们看一个例子：</p>        <p id="0d2c084c">IntelliJ IDEA建议此代码：</p><div class="code-block" data-lang="java">对于（Entry <class><!--?="" extends="" annotation=""-->，List <annotation>> e：getAnnotations（）。entrySet（））{if（e.getValue（）！= null &&！e.getValue（）。isEmpty（））{for（注解注解：e.getValue（））{destination.addAnnotation（e.getKey（），注解）; }}}</annotation></class></div>可以转换为以下代码：<div class="code-block" data-lang="java">getAnnotations（）。entrySet（）.stream（）.filter（e-> e.getValue（）！= null &&！e.getValue（）。isEmpty（））.forEach（e-> {for（注解注解：e.getValue（））{destination.addAnnotation（e.getKey（），注解）;}}）;</div>撇开原始代码一开始很难理解的事实，出于多种原因，您可以选择不应用更改：<ul class="list _ul"><li class="list__item" id="07c42a9f"><p>尽管重构了外部循环，但内部仍存在一个for循环<code class="code">forEach</code>方法。这表明可能有不同的方式来构造流调用，也许使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" rel="noopener noreferrer" data-external="true" target="_blank">flatMap</a> 。</p></li><li class="list__item" id="c5032d47"><p>的<code class="code">destination.addAnnotation</code>方法表明，可能有一种方法可以使用<code class="code">collect</code>打电话而不是<code class="code">forEach</code> 。</p></li><li class="list__item" id="f3a0a197"><p>可以说，它比原始代码更容易理解。</p></li></ul>但是，出于以下原因，您可以选择接受此更改：<ul class="list _ul"><li class="list__item" id="86b0b4b5"><p>这是一段复杂的代码，它遍历和处理集合中的数据，因此，朝Streams API迈进是正确的方向。当团队的开发人员更加熟悉Streams的工作方式时，可以对其进行进一步的重构或改进。</p></li><li class="list__item" id="92e8ae24"><p>在新代码中<code class="code">if</code>条件已移至<code class="code">filter</code>调用，更清楚地说明此部分代码的用途。</p></li></ul>除了“保留代码”和“应用更改”选项外，还有第三个选项：将旧代码重构为更具可读性的内容，即使它不使用Java 8。这可能是一段很好的代码，以便以后进行重构，而不是试图解决所有代码的问题，而只是尝试采用更多的Java 8约定。<p></p>    </div>    <section class="procedure-steps"><h3 id="ca58b222">新的日期和时间API</h3><p id="0fb72443">我们为“ Java8”配置文件选择的检查有助于我们找到可以使用lambda表达式的位置，Collections上的新方法和Streams API，并将自动将修复程序应用于这些位置。Java 8中还有许多其他新功能，在以下各节中，我们将重点介绍IntelliJ IDEA的某些功能，这些功能也可以帮助您使用这些功能。</p><p id="5f57765d">在本节中，我们将研究通过使用新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" rel="noopener noreferrer" data-external="true" target="_blank">Date and Time API</a>而不是<code class="code">java.util.Date</code>和<code class="code">java.util.Calendar</code> 。</p><ol class="list _decimal"><li class="list__item" id="9de91e28"><p>您需要启用新的检查以查找对旧的Date and Time API的使用。</p><figure><img alt="ij java 8日期时间检查" title="ij java 8日期时间检查" src="/help/img/idea/2019.3/ij_java_8_date_time_inspection.png" id="ce35079d" width="382" height="265"></figure>请注意，尽管许多方法已被弃用<code class="code">java.util.Date</code>在一段时间内，该类本身不会被弃用，因此，如果在代码中使用它，则不会收到弃用警告。这就是为什么此检查对查找用法有用的原因。<p></p></li><li class="list__item" id="781af692"><p>            <a href="running-inspections.html">运行检查</a> 。您应该看到如下所示的结果列表：</p><figure><img alt="ij java 8日期时间检查结果" title="ij java 8日期时间检查结果" src="/help/img/idea/2019.3/ij_java_8_date_time_inspection_results.png" id="86b8e170" width="449" height="356"></figure>        <p></p></li><li class="list__item" id="0310369b"><p>与早期的检查不同，这些检查没有建议的修复程序，因为它们将要求您和您的团队评估旧类的使用并决定如何将其迁移到新的API。如果你有一个<code class="code">Date</code>表示没有时间的单个日期的字段，例如：</p><div class="code-block" data-lang="java">公共类HotelBooking {私人最终旅馆酒店；私人最终日期checkInDate;私人最终日期checkOutDate; //构造函数，getter和setter ...}</div>您可以选择将其替换为<code class="code">LocalDate</code> 。这可以通过上下文菜单“ <span class="control">重构” |“</span>完成”来完成<span class="control">。输入迁移...</span>或通过<kbd data-primary_default_for_windows="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_sublime_text="N/A" data-primary_visual_studio="Ctrl+Shift+F6" data-secondary_macos="⇧⌘F6" data-secondary_eclipse="⌃⇧F6" data-secondary_eclipse_macos="N/A" data-secondary_emacs="⌃⇧F6" data-secondary_intellij_idea_classic="⇧⌘F6" data-secondary_netbeans="⌃⇧F6" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⇧F6">Ctrl+Shift+F6</kbd> 。在弹出窗口中输入LocalDate并选择<code class="code">java.time.LocalDate</code> 。当您按Enter键时，这将更改此字段的类型以及获取和设置器。您可能仍需要解决使用字段，getter或setter的编译错误。<p></p></li><li class="list__item" id="585de306"><p>对于既是日期又是时间的字段，您可以选择将其迁移到<code class="code">java.time.LocalDateTime</code> 。对于只有时间的字段， <code class="code">java.time.LocalTime</code>可能是适当的。</p></li><li class="list__item" id="ebddea52"><p>如果您使用新的设置原始值<code class="code">Date</code> ，知道这等于现在的日期和时间：</p><div class="code-block" data-lang="java">booking.setCheckInDate（new Date（））;</div>您可以改用<code class="code">now()</code>方法：<div class="code-block" data-lang="java">booking.setCheckInDate（LocalDate.now（））;</div>        <p></p></li><li class="list__item" id="e44cc2cb"><p>为以下项设置值的一种常见且可读的方法<code class="code">java.util.Date</code>被用来<code class="code">java.text.SimpleDateFormat</code> 。您可能会看到类似于以下内容的代码：</p><div class="code-block" data-lang="java">SimpleDateFormat格式=新的SimpleDateFormat（“ yyyy-MM-dd”）; booking.setCheckInDate（format.parse（“ 2017-03-02”））;</div>如果此入住日期已迁移到<code class="code">LocalDate</code> ，您可以轻松地将此日期设置为特定日期，而无需使用格式化程序：<div class="code-block" data-lang="java">booking.setCheckInDate（LocalDate.of（2017，3，2））;</div>        <p></p></li></ol><p id="d1015ba9">这些示例只是为了完全利用Java 8中的新日期和时间功能，几乎不希望您进行或需要进行的更改的内容。查看<a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" rel="noopener noreferrer" data-external="true" target="_blank">Oracle提供</a>的<a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" rel="noopener noreferrer" data-external="true" target="_blank">教程，以</a>获取有关新API功能以及如何使用它们的更多信息。</p></section>    <div class="chapter"><h2 id="20fc38e9">迁移到新的日期和时间API的影响</h2>        <p id="32e376be">与将匿名内部类迁移到Lambda Expressions和循环到Streams API相比，更新代码以使用新的Date and Time API需要更多的手动干预。 IntelliJ IDEA将帮助您了解您使用旧版本的数量和位置<code class="code">java.util.Date</code>和<code class="code">java.util.Calendar</code>类，这将帮助您了解迁移范围。IntelliJ IDEA的重构工具可以在必要时帮助您迁移这些类型。但是，您将需要制定一个策略，以了解如何处理每个更改，要使用的新类型以及如何正确使用这些类型。这不是您可以自动应用的更改。</p>    </div>    <section class="procedure-steps"><h3 id="86f4c8c8">使用可选</h3><p id="017eeba8">我们将要介绍的最后一个Java 8功能是新的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener noreferrer" data-external="true" target="_blank">Optional</a>类型。 <code class="code">java.util.Optional</code>提供给您一种处理空值的方法，并提供一种指定方法调用是否应返回空值的方法。像日期和时间一样，IntelliJ IDEA的功能将帮助您确定可能会受益于代码使用的代码区域。 <code class="code">Optional</code>类型。</p><ol class="list _decimal"><li class="list__item" id="6183702e"><p>有许多检查在Java代码中查找使用空值，这些检查对于确定可从使用中受益的区域很有用。 <code class="code">Optional</code> 。为了简单起见，我们将仅启用其中两个检查：</p><figure><img alt="ij Java 8空检查" title="ij Java 8空检查" src="/help/img/idea/2019.3/ij_java_8_null_inspections.png" id="3ebb27a7" width="363" height="473"></figure>        <p></p></li><li class="list__item" id="58d3ed27"><p>            <a href="running-inspections.html">运行代码分析</a> 。您应该看到如下所示的结果列表：</p><figure><img alt="ij java 8空检查结果" title="ij java 8空检查结果" src="/help/img/idea/2019.3/ij_java_8_null_inspection_results.png" id="4bedbfef" width="427" height="321"></figure>        <p></p></li><li class="list__item" id="4f103b06"><p>如果您看到字段的“分配为null”，则可能需要考虑将此字段转换为<code class="code">Optional</code> 。例如，在下面的代码中，将标记分配偏移的行：</p><div class="code-block" data-lang="java">私有整数偏移量； //代码...。公共生成器offset（int value）{offset = value> 0？值：null;返回这个} //更多代码...</div>这是因为在另一种方法中，代码在执行此操作之前会检查该值是否已设置：<div class="code-block" data-lang="java">如果（偏移！= null）{cursor.skip（offset）; }</div>在这种情况下，null是offset的有效值-表示尚未设置，因此不应使用。您可能希望将字段更改为<code class="code">Optional</code>的<code class="code">Integer</code>通过<kbd data-primary_default_for_windows="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_sublime_text="N/A" data-primary_visual_studio="Ctrl+Shift+F6" data-secondary_macos="⇧⌘F6" data-secondary_eclipse="⌃⇧F6" data-secondary_eclipse_macos="N/A" data-secondary_emacs="⌃⇧F6" data-secondary_intellij_idea_classic="⇧⌘F6" data-secondary_netbeans="⌃⇧F6" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⇧F6">Ctrl+Shift+F6</kbd> ，并更改设置值的方式：<div class="code-block" data-lang="java">private可选<integer>偏移量； //代码...公共生成器offset（int value）{offset = value> 0？Optional.of（value）：Optional.empty（）;返回这个} //更多代码...</integer></div>然后您可以在<code class="code">Optional</code>而不是执行null检查。最简单的解决方案是：<div class="code-block" data-lang="java">如果（offset.isPresent（））{cursor.skip（offset）; }</div>但是使用Lambda表达式定义该值的操作要优雅得多：<div class="code-block" data-lang="java">offset.ifPresent（（）-> cursor.skip（offset））;</div>        <p></p></li><li class="list__item" id="0788411e"><p>检查还指示方法返回null的位置。如果您有一个可以返回null值的方法，则调用此方法的代码应检查它是否返回null并采取适当的措施。但是，很容易忘记执行此操作，尤其是在开发人员不知道该方法可以返回null的情况下。更改这些方法以返回<code class="code">Optional</code>使其更加明确，这可能不会返回值。例如，也许我们的检查将这个方法标记为返回空值：</p><div class="code-block" data-lang="java">公开的客户findFirst（）{如果（customers.isEmpty（））{返回null； }其他{返回customer.get（0）; }}</div>我们可以更改此方法以返回<code class="code">Optional</code>的<code class="code">Customer</code> ：<div class="code-block" data-lang="java">public可选的<customer>findFirst（）{如果（customers.isEmpty（））{返回Optional.empty（）; } else {return Optional.ofNullable（customers.get（0））; }}</customer></div>        <p></p></li><li class="list__item" id="9ab22320"><p>您需要更改调用这些方法的代码以处理<code class="code">Optional</code>类型。如果值不存在，这可能是决定如何处理的正确位置。在上面的示例中，也许调用<code class="code">findFirst</code>方法看起来像这样：</p><div class="code-block" data-lang="java">Customer firstCustomer = customerDao.findFirst（）;如果（firstCustomer == null）{抛出新的CustomerNotFoundException（）; } else {firstCustomer.setNewOffer（offer）; }</div>但是我们现在要返回<code class="code">Optional</code> ，我们可以消除null检查：<div class="code-block" data-lang="java">可选的<customer>firstCustomer = customerDao.findFirst（）; firstCustomer.orElseThrow（（）-> new CustomerNotFoundException（））.setNewOffer（offer）;</customer></div>        <p></p></li></ol></section>    <div class="chapter"><h2 id="c0a42c4c">迁移到可选的影响</h2>        <p id="b69b46d0">将字段类型更改为<code class="code">Optional</code>会产生很大的影响，而且要自动完成所有任务并不容易。首先，请尝试继续使用<code class="code">Optional</code>在班级内部-如果您可以将字段更改为<code class="code">Optional</code>尽量不要通过getter和setter公开它，这将使您进行更逐步的迁移。</p>        <p id="a770e02e">将方法返回类型更改为<code class="code">Optional</code>产生了更大的影响，您可能会以意想不到的方式看到这些更改在您的代码库中泛滥成灾。将这种方法应用于所有可以为null的值可能会导致<code class="code">Optional</code>代码中的变量和字段，可以在多个位置执行<code class="code">isPresent</code>检查或使用<code class="code">Optional</code>执行操作或引发适当异常的方法。</p>        <p id="9cd340b6">请记住，使用Java 8中的新功能的目的是简化代码并提高可读性，因此将更改范围限制在代码的小部分，并检查是否使用<code class="code">Optional</code>使您的代码更易于理解，而不是难以维护。</p>        <p id="a74102f9">IntelliJ IDEA的检查将确定可能的更改位置，并且重构工具可以帮助应用这些更改，但是可以重构为<code class="code">Optional</code>影响很大，您和您的团队应该确定一个策略，以了解要更改的区域以及如何应对这些更改。您甚至可以使用建议的“将字段[fieldName]注释为@Nullable”的修补程序来标记那些要迁移到的字段<code class="code">Optional</code> ，以便朝这个方向迈出一步，对代码的影响较小。</p>    </div>    <div class="chapter"><h2 id="92f446e6">摘要</h2>        <p id="1cb2d91a">IntelliJ IDEA的检查（尤其是与语言迁移有关的检查）可以帮助识别代码中可以重构为使用Java 8功能的区域，甚至自动应用这些修复程序。</p>        <p id="971194ea">如果您已自动应用了这些修补程序，那么查看更新的代码以确保它不难理解是很有价值的，并且可以帮助您熟悉新功能。</p>        <p id="1ab7e87b">本教程提供了有关如何迁移代码的一些指导。我们介绍了<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener noreferrer" data-external="true" target="_blank">lambda表达式</a>和<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" rel="noopener noreferrer" data-external="true" target="_blank">方法参考</a> ， <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener noreferrer" data-external="true" target="_blank">Collection</a>上的一些新方法，介绍了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener noreferrer" data-external="true" target="_blank">Streams API</a> ，展示了IntelliJ IDEA如何帮助您使用新的<a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" rel="noopener noreferrer" data-external="true" target="_blank">Date and Time API，</a>并研究了如何识别可能会受益于使用新<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener noreferrer" data-external="true" target="_blank">Optional的地方。</a>类型。</p>        <p id="a9fe0887">Java 8中有许多新功能，旨在使程序员的工作更轻松-使代码更具可读性，并使对数据结构执行复杂的操作更加容易。IntelliJ IDEA当然不仅支持这些功能，而且还可以帮助开发人员使用它们，包括迁移现有代码并在编辑器中提供帮助和建议，以指导您使用它们。</p>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月29日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="java-se.html">Java SE</a> <a class="navigation-links__next" href="getting-started-with-java-9-module-system.html">Java 9模块系统入门</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>