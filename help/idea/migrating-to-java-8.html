<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Migrating to Java 8 - Help | IntelliJ IDEA</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Migrating_to_Java_8" data-breadcrumbs="Language and framework-specific guidelines/Java_SE.xml|Java SE/Migrating_to_Java_8.xml|Migrating to Java 8" data-main-title="Migrating to Java 8"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search IntelliJ IDEA Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="primary" value="primary_default_for_windows" selected>Default for Windows</option><option data-group="primary" value="primary_eclipse">Eclipse</option><option data-group="primary" value="primary_emacs">Emacs</option><option data-group="primary" value="primary_netbeans">NetBeans</option><option data-group="primary" value="primary_sublime_text">Sublime Text</option><option data-group="primary" value="primary_visual_studio">Visual Studio</option><option data-group="secondary" value="secondary_macos">macOS</option><option data-group="secondary" value="secondary_eclipse">Eclipse</option><option data-group="secondary" value="secondary_eclipse_macos">Eclipse (macOS)</option><option data-group="secondary" value="secondary_emacs">Emacs</option><option data-group="secondary" value="secondary_intellij_idea_classic">IntelliJ IDEA Classic</option><option data-group="secondary" value="secondary_netbeans">NetBeans</option><option data-group="secondary" value="secondary_sublime_text">Sublime Text</option><option data-group="secondary" value="secondary_sublime_text_macos">Sublime Text (macOS)</option><option data-group="secondary" value="secondary_visual_studio">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 data-toc="Migrating_to_Java_8" id="Migrating_to_Java_8.xml">Migrating to Java 8</h1>    <p id="f38454ff">Keeping your code up to date with the latest versions of languages and libraries is a challenging task.        Fortunately, IntelliJ IDEA can make this easier, with inspections to guide your efforts, automatic fixes, and        the usual refactoring tools.    </p>    <p id="d930440e">        <a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" data-external="true" target="_blank" rel="noopener noreferrer">Java SE 8</a>        brings entire new concepts to the language, like lambda expressions, and adds new methods to classes that        developers have been using comfortably for years. In addition, there are new ways of doing things, including the        new        <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-external="true" target="_blank" rel="noopener noreferrer">Date and Time API</a>,        and an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-external="true" target="_blank" rel="noopener noreferrer">Optional</a>        type to help with null-safety.    </p>    <p id="6327132b">In this tutorial we're going to show how IntelliJ IDEA can help you transition your code from Java 6 (or 7) to Java        8, using code examples to show what help is available and when you may, or may not, choose to use new features.    </p>    <p id="189fa1d2">This tutorial assumes the following prerequisites:        <ul class="list _bullet"><li class="list__item" id="a14e75f4"><p>You already have an IntelliJ IDEA project for an existing codebase.</p></li></ul>    </p>    <p id="ba7d609b">On this page:</p>    <ul class="list" data-skip-index="skip"><li class="list__item"><a href="#3ed4379e">Approaching the problem</a></li><li class="list__item"><a href="#80944bd4">Initial setup</a></li><li class="list__item"><a href="#2a4ccf96">Configuring and running language level migration inspections</a></li><li class="list__item"><a href="#9d7a88ec">Lambda expressions</a></li><li class="list__item"><a href="#c8031520">Impact of applying lambda expressions</a></li><li class="list__item"><a href="#4feecb4d">New Collection Methods</a></li><li class="list__item"><a href="#e0f6166e">Streams API - foreach</a></li><li class="list__item"><a href="#d0864fd6">Streams API - collect</a></li><li class="list__item"><a href="#8f6efd7a">Impact of replacing foreach with Streams</a></li><li class="list__item"><a href="#ca58b222">New Date and Time API</a></li><li class="list__item"><a href="#20fc38e9">Impact of migrating to the new Date and Time API</a></li><li class="list__item"><a href="#86f4c8c8">Using Optional</a></li><li class="list__item"><a href="#c0a42c4c">Impact of migrating to Optional</a></li><li class="list__item"><a href="#92f446e6">Summary</a></li></ul>    <section class="procedure-steps"><h3 id="3ed4379e">Approaching the problem</h3><p id="90be7a77">The sheer number of options and features that IntelliJ IDEA has available might be overwhelming,                especially when tackling a problem as big as trying to migrate a whole codebase (or even just a module                or package) to a new version. As with most software development problems, it pays to approach this in an                iterative fashion.            </p><ol class="list _decimal"><li class="list__item" id="2bcfb722"><p>Pick a small number of changes to implement.</p></li><li class="list__item" id="69e942fd"><p>Pick a section of the codebase to apply them to.</p></li><li class="list__item" id="8c6f93c4"><p>Apply the changes in batches, running your project tests frequently and checking in to your VCS system            when the tests are green.        </p></li></ol><p id="e30c2322">To this end, this tutorial will group changes into sections rather than assume a Big Bang approach.</p></section>    <section class="procedure-steps"><h3 id="80944bd4">Initial setup</h3><ol class="list _decimal"><li class="list__item" id="22f2da2f"><p>Make sure you're compiling with a Java 8 SDK. If you're not, change your SDK            to the latest version of Java 8.        </p></li><li class="list__item" id="87482927"><p>In the <a href="project-page.html">project settings</a>, you should set your language level to "8.0 - Lambdas,            type annotations".        </p></li></ol><p id="9905f06d">If you are compiling the code in a CI environment, you'll need to ensure the new code is compiled using                Java 8 there as well. Configuring this is beyond the scope of this tutorial.            </p></section>    <section class="procedure-steps"><h3 id="2a4ccf96">Configuring and running language level migration inspections</h3><p id="24a87f24">Your project may already make use of inspections to encourage a certain level                of consistency and quality in the code. To focus purely on just making changes related to upgrading to                Java 8, we're going to create a new inspection profile.            </p><ol class="list _decimal"><li class="list__item" id="36210953"><p>Navigate to the            <a href="code-inspection.html#access-inspections-and-settings">inspections settings</a>.        </p></li><li class="list__item" id="48ae08e8"><p>            <a href="customizing-profiles.html">Create a new inspection profile</a>            called "Java8".        </p></li><li class="list__item" id="c1c149c5"><p>            As a starting point for this profile, deselect everything using the "reset to empty" button            <img alt="resetProfile.png" title="resetProfile.png" src="/help/img/idea/2019.3/resetProfile.png" id="97ffd724" width="20" height="22" class="inline-icon-20">.        </p></li><li class="list__item" id="a1479803">            We're going to select a set of language migration inspections to point out sections of the code we might            want to update:            <figure><img alt="ij java 8 migration inspections" title="ij java 8 migration inspections" src="/help/img/idea/2019.3/ij_java_8_migration_inspections.png" id="9b8efb47" width="513" height="514"></figure>            These inspections will show us areas in your code where you may be able to use the following Java 8            features:            <ul class="list _ul"><li class="list__item" id="6633a2ca">                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" data-external="true" target="_blank" rel="noopener noreferrer">Lambda expressions</a>                </li><li class="list__item" id="bdab02e4">                    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-external="true" target="_blank" rel="noopener noreferrer">Method references</a>                </li><li class="list__item" id="fad66b9a"><p>New                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" data-external="true" target="_blank" rel="noopener noreferrer">Collection</a>                    methods                </p></li><li class="list__item" id="1e5755aa">                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-external="true" target="_blank" rel="noopener noreferrer">Streams API</a>                </li></ul>        </li><li class="list__item" id="90e15e9b"><p>Click OK to save these settings to the "Java8" profile and close the settings window.</p></li><li class="list__item" id="580703d1"><p><a href="running-inspections.html">Run the inspections</a>, selecting the "Java8" profile and the scope to run            the inspections on. If your project is small, that might be the whole codebase, but more likely you will            want to select a module or package to start with.        </p></li></ol><p id="fe9dc3ca">                Once                <span class="control">Analyse code</span>                has finished running, you'll see a set of results in the                <a href="inspection-results-tool-window.html">Inspection Results Tool Window</a>.            </p></section>    <section class="procedure-steps"><h3 id="9d7a88ec">Lambda expressions</h3><p id="d6873c80">The inspections will show you places where you can convert code automatically to use lambda expressions.                There are a number of places you might typically discover this in your existing code, for example when                you create anonymous inner classes for:                <ul class="list _ul"><li class="list__item" id="1197868c"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" data-external="true" target="_blank" rel="noopener noreferrer">Runnable</a>,                        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" data-external="true" target="_blank" rel="noopener noreferrer">Callable</a>                    </p></li><li class="list__item" id="01443eb5">                        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" data-external="true" target="_blank" rel="noopener noreferrer">Comparator</a>                    </li><li class="list__item" id="0f71afc9"><p>                        <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileFilter.html" data-external="true" target="_blank" rel="noopener noreferrer">FileFilter</a>,                        <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html" data-external="true" target="_blank" rel="noopener noreferrer">PathMatcher</a>                    </p></li><li class="list__item" id="2ad97018">                        <a href="http://docs.oracle.com/javase/8/javafx/api/toc.htm" data-external="true" target="_blank" rel="noopener noreferrer">EventHandler</a>                    </li><li class="list__item" id="e7c6a69f"><p>Third party interfaces like                        <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Predicate.html" data-external="true" target="_blank" rel="noopener noreferrer">Guava's Predicate</a>                    </p></li></ul>            </p><ol class="list _decimal"><li class="list__item" id="b5e98c64"><p>In the <a href="inspection-results-tool-window.html">Inspection Results Tool Window</a>, you should see results grouped under "Java            language level migration aids". Under this heading, you may see "Anonymous type can be replaced with            lambda". Open up this heading to see all the sections of the code where IntelliJ IDEA has detected you can            use a lambda. You might see something like this:            <figure><img alt="ij java 8 inspection results migration runnable" title="ij java 8 inspection results migration runnable" src="/help/img/idea/2019.3/ij_java_8_inspection_results_migration_runnable.png" id="7bf28528" width="1012" height="282"></figure>        </p></li><li class="list__item" id="3ee6cd97"><p>For example, you may come across a            <code class="code">Runnable</code>            anonymous inner class:            <div class="code-block" data-lang="java">
                executorService.scheduleAtFixedRate(new Runnable() {
                    @Override
                    public void run() {
                        getDs().save(new CappedPic(title));
                    }
                }, 0, 500, MILLISECONDS);</div>        </p></li><li class="list__item" id="50f83762">Many inspections suggest a fix that can be applied, and "Anonymous type can be replaced with            lambda" does have a suggested resolution. To apply the fix, either:            <ul class="list _ul"><li class="list__item" id="dcd6f4f9"><p>Click on the                    <span class="control">Problem Resolution</span>                    in the right of the inspection window, in our case this is                    <span class="control">Replace with lambda</span>.                </p></li><li class="list__item" id="fd5c6223"><p>Or press <kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd> on the grey code in the editor and select                    <span class="control">Replace with lambda</span>.                </p></li></ul>        </li><li class="list__item" id="da982193"><p>IntelliJ IDEA will then automatically change the code above to use a lambda expression:            <div class="code-block" data-lang="java">
                executorService.scheduleAtFixedRate(() -&gt; getDs().save(new CappedPic(title)), 0, 500, MILLISECONDS);</div>        </p></li></ol><p id="132d7cf3">                You'll notice that lambda expressions can state very little in terms of type information. Here, the fact                that this lambda represents an implementation of                <code class="code">Runnable</code>                all but disappears. IntelliJ IDEA will provide you with information about the type of the lambda expression                via the lambda icon in the left gutter:                <figure><img alt="ij java 8 lambda gutter icon" title="ij java 8 lambda gutter icon" src="/help/img/idea/2019.3/ij_java_8_lambda_gutter_icon.png" id="3c238da3" width="914" height="70"></figure>                Hovering over this will tell you the type, and clicking lets you navigate to the declaration.            </p></section>    <div class="chapter"><h2 id="c8031520">Impact of applying lambda expressions</h2>        <p id="9bec3af5">            You should be able to automatically apply this fix to all places where anonymous inner classes are found            in your codebase without impacting the functionality in your system. Applying the change will generally            also improve the readability of your code, removing lines of boilerplate like in the example above.        </p>        <p id="81941d22">            However, you may want to check each individual change, as:            <ul class="list _ul"><li class="list__item" id="c4bdad31"><p>Larger anonymous inner classes may not be very readable in a lambda form.</p></li><li class="list__item" id="5f6b1fbf"><p>There may be additional changes and improvements you can make.</p></li></ul>        </p>        <p id="77601735">Let's address both points with an example.</p>        <p id="818b3694">We might be using a            <code class="code">Runnable</code>            to group a specific set of assertions in our test:            <div class="code-block" data-lang="java">
                Runnable runnable = new Runnable() {
                    @Override
                    public void run() {
                        datastoreProvider.register(database);
                        Assert.assertNull(database.find(User.class, "id", 1).get());
                        Assert.assertNull(database.find(User.class, "id", 3).get());

                        User foundUser = database.find(User.class, "id", 2).get();
                        Assert.assertNotNull(foundUser);
                        Assert.assertNotNull(database.find(User.class, "id", 4).get());
                        Assert.assertEquals("Should find 1 friend", 1, foundUser.friends.size());
                        Assert.assertEquals("Should find the right friend", 4, foundUser.friends.get(0).id);
                    }
                };</div>        </p>        <p id="a439a7d6">            Converting this to a lambda results in:            <div class="code-block" data-lang="java">
                Runnable runnable = () -&gt; {
                    datastoreProvider.register(database);
                    Assert.assertNull(database.find(User.class, "id", 1).get());
                    Assert.assertNull(database.find(User.class, "id", 3).get());

                    User foundUser = database.find(User.class, "id", 2).get();
                    Assert.assertNotNull(foundUser);
                    Assert.assertNotNull(database.find(User.class, "id", 4).get());
                    Assert.assertEquals("Should find 1 friend", 1, foundUser.friends.size());
                    Assert.assertEquals("Should find the right friend", 4, foundUser.friends.get(0).id);
                };</div>            This is not much shorter, nor does it impact readability much.        </p>        <p id="2fc1280d">In cases like these, you may choose to use IntelliJ IDEA's extract method to pull these            lines into a single method instead:            <div class="code-block" data-lang="java">
                Runnable runnable = () -&gt; {
                    assertUserMatchesSpecification(database, datastoreProvider);
                };</div>        </p>        <p id="40621238">The second reason to check all your lambda conversions is that some lambdas can be further simplified.            This last example is one of them - IntelliJ IDEA will show the curly braces in grey, and            pressing <kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd> with the cursor on the braces will pop up the suggested            change            <span class="control">Statement lambda can be replaced with expression lambda</span>:        </p>        <p id="632738db"><figure><img alt="ij java 8 statement lambda can be replaced" title="ij java 8 statement lambda can be replaced" src="/help/img/idea/2019.3/ij_java_8_statement_lambda_can_be_replaced.png" id="71c77cbc" width="536" height="62"></figure></p>        <p id="84c262aa">Accepting this change will result in:            <div class="code-block" data-lang="java">
                Runnable runnable = () -&gt; assertUserMatchesSpecification(database, datastoreProvider);</div>        </p>        <p id="7355b8e7">Once you've changed your anonymous inner classes to lambdas and made any manual adjustments you might want            to make, like extracting methods or reformatting the code, run all your tests to make sure everything still            works. If so, commit these changes to VCS. Once you've done this, you'll be ready to move to the next step.        </p>    </div>    <section class="procedure-steps"><h3 id="4feecb4d">New Collection Methods</h3><p id="d44343ba">                Java 8 introduced a new way of working with collections of data, through the Streams API. What's less                well known is that many of the                <code class="code">Collection</code>                classes we're used to working                with have new methods on them that are not via the Streams API. For example,                <code class="code">java.util.Iterable</code>                has a                <code class="code">forEach</code>                method that lets you pass in a lambda that represents an operation to run on every element.                IntelliJ IDEA's inspections will highlight areas where you can use this and other new methods.            </p><ol class="list _decimal"><li class="list__item" id="620117d0"><p>Back in the <a href="inspection-results-tool-window.html">Inspection Results Tool Window</a>, you should see "foreach can be collapsed            with stream api" under "Java language level migration aids". You may not realise when you're going            through all the inspections, but not all of these fixes will use the Streams API (more on Streams later).            For example:            <div class="code-block" data-lang="java">
                for (Class&lt;? extends Annotation &gt; annotation : INTERESTING_ANNOTATIONS) {
                    addAnnotation(annotation);
                }</div>            IntelliJ IDEA suggests "Can be replaced with foreach call". Applying this inspection gives us:            <div class="code-block" data-lang="java">
                INTERESTING_ANNOTATIONS.forEach(this::addAnnotation);</div>            Note that IntelliJ IDEA has applied all simplifications it could, going as far as using a            <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-external="true" target="_blank" rel="noopener noreferrer">Method Reference</a>            rather than a lambda. Method references are another new features in Java 8, which can generally be used            where a lambda expression would usually call a single method.        </p></li><li class="list__item" id="2ae5a1b9"><p>            Method references take a while to get used to, so you may prefer to expand this into a lambda to see the            lambda version:            <figure><img alt="ij java 8 replace method reference with lambda" title="ij java 8 replace method reference with lambda" src="/help/img/idea/2019.3/ij_java_8_replace_method_reference_with_lambda.png" id="2bfa45d1" width="616" height="82"></figure>            Press <kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd> on the method reference and click            <span class="control">Replace method reference with lambda</span>. This is especially useful as you get used to            all the new syntax. In lambda form, it looks like:            <div class="code-block" data-lang="java">
                INTERESTING_ANNOTATIONS.forEach((annotation) -&gt; addAnnotation(annotation));</div>        </p></li></ol><p id="6ecd2b15">Both of the new forms do exactly the same thing as the original code - for every item in the            <code class="code">INTERESTING_ANNOTATIONS</code>            list, it calls            <code class="code">addAnnotation</code>            with the item.</p></section>    <section class="procedure-steps"><h3 id="e0f6166e">Streams API - foreach</h3><p id="5a0c22b1">                IntelliJ IDEA's inspections will suggest using the                <code class="code">forEach</code> on                <code class="code">Iterable</code>                where appropriate, but it will also the new Streams API where this                is a better choice.            </p><p id="aab65150">                The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-external="true" target="_blank" rel="noopener noreferrer">Streams API</a>                is a powerful tool for querying and manipulating data, and using it could significantly change and                simplify the code you write. For this tutorial, we're going to look at some of the simplest use                cases to get you started. Once you're more comfortable using this style of coding, you may then want                to use its capabilities further.            </p><ol class="list _decimal"><li class="list__item" id="83812ba9"><p>What does the Streams API give us that we can't simply get from using a            <code class="code">forEach</code> method? Let's look at an example that's a slightly more complicated for loop than            the previous one:            <div class="code-block" data-lang="java">
                public void addAllBooksToLibrary(Set&lt;Book&gt; books) {
                    for (Book book: books) {
                        if (book.isInPrint()) {
                            library.add(book);
                        }
                    }
                }</div>            Firstly the loop body checks some condition, then does something with the items that pass that condition.        </p></li><li class="list__item" id="ac1e6e1c"><p>            Selecting the fix            <span class="control">Replace with forEach</span> will use the Streams API to do the same thing:            <div class="code-block" data-lang="java">
                public void addAllBooksToLibrary(Set &lt;Book&gt; books) {
                    books.stream()
                         .filter(book -&gt; book.isInPrint())
                         .forEach(library::add);
                }</div>            In this case, IntelliJ IDEA has selected a method reference for the            <code class="code">forEach</code>            parameter. For filter, IntelliJ IDEA has used a lambda, but will suggest in the editor that this particular            example can use a method reference:            <figure><img alt="ij java 8 can be replaced with method ref" title="ij java 8 can be replaced with method ref" src="/help/img/idea/2019.3/ij_java_8_can_be_replaced_with_method_ref.png" id="e7b775f2" width="535" height="102"></figure>        </p></li><li class="list__item" id="c4c07873"><p>Applying this fix gives:            <div class="code-block" data-lang="java">
                books.stream()
                     .filter(Book::isInPrint)
                     .forEach(library::add);</div>        </p></li></ol></section>    <section class="procedure-steps"><h3 id="d0864fd6">Streams API - collect</h3><p id="3607f9ef">Instead of "can be replaced with foreach" call you might see "can be replaced with collect call". This is                very similar to the above example, but instead of calling a                <code class="code">forEach</code>                method at the end of the stream and performing some operation, this will use the stream's collect                method to put all the results from the stream operation into a new                <code class="code">Collection</code>. It's very common to see a                <code class="code">for</code>                loop that iterates over some collection,                performs some sort of filtering or manipulating, and outputs the results into a new collection, and                that's the sort of code this inspection will identify and migrate to using the Streams API.            </p><ol class="list _decimal"><li class="list__item" id="e0f3463c"><p>            In the <a href="inspection-results-tool-window.html">Inspection Results Tool Window</a>, you should see "foreach can be replaced with            collect call" under "Java language level migration aids". Selecting one of these inspection results will            show you a for loop that might look something like:            <div class="code-block" data-lang="java">
                List &lt;Key&gt; keys = ....

                List &lt;Key.Id&gt; objIds = new ArrayList&lt;Key.Id&gt;();
                for (Key key : keys) {
                    objIds.add(key.getId());
                }</div>            Here, we're looping over a list of Key objects, getting the Id from each of these objects, and putting them            all into a separate collection of objIds.        </p></li><li class="list__item" id="7866a8aa"><p>Apply the            <span class="control">Replace with collect</span>            fix to turn this code into:            <div class="code-block" data-lang="java">
                List&lt;Key.Id&gt; objIds = keys.stream().map(Key::getId).collect(Collectors.toList());
            </div>        </p></li><li class="list__item" id="bcc6690a"><p>Reformat this code so that you can see more clearly all the Stream operations:            <div class="code-block" data-lang="java">
                List&lt;Key.Id&gt; objIds = keys.stream()
                                          .map(Key::getId)
                                          .collect(Collectors.toList());</div>            This does exactly the same thing the original code did - takes a collection of            <code class="code">Key</code>s, "maps" each            <code class="code">Key</code>            to its            <code class="code">Id</code>, and collects those into a new list,            <code class="code">objIds</code>.        </p></li></ol><p id="5a09a4f7">Like the                <code class="code">forEach</code>                example, IntelliJ IDEA can work out if a filter needs applying to a collect statement as                well as maps, so it can cleverly turn many of your complex loops into a set of Stream operations.            </p></section>    <div class="chapter"><h2 id="8f6efd7a">Impact of replacing foreach with Streams</h2>        <p id="cb289cca">            It may be tempting to run these inspections and simply apply all fixes automatically. When it comes to            converting your code to use new methods on Collections or Streams, a little care should be taken. The            IDE will ensure that            your code works the same way it used to, but you need to check that your code remains readable and            understandable after applying the changes. If you and your team are using Java 8 features for the first            time, some of the new code will be very unfamiliar and probably unclear. Take the time to look at each            change individually and check you're happy you understand the new code before going ahead.        </p>        <p id="1e96e8dc">            Like with lambdas, a good rule of thumb is to start with small sections of code - short for loops that            translate into two or fewer stream operations, preferably with single-line lambdas. As you become more            familiar with the methods, then you may want to tackle more complex code.        </p>        <p id="cae4d772">Let's look at an example:</p>        <p id="0d2c084c">            IntelliJ IDEA suggests that this code:            <div class="code-block" data-lang="java">
                for (Entry&lt;Class &lt;? extends Annotation&gt;, List&lt;Annotation&gt;&gt; e : getAnnotations().entrySet()) {
                    if (e.getValue() != null &amp;&amp; !e.getValue().isEmpty()) {
                        for (Annotation annotation: e.getValue()) {
                            destination.addAnnotation(e.getKey(), annotation);
                        }
                    }
                } </div>            Can be converted to this code:            <div class="code-block" data-lang="java">
                getAnnotations().entrySet()
                                .stream()
                                .filter(e -&gt; e.getValue() != null &amp;&amp; !e.getValue().isEmpty())
                                .forEach(e -&gt; {
                                    for (Annotation annotation: e.getValue()) {
                                        destination.addAnnotation(e.getKey(), annotation);
                                    }
                                });</div>            Setting aside the fact that the original code is challenging to understand to begin with, you may choose not            to apply the changes for a number of reasons:            <ul class="list _ul"><li class="list__item" id="07c42a9f"><p>Despite refactoring away the outer-loop, there's still a for loop inside the                    <code class="code">forEach</code> method. This suggests                    that there may be a different way to structure the stream call, perhaps using                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" data-external="true" target="_blank" rel="noopener noreferrer">flatMap</a>.                </p></li><li class="list__item" id="c5032d47"><p>The                    <code class="code">destination.addAnnotation</code>                    method suggests that there may be a way to restructure this to use a                    <code class="code">collect</code>                    call rather than a                    <code class="code">forEach</code>.                </p></li><li class="list__item" id="f3a0a197"><p>It's arguably not easier to understand than the original code.</p></li></ul>            However, you may choose to accept this change for the following reasons:            <ul class="list _ul"><li class="list__item" id="86b0b4b5"><p>This is a complex piece of code that is iterating through and manipulating data in a collection,                    therefore a move towards the Streams API is a move in the right direction. It can be further                    refactored or improved later when the team's developers are more familiar with the way Streams                    work.                </p></li><li class="list__item" id="92e8ae24"><p>In the new code the                    <code class="code">if</code>                    condition has been moved into a                    <code class="code">filter</code>                    call, making clearer what purpose this section of the code is.                </p></li></ul>            Apart from the options "keep the code" and "apply the changes", there's a third option: refactor the old            code to something more readable, even if it doesn't use Java 8. This might be a good piece of code to            make a note of to refactor later, rather than trying to tackle all the code's problems while simply            trying to adopt more Java 8 conventions.        </p>    </div>    <section class="procedure-steps"><h3 id="ca58b222">New Date and Time API</h3><p id="0fb72443">                The inspections we've selected for our "Java8" profile help us to locate places where we can use                lambda expressions, new methods on Collections and the Streams API, and will apply fixes                automatically to those places.  There are plenty of other new features in Java 8, and in the                following sections we'll highlight some features of IntelliJ IDEA that may help you use these too.            </p><p id="5f57765d">                In this section, we'll look at locating places that may benefit from using the new                <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-external="true" target="_blank" rel="noopener noreferrer">Date and Time API</a>                instead of                <code class="code">java.util.Date</code> and                <code class="code">java.util.Calendar</code>.            </p><ol class="list _decimal"><li class="list__item" id="9de91e28"><p>You'll need to enable a new inspection to locate uses of the old Date and Time API.            <figure><img alt="ij java 8 date time inspection" title="ij java 8 date time inspection" src="/help/img/idea/2019.3/ij_java_8_date_time_inspection.png" id="ce35079d" width="382" height="265"></figure>            Note that although many methods have been deprecated on            <code class="code">java.util.Date</code> for some time, the class itself is not deprecated, so if you use it in your            code you will not receive deprecation warnings. That's why this inspection is useful to locate usages.        </p></li><li class="list__item" id="781af692"><p>            <a href="running-inspections.html">Run the inspection</a>. You should see a list of results that looks something like            this:            <figure><img alt="ij java 8 date time inspection results" title="ij java 8 date time inspection results" src="/help/img/idea/2019.3/ij_java_8_date_time_inspection_results.png" id="86b8e170" width="449" height="356"></figure>        </p></li><li class="list__item" id="0310369b"><p>            Unlike the earlier inspections, these do not have suggested fixes as they will require you and your team            to evaluate the use of the old classes and decide how to migrate them to the new API.  If you have a            <code class="code">Date</code>            field that represents a single date without a time, for example:            <div class="code-block" data-lang="java">
                public class HotelBooking {
                    private final Hotel hotel;
                    private final Date checkInDate;
                    private final Date checkOutDate;

                    // constructor, getters and setters...
                }</div>            you may choose to replace this with a            <code class="code">LocalDate</code>. This can be done via the context menu            <span class="control">Refactor | Type Migration...</span>            or via <kbd data-primary_default_for_windows="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_sublime_text="N/A" data-primary_visual_studio="Ctrl+Shift+F6" data-secondary_macos="⇧⌘F6" data-secondary_eclipse="⌃⇧F6" data-secondary_eclipse_macos="N/A" data-secondary_emacs="⌃⇧F6" data-secondary_intellij_idea_classic="⇧⌘F6" data-secondary_netbeans="⌃⇧F6" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⇧F6">Ctrl+Shift+F6</kbd>.  Type LocalDate in the popup and select            <code class="code">java.time.LocalDate</code>.   When you press enter, this will change the type of this field and            getters and setters.  You may still need to address compilation errors where the field, getters or            setters are used.        </p></li><li class="list__item" id="585de306"><p>            For fields that are both date and time, you may choose to migrate these to            <code class="code">java.time.LocalDateTime</code>. For            fields that are only time,            <code class="code">java.time.LocalTime</code>            may be appropriate.        </p></li><li class="list__item" id="ebddea52"><p>            If you were setting the original values with a new            <code class="code">Date</code>, knowing that this is the equivalent to the date and time right now:            <div class="code-block" data-lang="java">
                booking.setCheckInDate(new Date());
            </div>            you can instead use the            <code class="code">now()</code>            method:            <div class="code-block" data-lang="java">
                booking.setCheckInDate(LocalDate.now());
            </div>        </p></li><li class="list__item" id="e44cc2cb"><p>            A common and readable way to set a value for            <code class="code">java.util.Date</code>            was to use            <code class="code">java.text.SimpleDateFormat</code>. You            might see code that looks something like:            <div class="code-block" data-lang="java">
                SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
                booking.setCheckInDate(format.parse("2017-03-02"));
            </div>            If this check in date has been migrated to a            <code class="code">LocalDate</code>, you can easily set this to the specific date without the use of a formatter:            <div class="code-block" data-lang="java">
                booking.setCheckInDate(LocalDate.of(2017, 3, 2));
            </div>        </p></li></ol><p id="d1015ba9">                These examples barely scratch the surface of the changes you may want or need to do in order to fully                utilise the new date and time features in Java 8. Take a look at the                <a href="http://docs.oracle.com/javase/tutorial/datetime/TOC.html" data-external="true" target="_blank" rel="noopener noreferrer">tutorial provided by Oracle</a>                for more information on the new API features and how to use them.            </p></section>    <div class="chapter"><h2 id="20fc38e9">Impact of migrating to the new Date and Time API</h2>        <p id="32e376be">            Updating your code to use the new Date and Time API requires much more manual intervention than            migrating anonymous inner classes to Lambda Expressions and loops to the Streams API. IntelliJ IDEA will            help you see how much and where you use the old            <code class="code">java.util.Date</code> and            <code class="code">java.util.Calendar</code>            classes, which will help you understand the            scope of the migration. IntelliJ IDEA's refactoring tools can help you migrate these types if necessary.            However, you will need to have a strategy on how to approach each of the changes, which new types you            want to use, and how to use these correctly. This is not a change you can apply automatically.        </p>    </div>    <section class="procedure-steps"><h3 id="86f4c8c8">Using Optional</h3><p id="017eeba8">                The last Java 8 feature we'll look at is the new                <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-external="true" target="_blank" rel="noopener noreferrer">Optional</a>                type.                <code class="code">java.util.Optional</code>                gives you a way to handle null values, and a way to specify if a method call is expected to return a                null value or not. Like Date and Time, IntelliJ IDEA's features will help you to identify areas of your                code that might benefit from using the                <code class="code">Optional</code>                type.            </p><ol class="list _decimal"><li class="list__item" id="6183702e"><p>There are a number of inspections that look for the use nulls in Java code, these can be useful for            identifying areas that may benefit from using            <code class="code">Optional</code>.            We'll look at enabling just two of these inspections for simplicity:            <figure><img alt="ij java 8 null inspections" title="ij java 8 null inspections" src="/help/img/idea/2019.3/ij_java_8_null_inspections.png" id="3ebb27a7" width="363" height="473"></figure>        </p></li><li class="list__item" id="58d3ed27"><p>            <a href="running-inspections.html">Run the code analysis</a>. You should see a list of results that looks something like            this:            <figure><img alt="ij java 8 null inspection results" title="ij java 8 null inspection results" src="/help/img/idea/2019.3/ij_java_8_null_inspection_results.png" id="4bedbfef" width="427" height="321"></figure>        </p></li><li class="list__item" id="4f103b06"><p>            If you see "Assignment to null" for fields, you may want to consider turning this field into an            <code class="code">Optional</code>.            For example, in the code below, the line where offset is assigned will be flagged:            <div class="code-block" data-lang="java">
                private Integer offset;

                // code....

                public Builder offset(int value) {
                    offset = value &gt; 0 ? value : null;
                    return this;
                }

                // more code...</div>            That's because in another method, the code checks to see if this value has been set before doing            something with it:            <div class="code-block" data-lang="java">
                if (offset != null) {
                    cursor.skip(offset);
                }</div>            In this case, null is a valid value for offset - it indicates this has not been set, and            therefore shouldn't be used.  You may wish to change the field into an            <code class="code">Optional</code>            of            <code class="code">Integer</code>            via            <kbd data-primary_default_for_windows="Ctrl+Shift+F6" data-primary_eclipse="Ctrl+Shift+F6" data-primary_emacs="Ctrl+Shift+F6" data-primary_netbeans="Ctrl+Shift+F6" data-primary_sublime_text="N/A" data-primary_visual_studio="Ctrl+Shift+F6" data-secondary_macos="⇧⌘F6" data-secondary_eclipse="⌃⇧F6" data-secondary_eclipse_macos="N/A" data-secondary_emacs="⌃⇧F6" data-secondary_intellij_idea_classic="⇧⌘F6" data-secondary_netbeans="⌃⇧F6" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⇧F6">Ctrl+Shift+F6</kbd>, and alter the way the value is set:            <div class="code-block" data-lang="java">
                private Optional&lt;Integer&gt; offset;

                // code...

                public Builder offset(int value) {
                    offset = value &gt; 0 ? Optional.of(value) : Optional.empty();
                    return this;
                }

                // more code...</div>            Then you can use the methods on            <code class="code">Optional</code>            instead of performing null-checks.  The simplest            solution is:            <div class="code-block" data-lang="java">
                if (offset.isPresent()) {
                    cursor.skip(offset);
                }</div>            But it's much more elegant to use a Lambda Expression to define what to do with the value:            <div class="code-block" data-lang="java">
                offset.ifPresent(() -&gt; cursor.skip(offset));
            </div>        </p></li><li class="list__item" id="0788411e"><p>            The inspections also indicate places where a method returns null.  If you have a method that can return a            null value, the code that calls this method should check if it returned null and take            appropriate action. It's easy to forget to do this though, especially if the developer isn't aware            the method can return a null. Changing these methods to return an            <code class="code">Optional</code>            makes it much more explicit this might not return a value.  For example, maybe our inspections flagged this            method as returning a null value:            <div class="code-block" data-lang="java">
                public Customer findFirst() {
                    if (customers.isEmpty()) {
                        return null;
                    } else {
                        return customers.get(0);
                    }
                }</div>            We could alter this method to return an            <code class="code">Optional</code>            of            <code class="code">Customer</code>:            <div class="code-block" data-lang="java">
                public Optional&lt;Customer&gt; findFirst() {
                    if (customers.isEmpty()) {
                        return Optional.empty();
                    } else {
                        return Optional.ofNullable(customers.get(0));
                    }
                }</div>        </p></li><li class="list__item" id="9ab22320"><p>            You'll need to change the code that calls these methods to deal with the            <code class="code">Optional</code>            type. This might be            the correct place to make a decision about what to do if the value does not exist.  In the example            above, perhaps the code that calls the            <code class="code">findFirst</code>            method used to look like this:            <div class="code-block" data-lang="java">
                Customer firstCustomer = customerDao.findFirst();
                if (firstCustomer == null) {
                    throw new CustomerNotFoundException();
                } else {
                    firstCustomer.setNewOffer(offer);
                }</div>            But we're now returning an            <code class="code">Optional</code>, we can eliminate the null check:            <div class="code-block" data-lang="java">
                Optional&lt;Customer&gt; firstCustomer = customerDao.findFirst();
                firstCustomer.orElseThrow(() -&gt; new CustomerNotFoundException())
                             .setNewOffer(offer);
            </div>        </p></li></ol></section>    <div class="chapter"><h2 id="c0a42c4c">Impact of migrating to Optional</h2>        <p id="b69b46d0">            Changing a field type to            <code class="code">Optional</code>            can have a big impact, and it's not easy to do everything automatically.  To start with, try to keep the            use of            <code class="code">Optional</code>            inside the class - if you can change the field to an            <code class="code">Optional</code>            try not expose this via getters and setters, this will let you do a more gradual migration.        </p>        <p id="a770e02e">            Changing method return types to            <code class="code">Optional</code>            has an even bigger impact, and you may see these changes ripple            through your codebase in an unexpected way.  Applying this approach to all values that can be null could            result in            <code class="code">Optional</code>            variables and fields all over the code, with multiple places to performing            <code class="code">isPresent</code>            checks or using the            <code class="code">Optional</code>            methods to perform an action or throw an appropriate exception.        </p>        <p id="9cd340b6">            Remember that the goal of using the new features in Java 8 is to simplify the code and aid readability,            so limit the scope of the changes to small sections of the code and check that using            <code class="code">Optional</code>            is making your code easier to understand, not more difficult to maintain.        </p>        <p id="a74102f9">            IntelliJ IDEA's inspections will identify possible places for change, and the refactoring tools can help            apply these changes, but refactoring to            <code class="code">Optional</code>            has a large impact and you and your team should identify a strategy for which areas to change and how to            approach these changes.  You can even use the suggested fix of "Annotate field [fieldName] as @Nullable"            to mark those fields that are candidates for migrating to            <code class="code">Optional</code>, in order to take a step in that direction with a smaller impact on the code.        </p>    </div>    <div class="chapter"><h2 id="92f446e6">Summary</h2>        <p id="1cb2d91a">            IntelliJ IDEA's Inspections, in particular those around language migration, can help identify areas in your            code that can be refactored to use Java 8 features, and even apply those fixes automatically.        </p>        <p id="971194ea">            If you have applied the fixes automatically, it's valuable to look at the updated code to check it            isn't harder to understand, and to help you become familiar with the new features.        </p>        <p id="1ab7e87b">            This tutorial gave some pointers on how to migrate your code. We've covered            <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" data-external="true" target="_blank" rel="noopener noreferrer">lambda expressions</a>            and            <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" data-external="true" target="_blank" rel="noopener noreferrer">method references</a>, some new methods on            <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" data-external="true" target="_blank" rel="noopener noreferrer">Collection</a>,            introduced the            <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" data-external="true" target="_blank" rel="noopener noreferrer">Streams API</a>,            shown how IntelliJ IDEA can help you use the new            <a href="http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html" data-external="true" target="_blank" rel="noopener noreferrer">Date and Time API</a>            and looked at how to identify places that might benefit from using the new            <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" data-external="true" target="_blank" rel="noopener noreferrer">Optional</a> type.        </p>        <p id="a9fe0887">            There are plenty of new features in Java 8 designed to make life easier for programmers - to            make code more readable, and to make it easier to perform complex operations on data structures.            IntelliJ IDEA of course not only supports these features, but helps developers make use of them, including            migrating existing code and providing help and suggestions in the editor to guide you as you use them.        </p>    </div><div class="last-modified" data-skip-index="skip">Last modified: 29 November 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="java-se.html">Java SE</a><a class="navigation-links__next" href="getting-started-with-java-9-module-system.html">Getting Started with Java 9 Module System</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>