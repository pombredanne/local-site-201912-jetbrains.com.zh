<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Tutorial: Java Debugging Deep Dive - Help | IntelliJ IDEA</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Tutorial_Java_Debugging_Deep_Dive" data-breadcrumbs="Building, running, testing and deploying applications/Debugging_Code.xml|Debugging/Tutorial_Java_Debugging_Deep_Dive.xml|Tutorial: Java Debugging Deep Dive" data-main-title="Tutorial: Java Debugging Deep Dive"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search IntelliJ IDEA Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="primary" value="primary_default_for_windows" selected>Default for Windows</option><option data-group="primary" value="primary_eclipse">Eclipse</option><option data-group="primary" value="primary_emacs">Emacs</option><option data-group="primary" value="primary_netbeans">NetBeans</option><option data-group="primary" value="primary_sublime_text">Sublime Text</option><option data-group="primary" value="primary_visual_studio">Visual Studio</option><option data-group="secondary" value="secondary_macos">macOS</option><option data-group="secondary" value="secondary_eclipse">Eclipse</option><option data-group="secondary" value="secondary_eclipse_macos">Eclipse (macOS)</option><option data-group="secondary" value="secondary_emacs">Emacs</option><option data-group="secondary" value="secondary_intellij_idea_classic">IntelliJ IDEA Classic</option><option data-group="secondary" value="secondary_netbeans">NetBeans</option><option data-group="secondary" value="secondary_sublime_text">Sublime Text</option><option data-group="secondary" value="secondary_sublime_text_macos">Sublime Text (macOS)</option><option data-group="secondary" value="secondary_visual_studio">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Tutorial_Java_Debugging_Deep_Dive" id="Tutorial_Java_Debugging_Deep_Dive.xml">Tutorial: Java Debugging Deep Dive</h1>    <div class="chapter"><h2 id="f511d12a" data-toc="Tutorial_Java_Debugging_Deep_Dive#f511d12a">Overview</h2>        <p id="5a6ca2ab">            Debugging is one of the most powerful tools in any developer's arsenal. It gives us a unique insight into            how a program runs and allows us to gain a much deeper understanding of the piece of code we debug. It            allows us to trace running code and inspect the state and the flow of the execution. As part of that, it            gives us the illusion of a sequential flow. This is very intuitive and powerful but also may be            misleading as most modern applications are multithreaded.        </p>        <p id="12f6096b">"Debugging" suggests we deal with bugs but this is actually a misnomer. The information we get from debugging            is useful even when there is no problem with the code. Finding bugs just happens to be a very common use            case for the knowledge we can get from a debug session.        </p>        <p id="dbe32d1d">The IntelliJ IDEA debugger offers a rich experience that helps us to easily debug anything from the simplest            code to complex multithreaded applications.        </p>        <p id="82a07247">Before we start, a word of caution: debugging is a very powerful tool but it does come with a cost. The debug process is part            of the runtime and therefore affects it.            Every evaluation of an expression happens using the same memory of            the debugged application, and can modify and potentially corrupt the state.            During this tutorial, bear in mind that debugging is an intrusive approach that may affect the outcome of            the debugged application. We will explore a few ways to minimize its impact and sometimes even exploit it.            The timing of execution is also very different when you debug code compared to running it.            The minimal debug tracking overhead in itself may already be enough to change the timing of events and therefore the application behaviour. Every            <a href="using-breakpoints.html">breakpoint</a>            or log is a possible synchronization point, and stepping obviously changes the timings significantly.            As we are about to see, this becomes a critical issue in multithreaded environments, when sometimes reproducing a bug            depends on a very specific sequence of events.        </p>        <p id="d9d791bd">Last point to remember is that debugging is not a substitute for understanding the code. In fact, the            only way to learn from a debug session is to constantly compare the information the debugger shows us with            our expectations from the code and how we think it "should" behave.            Before starting a debugging session we must have some knowledge of what we're trying to achieve by it.            If we're looking for a bug, we need to roughly know what is incorrect, i.e. what is different from the            expected behaviour or state. In most cases we will also have some initial assumption as to why things are            wrong. This will dictate how our debugging session should be conducted. When we debug,            we must always compare that information with our expectations, and pay close attention when the code deviates from these expectations.            <br>This is the point where debugging is so effective.            <br>This is the point where we learn.        </p>        <p id="749bca72">            In this tutorial we try to dive deeper into debugging techniques and assume you are already familiar with the            basic concepts such as:            </p><ul class="list _bullet"><li class="list__item" id="4cf8dd96"><p><a href="using-breakpoints.html#set-line-breakpoint">Line breakpoints</a> to suspend the JVM or thread.</p></li><li class="list__item" id="36b39a5e"><p><a href="stepping-through-the-program.html">Stepping</a>.</p></li><li class="list__item" id="a77b0c5d"><p><a href="settings-debugger-stepping.html">Classes configured to be skipped</a>.</p></li><li class="list__item" id="f187d5ad"><p><a href="stepping-through-the-program.html#force-step-into">Force to step into</a> "skipped code".</p></li><li class="list__item" id="f50f9493">                                        <a href="examining-suspended-program.html#evaluating-expressions">Evaluating expressions</a>                </li><li class="list__item" id="9e654034"><p>Using a                                        <a href="examining-suspended-program.html#watches">watch</a>                </p></li><li class="list__item" id="09b68329"><p>Defining a <a href="debugger-data-type-renderers.html">type renderer</a></p></li></ul>        <p></p>    </div>    <div class="chapter"><h2 id="af0a6b11" data-toc="Tutorial_Java_Debugging_Deep_Dive#af0a6b11">Debugging code that was compiled without the debug flag</h2>        <p id="8fa9f6a0">Code that was compiled without the debug flag cannot be debugged. There is no way to step into this            code. When the debugger encounters such code during a debugging session, it will step over that part            of code.        </p>        <p id="091153ff">Line breakpoints are also not possible to define and hit. However, this is where the            <a href="using-breakpoints.html#method_breakpoint">Method Breakpoint</a>            might save us, as we can still define in IntelliJ IDEA a breakpoint to stop before entry            or exit from a specific method, even if the method itself was compiled without the debug flag.        </p>        <p id="dcc5070c">When viewing the state, since the actual variables within the method cannot be inspected, we will see a warning message instead. </p>        <figure><img alt="Variables debug info not available" title="Variables debug info not available" src="/help/img/idea/2019.3/ij_debugging_classes_compiled_without_debug_flag.png" id="9249e447" width="288" height="79"></figure>    </div>    <div class="chapter"><h2 id="9963db50" data-toc="Tutorial_Java_Debugging_Deep_Dive#9963db50">Debugging without source code</h2>        <p id="aa382b44">If we don't have the source to specific code, IntelliJ IDEA will still decompile the class and show            our steps in the decompiled source. This is very helpful, but note that the generated decompiled            class may look different from the original, and if the lines do not match, debugging in            decompiled code may be confusing. Always try to obtain the source code of the classes you want            to step into.        </p>    </div>    <div class="chapter"><h2 id="eeec1349" data-toc="Tutorial_Java_Debugging_Deep_Dive#eeec1349">Detecting unexpected state or flow</h2>        This section covers what to do if we know where things have already gone wrong, but don't know why.        <div class="chapter"><h3 id="96a9a5ff">Exploring the call frames</h3>            <p id="9fd50cb3">A                <span class="keyword">Line Breakpoint</span>                should be enough for most cases of detecting the cause behind an unexpected call                or call with unexpected parameter values to a method. If we're not sure where it's being called                from, we can put the breakpoint inside the method. When the VM is suspended, click the                previous <a href="debug-tool-window-frames.html">call frames</a> to view the call stack and inspect the state in each scope to see how we                got here.            </p>            <figure><img alt="Call frames" title="Call frames" src="/help/img/idea/2019.3/ij_debugging_call_frame.png" id="5c8e2b49" width="341" height="542"></figure>        </div>        <div class="chapter"><h3 id="67d8d4d1">Drop frames</h3>            <p id="e435ceef">If we stepped too far and want to go back up the stack to then re-execute the code, we can use                the                <a href="stepping-through-the-program.html#drop-frame">Drop Frame</a>                feature. It's a useful feature,                but also potentially dangerous: we must be aware that re-executing the code will execute the same                instructions twice, and if those instructions modify state we might end up in a corrupted                state, and certainly in a scenario that would not happen in a normal run under the same                conditions. To make the impact of                <span class="keyword">Drop Frame</span>                obvious, consider this simple program:            </p>            <div class="code-block" data-lang="java">
                public class DropFrameDemo
                {
                    private static int state = 0;

                    public static void main(final String[] args)
                    {
                        modifyStateBasedOnParameter(state);
                        modifyStateBasedOnStaticField();
                    }

                    // dropping frame within this method,
                    // and executing again will print state = 2
                    private static void modifyStateBasedOnStaticField()
                    {
                        state++;
                        System.out.println("state = " + state);
                    }

                    // dropping frame from within this method,
                    // and executing again will print state = 1
                    private static void modifyStateBasedOnParameter(final int parameter)
                    {
                        state = parameter + 1;
                        System.out.println("state = " + state);
                    }
                }
            </div>            <p id="dbb1496b">Breaking inside                <code class="code">modifyStateBasedOnParameter()</code>                will not impact the state because IntelliJ IDEA remembers the parameter values passed in to that                frame and will not recalculate those. However, breaking inside                <code class="code">modifyStateBasedOnStaticField()</code>                will make the                <code class="code">state</code>                field equal '2'. A value which is impossible under a normal run of                <code class="code">main()</code>.            </p>        </div>        <div class="chapter"><h3 id="2e76318a">Detecting unexpected flow by method</h3>            <aside data-type="note" class="prompt" data-title="" rel="2e76318a" id="80ad256e"><p>                In older versions of IntelliJ IDEA a method breakpoint significantly slows down the execution.                <br>                Since version 2017.1 the method breakpoint is actually emulated by line breakpoints and so is just as fast.            </p></aside>            <p id="c623b7ea">An alternative to having a line breakpoint defined within the problematic method is to define a                <a href="using-breakpoints.html#method_breakpoint">Method Breakpoint</a>. This type of breakpoint is not attached to a source                code line number, but to the entry and                exit of a call to a method. It is especially useful in two main cases:                </p><ul class="list _bullet"><li class="list__item" id="5dbac38d"><p>When a method is defined by an interface and we want to breakpoint in <span class="emphasis">all</span> implementations of it.</p></li><li class="list__item" id="709e27d0"><p>When we don't have the source                        code, only a decompiled version, and we still want to inspect the ins and outs of a method                        call, without any confusing differences in line numbers between the compiled class and the                        decompiled source code.</p></li></ul>            <p></p>        </div>        <div class="chapter"><h3 id="f1731614">Detecting unexpected object state</h3>            <aside data-type="note" class="prompt" data-title="" rel="f1731614" id="84375cb8"><p>                A field watchpoint is a type of breakpoint that slows down execution significantly and should be used with care,                especially in multithreaded applications where a change in timing can affect the scenario.            </p></aside>            <p id="b4dcf369">                Sometimes its hard to figure out the exact flow that caused a field to get to some unexpected state.                In those special cases we can use a breakpoint that will be hit anytime the program either read from or write to a specific field.                see <a href="using-breakpoints.html#field_watchpoint">Field Watchpoint</a>.            </p>        </div>        <div class="chapter"><h3 id="fd919cd8">Detecting unexpected exception thrown</h3>            <p id="d4fafc19">Although not strictly a debugging feature, when we want to investigate why an exception was thrown,                we can                <a href="analyze-stacktrace-dialog.html">analyse the exception stack trace</a>                and quickly get to the line of code that generated that                exception. From there the combination of <span class="keyword">Line Breakpoint</span> and                <span class="keyword">Stepping</span> is usually enough to figure out what is wrong.            </p>            <figure><img alt="Analyze Stacktrace" title="Analyze Stacktrace" src="/help/img/idea/2019.3/ij_debugging_analyze_stack_trace.png" id="b3d34436" width="790" height="265"></figure>            <p id="033a18aa">Sometimes however, the exception is wrapped in another exception or caught and swallowed by the catch block.                All we see are its side effects (perhaps a log) but not its stack trace. For that                we can use an <a href="using-breakpoints.html#exception-breakpoints">Exception Breakpoint</a>.            </p>        </div>    </div>        <div class="chapter"><h2 id="533a3b2f" data-toc="Tutorial_Java_Debugging_Deep_Dive#533a3b2f">Debugging Asynchronous flow</h2>        <p id="8b829a0a">            Reactive programming is increasingly popular and with the help of many frameworks and libraries out there,            developers are writing a lot more asynchronous code.            <br>The flow in an asynchronous application is a major challenge for debugging tools and the developers who use them.            The execution jumps between frames and makes it harder to understand and follow the code.            <br>Stepping forward is the easier bit. We can insert breakpoints at different points in the code and regardless of the            executing thread, see the progress from one code snippet to the next.            <br>When doing that, pay attention to whether a breakpoint suspends just a thread or the entire application.            The decision is based on the goal of the debugging session.            If you want to check the state of all threads and see what thread has progressed and what            thread might be unnecessarily waiting, you can freeze the entire system at this point and view call frames            and stack traces of all threads.<br>            If you're debugging a specific action, you can suspend just one thread and let the rest of the system keep working.        </p>        <div class="chapter"><h3 id="async_stacktraces">Async Stacktraces</h3>            <p id="9756e0c9">                The real pain with asynchronous debugging starts when we want to look back from a specific point in the code                and understand how we got here.                Consider the example of asynchronous code below (using JDK's CompletableFutures):                </p><div class="code-block" data-lang="java">
                    private void asyncExample() throws InterruptedException, ExecutionException
                    {
                        final CompletableFuture<string> future = supplyAsync(() -> "F").thenApplyAsync(this::append_oo);
                        System.out.println(future.get());
                    }

                    private String append_oo(String str)
                    {
                        return str +"oo";
                    }
                </string></div>                When we stop inside the method <code class="code">append_oo</code>we can see that the stack trace gives us very little information.                <br>Specifically, we can't see the future applied above it nor can we see the <code class="code">asyncExample</code> method that for us started it all.                <br>                <figure><img alt="ij debugging async stacktrace" title="ij debugging async stacktrace" src="/help/img/idea/2019.3/ij_debugging_async_stacktrace.png" id="51a395f8" width="357" height="269"></figure>            <p></p>            <p id="e5e31f2c">                In an asynchronous context, stack traces will only show us a very limited picture and what we really need is                the flow of information between the threads or the combined stack traces of all threads that got us to this point (also known as the causality chain).            </p>                        <p id="12b28f9e">                IntelliJ IDEA provides a way to view those <span class="keyword">Async stack traces</span>.                <br>While in a debugging session, IntelliJ IDEA will capture stack traces and will show them later                when viewing the stacktrace of the next part of the asynchronous flow:                <br></p><figure><img alt="ij debugging async causality chain" title="ij debugging async causality chain" src="/help/img/idea/2019.3/ij_debugging_async_causality_chain.png" id="53c2a6b4" width="359" height="195"></figure>                <br>Or even clearer when we filter the external libraries:                <br><figure><img alt="ij debugging async causality chain filtered" title="ij debugging async causality chain filtered" src="/help/img/idea/2019.3/ij_debugging_async_causality_chain_filtered.png" id="db9f9787" width="363" height="126"></figure>                <br>                The stack traces to capture and the point to insert them needs to be configured in the debugger preferences under <a href="async-stacktraces.html">Async Stack Traces</a>.                <br>IntelliJ IDEA needs to know the class name and the method to appear at the top of the stack trace which we need to capture.                In our example <code class="code">java.util.concurrent.CompletableFuture</code> <code class="code">thenApplyAsync</code>.                The debugger also needs to know the position in the other stack trace where we want to insert the captured stack trace.                In our example it is                <code class="code">java.util.concurrent.CompletableFuture$AsyncApply</code> <code class="code">exec</code>.                <br>                In order to match the two stack traces we also needs two keys - one for each context which will point to the same value when                one stack trace is indeed the next logical step in our async chain.                In our example the key expression we can use is <code class="code">param_0</code> (parameter 0 - the method reference we pass into thenApplyAsync).                It will be matched with <code class="code">fn</code> - the variable inside <code class="code">java.util.concurrent.CompletableFuture$AsyncApply</code>                that holds the function in the second call frame.                <figure><img alt="ij debugging async capture" title="ij debugging async capture" src="/help/img/idea/2019.3/ij_debugging_async_capture.png" id="f76e3095" width="841" height="116"></figure>                <br>                This should be <a href="async-stacktraces.html">configured in the debugger settings</a> once and configuration for common async frameworks such as <span class="keyword">CompletableFuture</span>                used here will be provided.                <br>            <p></p>        </div>    </div>    <div class="chapter"><h2 id="multithreaded_applications" data-toc="Tutorial_Java_Debugging_Deep_Dive#multithreaded_applications">Debugging multithreaded applications</h2>        <p id="a04fc5f8">            Multithreaded applications are the biggest challenge to debug. These applications are not            deterministic and much harder to control. The illusion of a sequential flow we get from            <span class="keyword">stepping</span> in a debug session does not help either and can be misleading.            <br>When investigating issues that can be concurrency bugs,            we need to try to <span class="keyword">step</span> less and fine-tune our <span class="keyword">breakpoints</span>            more. This is because a lot of the concurrency bugs depend on a specific interaction between            different threads, and an intrusive debugging session will interfere with that. We'll show how using            various            <span class="emphasis">Breakpoint properties</span>            allows us to limit the interference to a minimum.            The other important topic is controlling and            <a href="debug-tool-window-threads.html">switching between different threads</a>            in the application. We'll go through some examples of debugging different concurrency bugs to            demonstrate how IntelliJ IDEA's features help with this.        </p>        <aside data-type="tip" class="prompt" data-title="" rel="a04fc5f8" id="9a9766c4"><p>Always name your threads in multithreaded applications according to their function. It simplifies both            logging and debugging.        </p></aside>        <div class="chapter"><h3 id="breakpoint_properties">Controlling a breakpoint</h3>            <p id="51877186">IntelliJ IDEA                <a href="using-breakpoints.html#breakpoint-properties">debugger properties</a>                allow us to control the actions taken when a                <span class="keyword">breakpoint</span>                is triggered.                Some of them define an action, and others are there to add further conditions on whether to take                the action at all. This fine level of control of the breakpoints is critical for concurrency bugs,                because most will only be reproduced when threads interact in a very specific way. Any                interference of the breakpoints may prevent us from reproducing the bug.            </p>            <div class="chapter"><h4 id="9474ef7d">Breakpoint actions</h4>                Deciding on the breakpoint action depends on what we want to achieve in the debugging session.                <p id="69241dc4">                    If we can define the condition or point in the code where we can get more insight from viewing                    the entire system state, we should                    suspend the entire VM.                </p>                <p id="cd16b90e">                    Sometimes, <a href="using-breakpoints.html#suspend_policy">suspending only one thread</a> and                    not the whole VM is preferable. This is especially                    true when the application is part of a larger system and suspending the VM will cause either an                    overflow of messages waiting to be served, or request timeouts that end up breaking the entire                    system. When we have many worker threads, it is better to keep almost all working and focus                    on just one thread which is interesting to us.                </p>                <p id="7761ed53">                    When we deal with a concurrency bug, any suspension of execution may prevent us from reproducing                    the bug. We can opt to make the breakpoint not suspend anything, just                    <a href="using-breakpoints.html#log">log</a>                    either a message or a value of a particular expression to the console, then inspect the log.                    This works well when we have a strong theory about what exactly are we looking for.                </p>            </div>            <div class="chapter"><h4 id="1b269e10">Restrict breakpoint with conditions</h4>                <p id="ca4bebba">Apart from being convenient, breakpoint conditions let us minimize the intrusive nature of the                    debugging session. They allow us to limit the breakpoint actions to only what we see as absolutely                    essential.                </p>                <aside data-type="note" class="prompt" data-title="" rel="ca4bebba" id="efef9d1a"><p>The conditions themselves have an overhead and are being evaluated every time the breakpoint is                    hit.                </p></aside>                    <p id="4b450f15">                    <a href="using-breakpoints.html#breakpoint_condition">Conditional expressions</a>                    are the most widely used condition. They allow us to trigger the breakpoint only when our application                    reaches a specific state. Ideal if we can define an expression that captures the exact point when things start to go                    wrong.                    </p>                    <p id="d4a32439">                    <a href="using-breakpoints.html#pass_count">Pass count</a>                    is useful in code that is being run many times, either an event handler or a loop and                    the interesting scenario we're after only manifests itself after a specific number of passes.                    </p>                    <p id="695ba8c7">                    We use this when the code is being hit many times but only the first case is interesting.                    The <a href="using-breakpoints.html#remove_once_hit">Remove Once Hit</a> option is especially useful in two scenarios:                    </p><ul class="list _bullet"><li class="list__item" id="654201d3"><p>When the breakpoint action is to log rather than suspend, which means we don't have the ability to remove or disable the breakpoint after it was hit.                        </p></li><li class="list__item" id="c0bd2b1f"><p>When the code is executed by many threads and we only want to suspend one of them.</p></li></ul>                    <p></p>                    <p id="dependency_on_other_breakpoint">                    A very useful feature. Its obvious use is as a filter to triggering a breakpoint in a scenario where                    we're interested in a visit to a method, or a specific state in the code only after another state                    was reached. But as well as that, we can use it to reproduce a particular concurrency issue,                    as it can help us suspend threads and control which thread reaches which particular line in the code                    and in which order.                    </p>                    <aside data-type="tip" class="prompt" data-title="" rel="dependency_on_other_breakpoint" id="a4478a3c">                        <p id="b4e346cd">Instance filtering uses instance ID, and therefore needs to be set when the application is already running.                        </p></aside>                    <p id="2c81073e">                    Allows us to <a href="using-breakpoints.html">filter</a> triggering by class or specific instance.                    </p>            </div>        </div>    </div>    <div class="chapter"><h2 id="24fda16e" data-toc="Tutorial_Java_Debugging_Deep_Dive#24fda16e">Debugging long running scenarios</h2>        <p id="800834d9">            <a href="using-breakpoints.html#method_breakpoint">Method Breakpoint</a> and <a href="using-breakpoints.html#field_watchpoint">Field Watchpoint</a> slow down            code execution considerably. When executing the            same code a huge number of times, even            <a href="using-breakpoints.html#breakpoint_condition">conditional breakpoints</a>            slow down the processing enough for            it to be noticeable. This is a real issue because the scenario of an event handler processing millions of            events is fairly common (think of replaying a journal file or processing huge production log files)            and evaluating a breakpoint condition inside that event handling code can            slow down the system to an unusable state. To overcome that, assuming we can modify running            code, we can improve the speed by employing a little trick we shall call "breakpoint in code".            This trick is very useful when we debug processing of millions of events where only one causes a            problem and we have no idea in advance which is the problematic one, and can save us a lot of waiting            for a conditional breakpoint to be triggered.            The fastest code is the executed code that was compiled and optimized by the JVM. We want to use            that fact and so, instead of writing a condition on a breakpoint, we introduce it to our executed            code in a way that we can manipulate later. We then debug without any breakpoint, thus running in            the fastest way a debugging session can run, and introduce a breakpoint while the code is running            only when we actually know we will hit it.        </p>        <section class="procedure-steps"><h3 id="824ea163">Breakpoint in code</h3><ol class="list _decimal"><li class="list__item" id="72c974e3">We introduce a loop to the code with our condition. This means we enter the loop only if the                interesting state occurs. We then print something to the console so we will know when the code                has                entered the loop. Because the loop does not change any state, once we enter the loop we will                stay inside it.                <div class="code-block" data-lang="java">
                    while (bugCondition(msg))
                    {
                        System.out.println("gotcha!");
                        try
                        {
                            Thread.sleep(1000);
                        }
                        catch (InterruptedException e)
                        {
                            //ignore
                        }
                    }</div>                <aside data-type="tip" class="prompt" data-title="" rel="b63b5e39" id="3ad6d528">                    <p id="75d914ed">The sleep here is just to avoid bombarding the console with "gotcha!" messages.</p></aside>            </li><li class="list__item" id="e1f502cc"><p id="92189f12">At this point we initiate the debug session, sit and wait for the "gotcha!" to appear. The                console will show us we "hit" the "breakpoint".</p>                <figure><img alt="Console shows breakpoint hit" title="Console shows breakpoint hit" src="/help/img/idea/2019.3/ij_debugging_gotcha.png" id="8984f504" width="250" height="508"></figure>            </li><li class="list__item" id="a84f776b">                <p id="a9ebb24a">When the "gotcha!" does appear, we introduce a real line breakpoint inside the loop. The breakpoint will be                    hit and suspend the VM or thread. Now we can inspect the event and its state. If inspecting is not                    enough, the last thing to do is to make our code exit the loop. There are two options to do                    that.                </p>                <ul class="list _bullet"><li class="list__item" id="1facc225">                        <p id="d637405c">We can take advantage of the <span class="keyword">Evaluate Expression</span> intrusive nature                            to evaluate a code fragment that will actually modify the loop condition to                            false. This is easily done if we use a field or variable as the condition of the                            loop, since we can then modify its value.                        </p>                        <div class="code-block" data-lang="java">
                            boolean enterLoop = bugCondition(msg);
                            while (enterLoop)
                            {
                                System.out.println("gotcha!");
                                try
                                {
                                    Thread.sleep(1_000);
                                }
                                catch (InterruptedException e)
                                {
                                    //ignore
                                }
                            }</div>                        <figure><img alt="Use Evaluate Expression to stop the loop" title="Use Evaluate Expression to stop the loop" src="/help/img/idea/2019.3/ij_debugging_enter_loop_false.png" id="c4878ffa" width="600" height="263"></figure>                    </li><li class="list__item" id="341f39ce">                        <p id="b5deb234">We can exit the loop by using another feature of a debugging session,                            <span class="keyword">HotSwap</span>. This allows us to modify the running code during                            debugging, compile it and then IntelliJ IDEA                            <a href="altering-the-program-s-execution-flow.html#reload_classes">will hot swap the debugged classes</a>                            with the new version.                            All we need to do is change the loop condition to 'false'.                            By default, IntelliJ IDEA will detect that a class has a new version and will ask us whether to reload the class with the new version.</p>                        <figure><img alt="Reload classes?" title="Reload classes?" src="/help/img/idea/2019.3/ij_debugging_reload_classes.png" id="00891923" width="600" height="163"></figure>                        <p id="e88c17b9">                            Once the new version is loaded, the new loop condition will make the code exit the loop and we can                            continue debugging from that point.                            You can either put another breakpoint after the loop to suspend the execution again or just step through the 'false' loop condition.                        </p>                    </li></ul>            </li></ol><aside data-type="note" class="prompt" data-title="" rel="a84f776b" id="a857b68f">                <p id="4930e579">                    Remember to delete this code after debugging. You should also have a failing test for the                    real feature to remind you to never commit it by mistake.                </p>            </aside></section>    </div>    <div class="chapter"><h2 id="d65ce967" data-toc="Tutorial_Java_Debugging_Deep_Dive#d65ce967">Looking for a race condition</h2>        <p id="426af685">            A race condition is a common issue in multithreaded applications. Multiple threads access and modify            the same state, potentially corrupting it or causing undesired flow. A race condition can be a very            subtle bug and is usually hard to reproduce. That is because it only occurs when the threads            execute the code in a very specific order. Other execution orders will look fine and not cause any issues.</p>        <p id="81c4be7e">            When looking for a race condition among threads, our debug run must start as minimally intrusively as            possible to not interfere with the execution order. Once we gain some information or have an assumption on            what the execution order is that will cause the bug, we can also use the debug features to reproduce it using a            <a href="#dependency_on_other_breakpoint">dependency between breakpoints</a>.        </p>        <div class="chapter"><h3 id="2ebd2467">Detecting race condition resulting in a corrupted state</h3>            <aside data-type="tip" class="prompt" data-title="" rel="2ebd2467" id="e4085ea1">                <p id="7e61bac9">If you suspect a race condition, start by debugging without any breakpoints just to make sure you can                    still reproduce the issue in the debug mode.                </p>            </aside>            <p id="6e540ef9">                Sometimes race conditions only occur once in every ten or a hundred runs of the system. If we suspect                there is a race condition in our multithreaded code, we must always make sure that the intrusive                nature of the debugging session does not make the issue non-reproducible. For example, here we've                created a system of publishers and subscribers, however all our subscribers share a primitive (and                not a thread-safe) counter to count the total number of consumed messages.            </p>            <div class="code-block" data-lang="java">
                private class Subscriber implements Runnable
                {
                    @Override
                    public void run()
                    {
                        while (true)
                        {
                            String msg = messageQueue.poll();
                            if (msg != null)
                            {
                                if (msg.equals(STOP))
                                {
                                    break;
                                }
                                else
                                {
                                    // race condition right here!
                                    counter++;
                                }
                            }
                        }
                    }
                }</div>            <p id="65d40997">                Once we've made sure the issue can be reproduced in the debug mode, we try setting a                <a href="using-breakpoints.html#log">breakpoint with logging</a>                instead of suspending the program execution. Here again, just the fact we are logging from                all threads to the same console may "synchronize" the threads in such a way that will "solve" the bug.                We need to be sure we can still reproduce it even if now it might take more attempts. Logging the                suspected state can narrow down our options and allow us to see that the problem is not with the                number of calls to the method but with the counter field.            </p>        </div>        <div class="chapter"><h3 id="7e1058c1">Avoiding debugger overhead</h3>            <p id="f5936f25">A race condition such as the one in our previous example will, on most machines, turn out to be a                "subtle" race condition. By "subtle" we mean that any modification or change to the runtime environment                can "fix" it.                Remember that the origin of the bug is the fact that advancing a primitive counter is not an atomic                operation.            </p>            <div class="code-block" data-lang="java">
                // race condition right here!
                counter++;
            </div>            <p id="62ee1eff">To reproduce the bug we need two threads, both reading the same value: the "second" thread must                read the value before the "first" one updates it and flushes its CPU cache. Easy enough to create on                multi-core machines during a normal run, but almost impossible to reproduce in a debugging session.            </p>            <p id="1f422bd5">                Logging, via a breakpoint, at that same point synchronizes the threads, as they all need to                write to the same log. This also flushes the CPU caches of all threads, as writing to                the log is atomic. In short, it prevents us from reproducing the bug. Suspending either the VM or                the thread cannot help us here either, as we can't separate the two instructions (reading the counter                value and incrementing it) to break between them. At this point, we need to make some assumptions then                prove or refute them. Since we cannot use any breakpoints, our only hope is that we can change the                actual executed code and introduce new code that will be compiled and therefore will interfere less.            </p>            <p id="dc99ddbd">This is very much a last resort option. A good pattern to help us here is a trace buffer.</p>            <div class="chapter"><h4 id="0835c3eb">Trace buffer</h4>                We can introduce an internal buffer and store the interesting values in this buffer.                Think of it as a localized, very efficient in memory log.                We must make sure that:                <ul class="list _bullet"><li class="list__item" id="77bca030"><p>We have a buffer <span class="keyword">per thread</span>, and those buffers are isolated so this does not introduce new                        concurrency issues.                    </p></li><li class="list__item" id="4aaa5c4d"><p>Because the buffer is per thread, it does not need to be thread safe and <span class="keyword">must not</span> be                        thread-safe. This is because we want to avoid introducing any synchronization points.                    </p></li><li class="list__item" id="187ff328"><p>The values we insert must not be references to a real state that can change, but copies or log                        messages.                    </p></li><li class="list__item" id="dfeed3b0"><p>The introduced code is as minimal as possible, to minimize its effect on the running code.</p></li><li class="list__item" id="921b8337"><p>We print or log the contents of the buffers only after the execution has ended, to avoid making                        the logging action a synchronization mechanism between threads. Another option is to only store                        the values in the trace buffer, then inspect its contents by putting a breakpoint after the                        critical part of the code has finished executing.                    </p></li></ul>                <div class="code-block" data-lang="java">
                    private class Subscriber implements Runnable
                    {
                        private int index = 0;
                        private final int[] traceBuffer = new int[NUMBER_OF_SUBSCRIBERS_AND_PUBLISHERS * 100];

                        @Override
                        public void run()
                        {
                            while (true)
                            {
                                String msg = messageQueue.poll();
                                if (msg != null)
                                {
                                    if (msg.equals(STOP))
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        traceBuffer[index++] = counter;
                                        // race condition right here!
                                        counter++;
                                    }
                                }
                            }
                        }
                    }</div>                <p id="5510cce8">For example, here we introduced a primitive <code class="code">int array</code> large enough for all messages, and in order to                    prove our suspicion of a bug in the counter, we store just the                    counter values before advancing it. Yes, it may not be the exact value advanced by the counter, but                    it will prove our assumption if the same counter value is reported by several threads.                    After all events are completed, we can inspect the trace buffers and find the duplicates.                </p>            </div>        </div>        <div class="chapter"><h3 id="d080e7e9">Detecting a race condition resulting in unexpected flow control</h3>            <div class="code-block" data-lang="java">
                private class Subscriber implements Runnable
                {
                    @Override
                    public void run()
                    {
                        String msg;
                        while (true)
                        {
                            msg = messageQueue.poll();
                            if (msg != null)
                            {
                                if (msg.equals(STOP))
                                {
                                    break;
                                }
                                // else do something
                            }
                        }
                        // Will NOT work with multiple subscribers, as main thread will
                        // wake up when the first subscriber is done.
                        // Using a CountDownLatch here is a much better approach.
                        synchronized (messageQueue)
                        {
                            messageQueue.notify();
                        }
                    }
                }</div>            <p id="a71f0f37">In this example we have another race condition, but the contended shared state is not directly visible                and is only deduced by what seems like a wrong flow control: the first subscriber will wake up the main                thread, which will exit even if the second thread is still processing a message. We can't inspect or                print the waiting thread in a 'trace buffer' in this case,                but we can inspect the position of various threads when we suspend the entire application.            </p>            <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="68e98393"><p>                    First, we can suspend the main thread after it wakes up. We can see that sometimes one of the                    subscriber threads is still marked running. This allows us to assume the problem's origin is in                    the fact that the <code class="code">notify()</code> method is called too soon.                </p></li><li class="list__item" id="5b675e37"><p>                    We can suspend only one of the subscriber threads. That will cause the other thread to notify the                    main thread. This will prove to us the problem can happen in any subscriber and is in its logic.                </p></li><li class="list__item" id="af5e4ea9">                    <p id="f3e1d23e">To be sure, we can suspend the entire VM earlier, just before a subscriber notifies the main thread.                        We can then inspect the status of the two subscriber threads and prove that one of them is still                        polling, while the other has already finished and is about to notify the main thread it's done.                    </p>                    <figure><img alt="Suspending the application before main thread notified" title="Suspending the application before main thread notified" src="/help/img/idea/2019.3/ij_debugging_race_condition_flow_control1.png" id="caec2456" width="710" height="471"></figure>                    <p id="06d71429">In this screen capture, we can see from inspecting the threads that both are marked 'RUNNING', which means that while                        the first is about to notify the main thread it is done (inside the synchronizaed  block),                        the other can still be processing messages.                    </p>                </li><li class="list__item" id="fd21a9e0">                    <p id="bc5a0946">To prove our assumption beyond any doubt we can also put a breakpoint inside the polling loop of                        the subscribers. We make that breakpoint depended on the previous breakpoint just before we                        notify the main thread we're done. Hitting the dependant breakpoint (as shown below) proves                        our theory.                    </p>                    <figure><img alt="Breakpoint inside the subscriber" title="Breakpoint inside the subscriber" src="/help/img/idea/2019.3/ij_debugging_race_condition_flow_control2.png" id="d4707a70" width="710" height="521"></figure>                </li></ol></section>        </div>    </div>    <div class="chapter"><h2 id="49fb4324" data-toc="Tutorial_Java_Debugging_Deep_Dive#49fb4324">Detecting a deadlock</h2>        <p id="d4ff4b12">A deadlock occurs when two threads will conflict in such a way that both are preventing each other from            working at all. Once they occur, deadlocks are easy to spot by looking at the frames of all threads.            We can do this by using            <a href="debug-tool-window-dump.html">Thread dump</a>.            This feature is also            <a href="run-tool-window.html#dump_threads">available when running</a>. If we know we're chasing a            deadlock, the running            mode is even preferable to debugging. This is because we will not interfere at all with the            execution this way, and the snapshot will be the output of a Java thread dump of the application. A            thread dump can detect deadlocks and warn about them. For example, in the dump below we can see the            process found 1 deadlock between the PublisherThread (which is stuck in line 44) and            SubscriberThread (in line 78).        </p>        <figure><img alt="Thread dump" title="Thread dump" src="/help/img/idea/2019.3/ij_debugging_thread_dump.png" id="786c0f09" width="790" height="308"></figure>        <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="1178818e">In this example, we can see that both threads are stuck waiting for a lock, which means that                another thread is not freeing those locks. We can also see that both are waiting for different                locks, as the synchronizer id is different. Even more informative is the deadlock summary at the top that                tells us what thread holds each lock.                We can see that the two deadlocked threads are holding the lock the other thread is trying to obtain.                <aside data-type="tip" class="prompt" data-title="" rel="1178818e" id="c9176f85"><p>Always name your threads in multithreaded applications according to their function.                    Anyone needing to look at a thread dump later, will thank you.                </p></aside>            </li><li class="list__item" id="fe42f9cb"><p>                This should already give us plenty of information on how the deadlock occurs. If it is still unclear                how our code reached a deadlock, we can then try debugging with breakpoints just before we hit                the lines provided by the thread dump. When we have a theory of what is wrong, we can try reproducing the                scenario by using the <a href="#dependency_on_other_breakpoint">dependency between breakpoints.</a>            </p></li><li class="list__item" id="bc29eec4">                <p id="2702dbfd">We can now create a <span class="keyword">Suspend Thread</span>                    breakpoint on one of those threads and verify, using another thread dump snapshot, the other thread reached                    its deadlock position.                </p>                <figure><img alt="Breakpoint in Publisher thread" title="Breakpoint in Publisher thread" src="/help/img/idea/2019.3/ij_debugging_deadlock1.png" id="0a197cdc" width="710" height="172"></figure>                Now we can inspect the state just before one of the threads gets deadlocked.</li><li class="list__item" id="42b8289f">                <p id="6d9d0c34">Another option is to put suspend thread breakpoints on both threads and switch between them.                    Inspecting the states of the <code class="code">Publisher</code> and <code class="code">Subscriber</code>                    in this example will show us the confusion that caused the deadlock.                </p>                <figure><img alt="Breakpoint in the publisher" title="Breakpoint in the publisher" src="/help/img/idea/2019.3/ij_debugging_deadlock2.png" id="3720355c" width="710" height="120"></figure>                <figure><img alt="Breakpoint in the subscriber" title="Breakpoint in the subscriber" src="/help/img/idea/2019.3/ij_debugging_deadlock3.png" id="4a84ae8c" width="710" height="94"></figure>            </li><li class="list__item" id="54c218ef"><p>When we inspect our lock instances we can see that the concurrent code was actually correct,                but we confused the read lock and write lock when we passed them to the two objects.                Look at the lock instances ids in the image above.            </p></li><li class="list__item" id="2ae2da4b"><p>Indeed, when we then inspect the constructions (where we injected those locks) we can see the bug:                </p><div class="code-block" data-lang="java">
                    ThreadGroup threadGroup = new ThreadGroup("Demo");

                    new Thread(threadGroup, new Subscriber(messageQueue, readLock, writeLock), "SubscriberThread").start();

                    //passing locks in the wrong order will cause deadlock between publisher and subscriber
                    new Thread(threadGroup, new Publisher(messageQueue, writeLock, readLock), "PublisherThread").start();
                </div>            <p></p></li></ol></section>    </div>    <div class="chapter"><h2 id="fd5ebfea" data-toc="Tutorial_Java_Debugging_Deep_Dive#fd5ebfea">Detecting a livelock</h2>        <p id="6997d55b">A livelock is a scenario where threads are not blocked, but still unable to make a progress.            From the outside, a livelock should behave just like a deadlock, but because the threads are not            blocked, the snapshot (thread dump) will not alert us on any deadlock.        </p>        <section class="procedure-steps"><ol class="list _decimal"><li class="list__item" id="b5796994">                <p id="40535803">One strategy to try before starting debugging, is to repeat the                    <span class="keyword">Thread Dump</span>                    several times then compare the stack traces for various threads. This should give us a                    clear view of the problematic areas in the code, in most cases a loop that the code cannot                    escape from.                </p>                <figure><img alt="Livelock snapshot" title="Livelock snapshot" src="/help/img/idea/2019.3/ij_debugging_livelock1.png" id="14713228" width="710" height="75"></figure>            </li><li class="list__item" id="d22c66c2">                <p id="e2df6bc2">If we're still unsure, we can use a                    <span class="keyword">Pass Count</span>                    with a large number that we assume will only be reached in a livelock situation.                </p>                <figure><img alt="Using pass count" title="Using pass count" src="/help/img/idea/2019.3/ij_debugging_livelock_pass_count.png" id="a3e7265c" width="613" height="552"></figure>                We can also <span class="keyword">Step</span> through the code and verify exactly what area of code is being executed repeatedly but not progressing.            </li><li class="list__item" id="8653fa5d">                <p id="db2783c9">At this point we can use a <span class="keyword">Conditional Expression</span>                    to capture the point in the execution when we enter the livelock situation                    (i.e when the application reaches a state that will prevent it from escaping the executed code block).                </p>                <p id="eec2a3df">In this example, we assume that the STOP message failed to break us from the loop, so either it                    was never sent or that it was not handled so we'll introduce a breakpoint with a condition that looks for a STOP message.                </p>                <figure><img alt="Using a conditional to capture livelock situation" title="Using a conditional to capture livelock situation" src="/help/img/idea/2019.3/ij_debugging_livelock_condition.png" id="1f0128fe" width="710" height="304"></figure>            </li><li class="list__item" id="fcace147">                <p id="2218f9aa">Our breakpoint is hit, meaning the STOP message was sent but not handled.</p>                <figure><img alt="Breakpoint hit" title="Breakpoint hit" src="/help/img/idea/2019.3/ij_debugging_livelock_stop_breakpoint.png" id="4ea214f9" width="442" height="165"></figure>            </li><li class="list__item" id="981ece8c">                <p id="ea8ba486">We step in, inspect the state with <span class="keyword">Evaluate Expression</span> and find the bug.                    The 'valid' method does not think <code class="code">STOP</code> is a valid message and puts us in this livelock scenario.                </p>                <figure><img alt="Using Evaluate Expression to test the theory" title="Using Evaluate Expression to test the theory" src="/help/img/idea/2019.3/ij_debugging_livelock_evaluate.png" id="e09ef2c5" width="546" height="201"></figure>            </li></ol></section>    </div><div class="last-modified" data-skip-index="skip">Last modified: 29 November 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="debugging-your-first-java-application.html">Debugging Your First Java Application</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>