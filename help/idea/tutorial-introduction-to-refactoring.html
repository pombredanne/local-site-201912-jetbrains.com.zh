<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>重构简介-帮助|帮助IntelliJ IDEA</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Tutorial_Introduction_to_Refactoring" data-breadcrumbs="Tutorials/Tutorial_Introduction_to_Refactoring.xml|Introduction to Refactoring" data-main-title="Introduction to Refactoring"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索IntelliJ IDEA帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>IntelliJ IDEA 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default_for_windows" data-group="primary" selected>Windows的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_sublime_text" data-group="primary">崇高文字</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_macos" data-group="secondary">苹果系统</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_macos" data-group="secondary">Eclipse（macOS）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_intellij_idea_classic" data-group="secondary">IntelliJ IDEA经典版</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_sublime_text" data-group="secondary">崇高文字</option><option value="secondary_sublime_text_macos" data-group="secondary">崇高文字（macOS）</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Tutorial_Introduction_to_Refactoring.xml" data-toc="Tutorial_Introduction_to_Refactoring">重构简介</h1>    <p id="405a16dd">在此页：</p>    <ul class="list" data-skip-index="skip"><li class="list__item"><a href="#c42edd19">介绍</a></li><li class="list__item"><a href="#ee20f5be">重命名</a></li><li class="list__item"><a href="#d26fb080">提取中</a></li><li class="list__item"><a href="#e2d541e4">删除中</a></li><li class="list__item"><a href="#7dcd4ba2">结论</a></li></ul>    <div class="chapter"><h2 id="c42edd19">介绍</h2>        <p id="ad3f2b92">IntelliJ IDEA提供了许多<a href="refactoring-source-code.html">自动重构功能</a> ，但是对于开发人员来说，仅仅知道如何执行它们是不够的，我们需要了解这些重构的含义，何时应用它们以及任何可能的不利因素或使用前要考虑的事情。他们。</p>        <p id="c2723725">            <a href="http://refactoring.com/" rel="noopener noreferrer" data-external="true" target="_blank">马丁·福勒（Martin Fowler）定义</a> ，“ ...是一种用于重组现有代码主体，在不改变其外部行为的情况下更改其内部结构的有纪律的技术”。因此，在生产代码中执行任何重构之前，必须具有全面的<a href="code-coverage.html">测试范围</a>以证明您没有无意中改变了行为，这一点很重要。</p>        <p id="bb373629">本教程的目的是向IntelliJ IDEA的功能介绍那些对重构（尤其是自动重构）概念不熟悉的人，并说明何时可能要应用三种基本的重构类型： <a href="rename-refactorings.html">重命名</a> ， <a href="extract-method.html">提取</a>和<a href="safe-delete.html">删除</a> 。</p>    </div>    <div class="chapter"><h2 id="ee20f5be">重命名</h2>        <p id="c7208dc5"><a href="http://refactoring.com/catalog/renameMethod.html" rel="noopener noreferrer" data-external="true" target="_blank">重命名</a>看似微不足道的重构，但是通过简单的查找和替换进行重命名通常意味着无意更改具有相同名称的不相关项。使用IntelliJ IDEA的<a href="rename-refactorings.html">重命名重构可以</a>最大程度地减少这些错误。</p>        <section class="procedure-steps"><h3 id="636a65c2">为什么要重命名？</h3><ol class="list _decimal"><li class="list__item" id="296d1241"><p>名称不够描述</p></li><li class="list__item" id="e3f1ea91"><p>类/方法/变量名称与实际名称不符</p></li><li class="list__item" id="7f348449"><p>引入了一些新内容，要求现有代码具有更特定的名称</p></li></ol></section>        <section class="procedure-steps"><h3 id="68d8e901">在编码时重命名</h3><p id="d1d8c251">假设您在实现某些功能或修复某些错误时遇到以下代码</p><div class="code-block" data-lang="java">服务器=新服务器（路径，端口，端点）； server.init（）; server.run（）;</div>假设我们要：<ul class="list _bullet"><li class="list__item" id="daf7f0e2"><p>改名<code class="code">endpoint</code> （一个字段），以描述它是哪种端点。</p></li><li class="list__item" id="1558e7bf"><p>改名<code class="code">init()</code> ，一种方法<code class="code">Server</code> ，以更准确地描述该方法。</p></li><li class="list__item" id="095bdce5"><p>改名<code class="code">Server</code> ，一类，更具体的东西。</p></li></ul>                <p></p><ol class="list _decimal"><li class="list__item" id="2404e52e">                <p id="b6660a97">重命名<code class="code">endpoint</code>字段，将光标放在单词end上，然后按<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd> 。IntelliJ IDEA将根据类名称和其他方面弹出建议列表。在这种情况下，还建议使用此字段的参数名称。</p>                <figure><img alt="重命名字段" title="重命名字段" src="/help/img/idea/2019.3/ij_rename_field.png" id="3204f3a4" width="675" height="189"></figure>。<p id="8f72f300">选择以下选项之一或输入您自己的选项。如果该字段具有吸气剂，则IntelliJ IDEA会询问您是否也要重命名。</p>                <figure><img alt="您想重命名吸气剂吗？" title="您想重命名吸气剂吗？" src="/help/img/idea/2019.3/ij_rename_getter.png" id="06bb3d89" width="410" height="148"></figure>。<p id="087f30f0">您会注意到，此字段的所有用法都更改为新名称，并且如果您选择重命名getter，则项目中的其他类将更新为使用新名称。有关方法重命名的更多信息，请参见下一步。</p>            </li><li class="list__item" id="c3b96215">                <p id="3865c5bf">要重命名该方法，过程是相同的：将光标放在<code class="code">init</code>然后按<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd> 。在这里，您的建议会更少，因此请输入新名称：</p>                <figure><img alt="重命名方法" title="重命名方法" src="/help/img/idea/2019.3/ij_rename_method.png" id="b8c3de0f" width="602" height="175"></figure>                <p id="d95e1e4c">除了重命名该方法之外，这还会重命名该方法的所有调用以及子类中所有被覆盖/实现的方法。IntelliJ IDEA也可以重命名该名称的非代码用法，如果您具有XML配置或其他引用类或方法的非Java文件，则该名称很有用。您可以配置如果按则重命名的内容<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd>第二次调出重命名对话框</p>                <figure><img alt="更多重命名设置" title="更多重命名设置" src="/help/img/idea/2019.3/ij_rename_dialog.png" id="fa00ae63" width="642" height="153"></figure>                <p id="453a2b8c">如果重命名不仅适用于代码，那么IntelliJ IDEA将为您预览重构，因此您可以选择要进行的更改。在这些情况下，通常您可能会选择不重命名注释中的出现，特别是如果原始方法名称是一个常见词，例如<code class="code">name</code> 。</p>                <figure><img alt="预览重命名" title="预览重命名" src="/help/img/idea/2019.3/ij_rename_method_more_details.png" id="d279cf21" width="883" height="316"></figure>                <p id="7ef66fcf">如果您不想进行某些更改，请按<kbd data-primary_default_for_windows="Backspace" data-primary_eclipse="Backspace" data-primary_emacs="Backspace" data-primary_netbeans="Backspace" data-primary_sublime_text="Backspace" data-primary_visual_studio="Backspace" data-secondary_macos="⌫" data-secondary_eclipse="⌫" data-secondary_eclipse_macos="⌫" data-secondary_emacs="⌫" data-secondary_intellij_idea_classic="⌫" data-secondary_netbeans="⌫" data-secondary_sublime_text="⌫" data-secondary_sublime_text_macos="⌫" data-secondary_visual_studio="⌫">Backspace</kbd>您不想更改的用法。</p>            </li><li class="list__item" id="12893239">                <p id="6c6feb06">重命名类是相似的，但也可以通过“ <a href="project-tool-window.html">项目工具窗口”执行</a> 。在这种情况下，因为我们发现要重命名使用类的类，所以我们将使用<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd>在代码中的类名上。</p>                <figure><img alt="重命名课程" title="重命名课程" src="/help/img/idea/2019.3/ij_rename_class.png" id="b50cd1d1" width="658" height="174"></figure>                <p id="624a5e3e">当然，任何使用此类的代码也将被重命名，但是您还可以选择重命名变量，继承者和代码的其他部分，以便它们与新名称对齐。同样，这些选项可以通过按<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd>第二次。</p>            </li></ol></section>        <section class="procedure-steps"><h3 id="a7e0bb90">重命名的影响</h3><p id="09eed093">重命名局部变量或私有方法可以非常安全地即时进行。例如，当您在开发涉及此代码区域的功能时，可以在不影响范围的情况下执行重构。</p><p id="8d00c4b8">重命名类或公共方法可能会影响许多文件。如果是这种情况，则这种重构至少应至少在其自己的提交中，以便将更改与您当时可能在进行的任何更改或其他功能清楚地分开。</p></section>    </div>    <div class="chapter"><h2 id="d26fb080">提取中</h2>        <p id="fe9f3b65">IntelliJ IDEA的<span class="emphasis">提取重构功能</span>使开发人员可以在清楚当前设计（无论是小规模还是大规模）不再适合目标时重塑其代码。</p>        <section class="procedure-steps"><h3 id="bfb38ff1">提取变量</h3><p id="c13d3d07">                    <a href="http://refactoring.com/catalog/extractVariable.html" rel="noopener noreferrer" data-external="true" target="_blank">提取变量</a>是影响很小的更改，可以使您的<a href="https://en.wikipedia.org/wiki/Self-documenting_code" rel="noopener noreferrer" data-external="true" target="_blank">代码自记录</a> 。它也可以用来减少代码重复。</p><p id="5a23e3ea">假设您遇到以下代码</p><div class="code-block" data-lang="java">静态字符串getUsernameFromMessage（String message）{返回message.substring（message.indexOf（“ \” screen_name \“：\”“）+ 15，message.indexOf（” \“”，message.indexOf（“ \” screen_name \“ ：\“”）+ 15））;}</div>我们可以使用extract变量通过以下方式提高此代码的可读性：<ul class="list _bullet"><li class="list__item" id="b3e80cd6"><p>删除重复项<code class="code">message.indexOf("\"screen_name\":\"") + 15)</code>                        </p></li><li class="list__item" id="11bcc7cf"><p>介绍变量以描述每个<code class="code">indexOf</code>电话代表</p></li><li class="list__item" id="dcb996a6"><p>删除幻数15</p></li></ul>                <p></p><ol class="list _decimal"><li class="list__item" id="a64a9c95">                <p id="e9e33417">首先，让我们减少重复，并引入一个描述此操作正在执行的变量。将光标放在表达式中的任何位置<code class="code">message.indexOf("\"screen_name\":\"") + 15)</code>然后按<kbd data-primary_default_for_windows="Ctrl+Alt+V" data-primary_eclipse="Shift+Alt+L" data-primary_emacs="Ctrl+Alt+V" data-primary_netbeans="Shift+Alt+V" data-primary_sublime_text="Ctrl+Alt+V" data-primary_visual_studio="Ctrl+Alt+V" data-secondary_macos="⌥⌘V" data-secondary_eclipse="⌥⇧L" data-secondary_eclipse_macos="⌥⌘L" data-secondary_emacs="⌃⌥V" data-secondary_intellij_idea_classic="⌥⌘V" data-secondary_netbeans="⌥⇧V" data-secondary_sublime_text="⌃⌥V" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⌥V">Ctrl+Alt+V</kbd> 。IntelliJ IDEA将为该重构建议一个上下文，您想选择一个封装此表达式的上下文：</p>                <figure><img alt="选择要提取的表达式" title="选择要提取的表达式" src="/help/img/idea/2019.3/ij_extract_variable_1.png" id="4f054ed4" width="833" height="154"></figure>                <p id="cf1bf946">接下来，如果IntelliJ IDEA检测到此表达式多次出现，则可以选择替换所有出现的内容或仅替换所选的出现的内容。</p>                <figure><img alt="选择替换所有出现" title="选择替换所有出现" src="/help/img/idea/2019.3/ij_extract_variable_2.png" id="edc90245" width="820" height="105"></figure>                <p id="b5c15ac1">提取变量后，IntelliJ IDEA会根据诸如表达式所使用的参数之类的内容来建议可能的名称。</p>                <figure><img alt="选择或输入名称" title="选择或输入名称" src="/help/img/idea/2019.3/ij_extract_variable_3_select_name.png" id="7275888d" width="610" height="146"></figure>                <p id="e1ff9b1c">我们将使用自己的名字， <code class="code">indexOfFieldValue</code> ，以描述这实际上代表什么。请注意，您可以决定是否希望该变量是最终变量。</p>            </li><li class="list__item" id="2146568f">                <p id="33b5455a">接下来，我们将为String值引入一个变量。这样做的原因有两个：第一，记录String值表示的内容，第二，因为它将帮助我们删除幻数。</p>                <p id="4494ebdb">将光标放在<code class="code">screen_name</code>然后按<kbd data-primary_default_for_windows="Ctrl+Alt+V" data-primary_eclipse="Shift+Alt+L" data-primary_emacs="Ctrl+Alt+V" data-primary_netbeans="Shift+Alt+V" data-primary_sublime_text="Ctrl+Alt+V" data-primary_visual_studio="Ctrl+Alt+V" data-secondary_macos="⌥⌘V" data-secondary_eclipse="⌥⇧L" data-secondary_eclipse_macos="⌥⌘L" data-secondary_emacs="⌃⌥V" data-secondary_intellij_idea_classic="⌥⌘V" data-secondary_netbeans="⌥⇧V" data-secondary_sublime_text="⌃⌥V" data-secondary_sublime_text_macos="N/A" data-secondary_visual_studio="⌃⌥V">Ctrl+Alt+V</kbd> 。</p>                <figure><img alt="选择字符串值" title="选择字符串值" src="/help/img/idea/2019.3/ij_extract_variable_4.png" id="473fe81a" width="688" height="131"></figure>                <p id="faf51145">我们要给它起一个更有意义的名称， <code class="code">fieldName</code> 。</p>                <figure><img alt="给变量起一个名字" title="给变量起一个名字" src="/help/img/idea/2019.3/ij_extract_variable_5.png" id="eb2c76bc" width="608" height="139"></figure>            </li><li class="list__item" id="654965db">                <p id="798e91d6">现在，我们将为另一个表达式创建一个变量，以用作参数<code class="code">substring()</code> ，使用相同的过程，我们称之为<code class="code">indexOfEndOfFieldValue</code> 。</p>                <figure><img alt="提取变量" title="提取变量" src="/help/img/idea/2019.3/ij_extract_variable_6.png" id="2dede89f" width="575" height="199"></figure>            </li><li class="list__item" id="e2d1ab63"><p>最后，我们可以删除幻数，因为这只是字段名称的长度。最终代码如下：</p><div class="code-block" data-lang="java">静态字符串getUsernameFromMessage（String message）{最终字符串fieldName =“ \” screen_name \“：\”“;最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最终int indexOfEndOfFieldValue = message.indexOf（” \ “”，indexOfFieldValue）；返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }</div>它比原始代码更长，但更具描述性，在这样的代码（其中每个表达式表示什么不清楚）中尤其重要。申请的选择<code class="code">final</code>是否使用取决于您，取决于您的编码标准。<p></p></li></ol></section>        <section class="procedure-steps"><h3 id="6d87592c">提取参数</h3><p id="fca5704c">                    <a href="javaintroduce.html">提取</a>或<a href="http://refactoring.com/catalog/addParameter.html" rel="noopener noreferrer" data-external="true" target="_blank">添加参数</a>使开发人员可以更改方法，以便于使用。您可能想要更改参数，例如，通过传入对象中的某些值而不是对象本身来进行更改，或者您可能希望从方法主体中引入一个值作为参数，以允许在更多地方使用该方法。我们将看一个后者的例子。</p><p id="9dbfe1bb">对于此示例，在重构之后，我们将使用与上一个示例相同的代码，并对其进行稍微扩展以显示同一类中的另一个方法：</p><div class="code-block" data-lang="java">静态字符串getTextFromMessage（String message）{最终字符串fieldName =“ \” text \“：\”“;最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最终int indexOfEndOfFieldValue = message.indexOf（” \ “”，indexOfFieldValue）；返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }静态字符串getUsernameFromMessage（String message）{最终字符串fieldName =“ \” screen_name \“：\”“;最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最终int indexOfEndOfFieldValue = message.indexOf（” \“”，indexOfFieldValue）；返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }</div><p id="d29ada3c">我们的目标是消除在这两种方法中看到的重复代码。为此，我们要：</p><ul class="list _bullet"><li class="list__item" id="cfac5636"><p>更改<code class="code">fieldName</code>变成一个参数，这样我们就可以<code class="code">getUsernameFromMessage</code>方法适用于任何领域。</p></li><li class="list__item" id="72f11c1b"><p>改名<code class="code">getUsernameFromMessage</code>代表它更一般的性质</p></li><li class="list__item" id="9ef10790"><p>删除中的重复代码<code class="code">getTextFromMessage</code> 。</p></li></ul><ol class="list _decimal"><li class="list__item" id="74babc82">                <p id="9552e690">将光标放在<code class="code">fieldName</code>然后按<kbd data-primary_default_for_windows="Ctrl+Alt+P" data-primary_eclipse="Ctrl+Alt+P" data-primary_emacs="Ctrl+Alt+P" data-primary_netbeans="Ctrl+Alt+P" data-primary_sublime_text="Ctrl+Alt+P" data-primary_visual_studio="Ctrl+Alt+P" data-secondary_macos="⌥⌘P" data-secondary_eclipse="⌃⌥P" data-secondary_eclipse_macos="⌥⌘P" data-secondary_emacs="⌃⌥P" data-secondary_intellij_idea_classic="⌥⌘P" data-secondary_netbeans="⌃⌥P" data-secondary_sublime_text="⌃⌥P" data-secondary_sublime_text_macos="⌥⌘P" data-secondary_visual_studio="⌃⌥P">Ctrl+Alt+P</kbd>                </p>                <figure><img alt="提取参数" title="提取参数" src="/help/img/idea/2019.3/ij_extract_parameter_1.png" id="da33ddac" width="822" height="176"></figure>                <p id="a2a1bc0d">与其他重构一样，可以根据需要为参数键入新名称。IntelliJ IDEA还将预览更新的方法签名。按<kbd data-primary_default_for_windows="Enter" data-primary_eclipse="Enter" data-primary_emacs="Enter" data-primary_netbeans="Enter" data-primary_sublime_text="Enter" data-primary_visual_studio="Enter" data-secondary_macos="⏎" data-secondary_eclipse="⏎" data-secondary_eclipse_macos="⏎" data-secondary_emacs="⏎" data-secondary_intellij_idea_classic="⏎" data-secondary_netbeans="⏎" data-secondary_sublime_text="⏎" data-secondary_sublime_text_macos="⏎" data-secondary_visual_studio="⏎">Enter</kbd>批准更改。</p>                <figure><img alt="新方法签名有任何问题" title="新方法签名有任何问题" src="/help/img/idea/2019.3/ij_extract_parameter_2_conflict.png" id="b5eaea50" width="567" height="509"></figure>                <p id="2555370c">这个特殊问题告诉我们该方法正被用作方法引用，并且此更改将导致该方法引用被转换为lambda表达式。该消息可能表明这不是您希望执行的重构。在这种情况下，下一个示例显示了我们可以使用“提取方法”采取的方法。但是，对于本示例，我们假设对引入新参数的结果感到满意，因此我们只选择<span class="keyword">Continue即可</span> 。</p>                <p id="795df528">接下来，IntelliJ IDEA将检测到任何现在可以被调用新方法签名的代码。</p>                <figure><img alt="现在这段代码是更新方法的重复" title="现在这段代码是更新方法的重复" src="/help/img/idea/2019.3/ij_extract_parameter_3_duplicate.png" id="66380e11" width="721" height="303"></figure>                <p id="560b0df4">如果在这种情况下选择“ <span class="keyword">替换”</span> ，则所有重复的代码都将被替换，并且IntelliJ IDEA将选择适当的值来传递新参数。</p>            </li><li class="list__item" id="62aa08b7">                <p id="4ae1d753">此时，原始方法<code class="code">getUsernameFromMessage</code>比以前更笼统，因此我们应该重命名。我们将光标放在名称上并使用<kbd data-primary_default_for_windows="Shift+F6" data-primary_eclipse="Shift+Alt+R" data-primary_emacs="Shift+F6" data-primary_netbeans="Ctrl+R" data-primary_sublime_text="Shift+F6" data-primary_visual_studio="Shift+F6" data-secondary_macos="⇧F6" data-secondary_eclipse="⌥⇧R" data-secondary_eclipse_macos="⇧F6" data-secondary_emacs="⇧F6" data-secondary_intellij_idea_classic="⇧F6" data-secondary_netbeans="⌃R" data-secondary_sublime_text="⇧F6" data-secondary_sublime_text_macos="⇧F6" data-secondary_visual_studio="⇧F6">Shift+F6</kbd> ，如上一节所示。</p>                <figure><img alt="重命名更新的方法" title="重命名更新的方法" src="/help/img/idea/2019.3/ij_extract_parameter_4_rename_method.png" id="d696b000" width="707" height="188"></figure>                </li><li class="list__item" id="b949fc9a">                <p id="a49bd96f">我们可以进一步简化代码。<a href="inline.html">内联</a>是提取的反函数，在这里的代码中， <a href="http://refactoring.com/catalog/inlineTemp.html" rel="noopener noreferrer" data-external="true" target="_blank">内联我们的临时变量</a>可能是适当的，因为变量名给我们的好处仅仅是将值直接传递给方法。或者，鉴于getTextFromMessage实际上是一个简单的委托<code class="code">getValueForField</code> ，我们可以使用内联完全删除此方法。</p>                <p id="8bfc11bd">要内联，请将光标放在<code class="code">getTextFromMessage</code>可变并按<kbd data-primary_default_for_windows="Ctrl+Alt+N" data-primary_eclipse="Shift+Alt+I" data-primary_emacs="Ctrl+Alt+N" data-primary_netbeans="Ctrl+Alt+N" data-primary_sublime_text="Ctrl+Alt+N" data-primary_visual_studio="Ctrl+Alt+N" data-secondary_macos="⌥⌘N" data-secondary_eclipse="⌥⇧I" data-secondary_eclipse_macos="⌥⌘I" data-secondary_emacs="⌃⌥N" data-secondary_intellij_idea_classic="⌥⌘N" data-secondary_netbeans="⌃⌥N" data-secondary_sublime_text="⌃⌥N" data-secondary_sublime_text_macos="⌥⌘N" data-secondary_visual_studio="⌃⌥N">Ctrl+Alt+N</kbd>                </p>                <figure><img alt="内联不必要的方法" title="内联不必要的方法" src="/help/img/idea/2019.3/ij_extract_parameter_5_inline.png" id="dc2bb28d" width="707" height="257"></figure>                </li><li class="list__item" id="61eae5cb">                <p id="b6625f0f">现在我们的最终代码如下：</p>                <div class="code-block" data-lang="java">静态字符串getValueForField（String message，String fieldName）{final int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最后的int indexOfEndOfFieldValue = message.indexOf（“ \”“，indexOfFieldValue）;返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）;}</div>                <p id="926cba2a">我们调用原始getUsernameFromMessage方法的代码是：</p>                <code class="code">Parser::getUsernameFromMessage</code>                <p id="f69b2ecf">现在</p>                <code class="code">(message) -> Parser.getValueForField(message, "\"screen_name\":\"")</code>                <p id="b5dc1ad1">我们调用原始getTextFromMessage方法的代码是：</p>                <code class="code">String[] wordsInMessage = Parser.getTextFromMessage(message).split("\\s");</code>                <p id="db28647c">现在</p>                <code class="code">String[] wordsInMessage = Parser.getValueForField(message, "\"text\":\"").split("\\s");</code>            </li></ol><p id="3a1d6444">请注意，我们应用此重构的方式将强制所有调用方传递字段名称，并且a）在代码周围扩展使用String值，并且b）可能会引入一个或多个这些String值的重复项。这可能适合您的代码，尤其是在处理字符串重复或不经常使用该方法的情况下。但是，如果这不是您希望减少代码重复的折衷方案，请参阅下一章中的替代方法。</p><p id="95a3d610">提取参数非常强大，因此值得阅读<a href="javaintroduce.html">更详细的帮助页面</a> 。</p></section>        <section class="procedure-steps"><h3 id="d85a1fdf">提取方法</h3><p id="16476a36">提高代码可读性的一种方法是将代码分成小块且易于理解的部分。<a href="http://refactoring.com/catalog/extractMethod.html" rel="noopener noreferrer" data-external="true" target="_blank">提取方法</a>使开发人员能够做到这一点，并在适当的时候将代码段移动到自己的描述性命名方法中。</p><p id="367e0e05">一些开发人员可能会发现自己编写了执行所需操作的长方法，并在完成（和测试）功能后，查看代码以了解可在何处进行重构和简化，并分解这些长方法。或者，当开发人员在实现新功能时遇到代码时，他们意识到将某些代码提取到自己的方法中可以使他们重用现有功能。</p><aside class="prompt" rel="367e0e05" id="ec354e14" data-type="tip" data-title=""><p>当IntelliJ IDEA检测到重复代码时，这是创建新方法的一个很好的选择，该方法可以被所有具有重复代码的地方调用。</p></aside><p id="cf740dbd">我们将看与上一节相同的示例，但与之前的方法略有不同。</p><div class="code-block" data-lang="java">静态字符串getTextFromMessage（String message）{最终字符串fieldName =“ \” text \“：\”“;最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最终int indexOfEndOfFieldValue = message.indexOf（” \ “”，indexOfFieldValue）；返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }静态字符串getUsernameFromMessage（String message）{最终字符串fieldName =“ \” screen_name \“：\”“;最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最终int indexOfEndOfFieldValue = message.indexOf（” \“”，indexOfFieldValue）；返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }</div><p id="5df9807c">正如我们前面所看到的，以前的重构有一些折衷：需要将方法引用转换为lambda表达式，并且所有调用代码都需要知道所需的字段名称。我们可以选择以不同的方式删除两个方法之间的代码重复：</p><ul class="list _bullet"><li class="list__item" id="2c701cf1"><p>将通用代码提取到自己的方法中。</p></li><li class="list__item" id="83896b47"><p>内联变量以简化其余代码。</p></li></ul><ol class="list _decimal"><li class="list__item" id="d52f5aad">                <p id="8e90a8ea">首先，突出显示这两种方法之间通用的代码：</p>                <figure><img alt="突出显示重复代码的实例" title="突出显示重复代码的实例" src="/help/img/idea/2019.3/ij_extract_method_1_duplicate_code.png" id="b84a0fda" width="731" height="232"></figure>                <p id="07dc0b5b">紧迫<kbd data-primary_default_for_windows="Ctrl+Alt+M" data-primary_eclipse="Shift+Alt+M" data-primary_emacs="Ctrl+Alt+M" data-primary_netbeans="Shift+Alt+M" data-primary_sublime_text="Ctrl+Alt+M" data-primary_visual_studio="Ctrl+Alt+M" data-secondary_macos="⌥⌘M" data-secondary_eclipse="⌥⇧M" data-secondary_eclipse_macos="⌥⌘M" data-secondary_emacs="⌃⌥M" data-secondary_intellij_idea_classic="⌥⌘M" data-secondary_netbeans="⌥⇧M" data-secondary_sublime_text="⌃⌥M" data-secondary_sublime_text_macos="⌥⌘M" data-secondary_visual_studio="⌃⌥M">Ctrl+Alt+M</kbd>将弹出“ <a href="extract-method-dialog.html">提取方法”对话框</a> 。</p>                <figure><img alt="提取方法对话框" title="提取方法对话框" src="/help/img/idea/2019.3/ij_extract_method_2_dialog.png" id="85475daa" width="524" height="444"></figure>                <p id="563f3f99">输入新方法的名称， <code class="code">getValueForField</code> ，然后检查参数名称和顺序。在这种情况下，我们将交换参数的顺序，因为我们更喜欢<code class="code">fieldName</code>参数，使其更接近方法的名称。这将取决于您的代码风格和团队偏好，您可能想大声朗读名称和参数，以了解用自然语言声明是否有意义。</p>                <figure><img alt="提取方法对话框中的最终设置" title="提取方法对话框中的最终设置" src="/help/img/idea/2019.3/ij_extract_method_3_dialog_complete.png" id="058cc4a2" width="524" height="444"></figure>                <p id="7461171f">当您按<span class="keyword">OK时</span> ，IntelliJ IDEA将检测到可以被对此新方法的调用替换的代码，并将提供重构的代码。我们将选择“ <span class="keyword">是”</span> 。</p>                <figure><img alt="重构重复代码" title="重构重复代码" src="/help/img/idea/2019.3/ij_extract_method_4_detect_duplicates.png" id="1c6f64e8" width="716" height="370"></figure>            </li><li class="list__item" id="fec9c6de">                <p id="7a07ca2b">至此，我们的<code class="code">getTextFromMessage</code>和<code class="code">getUsernameFromMessage</code>方法是两行简单的代码，在这里<a href="inline.html">内联</a> fieldName变量是有意义的，因为方法名具有足够的描述性，可以删除<a href="http://refactoring.com/catalog/inlineTemp.html" rel="noopener noreferrer" data-external="true" target="_blank">临时变量</a> 。按<kbd data-primary_default_for_windows="Ctrl+Alt+N" data-primary_eclipse="Shift+Alt+I" data-primary_emacs="Ctrl+Alt+N" data-primary_netbeans="Ctrl+Alt+N" data-primary_sublime_text="Ctrl+Alt+N" data-primary_visual_studio="Ctrl+Alt+N" data-secondary_macos="⌥⌘N" data-secondary_eclipse="⌥⇧I" data-secondary_eclipse_macos="⌥⌘I" data-secondary_emacs="⌃⌥N" data-secondary_intellij_idea_classic="⌥⌘N" data-secondary_netbeans="⌃⌥N" data-secondary_sublime_text="⌃⌥N" data-secondary_sublime_text_macos="⌥⌘N" data-secondary_visual_studio="⌃⌥N">Ctrl+Alt+N</kbd>上<code class="code">fieldName</code>然后选择<span class="keyword">Refactor</span> 。</p>                <figure><img alt="内联不必要的变量" title="内联不必要的变量" src="/help/img/idea/2019.3/ij_extract_method_5_inline.png" id="44301802" width="624" height="265"></figure>            </li><li class="list__item" id="08e952d2">                <p id="d6a41ba1">最后，您可能希望将所有相似的方法组合在一起。根据您的设置，IntelliJ IDEA可能已将新方法直接放置在您选择提取方法时所使用的方法的下面，如本例所示。要将辅助方法彼此并排放置，请将光标放在<code class="code">getValueForField</code>方法名称并按<kbd data-primary_default_for_windows="Ctrl+Shift+Down" data-primary_eclipse="Alt+Down" data-primary_emacs="N/A" data-primary_netbeans="Shift+Alt+Page Down" data-primary_sublime_text="N/A" data-primary_visual_studio="Ctrl+Shift+Down" data-secondary_macos="⇧⌘↓" data-secondary_eclipse="⌥↓" data-secondary_eclipse_macos="⌥↓" data-secondary_emacs="N/A" data-secondary_intellij_idea_classic="⇧⌘↓" data-secondary_netbeans="⌥⇧⇟" data-secondary_sublime_text="N/A" data-secondary_sublime_text_macos="⇧⌘↓" data-secondary_visual_studio="⌃⇧↓">Ctrl+Shift+Down</kbd> 。这将放置您的新方法， <code class="code">getValueForField</code> ，在现有的getUsernameFromMessage方法下。</p>                <p id="b9e663b0">我们的最终代码如下：</p>                <div class="code-block" data-lang="java">静态字符串getTextFromMessage（String message）{return getValueForField（“ \” text \“：\”“，message）;}静态字符串getUsernameFromMessage（String message）{返回getValueForField（” \“ screen_name \”：\“”，message） ; }静态字符串getValueForField（String fieldName，String message）{final int indexOfFieldValue = message.indexOf（fieldName）+ fieldName.length（）;最后的int indexOfEndOfFieldValue = message.indexOf（“ \”“，indexOfFieldValue）;返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）;}</div>                <p id="b84c07ec">现在，我们有两个非常具体的帮助程序方法，它们用于获取消息正文和用户名，以及一个更通用的方法，该方法可用于从消息中获取任何字段的值。当经常需要其他字段时，可以添加其他辅助方法。</p>            </li></ol><p id="c6f16d96">请注意，“提取参数”和“提取方法”示例以相同的代码开头，但以看起来非常不同的代码结尾。这不仅是因为我们使用了不同的重构，还因为我们做出了不同的决策-在第一个示例中，我们选择完全删除重复项，并将某些决策转移到方法的调用者中。在第二个示例中，我们选择提供一个API，该API将字段名的详细信息隐藏在小的辅助方法后面，但仍然提供更通用的方法。我们也可能会混合使用各种方法，我们选择的重构可能会引导我们朝特定的方向发展，但我们可以决定最终的目标。我们应该记住重构的目标（在这种情况下，减少重复），并了解选择一个方向而不是另一个方向时所要做出的取舍，例如，确定我们是否要调用代码来知道他们要询问的字段名称对于。</p></section>        <section class="procedure-steps"><h3 id="6313c149">提取的影响</h3><p id="a8d01139">好消息是您可以相当轻松地撤消提取。不仅通过选择<kbd data-primary_default_for_windows="Ctrl+Z" data-primary_eclipse="Ctrl+Z" data-primary_emacs="Ctrl+Shift+Minus" data-primary_netbeans="Ctrl+Z" data-primary_sublime_text="Ctrl+Z" data-primary_visual_studio="Ctrl+Z" data-secondary_macos="⌘Z" data-secondary_eclipse="⌃Z" data-secondary_eclipse_macos="⌘Z" data-secondary_emacs="⌃⇧-" data-secondary_intellij_idea_classic="⌘Z" data-secondary_netbeans="⌃Z" data-secondary_sublime_text="⌃Z" data-secondary_sublime_text_macos="⌘Z" data-secondary_visual_studio="⌃Z">Ctrl+Z</kbd> ，当然，但是可以通过<a href="inline.html">内联</a>创建的方法，使代码返回到以前的状态。</p><p id="ae89788d">经验丰富的开发人员经常使用我们在此处提到的摘录重构在代码演变时对其进行整形，并且每次触摸代码时或多或少使用它们的情况并不少见。某些未涵盖的内容，例如<a href="extract-interface.html">提取接口</a>和<a href="extract-superclass.html">提取超类</a> ，可能会对整体设计产生更大的影响，因此应格外小心。</p></section>    </div>    <div class="chapter"><h2 id="e2d541e4">删除中</h2>        <p id="5e11c249">有时，当您在多个步骤中重构了代码后，最终可能会得到不再使用的代码，或者理想情况下不应使用。由于重构的目的是简化，您应始终致力于在可能的地方删除未使用的代码-不管未使用的代码对应用程序性能的影响（或没有影响），未使用的代码肯定会给使用和尝试使用的开发人员造成重大损失。了解应用程序。</p>        <section class="procedure-steps"><h3 id="9b0f3d63">安全删除</h3><p id="c713ef1c">IntelliJ IDEA使您可以<a href="safe-delete.html">安全地删除</a>未使用的代码片段或整个文件，并通知您是否可以安全删除代码，还可以选择在更改之前预览更改。识别和处理未使用代码的最快方法是确保启用了相关检查，通常默认情况下它们是：</p><figure><img alt="检查以查找未使用的代码" title="检查以查找未使用的代码" src="/help/img/idea/2019.3/ij_safe_delete_1_inspections.png" id="7a5bd45d" width="1003" height="671"></figure><p id="b37ac1e1">让我们继续前面的重构示例。假设我们最终得到以下代码：</p><div class="code-block" data-lang="java">静态字符串getUsernameFromMessage（String message）{return getValueForField（“ \” screen_name \“：\”“，message）;}静态字符串getValueForField（String fieldName，String message）{最终int indexOfFieldValue = message.indexOf（fieldName）+ fieldName。 length（）;最终int indexOfEndOfFieldValue = message.indexOf（“ \”“，indexOfFieldValue）;返回message.substring（indexOfFieldValue，indexOfEndOfFieldValue）; }</div><p id="ebd4d22f">可能稍后，当我们回到这段代码时， <code class="code">getUsernameFromMessage</code>方法已不再使用-也许不再需要，或者人们习惯于打电话<code class="code">getValueForField</code>与相关参数。因此，假设我们对这些原因感到满意，我们可以继续删除此方法。</p><ol class="list _decimal"><li class="list__item" id="bec47cc2"><p>如果启用了未使用的声明检查，则方法名称将显示为灰色，表示未使用。</p><figure><img alt="未使用的方法可以安全删除" title="未使用的方法可以安全删除" src="/help/img/idea/2019.3/ij_safe_delete_2_unused.png" id="eb15435a" width="710" height="159"></figure>            <p></p></li><li class="list__item" id="e9274f6a"><p>将光标放在<code class="code">getUsernameFromMessage</code>然后按<kbd data-primary_default_for_windows="Alt+Enter" data-primary_eclipse="Alt+Enter" data-primary_emacs="Alt+Enter" data-primary_netbeans="Alt+Enter" data-primary_sublime_text="Alt+Enter" data-primary_visual_studio="Alt+Enter" data-secondary_macos="⌥⏎" data-secondary_eclipse="⌥⏎" data-secondary_eclipse_macos="⌘1" data-secondary_emacs="⌥⏎" data-secondary_intellij_idea_classic="⌥⏎" data-secondary_netbeans="⌥⏎" data-secondary_sublime_text="⌥⏎" data-secondary_sublime_text_macos="⌥⏎" data-secondary_visual_studio="⌥⏎">Alt+Enter</kbd> 。这将为您提供删除此方法的选项。</p><figure><img alt="删除未使用的方法" title="删除未使用的方法" src="/help/img/idea/2019.3/ij_safe_delete_3_delete.png" id="503136b8" width="747" height="183"></figure>            <p></p></li><li class="list__item" id="525c828b">                <p id="fb9af4f7">选择安全删除将弹出安全删除对话框，使您可以搜索此方法的用法。</p>                <figure><img alt="安全删除对话框" title="安全删除对话框" src="/help/img/idea/2019.3/ij_safe_delete_4_dialog.png" id="d7697513" width="506" height="125"></figure>                <p id="5dea14c8">按<span class="keyword">确定</span>继续进行搜索。在我们的情况下，删除是完全安全的，因此删除了该方法。</p>            </li><li class="list__item" id="ca028f4f">                <p id="bfa7c7c7">我们的“未使用”方法可能未标记为未使用，因为它可能会被测试覆盖。但是，如果我们仍然知道它尚未使用，或者已经通过<kbd data-primary_default_for_windows="Alt+F7" data-primary_eclipse="Ctrl+G" data-primary_emacs="Alt+F7" data-primary_netbeans="Alt+F7" data-primary_sublime_text="Alt+F7" data-primary_visual_studio="Shift+Alt+F7" data-secondary_macos="⌥F7" data-secondary_eclipse="⌃G" data-secondary_eclipse_macos="⇧⌘G" data-secondary_emacs="⌥F7" data-secondary_intellij_idea_classic="⌥F7" data-secondary_netbeans="⌥F7" data-secondary_sublime_text="⌥F7" data-secondary_sublime_text_macos="⌥F7" data-secondary_visual_studio="⌥⇧F7">Alt+F7</kbd> ，我们仍然可以安全地删除它。</p><p id="bfa7c7c7">将光标放在方法名称上，然后按<kbd data-primary_default_for_windows="Alt+Delete" data-primary_eclipse="Alt+Delete" data-primary_emacs="N/A" data-primary_netbeans="Alt+Delete" data-primary_sublime_text="Alt+Delete" data-primary_visual_studio="Alt+Delete" data-secondary_macos="⌘⌦" data-secondary_eclipse="⌥⌦" data-secondary_eclipse_macos="N/A" data-secondary_emacs="N/A" data-secondary_intellij_idea_classic="⌘⌦" data-secondary_netbeans="⌥⌦" data-secondary_sublime_text="⌥⌦" data-secondary_sublime_text_macos="⌘⌦" data-secondary_visual_studio="⌥⌦">Alt+Delete</kbd> 。这将像以前一样弹出安全删除对话框，这一次您按<span class="keyword">OK时，</span> IntelliJ IDEA会警告您该方法已使用</p>                <figure><img alt="找到用法" title="找到用法" src="/help/img/idea/2019.3/ij_safe_delete_5_usages_dialog.png" id="f90544d1" width="524" height="489"></figure>                <p id="c5c0a836">按<span class="keyword">查看用法</span>查看这些是什么</p>                <figure><img alt="查看所有代码用法" title="查看所有代码用法" src="/help/img/idea/2019.3/ij_safe_delete_6_usages.png" id="95d5d509" width="735" height="262"></figure>            </li><li class="list__item" id="63715d8c">                <p id="4495cf06">通过双击每个用法，使用结果面板导航到用法。在我们的例子中，我们看到有一个测试调用了我们要删除的方法。</p>                <figure><img alt="测试中使用的方法" title="测试中使用的方法" src="/help/img/idea/2019.3/ij_safe_delete_7_test.png" id="81b2bebb" width="623" height="109"></figure>                <p id="5c926ccb">由于存在该测试以确保我们不再需要的方法的正确性，因此我们也可以删除该测试。在编辑器窗口中，按<kbd data-primary_default_for_windows="Alt+Delete" data-primary_eclipse="Alt+Delete" data-primary_emacs="N/A" data-primary_netbeans="Alt+Delete" data-primary_sublime_text="Alt+Delete" data-primary_visual_studio="Alt+Delete" data-secondary_macos="⌘⌦" data-secondary_eclipse="⌥⌦" data-secondary_eclipse_macos="N/A" data-secondary_emacs="N/A" data-secondary_intellij_idea_classic="⌘⌦" data-secondary_netbeans="⌥⌦" data-secondary_sublime_text="⌥⌦" data-secondary_sublime_text_macos="⌘⌦" data-secondary_visual_studio="⌥⌦">Alt+Delete</kbd>在测试方法名称上，然后在“安全删除”对话框中说“ <span class="keyword">确定</span> ”。测试方法将被删除。</p>            </li><li class="list__item" id="188b39a6"><p id="e56d0ca9">现在，我们将在“安全删除冲突”窗口中看到此代码不再有效。</p>                <figure><img alt="不再使用该方法" title="不再使用该方法" src="/help/img/idea/2019.3/ij_safe_delete_8_invalid.png" id="4322a933" width="648" height="261"></figure>                <p id="7cd073d6">由于这是我们最初要删除的方法的唯一用法，因此可以选择“ <span class="keyword">重新运行安全删除”</span>按钮。这次，当您在“安全删除”对话框中按“ <span class="keyword">确定”</span>时， <code class="code">getUsernameFromMessage</code>方法将被删除。</p>            </li></ol></section>        <section class="procedure-steps"><h3 id="03d3d6ff">删除的影响</h3><aside class="prompt" rel="03d3d6ff" id="7402ed22" data-type="tip" data-title=""><p>如果您发现一个未使用但构成公共API一部分的公共方法，则应将其包含在测试中。“未使用”警告可能并不意味着您应该删除该方法，而是告诉您应该对该方法进行测试。</p></aside><p id="f78de189">IntelliJ的检查可以向您显示未使用的代码，但是如果您的代码将被打包为一个库供其他人使用，或者以其他方式公开了公共API，则可能在将某些公共符号标记为未使用时实际事实，它们由您无法控制的代码使用。如果公共符号似乎未使用，则应检查其他系统是否使用了这些符号。</p><p id="28eb6a05">未使用的参数，局部变量和私有字段是删除的理想选择，因为应该很容易看到删除它们不会影响任何功能。</p><p id="7662c467">使用安全删除来删除符号（无论它们是否未使用），可以让您在执行重构之前检查受影响的区域是否是您期望的区域，并使您可以控制要应用的更改。但是，仍然需要注意的是，公共符号可能会被您无法控制的系统使用，因此在删除这些符号时请务必谨慎。</p></section>    </div>    <div class="chapter"><h2 id="7dcd4ba2">结论</h2>        <p id="3bc2f9f0">IntelliJ IDEA具有许多自动重构功能，所有这些功能都旨在让您（开发人员）以尽可能低的影响力来重构代码。目的是进行小的，增量的更改，始终将代码保持在可编译的状态。重构功能的强大之处在于，将较小的更改链接在一起，可以将代码移向您所想到的某个目标：减少重复，删除不必要的代码，力求简单，提高可读性或对代码进行较大的重塑设计。</p>        <p id="8602d770">在进行新功能或错误修复时，可能进行小而简单的更改，甚至是理想的更改，但请记住，可能需要单独应用较大的更改，以区分不应影响现有功能和功能更改的重构。</p>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月29日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="tutorial-file-watchers-in-product.html">IntelliJ IDEA中的文件监视</a> <a class="navigation-links__next" href="replace-conditional-logic-with-strategy-pattern.html">程序用策略模式替换条件逻辑</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>