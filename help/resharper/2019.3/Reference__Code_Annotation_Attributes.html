<html lang="en-US" ><head><meta charset="UTF-8"><meta name="robots" content="noindex"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>代码注释属性-帮助|帮助锐化器</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Reference__Code_Annotation_Attributes" data-breadcrumbs="Reference/Reference__Code_Annotation_Attributes.xml|Code Annotation Attributes" data-main-title="Code Annotation Attributes" data-article-props="
                {
                
            " seeals=":[=" titl=":=" concept=",=" link=":=" ur=":" code_analysis__index.htm="," tex=":" code="" analysi="}=" code_analysis__code_annotations.htm="," use="" annotations="" to="" refine="" inspectio="}=" procedure=",=" code_analysis__annotations_in_source_code.htm="," in="" source="" cod="}=" code_analysis__string_formatting_methods.htm="," analysis="" and="" helpers="" for="" string="" literal="}=" code_analysis__value_analysis.htm="," value="" nullability="" ,="" ="url"="reference__options__code_inspection__code_annotations.html" ="text"="=" }="" ]}="" ]="" reference__code_annotation_attributes_1=""><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Reference__Code_Annotation_Attributes.xml" data-toc="Reference__Code_Annotation_Attributes">代码注释属性</h1><p id="a910921c">的<code class="code">JetBrains.Annotations</code>框架提供了以下描述的许多属性。</p><p id="ee11c3a6">要在代码中使用这些属性，您需要参考<code class="code">JetBrains.Annotations</code>如“ <a href="Code_Analysis__Annotations_in_Source_Code.html">源代码</a>中的<a href="Code_Analysis__Annotations_in_Source_Code.html">注释”</a>部分所述。</p><div class="chapter"><h2 id="05fc55bd" data-toc="Reference__Code_Annotation_Attributes#05fc55bd">注释属性</h2><div class="chapter"><h3 id="CanBeNullAttribute" data-toc="Reference__Code_Annotation_Attributes#CanBeNullAttribute">CanBeNullAttribute</h3>            <p id="95e4e9a2">指示标记元素的值可以是<code class="code">null</code>有时，所以检查<code class="code">null</code>在使用之前是必需的。</p>            <div class="chapter"><h4 id="e597616a">例</h4><div class="code-block" data-lang="csharp">[CanBeNull]对象Test（）=> null;无效UseTest（）{var p = Test（）; var s = p。ToString（）; //警告：可能是“系统”。NullReferenceException'}</div></div>        <a name="CanBeNullAttribute"></a>        <p id="b5361b01">有关更多信息，请参见<a href="Code_Analysis__Value_Analysis.html">值和可空性分析</a> 。</p>    </div><div class="chapter"><h3 id="NotNullAttribute" data-toc="Reference__Code_Annotation_Attributes#NotNullAttribute">NotNullAttribute</h3>            <p id="50902795">指示标记元素的值永远不能为<code class="code">null</code> 。</p>            <div class="chapter"><h4 id="391fd823">例</h4><div class="code-block" data-lang="csharp">[NotNull]对象Foo（）{返回null； //警告：可能为“空”分配}</div></div>        <a name="NotNullAttribute"></a>        <p id="83773f9f">有关更多信息，请参见<a href="Code_Analysis__Value_Analysis.html">值和可空性分析</a> 。</p>    </div><div class="chapter"><h3 id="ItemNotNullAttribute" data-toc="Reference__Code_Annotation_Attributes#ItemNotNullAttribute">ItemNotNullAttribute</h3>            <p id="69fa2636">可以应用于从IEnumerable派生的类型的符号，以及应用于Task和Lazy类的符号，以指示Task的集合项的值。结果属性还是惰性的。值属性永远不能为null。</p>            <div class="chapter"><h4 id="95d57485">例</h4><div class="code-block" data-lang="csharp">public void Foo（[ItemNotNull] List <string>books）{foreach（书籍中的各种书籍）{if（book！= null）//警告：表达式始终为true控制台。WriteLine（book。ToUpper（））; }}</string></div></div>            <a name="ItemNotNullAttribute"></a>        <p id="22c41f3d">有关更多信息，请参见<a href="Code_Analysis__Value_Analysis.html">值和可空性分析</a> 。</p>    </div><div class="chapter"><h3 id="ItemCanBeNullAttribute" data-toc="Reference__Code_Annotation_Attributes#ItemCanBeNullAttribute">ItemCanBeNullAttribute</h3>            <p id="49046af4">可以应用于从IEnumerable派生的类型的符号，以及应用于Task和Lazy类的符号，以指示Task的集合项的值。结果属性还是惰性的。值属性可以为null。</p>            <div class="chapter"><h4 id="d33f7dd8">例</h4><div class="code-block" data-lang="csharp">public void Foo（[ItemCanBeNull] List <string>books）{foreach（书籍中的各种书籍）{//警告：可能为'System。NullReferenceException'控制台。WriteLine（book。ToUpper（））; }}</string></div></div>         <a name="ItemCanBeNullAttribute"></a>        <p id="f858e30d">有关更多信息，请参见<a href="Code_Analysis__Value_Analysis.html">值和可空性分析</a> 。</p>    </div><div class="chapter"><h3 id="StringFormatMethodAttribute" data-toc="Reference__Code_Annotation_Attributes#StringFormatMethodAttribute">StringFormatMethodAttribute</h3>            <p id="f55dc8f1">指示标记的方法通过格式模式和（可选）参数构建字符串。包含格式字符串的参数应在构造函数中指定。格式字符串应位于<a href="http://msdn.microsoft.com/en-us/library/System.String.Format(System.IFormatProvider,System.String,System.Object[]).aspx" rel="noopener noreferrer" data-external="true" target="_blank">系统中。串。格式（系统IFormatProvider，系统。字符串，系统。类似于Object []）</a>的形式。</p>            <div class="chapter"><h4 id="3ad01afb">例</h4><div class="code-block" data-lang="csharp">[StringFormatMethod（“ message”）] void ShowError（字符串消息，params object []参数）{/ *做某事* /} void Foo（）{ShowError（“ Failed：{0}”）; //警告：格式字符串中不存在的参数}</div></div>        <div class="chapter"><h4 id="288ee827">会员</h4><code class="code">#ctor(System.String)</code>指定应将带注释的方法的哪个参数视为格式字符串</div><a name="StringFormatMethodAttribute"></a>        <p id="bfb21912">有关更多信息，请参见<a href="Code_Analysis__String_Formatting_Methods.html#custom">自定义字符串格式化方法</a> 。</p>    </div><div class="chapter"><h3 id="ValueProviderAttribute" data-toc="Reference__Code_Annotation_Attributes#ValueProviderAttribute">ValueProviderAttribute</h3>             <p id="e2f118f5">使用此注释可以指定一种类型，该类型包含带有带注释的属性/字段/参数值的静态或const字段。指定的类型将用于改进完成建议。</p>             <div class="chapter"><h4 id="b62a9ecf">例</h4><div class="code-block" data-lang="csharp">名称空间TestNamespace {公共类常量{public static int INT_CONST = 1;公共常量字符串STRING_CONST =“ 1”; }公共类Class1 {[ValueProvider（“ TestNamespace。常量“]] public int myField; public void Foo（[ValueProvider（” TestNamespace。常量“）]字符串str）{} public void Test（）{Foo（/ *这里尝试完成* /）; // myField = / *这里尝试完成* /}}}</div></div>        </div><div class="chapter"><h3 id="InvokerParameterNameAttribute" data-toc="Reference__Code_Annotation_Attributes#InvokerParameterNameAttribute">InvokerParameterNameAttribute</h3>            <p id="d0a0ba85">指示函数参数应该是字符串文字，并且与调用者函数的参数之一匹配。例如，ReSharper注释<a href="http://msdn.microsoft.com/en-us/library/System.ArgumentNullException.aspx" rel="noopener noreferrer" data-external="true" target="_blank">系统的参数</a><a href="http://msdn.microsoft.com/en-us/library/System.ArgumentNullException.aspx" rel="noopener noreferrer" data-external="true" target="_blank">。ArgumentNullException</a> 。</p>            <div class="chapter"><h4 id="4c1e1891">例</h4><div class="code-block" data-lang="csharp">void Foo（string param）{if（param == null）throw new ArgumentNullException（“ par”）; //警告：无法解析符号}</div></div>        </div><div class="chapter"><h3 id="NotifyPropertyChangedInvocatorAttribute" data-toc="Reference__Code_Annotation_Attributes#NotifyPropertyChangedInvocatorAttribute">NotifyPropertyChangedInvocatorAttribute</h3>             <p id="5ae0dd71">指示该方法包含在实现的类型中<code class="code">System.ComponentModel.INotifyPropertyChanged</code>接口，此方法用于通知某些属性值已更改。</p>             <p id="65d4209f">该方法应该是非静态的并且符合支持的签名之一：</p><ul class="list _ul"><li class="list__item" id="d1ac0cf6"><code class="code">NotifyChanged(string)</code></li><li class="list__item" id="6125ebaf"><code class="code">NotifyChanged(params string[])</code></li><li class="list__item" id="2ab8e643"><code class="code">NotifyChanged{T}(Expression{Func{T}})</code></li><li class="list__item" id="65bb3352"><code class="code">NotifyChanged{T,U}(Expression{Func{T,U}})</code></li><li class="list__item" id="0cda7efb"><code class="code">SetProperty{T}(ref T, T, string)</code></li></ul>             <p></p>             <div class="chapter"><h4 id="d15463c8">例</h4><div class="code-block" data-lang="csharp">公共类Foo：InotifyPropertyChanged {公共事件PropertyChangedEventHandler PropertyChanged; [NotifyPropertyChangedInvocator]受保护的虚拟无效NotifyChanged（string propertyName）{...}字符串_name;公共字符串Name {get {return _name; }设置{_name = value; NotifyChanged（“ LastName”）; /* 警告 */ } } }</div>生成的通知示例：<ul class="list _ul"><li class="list__item" id="721c3f01"><code class="code">NotifyChanged("Property")</code></li><li class="list__item" id="6df73d30"><code class="code">NotifyChanged(() => Property)</code></li><li class="list__item" id="706a8f42"><code class="code">NotifyChanged((VM x) => x.Property)</code></li><li class="list__item" id="bcffac0c"><code class="code">SetProperty(ref myField, value, "Property")</code></li></ul>             </div>        <a name="NotifyPropertyChangedInvocatorAttribute"></a>        <p id="6a136a90">有关更多信息，请参见<a href="Coding_Assistance__INotifyPropertyChanged_Support.html">INotifyPropertyChanged支持</a> 。</p>    </div><div class="chapter"><h3 id="ContractAnnotationAttribute" data-toc="Reference__Code_Annotation_Attributes#ContractAnnotationAttribute">ContractAnnotationAttribute</h3>            <p id="97178967">描述方法输入和输出之间的依赖关系。</p>            <div class="chapter"><h4 id="13d4f93b">句法</h4>函数定义表语法：<ul class="list _ul"><li class="list__item" id="99dc2b28"><p>FDT :: = FDTRow [; FDTRow] *</p></li><li class="list__item" id="1054bbe0"><p>FDTRow :: =输入=>输出|输出<=输入</p></li><li class="list__item" id="0419223f"><p>输入:: = ParameterName：值[，输入] *</p></li><li class="list__item" id="49b56b02"><p>输出:: = [ParameterName：Value] * {停止|停止|无效|没有|值}</p></li><li class="list__item" id="139d6f2c"><p>值:: = true |错误|空| notnull |坎贝努尔</p></li></ul>如果该方法具有单个输入参数，则可以省略其名称。<br>使用<code class="code">halt</code> （要么<code class="code">void</code> / <code class="code">nothing</code> ，与方法输出相同），这意味着该方法不会正常返回（引发或终止进程）。<br>值<code class="code">canbenull</code>仅适用于输出参数。<br>您可以使用多个<code class="code">[ContractAnnotation]</code>对于每个FDT行，或将单个属性与以分号分隔的行一起使用。没有订单行的概念，将检查所有行的适用性，并根据分析引擎跟踪的每个程序状态来应用所有行。<br>            </div>            <div class="chapter"><h4 id="05824cd7">例子</h4><ul class="list _ul"><li class="list__item" id="a0332451"><div class="code-block" data-lang="csharp">[ContractAnnotation（“ =>暂停”）] public void TerminationMethod（）</div></li><li class="list__item" id="e1ad461a"><div class="code-block" data-lang="csharp">[ContractAnnotation（“ null <= param：null”）] //反向条件语法公共字符串GetName（字符串姓氏）</div></li><li class="list__item" id="23eb20d6"><div class="code-block" data-lang="csharp">[ContractAnnotation（“ s：null => true”）]公共布尔IsNullOrEmpty（string s）//字符串。IsNullOrEmpty（）</div></li><li class="list__item" id="f4719905"><div class="code-block" data-lang="csharp">//如果参数为null则返回null的方法，//如果参数非null则返回null的方法[ContractAnnotation（“ null => null; notnull => notnull”）]公共对象Transform（对象数据）</div></li><li class="list__item" id="9ce34b2d"><div class="code-block" data-lang="csharp">[ContractAnnotation（“ => true，结果：notnull； => false，结果：null”）] public bool TryParse（字符串s，输出Person结果）</div></li></ul></div>        <a name="ContractAnnotationAttribute"></a>        <p id="d528e759">有关更多信息，请参见<a href="Contract_Annotations.html">合同注释</a> 。</p>    </div><div class="chapter"><h3 id="LocalizationRequiredAttribute" data-toc="Reference__Code_Annotation_Attributes#LocalizationRequiredAttribute">LocalizationRequiredAttribute</h3>            <p id="1b49d078">指示标记的元素是否应该本地化。</p>            <div class="chapter"><h4 id="9da54eb4">例</h4><div class="code-block" data-lang="csharp">[LocalizationRequiredAttribute（true）]类Foo {string str =“ my string”; //警告：可本地化的字符串}</div></div>        <a name="LocalizationRequiredAttribute"></a>有关更多信息，请参见<a href="Localization_Inspection.html">本地化检查和快速修复。</a>            </div><div class="chapter"><h3 id="CannotApplyEqualityOperatorAttribute" data-toc="Reference__Code_Annotation_Attributes#CannotApplyEqualityOperatorAttribute">CannotApplyEqualityOperatorAttribute</h3>            <p id="c2971a88">表示不能使用'=='或'！比较标记类型（或其派生类型）的值。='运算子和<code class="code">Equals()</code>应该改为使用。但是，使用'=='或'！='与<code class="code">null</code>始终被允许。</p>            <div class="chapter"><h4 id="37f9c5a2">例</h4><div class="code-block" data-lang="csharp">[CannotApplyEqualityOperator]类NoEquality {}类UsesNoEquality {void Test（）{var ca1 = new NoEquality（）; var ca2 = new NoEquality（）;如果（ca1！= null）{// OK bool条件= ca1 == ca2; // 警告 } } }</div></div>        </div><div class="chapter"><h3 id="BaseTypeRequiredAttribute" data-toc="Reference__Code_Annotation_Attributes#BaseTypeRequiredAttribute">BaseTypeRequiredAttribute</h3>            <p id="1e86e6c8">当应用于目标属性时，为使用目标属性标记的任何类型指定实现或继承特定类型的要求。</p>            <div class="chapter"><h4 id="4a580ffc">例</h4><div class="code-block" data-lang="csharp">[BaseTypeRequired（typeof（IComponent）] //指定需求类ComponentAttribute：属性{} [Component] // ComponentAttribute需要实现IComponent接口类MyComponent：IComponent {}</div></div>        </div><div class="chapter"><h3 id="UsedImplicitlyAttribute" data-toc="Reference__Code_Annotation_Attributes#UsedImplicitlyAttribute">UsedImplicitlyAttribute</h3>            <p id="f64a9692">指示标记的符号被隐式使用（例如，通过外部库中的反射），因此不会将该符号报告为未使用（以及其他使用情况检查）。</p>        </div><div class="chapter"><h3 id="MeansImplicitUseAttribute" data-toc="Reference__Code_Annotation_Attributes#MeansImplicitUseAttribute">MeansImplicitUseAttribute</h3>            <p id="6333dd06">应该在属性上使用，以便标记有此类属性的符号不会被报告为未使用。标记的属性的行为与<a href="#UsedImplicitlyAttribute">UsedImplicitlyAttribute</a>相同。</p>        </div><div class="chapter"><h3 id="PublicAPIAttribute" data-toc="Reference__Code_Annotation_Attributes#PublicAPIAttribute">PublicAPIAttribute</h3>            <p id="fefdf9b5">此属性旨在标记公共可用的API，不应将其删除，因此将其视为已使用。</p>        </div><div class="chapter"><h3 id="InstantHandleAttribute" data-toc="Reference__Code_Annotation_Attributes#InstantHandleAttribute">InstantHandleAttribute</h3>            <p id="978458a9">告诉代码分析引擎，当调用的方法在堆栈上时，参数是否已完全处理。如果参数是委托，则表示在执行方法的同时执行委托。如果参数是可枚举的，则表示在执行该方法时将对其进行枚举。</p>        </div><div class="chapter"><h3 id="PureAttribute" data-toc="Reference__Code_Annotation_Attributes#PureAttribute">PureAttribute</h3>            <p id="79a68589">指示方法不进行任何可观察的状态更改。与...相同<code class="code">System.Diagnostics.Contracts.PureAttribute</code> 。</p>            <div class="chapter"><h4 id="e5a86bb5">例</h4><div class="code-block" data-lang="csharp">[Pure] int Multiply（int x，int y）=> x * y; M（）{Multiply（123，42）; //警告：未使用纯方法的返回值}</div></div>        </div><div class="chapter"><h3 id="MustUseReturnValueAttribute" data-toc="Reference__Code_Annotation_Attributes#MustUseReturnValueAttribute">MustUseReturnValueAttribute</h3>            <p id="32f80b47">指示必须使用方法调用的返回值。</p>            <p id="7fd4c5a4">用此属性修饰的方法（与纯方法相反）可能会更改状态，但是如果不使用它们的返回值就没有意义。<br>与<a href="#PureAttribute">PureAttribute相似</a> ，此属性将在未使用返回值时帮助检测方法的用法。另外，您可以选择指定一个自定义消息，该消息将在显示警告时使用，例如</p><div class="code-block" data-lang="csharp">[MustUseReturnValue（“将返回值用于...”）]</div>。<p></p>        </div><div class="chapter"><h3 id="ProvidesContextAttribute" data-toc="Reference__Code_Annotation_Attributes#ProvidesContextAttribute">ProvidesContextAttribute</h3>            <p id="28ed4e43">指示某种类型的类型成员或参数，应使用它代替所有其他方式来获取该类型的值。当您评估了一些“上下文”值并将其存储在某处时，此注释很有用，这意味着获取该值的所有其他方法都必须与现有方法合并。</p>            <div class="chapter"><h4 id="bec3200e">例</h4><div class="code-block" data-lang="csharp">类Foo {[ProvidesContext] IBarService _barService = ...; void ProcessNode（INode node）{DoSomething（node，node。GetGlobalServices（）。酒吧）; // ^警告：请使用'_barService'字段的值}}</div></div>        </div><div class="chapter"><h3 id="PathReferenceAttribute" data-toc="Reference__Code_Annotation_Attributes#PathReferenceAttribute">PathReferenceAttribute</h3>            <p id="f5873754">指示参数是Web项目中文件或文件夹的路径。路径可以是相对的，也可以是绝对的，从Web根（〜）开始。</p>        </div><div class="chapter"><h3 id="SourceTemplateAttribute" data-toc="Reference__Code_Annotation_Attributes#SourceTemplateAttribute">SourceTemplateAttribute</h3>            <p id="27f178b3">标有该属性的扩展方法由代码完成处理为“源模板”。当扩展方法在某个表达式上完成时，其源代码会像调用站点上的模板一样自动扩展。</p>            <p id="44009867">模板方法主体可以包含有效的源代码和/或以“ $”开头的特殊注释。应用模板时，这些注释中的文本将作为源代码添加。模板参数既可以用作其他方法参数，也可以用作包装在两个“ $”符号中的标识符。使用<a href="#MacroAttribute">MacroAttribute</a>属性为参数指定宏。</p>            <div class="chapter"><h4 id="12b06d0e">例</h4>在此示例中，“ forEach”方法是可用于可枚举类型的所有值的源模板，生成普通的C＃“ foreach”语句并将插入符插入块内：<div class="code-block" data-lang="csharp">[SourceTemplate] public static void forEach <t>（此IEnumerable <t>xs）{foreach（xs中的var x）{// $ $ END $}}</t></t></div>            </div>        <a name="SourceTemplateAttribute"></a>        <p id="d6dc4483">有关更多信息，请参见<a href="Source_Templates.html">源模板</a> 。</p>    </div><div class="chapter"><h3 id="MacroAttribute" data-toc="Reference__Code_Annotation_Attributes#MacroAttribute">宏属性</h3>            <p id="6d9d1126">允许为<a href="#SourceTemplateAttribute">SourceTemplateAttribute</a>的参数指定宏。</p>            <p id="3dbbe554">您可以将属性应用于整个方法或其任何其他参数。宏表达式在<a href="#Expression">Expression</a>属性中定义。当应用于方法时，目标模板参数在<a href="#Target">Target</a>属性中定义。要以静默方式将宏应用于参数，请设置<a href="#Editable">Editable</a>属性值= -1。</p>            <div class="chapter"><h4 id="a404c0e3">例</h4>将属性应用于源模板方法：<div class="code-block" data-lang="csharp">[SourceTemplate，Macro（Target =“ item”，Expression =“ suggestVariableName（）”）]公共静态无效的forEach <t>（此IEnumerable <t>集合）{foreach（集合中的</t></t>变量<t><t>项）{// $ $ END $}}</t></t></div>将属性应用于模板方法参数：<div class="code-block" data-lang="csharp">[SourceTemplate] public static void something（此实体x，[Macro（Expression =“ guid（）”，Editable = -1）]字符串newguid）{/ * $ var $ x $ Id =“ $ newguid $” + x。ToString（）; X。DoSomething（$ x $ Id）; * /}</div>            </div>        <div class="chapter"><h4 id="0ad54156">会员</h4><code class="code">Expression</code>            <p id="9035af84">允许指定在扩展模板时将为<a href="#SourceTemplateAttribute">SourceTemplateAttribute</a>参数执行的宏。</p>        <code class="code">Editable</code>            <p id="f9974bf5">允许指定在部署模板时目标参数的哪个出现变为可编辑的。</p>            <p id="c162cb21">如果在模板中多次使用目标参数，则只有一个出现可编辑；其他事件将同步更改。要指定可编辑事件的从零开始的索引，请使用> = 0的值。要在扩展模板时使参数不可编辑，请使用-1。</p>        <code class="code">Target</code>            <p id="2adfed94">如果将<a href="#MacroAttribute">MacroAttribute</a>应用于模板方法，则标识<a href="#SourceTemplateAttribute">SourceTemplateAttribute</a>的目标参数。</p>        </div><a name="MacroAttribute"></a>        <a name="SourceTemplateAttribute"></a>        <p id="0fb501b5">有关更多信息，请参见<a href="Source_Templates.html">源模板</a> 。</p>        </div><div class="chapter"><h3 id="AspMvcActionAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcActionAttribute">AspMvcActionAttribute</h3>            <p id="04fdfd77">ASP.NET MVC属性。如果应用于参数，则表明该参数是MVC操作。如果应用于方法，则从上下文隐式计算MVC操作名称。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcAreaAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcAreaAttribute">AspMvcAreaAttribute</h3>            <p id="8eb67191">ASP.NET MVC属性。指示标记的参数是MVC区域。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcControllerAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcControllerAttribute">AspMvcControllerAttribute</h3>            <p id="60ef0f0e">ASP.NET MVC属性。如果应用于参数，则表明该参数是MVC控制器。如果应用于方法，则从上下文隐式计算MVC控制器名称。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcMasterAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcMasterAttribute">AspMvcMasterAttribute</h3>            <p id="6c1c426d">ASP.NET MVC属性。指示标记的参数是MVC主控。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Controller.View(String, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcModelTypeAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcModelTypeAttribute">AspMvcModelTypeAttribute</h3>            <p id="ff0dcfd4">ASP.NET MVC属性。指示标记的参数是MVC模型类型。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Controller.View(String, Object)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcPartialViewAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcPartialViewAttribute">AspMvcPartialViewAttribute</h3>            <p id="c1cc6e5a">ASP.NET MVC属性。如果应用于参数，则表示该参数是MVC局部视图。如果应用于方法，则从上下文隐式计算MVC部分视图名称。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcSuppressViewErrorAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcSuppressViewErrorAttribute">AspMvcSuppressViewErrorAttribute</h3>            <p id="f61eb522">ASP.NET MVC属性。允许在类或方法中禁用对MVC视图的检查。</p>        </div><div class="chapter"><h3 id="AspMvcDisplayTemplateAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcDisplayTemplateAttribute">AspMvcDisplayTemplateAttribute</h3>            <p id="a37758f8">ASP.NET MVC属性。指示参数是MVC显示模板。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcEditorTemplateAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcEditorTemplateAttribute">AspMvcEditorTemplateAttribute</h3>            <p id="665ad0e3">ASP.NET MVC属性。指示标记的参数是MVC编辑器模板。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcTemplateAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcTemplateAttribute">AspMvcTemplateAttribute</h3>            <p id="90190565">ASP.NET MVC属性。指示标记的参数是MVC模板。将此属性用于类似于以下内容的自定义包装<code class="code">System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcViewAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcViewAttribute">AspMvcViewAttribute</h3>            <p id="a358d8e8">ASP.NET MVC属性。如果应用于参数，则表明该参数是MVC视图组件。如果应用于方法，则从上下文隐式计算MVC视图名称。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.Mvc.Controller.View(Object)</code> 。</p>        </div><div class="chapter"><h3 id="AspMvcViewComponentAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcViewComponentAttribute">AspMvcViewComponentAttribute</h3>            <p id="30d4b71a">ASP.NET MVC属性。如果应用于参数，则指示该参数是MVC视图组件名称。</p>        </div><div class="chapter"><h3 id="AspMvcViewComponentViewAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcViewComponentViewAttribute">AspMvcViewComponentViewAttribute</h3>            <p id="edf18448">ASP.NET MVC属性。如果应用于参数，则表示该参数是MVC视图组件视图。如果应用于方法，则MVC视图组件视图名称是默认名称。</p>        </div><div class="chapter"><h3 id="AspMvcActionSelectorAttribute" data-toc="Reference__Code_Annotation_Attributes#AspMvcActionSelectorAttribute">AspMvcActionSelectorAttribute</h3>            <p id="c8ba54d6">ASP.NET MVC属性。当应用于属性的参数时，指示此参数是MVC操作名称。</p>            <div class="chapter"><h4 id="c1ff0860">例</h4><div class="code-block" data-lang="csharp">[ActionName（“ Foo”）] public ActionResult Login（string returnUrl）{ViewBag。ReturnUrl =网址。动作（“ Foo”）； // OK return RedirectToAction（“ Bar”）; //错误：无法解决操作}</div></div>        </div><div class="chapter"><h3 id="RazorSectionAttribute" data-toc="Reference__Code_Annotation_Attributes#RazorSectionAttribute">RazorSectionAttribute</h3>            <p id="a40ccf25">剃刀属性。指示标记的参数或方法是“剃刀”部分。将此属性用于类似于以下内容的自定义包装<code class="code">System.Web.WebPages.WebPageBase.RenderSection(String)</code> 。</p>        </div><div class="chapter"><h3 id="CollectionAccessAttribute" data-toc="Reference__Code_Annotation_Attributes#CollectionAccessAttribute">CollectionAccessAttribute</h3>            <p id="c47805e0">指示对集合类型的方法，构造函数调用或属性访问如何影响集合的内容。使用<a href="#CollectionAccessType">CollectionAccessType</a>指定访问类型。</p>            <p id="2ca1f0dd">仅当所有收集方法都标记有该属性时，才使用该属性。</p>            <div class="chapter"><h4 id="0740b341">例</h4><div class="code-block" data-lang="csharp">公共类MyStringCollection：列表<string>{[[CollectionAccess（CollectionAccessType。读取）]公共字符串GetFirstString（）{返回此值。ElementAt（0）; }}类Test {public void Foo（）{//警告：集合的内容永远不会更新var col = new MyStringCollection（）;字符串x = col。GetFirstString（）; }}</string></div></div>         </div><div class="chapter"><h3 id="AssertionMethodAttribute" data-toc="Reference__Code_Annotation_Attributes#AssertionMethodAttribute">AssertionMethodAttribute</h3>            <p id="b7f6e9eb">指示标记的方法是断言方法，即，如果满足条件之一，则中止控制流。要设置条件，请使用<a href="#AssertionConditionAttribute">AssertionConditionAttribute</a>属性标记参数之一。</p>        </div><div class="chapter"><h3 id="AssertionConditionAttribute" data-toc="Reference__Code_Annotation_Attributes#AssertionConditionAttribute">AssertionConditionAttribute</h3>            <p id="93657496">指示断言方法的条件参数。方法本身应由<a href="#AssertionMethodAttribute">AssertionMethodAttribute</a>属性标记。该属性的必需参数是断言类型。</p>        </div><div class="chapter"><h3 id="TerminatesProgramAttribute" data-toc="Reference__Code_Annotation_Attributes#TerminatesProgramAttribute">TerminatesProgramAttribute</h3>            <p id="66c2b186">指示标记的方法无条件终止控制流执行。例如，它可以无条件地引发异常。</p>        </div><div class="chapter"><h3 id="LinqTunnelAttribute" data-toc="Reference__Code_Annotation_Attributes#LinqTunnelAttribute">LinqTunnelAttribute</h3>            <p id="5e5515fc">指示该方法是纯LINQ方法，具有延迟的枚举（如Enumerable。选择， 。哪里）。通过分析LINQ方法链，此批注允许对委托类型的参数进行[InstantHandle]批注的推断。</p>        </div><div class="chapter"><h3 id="NoEnumerationAttribute" data-toc="Reference__Code_Annotation_Attributes#NoEnumerationAttribute">NoEnumerationAttribute</h3>            <p id="7483a552">表示未枚举作为参数传递的IEnumerable。使用此注释可以取消“可能的IEnumerable多重枚举”检查。</p>            <div class="chapter"><h4 id="188d6b9d">例</h4><div class="code-block" data-lang="csharp">静态void ThrowIfNull <t>（[NoEnumeration] T v，字符串n）其中T：class {//自定义检查null但不枚举} void Foo（IEnumerable <string>values）{ThrowIfNull（values，nameof（values））; var x =值。ToList（）; //没有关于多重枚举的警告}</string></t></div></div>         </div><div class="chapter"><h3 id="RegexPatternAttribute" data-toc="Reference__Code_Annotation_Attributes#RegexPatternAttribute">RegexPatternAttribute</h3>            <p id="b39375b5">指示标记的参数是正则表达式模式。</p>        <a name="RegexPatternAttribute"></a>        <p id="a1cd5039">有关更多信息，请参见<a href="Regular_Expressions_Assistance.html">正则表达式帮助</a> 。</p>    </div><div class="chapter"><h3 id="NoReorderAttribute" data-toc="Reference__Code_Annotation_Attributes#NoReorderAttribute">NoReorderAttribute</h3>            <p id="e611a6e3">防止“成员重新排序”功能抛出标记的类的成员。</p>            <p id="8946f2f6">必须在成员重新排序模式中提及该属性。</p>        <a name="NoReorderAttribute"></a>有关更多信息，请参见<a href="File_and_Type_Layout.html">文件和类型布局。</a>            </div><div class="chapter"><h3 id="XamlItemsControlAttribute" data-toc="Reference__Code_Annotation_Attributes#XamlItemsControlAttribute">XamlItemsControlAttribute</h3>            <p id="98648640">XAML属性。指示具有<code class="code">ItemsSource</code>财产，应视为<code class="code">ItemsControl</code>派生类型，以启用内部项目<code class="code">DataContext</code>类型解析。</p>        </div><div class="chapter"><h3 id="XamlItemBindingOfItemsControlAttribute" data-toc="Reference__Code_Annotation_Attributes#XamlItemBindingOfItemsControlAttribute">XamlItemBindingOfItemsControlAttribute</h3>            <p id="a8746070">XAML属性。表示一些属性<code class="code">BindingBase</code>派生类型，用于绑定某些<code class="code">ItemsControl</code>派生类型。此注释将启用<code class="code">DataContext</code>为此类属性的XAML绑定键入resolve。</p>            <p id="d07e4f00">属性应具有树的祖先<code class="code">ItemsControl</code>类型或使用<a href="#XamlItemsControlAttribute">XamlItemsControlAttribute</a>属性标记。</p>        </div></div><div class="chapter"><h2 id="2901108d" data-toc="Reference__Code_Annotation_Attributes#2901108d">助手类型</h2><div class="chapter"><h3 id="ImplicitUseKindFlags" data-toc="Reference__Code_Annotation_Attributes#ImplicitUseKindFlags">ImplicitUseKindFlags</h3>            <p id="433f5c1d">当标记有<a href="#MeansImplicitUseAttribute">MeansImplicitUseAttribute</a>或<a href="#UsedImplicitlyAttribute">UsedImplicitlyAttribute</a>时，指定隐式使用符号的详细信息。</p>        <div class="chapter"><h4 id="ca1e7b5b">会员</h4><code class="code">Access</code>            <p id="bd6ab7ff">仅使用标记了属性的实体被视为已使用。</p>        <code class="code">Assign</code>            <p id="e0523ddc">指示对成员的隐式分配。</p>        <code class="code">InstantiatedWithFixedConstructorSignature</code>            <p id="a3179f67">指示具有固定构造函数签名的类型的隐式实例化。这意味着任何未使用的构造函数参数都不会这样报告。</p>        <code class="code">InstantiatedNoFixedConstructorSignature</code>            <p id="c00cc42e">指示类型的隐式实例化。</p>        </div></div><div class="chapter"><h3 id="ImplicitUseTargetFlags" data-toc="Reference__Code_Annotation_Attributes#ImplicitUseTargetFlags">ImplicitUseTargetFlags</h3>            <p id="81af236a">指定标记为<a href="#MeansImplicitUseAttribute">MeansImplicitUseAttribute</a>或<a href="#UsedImplicitlyAttribute">UsedImplicitlyAttribute</a>时被视为隐式使用的<a href="#UsedImplicitlyAttribute">内容</a> 。</p>        <div class="chapter"><h4 id="b36a3c46">会员</h4><code class="code">Members</code>            <p id="446783af">标记了属性的实体成员被视为已使用。</p>        <code class="code">WithMembers</code>            <p id="1fae9e08">标记了属性的实体及其所有使用的成员。</p>        </div></div><div class="chapter"><h3 id="CollectionAccessType" data-toc="Reference__Code_Annotation_Attributes#CollectionAccessType">CollectionAccessType</h3>            <p id="b092f0d1">为<a href="#CollectionAccessAttribute">CollectionAccessAttribute</a>提供一个值，以定义收集方法调用如何影响收集的内容。</p>        <div class="chapter"><h4 id="08cfc7a1">会员</h4><code class="code">None</code>            <p id="76a29a86">方法不使用或修改集合的内容。</p>        <code class="code">Read</code>            <p id="5800807b">方法仅读取集合的内容，而不修改它。</p>        <code class="code">ModifyExistingContent</code>            <p id="a05169b6">方法可以更改集合的内容，但不能添加新元素。</p>        <code class="code">UpdatedContent</code>            <p id="feef6bdc">方法可以将新元素添加到集合中。</p>        </div></div><div class="chapter"><h3 id="AssertionConditionType" data-toc="Reference__Code_Annotation_Attributes#AssertionConditionType">AssertionConditionType</h3>            <p id="63f5dc9e">指定断言类型。如果断言方法参数满足条件，则执行继续。否则，假定执行被暂停。</p>        <div class="chapter"><h4 id="44d888cd">会员</h4><code class="code">IS_TRUE</code>            <p id="ba83ab49">标记的参数应评估为true。</p>        <code class="code">IS_FALSE</code>            <p id="ebcd87ec">标记的参数应评估为false。</p>        <code class="code">IS_NULL</code>            <p id="e6fff430">标记的参数应评估为空值。</p>        <code class="code">IS_NOT_NULL</code>            <p id="63fb8283">标记的参数应评估为非空值。</p>        </div></div></div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Reference__Architecture_View.html">架构视图</a> <a class="navigation-links__next" href="Reference_Code_Inspection_Index.html">代码检查索引</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>