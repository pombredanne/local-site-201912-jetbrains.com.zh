<html lang="en-US" ><head><meta charset="UTF-8"><meta name="robots" content="noindex"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>C ++中的编码协助-帮助|帮助锐化器</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Coding_Assistance_in_CPP" data-breadcrumbs="ReSharper_by_Language__Index.xml|ReSharper by Language/ReSharper_by_Language_CPP.xml|ReSharper by Language: C++/Coding_Assistance_in_CPP.xml|Coding Assistance in C++" data-main-title="Coding Assistance in C++" data-article-props="
                {
                
            " seeals=":[=" titl=":=" concept=",=" link=":=" ur=":" coding_assistance__index.htm="," tex=":" coding="" assistanc="}=" auto-completing_code.htm="," code="" completion="" (intellisense="}=" coding_assistance__context_actions.htm="," context="" action="}=" referenc=",=" coding_assistance__extend_shrink_selection.htm="," extend="" shrink="" selectio="}=" reference__options__languages__cpp__context_actions.htm="," actions="" for="" c+="}=" ="" data-disqus-id="Coding_Assistance_in_CPP_10"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Coding_Assistance_in_CPP.xml" data-toc="Coding_Assistance_in_CPP">C ++中的编码协助</h1>                <a name="cpp_support_note"></a>        <aside class="prompt" rel="Coding_Assistance_in_CPP.xml" id="83cb644c" data-type="note" data-title="">            <p id="29a2648b">                <a name="cpp_products"></a> <a href="/resharper-cpp/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper C ++</a>提供了C ++支持， <a href="/resharper-cpp/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper C ++</a>是一种专用产品，可以单独安装，也可以与ReSharper或<a href="/dotnet/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper Ultimate</a>并排安装。</p>        </aside>        <a name="intro_most"></a>        <p id="4a8a4218">ReSharper的大多数编码辅助功能<a name="intro_tail"></a> C ++也支持。您可以在“ <a href="Coding_Assistance__Index.html">编码协助”</a>部分的相应主题中找到有关这些功能的详细信息。在本节的主要主题中，您还可以找到功能矩阵并检查C ++确切支持的功能。</p>        <p id="fe1545da">在本主题中，您可以找到一些在C ++中使用编码辅助功能的示例。</p>        <p id="enable_ca_features_in_external_full">        <a name="enable_ca_features_in_external"></a>默认情况下，所有解决方案文件中都提供<a href="Code_Analysis_in_CPP.html#Inspection">代码检查</a> ， <a href="Code_Analysis_in_CPP.html#quick_fixes">快速修复</a>和<a href="#contextActions">上下文操作</a> 。如有必要，您可以通过在解决方案外部的文件中<span class="control">启用检查，快速修复和上下文操作</span>复选框<span class="control">来</span>从解决方案引用的外部文件中启用这些功能。 <a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">代码编辑| C ++ |的检查</span>页面<a name="product_settings"></a> ReSharper选项（ <kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt+R,,O</span></kbd> ）。</p>    <div class="chapter"><h2 id="completion" data-toc="Coding_Assistance_in_CPP#completion">代码完成</h2>        <div class="chapter"><h3 id="automatic-and-basic-completion">自动和基本完成</h3>            <p id="d993d74b">在C ++文件中，您可以使用<a href="Coding_Assistance_Code_Completion_Auto.html">自动</a>和<a href="Coding_Assistance__Code_Completion__Symbol.html">基本</a> <kbd data-rs="Ctrl+Space" data-vs="Ctrl+Space">Ctrl+Space</kbd>编写代码时完成。例如，您可以快速添加从其他名称空间获取的枚举成员：</p>            <figure><img alt="用C ++自动完成" title="用C ++自动完成" src="/help/img/dotnet/2019.3/cpp_completion_1.png" id="79aae222" width="230" height="164"></figure>            <p id="52fc0429">选定的完成项目将显示一个弹出窗口，其中带有语法突出显示的签名和文档。如有必要，您可以通过取消选中“ <span class="control">显示摘要”</span>复选框来禁用此弹出窗口<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">环境|智能感知的“完成外观”</span>页面<a name="product_settings"></a> ReSharper选项（ <kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt+R,,O</span></kbd> ）。</p>            <figure><img alt="C ++基本完成" title="C ++基本完成" src="/help/img/dotnet/2019.3/cpp_completion_11.png" id="8523b36c" width="397" height="214"></figure>        </div>                <div class="chapter"><h3 id="import-symbol-completion">导入符号完成</h3>            <p id="59656211">                <a name="import_symbol_intro"></a>当您要使用的符号未与相应的符号导入当前文件时<code class="code">#include</code> ，但它是在标准库或解决方案的其他地方定义的，您可以按<kbd data-rs="Ctrl+Alt+Space" data-vs="Shift+Alt+Space">Ctrl+Alt+Space</kbd>在完成建议中快速找到该符号：</p><figure><img alt="ReSharper：在C ++中导入符号完成" title="ReSharper：在C ++中导入符号完成" src="/help/img/dotnet/2019.3/cpp_import_completion.png" id="a99a9ddb" width="469" height="125"></figure>或者，您可以通过<span class="control">在基本完成</span>选择<span class="control">显示进口项目</span>包括导入符号的建议分为自动和基本完成的建议清单<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">代码编辑| C ++ |的代码完成</span>页<a name="product_settings"></a> ReSharper选项（ <kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt+R,,O</span></kbd> ）。<br>                <a name="import_symbol_performance"></a>请注意，这会带来性能上的损失（因为每次ReSharper生成完成列表时，它都必须查看解决方案中的所有符号以匹配它们），因此默认情况下将其禁用。<p></p>        </div>        <div class="chapter"><h3 id="dotCompletion">点/箭头完成助手</h3>            <p id="4bb0629f">调用方法时，您始终可以输入点<code class="code">.</code>或箭<code class="code">-></code>并在完成列表中获取所有可用方法。不匹配的方法<code class="code">.</code> / <code class="code">-></code>以灰色显示。如果选择这种方法， <code class="code">.</code> / <code class="code">-></code>将自动更正：</p>            <figure><img alt="用箭头替换圆点" title="用箭头替换圆点" src="/help/img/dotnet/2019.3/cpp_completion_pointer.png" id="b14c697c" width="552" height="219"></figure>        </div>        <div class="chapter"><h3 id="generative-completion">生成完成</h3>            <p id="307eb04d">                还提供<a href="Coding_Assistance__Code_Completion__Generative.html">生成完成</a>建议。例如，当您在对象上调用成员函数声明时...</p>            <figure><img alt="C ++中的生成完成" title="C ++中的生成完成" src="/help/img/dotnet/2019.3/cpp_completion_2.png" id="e177b807" width="254" height="142"></figure>            <p id="a9738cfa">ReSharper生成以下功能：</p>            <figure><img alt="C ++中的生成完成" title="C ++中的生成完成" src="/help/img/dotnet/2019.3/cpp_completion_3.png" id="044cb9b8" width="240" height="70"></figure>        </div>        <div class="chapter"><h3 id="postfix_completion">后缀完成</h3>            <p id="e20673ec">C ++中的后缀完成与C＃扩展方法非常相似。如果输入点<code class="code">.</code>或箭<code class="code">-></code>在表达式之后，ReSharper将建议一些免费函数，这些函数将接受该表达式作为第一个参数。当您接受建议时，ReSharper将重写您的代码，以便将该表达式作为第一个参数传递：</p>            <figure id="dddef5f2" width="600" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.3/cpp_postfix.png" width="600" data-gif-src="/help/img/dotnet/2019.3/cpp_postfix.animated.gif" style="width:600px"></figure>            <p id="5bf4a726">Postfix完成还包括<a href="Code_Templates_in_CPP.html#postfix">Postfix模板</a> ，这些<a href="Code_Templates_in_CPP.html#postfix">模板</a>无需查找合适的方法，而使您可以使用常用的语言构造快速包装表达式。</p>        </div>        <div class="chapter"><h3 id="free_functions">代码完成中的免费功能</h3>            <a name="free_func_intro"></a>                <p id="095141ae">一种常见的C ++编码实践是将非成员非友函数优先于成员函数。这是增加封装并使类接口尽可能少的好方法。当您键入一个点<code class="code">.</code>或箭<code class="code">-></code>在表达式之后，将在成员函数之后的完成列表中建议将表达式作为第一个参数的自由函数：</p>                <figure id="18989871" width="596" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.3/free_func_completion.png" width="596" data-gif-src="/help/img/dotnet/2019.3/free_func_completion.animated.gif" style="width:596px"></figure>                        <p id="c35bccf4">如果您不希望完成建议中包含免费功能，则可以清除相应的复选框<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">代码编辑| C ++ |的代码完成</span>页<a name="product_settings"></a> ReSharper选项（ <kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt+R,,O</span></kbd> ）。</p>        </div>        <div class="chapter"><h3 id="code-completion-in-dependent-code">相关代码中的代码完成</h3>            <p id="cf267aa7">ReSharper自动使用默认模板参数在相关代码中提供完成建议。在模板主体中键入内容时，如果没有参数的类型信息，则代码补全可能不可用。但是，对于具有默认参数的模板参数，ReSharper将基于这些默认参数提供完成建议。</p>            <figure><img alt="ReSharper C ++：相关代码中的代码完成" title="ReSharper C ++：相关代码中的代码完成" src="/help/img/dotnet/2019.3/cpp_templates_completion.png" id="6a86c4f8" width="504" height="158"></figure>        </div>    </div>    <div class="chapter"><h2 id="syntaxHighlighting" data-toc="Coding_Assistance_in_CPP#syntaxHighlighting">语法高亮和工具提示</h2>        <p id="2e20045a">默认情况下，ReSharper提供可配置颜色的C ++语法扩展突出显示。如有必要，可以在“ <span class="menupath" data-skip-index="skip">代码编辑” |“</span>禁用”中将其禁用<span class="menupath" data-skip-index="skip">。 C ++ |</span> ReSharper选项的“ <span class="menupath" data-skip-index="skip">检查”</span>页面。 <a name="syntax_highlighting_options"></a>                您可以突出显示20种标识符类型。您可以随时在Visual Studio选项（ <span class="menupath" data-skip-index="skip">工具|选项|环境|字体和颜色</span> ）中更改颜色和字体。</p>        <figure><img alt="为C ++标识符配置语法突出显示" title="为C ++标识符配置语法突出显示" src="/help/img/dotnet/2019.3/cpp_syntax_highlighting.png" id="daf8277c" width="757" height="441"></figure>        <p id="0ce74d1f">ReSharper还用自己的工具提示替换了代码元素的Visual Studio工具提示，这些工具提示突出显示了语法，显示方法和字段签名，格式化的XML和Doxygen注释：</p>        <figure><img alt="ReSharper：C ++中的编辑器工具提示" title="ReSharper：C ++中的编辑器工具提示" src="/help/img/dotnet/2019.3/cpp_tooltip.png" id="bf074d90" width="536" height="151"></figure>        <p id="62571b55">如有必要，可以通过清除“ <span class="menupath" data-skip-index="skip">环境” |</span> “ <span class="menupath" data-skip-index="skip">环境”中</span>的“ <span class="control">替换C ++的Visual Studio工具提示”</span>复选框来禁用ReSharper工具提示<span class="menupath" data-skip-index="skip">。编辑器</span> ReSharper选项的“ <span class="menupath" data-skip-index="skip">Visual Studio功能”</span>页面。</p>    </div>    <div class="chapter"><h2 id="parameter-name-hints" data-toc="Coding_Assistance_in_CPP#parameter-name-hints">镶嵌提示</h2>        <p id="1f25ca09">参数名称提示为<a name="definition"></a>在方法调用的相应参数旁边显示参数名称的编辑器装饰。它们可以帮助您在函数调用和聚合初始化的长（有时是嵌套）参数列表中找到所需的方法。<br>在下面的示例中，参数名称提示有助于发现height和width参数混合的事实：</p>        <figure><img alt="ReSharper C ++：参数和名称空间名称提示" title="ReSharper C ++：参数和名称空间名称提示" src="/help/img/dotnet/2019.3/cpp_name_hints.png" id="749cc9fe" width="420" height="85"></figure>        <p id="aac4887b">如果您不遵循<a href="http://llvm.org/docs/CodingStandards.html#namespace-indentation" rel="noopener noreferrer" data-external="true" target="_blank">LLVM</a>或<a href="https://google.github.io/styleguide/cppguide.html#Namespaces" rel="noopener noreferrer" data-external="true" target="_blank">Google</a>准则，则在名称空间定义末尾的名称空间名称提示可能会有所帮助，后者建议在名称空间结束括号后的注释中添加名称空间。</p>        <aside class="prompt" rel="aac4887b" id="d8953336" data-type="tip" data-title="">            <p id="3d0092f0">你可以按<kbd data-rs="Alt+Enter" data-vs="Alt+Enter">Alt+Enter</kbd>在名称空间定义的末尾，并使用<a href="Clang_Tidy_Integration.html#clang-tidy-fixes">Clang-Tidy修复程序</a>生成结束的名称空间注释。</p>        </aside>        <p id="preprocessor_directive_hints">预处理程序指令提示可帮助您快速了解条件包含（ <code class="code">#ifdef</code> ， <code class="code">#ifndef</code> ， <code class="code">#if</code> ， <code class="code">#endif</code> ， <code class="code">#else</code>和<code class="code">#elif</code> ）对应于宏定义：</p><figure><img alt="ReSharper：C ++中的预处理器指令提示" title="ReSharper：C ++中的预处理器指令提示" src="/help/img/dotnet/2019.3/preprocessor_directive_hints.png" id="72708786" width="300" height="108"></figure>        <p></p>        <p id="name_hints_aggregate_declarations">类型名称提示将有助于弄清C ++ 17和更高版本中复杂的聚合初始化：</p><figure><img alt="ReSharper C ++：聚合初始化中的参数和名称空间名称提示" title="ReSharper C ++：聚合初始化中的参数和名称空间名称提示" src="/help/img/dotnet/2019.3/cpp_name_hints_aggregate.png" id="62f3cdf0" width="503" height="270"></figure>        <p></p>        <p id="hints_non_const_reference">非常量引用传递的函数参数有参考提示：</p><figure><img alt="ReSharper：非常量引用传递的函数参数的引用提示" title="ReSharper：非常量引用传递的函数参数的引用提示" src="/help/img/dotnet/2019.3/hints_for_references.png" id="1ba77d9b" width="402" height="40"></figure>        <p></p>        <p id="904b31e9">有用于参数和名称空间名称提示的<a href="Inline_Parameter_Name_Hints.html#configuring-parameter-name-hints">精细配置选项</a> 。</p>    </div>    <div class="chapter"><h2 id="parameter-information" data-toc="Coding_Assistance_in_CPP#parameter-information">参数信息</h2>        <p id="intro">每当您编写或研究函数调用时，ReSharper都会帮助您查看有关函数所有重载的允许参数的详细信息。在工具提示中，您将看到所有公共签名，包括带有参数的简短签名以及从函数文档中获得的简短说明（如果有）。</p>        <p id="using">在您输入参数时，ReSharper会自动突出显示与输入的参数兼容的下一个签名，并将不适用的签名显示为灰色。要研究现有函数调用的替代签名，请将插入号设置在函数括号内，然后按<kbd data-rs="Ctrl+P" data-vs="Ctrl+Shift+Space">Ctrl+P</kbd>或选择<span class="menupath" data-skip-index="skip">ReSharper |编辑</span>从主菜单中获取<span class="menupath" data-skip-index="skip">参数信息</span> 。</p>        <figure><img alt="ReSharper C ++：参数信息" title="ReSharper C ++：参数信息" src="/help/img/dotnet/2019.3/cpp_parameter_info.png" id="b228010a" width="565" height="208"></figure>        <p id="80fcb649">参数信息工具提示还提供有关执行聚合初始化时聚合类成员的详细信息，显示有关用户定义的二进制运算符，已删除函数和隐式生成的函数的信息。<br>在从属代码上，它从文档注释中获取模板参数的模板参数描述，并使用默认模板参数来提供有关从属代码中参数的信息。</p>        <figure><img alt="ReSharper C ++：具有相关代码的参数信息" title="ReSharper C ++：具有相关代码的参数信息" src="/help/img/dotnet/2019.3/cpp_parameter_info_dependent_code.png" id="fd9f2c13" width="263" height="121"></figure>        <p id="fa67a5fa">参数信息工具提示可在“ <span class="menupath" data-skip-index="skip">环境” |“</span>配置”中配置。 <span class="menupath" data-skip-index="skip">智能感知</span> ReSharper选项的“ <span class="menupath" data-skip-index="skip">参数信息”</span>页面。</p>    </div>    <div class="chapter"><h2 id="contextActions" data-toc="Coding_Assistance_in_CPP#contextActions">上下文动作</h2>        <a name="ca_samples"></a>        <p id="d279712c">ReSharper提供了一组针对C ++代码的<a href="Coding_Assistance__Context_Actions.html">上下文操作</a> 。您可以在“ <a href="Reference__Options__Languages__CPP__Context_Actions.html">代码编辑”中</a>找到这些动作的完整列表。 <a href="Reference__Options__Languages__CPP__Context_Actions.html">C ++ |</a> ReSharper选项的<a href="Reference__Options__Languages__CPP__Context_Actions.html">上下文操作</a>页面。如有必要，您还可以使用此页面禁用某些操作。</p>        <p id="8eb7a628">一旦上下文动作可用于当前插入符号位置，ReSharper就会显示相应的<a href="Actions_List.html#indicators">动作指示符</a> <img alt="ThemedIcon ContextAction屏幕灰色" title="ThemedIcon ContextAction屏幕灰色" src="/help/img/dotnet/2019.3/ThemedIcon.ContextAction.Screen.[Gray].png" id="399310a3" width="16" height="16" class="inline-icon-16">在插入符号的左侧。但是，有时ReSharper为当前的插入位置提供了一些上下文相关的功能。在这种情况下，将显示与优先级最高的动作对应的动作指示器，并且仅当您通过单击动作指示器或按来展开<a href="Actions_List.html#action_list">动作列表</a>时，所有其他动作才会出现<kbd data-rs="Alt+Enter" data-vs="Alt+Enter">Alt+Enter</kbd>上下文操作的优先级最低，因此，它们通常出现在操作列表的底部。</p>        <p id="6b404817">以下是C ++上下文操作的一些示例：</p>            <div class="chapter"><h3 id="enum-to-string">将枚举转换为字符串（生成枚举到字符串助手）</h3>            <p id="25ff0c2c">此上下文操作为特定的枚举生成一个辅助函数，该函数将其枚举数转换为相应的字符串。</p>            <p id="551ea2d1">例如，如果您对以下枚举调用此操作：</p>            <div class="code-block" data-lang="cpp">枚举类西装{钻石，红心，棍棒，黑桃}；</div>            <p id="985f9d84">ReSharper将为您生成以下功能：</p>            <div class="code-block" data-lang="cpp">const char * to_string（Suit e）{switch（e）{case Suit :: Diamonds：返回“ Diamonds”; case Suit :: Hearts：返回“心”； case Suit :: Clubs：返回“俱乐部”； case Suit :: Spades：返回“ Spades”;默认值：返回“未知”； }}</div>            <p id="bd3557fe">如有必要，您可以通过<a href="Templates__Creating_and_Editing_Templates__Editing_a_Template.html">编辑</a> ReSharper用于生成的<a href="Reference__Templates_Explorer__Live_Templates_CPP.html#Live_enum_to_string_CPP">enum_to_string</a>活动模板来自定义生成的函数。例如，您可以配置模板以生成流输出运算符重载：</p>            <div class="code-block" data-lang="cpp">std :: ostream＆运算符<<（std :: ostream＆out，Suit e）{开关（e）{case Suit :: Diamonds：返回<< <<“ Diamonds ;; case Suit :: Hearts：返回<<“ Hearts”; case Suit :: Clubs：返回<<“ Clubs”; case Suit :: Spades：返回<<“ Spades”;默认值：assert（false）;返回<<“未知”； }}</div>        </div>        <div class="chapter"><h3 id="generate_case_stubs">生成缺少的案例陈述</h3>            <p id="c8c1d575">您可以使用上下文操作来生成所有缺少的case语句，而不必在切换枚举时手动编写所有case语句：</p><figure><img alt="在C ++中生成缺少的case语句" title="在C ++中生成缺少的case语句" src="/help/img/dotnet/2019.3/cpp_generate_missing_case_1.png" id="fcf99053" width="268" height="247"></figure>然后，您要做的就是为每个语句编写所需的逻辑。<figure><img alt="在C ++中生成缺少的case语句" title="在C ++中生成缺少的case语句" src="/help/img/dotnet/2019.3/cpp_generate_missing_case_2.png" id="4b1d8517" width="224" height="245"></figure>            <p></p>        </div>        <div class="chapter"><h3 id="merge_nested_ifs">合并嵌套的“ if”语句</h3>            <p id="9d9065b0">ReSharper帮助您将嵌套的“ if”语句与上下文操作合并：</p><figure><img alt="在C ++中合并嵌套的'if'语句" title="在C ++中合并嵌套的'if'语句" src="/help/img/dotnet/2019.3/cpp_merge_nested_ifs.png" id="5b867ad7" width="279" height="81"></figure>            <p></p>        </div>        <div class="chapter"><h3 id="generate_implementation">生成实施</h3>            <p id="c0464ce9">ReSharper可帮助您自动创建函数或方法的存根实现。您始终可以生成一个内联实现，并且，如果函数是在头文件中定义的，并且有相应的源文件，则可以在源文件中生成该实现。</p>            <aside class="prompt" rel="c0464ce9" id="7cdfbf96" data-type="tip" data-title="">                <p id="5381736d">您可以使用<a href="Code_Analysis_in_CPP.html#create_declaration">quick-fix快速</a>为现有方法实现创建声明。</p>            </aside>            <figure><img alt="生成函数的实现" title="生成函数的实现" src="/help/img/dotnet/2019.3/cpp_generate_implementation.png" id="b8ac5419" width="349" height="137"></figure>        </div>        <div class="chapter"><h3 id="move_implementation">将实现移出类范围</h3>            <p id="4a567b33">ReSharper可以帮助您将函数或方法的实现从标头移动到相应的源文件（如果存在）。应用此上下文操作后，将定义保留在其原始位置，并将实现移至源文件。编辑器上下文也将切换到源文件。</p>            <figure><img alt="将实现从类范围移到源文件" title="将实现从类范围移到源文件" src="/help/img/dotnet/2019.3/cpp_move_implementation.png" id="ffca5c04" width="280" height="97"></figure>            <p id="3d9e5c64">您还可以使用上下文操作来移动当前选择中的所有实现。</p>        </div>        <div class="chapter"><h3 id="ca_document">文件实体</h3>            <p id="7226f7ac">通过此上下文操作，您可以生成C ++符号的文档注释。如有必要，您可以通过<a href="Templates__Creating_and_Editing_Templates__Editing_a_Template.html">编辑</a> ReSharper用于生成的<a href="Reference__Templates_Explorer__Live_Templates_CPP.html#Live_doc_CPP">doc</a>实时模板来自定义注释存根。</p>            <figure id="ced768ef" width="504" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.3/cpp_doc.png" width="504" data-gif-src="/help/img/dotnet/2019.3/cpp_doc.animated.gif" style="width:504px"></figure>        </div>    </div>    <div class="chapter"><h2 id="pairedItems" data-toc="Coding_Assistance_in_CPP#pairedItems">突出显示配对项目</h2>        <p id="eac15372">将尖号设置为一对时，ReSharper会突出显示各种匹配项：</p>        <ul class="list _ul"><li class="list__item" id="e75ced66"><p>                <a href="Coding_Assistance__Matching_Delimiters.html">匹配定界符</a> <a name="delimiters"></a> （ <code class="code">()</code> ， <code class="code">[]</code> ， <code class="code">{}</code>和<code class="code"><></code> ）</p></li><li class="list__item" id="46d4f0ff"><p>匹配宏，例如， <code class="code">BEGIN_NAMESPACE</code> / <code class="code">END_NAMESPACE</code>            </p></li><li class="list__item" id="807e5b49"><p>匹配格式说明符和参数<code class="code">printf</code>和<code class="code">boost::format</code>            </p></li></ul>    </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Code_Analysis_in_CPP.html">代码检查和快速修复</a> <a class="navigation-links__next" href="Code_Style_Assistance_in_CPP.html">代码样式帮助</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>