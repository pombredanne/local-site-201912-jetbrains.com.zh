<html lang="en-US" ><head><meta charset="UTF-8"><meta name="robots" content="noindex"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>代码检查：隐式捕获闭包-帮助|帮助锐化器</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="ImplicitlyCapturedClosure" data-breadcrumbs="ImplicitlyCapturedClosure.xml|Code Inspection: Implicitly captured closure" data-main-title="Code Inspection: Implicitly captured closure" data-article-props="
                {
                
            " seeals=":[=" titl=":=" concept=",=" link=":=" ur=":" finding_code_issues.htm="," tex=":" find="" issues="" with="" inspectio="}=" code_analysis__code_inspections.htm="," code="" inspection="}=" design_time_inspection.htm="," detect="" in="" design="" tim="}=" ="" data-disqus-id="ImplicitlyCapturedClosure_10"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.3帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="ImplicitlyCapturedClosure.xml" data-toc="ImplicitlyCapturedClosure">代码检查：隐式捕获闭包</h1>    <a name="tip_disable"></a>        <aside class="prompt" rel="ImplicitlyCapturedClosure.xml" id="8916f93b" data-type="tip" data-title="">            <p id="38b6bbe2">您可以<a href="Code_Analysis__Configuring_Warnings.html#suppress">禁止执行此检查以忽略特定问题</a> ， <a href="Code_Analysis__Configuring_Warnings.html#change_severity">更改其严重性级别以使问题更小或更明显</a> ，或者将<a href="Code_Analysis__Configuring_Warnings.html#disable">其完全禁用</a> 。</p>        </aside>        <p id="a7f62f7e">该检查使您注意以下事实：捕获的封闭值比明显可见的多，这对这些值的寿命有影响。</p>    <p id="87dd1dfd">考虑以下代码：</p>    <div class="code-block" data-lang="csharp">使用系统；公共类Class1 {private Action _someAction; public void Method（）{var obj1 = new object（）; var obj2 = new object（）; _someAction + =（）=> {控制台。WriteLine（obj1）;安慰。WriteLine（obj2）; }; //“隐式捕获的闭包：obj2” _someAction + =（）=> {控制台。WriteLine（obj1）; }; }}</div>    <p id="a1dd1233">在第一个闭包中，我们看到<code class="code">obj1</code>和<code class="code">obj2</code>被<span class="emphasis">明确</span>捕获；我们只要看一下代码就可以看到这一点。对于第二个闭合，我们可以看到<code class="code">obj1</code>被<span class="emphasis">明确</span>捕获，但是ReSharper警告我们<code class="code">obj2</code>被<span class="emphasis">隐式</span>捕获。</p>    <p id="069b6168">这是由于C＃编译器中的实现细节。在编译期间，将闭包重写为具有保存捕获的值的字段和表示闭包本身的方法的类。C＃编译器将为每个方法仅创建一个此类私有类，如果在一个方法中定义了多个闭包，则该类将包含多个方法（每个闭包一个），并且还将包括所有闭包中捕获的所有值。</p>    <p id="f6048f04">如果我们看一下编译器生成的代码，它看起来像这样（一些名称已被清理以方便阅读）：</p>    <div class="code-block" data-lang="csharp">公共类Class1 {[CompilerGenerated]私有密封类<> c__DisplayClass1_0 {公共对象obj1;公共对象obj2;内部无效<method>b__0（）{控制台。WriteLine（obj1）;安慰。WriteLine（obj2）; } internal void <method>b__1（）{控制台。WriteLine（obj1）; }}私有动作_someAction; public void Method（）{//创建显示类-两个闭包都只有一个类var dc = new Class1。<> c__DisplayClass1_0（）; //将闭合值捕获为显示类dc.obj1 = new object（）;上的字段dc.obj2 =新的object（）; //将显示类方法添加为闭包值_someAction + = new Action（ <method>dc。b__0）; _someAction + =新动作（ <method>dc。b__1）; }}</method></method></method></method></div>    <p id="6b5bfbfa">该方法运行时，它将创建显示类，该类捕获所有闭包的所有值。因此，即使其中一个闭包中未使用值，它也将被捕获。这是ReSharper突出显示的“隐式”捕获。</p>    <p id="8ec35e6c">这种检查的含义是， <span class="emphasis">直到关闭本身就是垃圾收集，才会</span>隐式捕获封闭值。现在，此值的生存期与未明确使用该值的闭包的生存期相关。如果闭包的寿命很长，那么这可能会对您的代码产生负面影响，尤其是当捕获的值很大时。</p>    <p id="79cae224">请注意，尽管这是编译器的实现细节，但在各个版本和实现（例如Microsoft（在Roslyn之前和之后）或Mono的编译器）之间是一致的。为了正确处理捕获值类型的多个闭包，实现必须按所述方式工作。例如，如果多个闭包捕获了一个<code class="code">int</code> ，那么它们必须捕获相同的实例，这只能在单个共享的私有嵌套类中发生。这样做的副作用是，所有捕获的值的生存期现在是捕获任何值的任何闭包的最大生存期。</p>    <a name="seealso_inspection_default"></a>            <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月28日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="RedundantArgumentDefaultValue.html">代码检查：带有默认值的冗余参数</a> <a class="navigation-links__next" href="ArrangeVarKeywordsInDecontructingDeclaration.html">代码检查：在解构声明中联接或分隔“ var”</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>