<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><meta content="noindex" name="robots"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Code Inspection: Implicitly captured closure - Help | ReSharper</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="ImplicitlyCapturedClosure" data-breadcrumbs="ImplicitlyCapturedClosure.xml|Code Inspection: Implicitly captured closure" data-main-title="Code Inspection: Implicitly captured closure" data-article-props="&#xA;                {&#xA;                &#xA;            &#34;seeAlso&#34;:[&#xA;            &#xA;                {&#34;title&#34;: &#34;Concepts&#34;,&#xA;                 &#34;links&#34;: [&#xA;                &#xA;        {&#34;url&#34;:&#34;Finding_Code_Issues.html&#34;,&#34;text&#34;:&#34;Find Code Issues with Code Inspection&#34;}&#xA;    ,&#xA;        {&#34;url&#34;:&#34;Code_Analysis__Code_Inspections.html&#34;,&#34;text&#34;:&#34;Code Inspections&#34;}&#xA;    ,&#xA;        {&#34;url&#34;:&#34;Design_time_Inspection.html&#34;,&#34;text&#34;:&#34;Detect Code Issues in Design Time&#34;}&#xA;    &#xA;                    ]}&#xA;            ]&#xA;        &#xA;                }&#xA;            " data-disqus-id="ImplicitlyCapturedClosure_10"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="ImplicitlyCapturedClosure" id="ImplicitlyCapturedClosure.xml">Code Inspection: Implicitly captured closure</h1>    <a name="tip_disable"></a>        <aside data-type="tip" class="prompt" data-title="" rel="ImplicitlyCapturedClosure.xml" id="8916f93b">            <p id="38b6bbe2">                You can                <a href="Code_Analysis__Configuring_Warnings.html#suppress">                    suppress this inspection to ignore specific issues</a>,                <a href="Code_Analysis__Configuring_Warnings.html#change_severity">                    change its severity level to make the issues less or more noticeable</a>, or                <a href="Code_Analysis__Configuring_Warnings.html#disable">disable it altogether</a>.            </p>        </aside>        <p id="a7f62f7e">        This inspection draws your attention to the fact that more closure values are being captured        than is obviously visibly, which has an impact on the lifetime of these values.    </p>    <p id="87dd1dfd">Consider the following code:</p>    <div class="code-block" data-lang="csharp">

using System;
public class Class1 {
    private Action _someAction;

    public void Method() {
        var obj1 = new object();
        var obj2 = new object();

        _someAction += () =&gt; {
            Console.WriteLine(obj1);
            Console.WriteLine(obj2);
        };

        // "Implicitly captured closure: obj2"
        _someAction += () =&gt; {
            Console.WriteLine(obj1);
        };
    }
}

    </div>    <p id="a1dd1233">        In the first closure, we see that both        <code class="code">obj1</code> and        <code class="code">obj2</code> are being        <span class="emphasis">explicitly</span>        captured; we can see this just by looking at the code.        For the second closure, we can see that        <code class="code">obj1</code> is being        <span class="emphasis">explicitly</span>        captured, but ReSharper is warning us that        <code class="code">obj2</code> is being        <span class="emphasis">implicitly</span>        captured.    </p>    <p id="069b6168">        This is due to an implementation detail in the C# compiler. During compilation, closures are rewritten into        classes with fields that hold the captured values, and methods that represent the closure itself. The C#        compiler will only create one such private class per method, and if more than one closure is defined in a        method, then this class will contain multiple methods, one for each closure, and it will also include all        captured values from all closures.    </p>    <p id="f6048f04">        If we look at the code that the compiler generates,        it looks a little like this (some names have been cleaned up to ease reading):    </p>    <div class="code-block" data-lang="csharp">

public class Class1
{
    [CompilerGenerated]
    private sealed class &lt;&gt;c__DisplayClass1_0
    {
        public object obj1;
        public object obj2;

        internal void &lt;Method&gt;b__0()
        {
            Console.WriteLine(obj1);
            Console.WriteLine(obj2);
        }

        internal void &lt;Method&gt;b__1()
        {
            Console.WriteLine(obj1);
        }
    }

    private Action _someAction;

    public void Method()
    {
        // Create the display class - just one class for both closures
        var dc = new Class1.&lt;&gt;c__DisplayClass1_0();

        // Capture the closure values as fields on the display class
        dc.obj1 = new object();
        dc.obj2 = new object();

        // Add the display class methods as closure values
        _someAction += new Action(dc.&lt;Method&gt;b__0);
        _someAction += new Action(dc.&lt;Method&gt;b__1);
    }
}

    </div>    <p id="6b5bfbfa">        When the method runs, it creates the display class, which captures all values, for all closures. So even if a        value isn't used in one of the closures, it will still be captured. This is the "implicit" capture that        ReSharper is highlighting.    </p>    <p id="8ec35e6c">        The implication of this inspection is that the implicitly captured closure value        <span class="emphasis">will not be garbage collected until the closure itself is garbage collected</span>.        The lifetime of this value is now tied to the lifetime of a        closure that does not explicitly use the value.        If the closure is long lived, this might have a negative effect        on your code, especially if the captured value is very large.    </p>    <p id="79cae224">        Note that while this is an implementation detail of the compiler, it is consistent across versions and        implementations such as Microsoft (pre and post Roslyn) or Mono's compiler.        The implementation must work as        described in order to correctly handle multiple closures capturing a value type.        For example, if multiple closures capture an        <code class="code">int</code>, then they must capture the same instance, which can only happen with a single shared        private nested class.        The side effect of this is that the lifetime of all captured values is now the maximum        lifetime of any closure that captures any of the values.    </p>    <a name="seealso_inspection_default"></a>            <div class="last-modified" data-skip-index="skip">Last modified: 28 November 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="RedundantArgumentDefaultValue.html">Code Inspection: Redundant argument with default value</a><a class="navigation-links__next" href="ArrangeVarKeywordsInDecontructingDeclaration.html">Code Inspection: Join or separate 'var' in deconstruction declarations</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>