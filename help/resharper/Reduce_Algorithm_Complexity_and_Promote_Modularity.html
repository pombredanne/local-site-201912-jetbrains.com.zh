<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>降低算法复杂度并提高模块化-帮助|帮助锐化器</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body type=""  data-id="Reduce_Algorithm_Complexity_and_Promote_Modularity" data-article-props="
                {
                
            " seeals=":[=" titl=":=" concept=",=" link=":=" ur=":" refactor_this.htm="," tex=":" refactor="" thi="}=" refactorings__index.htm="," refactoring="}=" refactorings__move__type_to_another_type.htm="," move="" to="" another="" refactorin="}=" refactorings__extract_method.htm="," extract="" method="" ="url"="refactorings__extract_superclass.html" ="text"="extract=" code_analysis__quick-fixes.htm="," quick-fixes="" for="" issue="}=" coding_assistance__context_actions.htm="," context="" action="}=" ="" data-disqus-id="Reduce_Algorithm_Complexity_and_Promote_Modularity_10"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Reduce_Algorithm_Complexity_and_Promote_Modularity.xml" data-toc="Reduce_Algorithm_Complexity_and_Promote_Modularity">降低算法复杂度并提高模块化</h1>    <p id="7d38f9bd">几乎每个开发人员都发现自己处在一种复杂的算法中，即它实际上是一个单一的，几乎不可读的方法，并与类中的其他方法纠缠在一起。例如，假设您有一个用于求解方程式的通用类：</p>    <div class="code-block" data-lang="csharp">公共类EquationSolvers {公共静态元组<double, double="">二次方（double a，double b，double c）{double disc = b * b-4 * a * c;如果（disc <0）抛出新的ArgumentException（“无法求解具有复数根的方程式”）；双sqrt =数学。Sqrt（光盘）;返回新的元组<double, double="">（（-b + sqrt）/（2 * a），（-b-sqrt）/（2 * a））; } //其他求解器在这里}</double,></double,></div>    <p id="bc63f46c">上面的方程式求解器是硬编码的，这意味着要替换其他求解器，您将必须手动替换每个实例。让我们从将其带入一个单独的类开始。为此，我们使用“ <a href="Refactorings__Move__Type_to_Another_Type.html">移至另一种类型”重构</a> <kbd data-rs="F6" data-vs="Ctrl+R,O">F6</kbd> ：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity1.png" id="3b6818bd" width="592" height="317"></figure>    <p id="600e7f15">然后，我们需要指定将方法移至的类。为了更好地分离关注点，我们选择了一个单独的类，称为<code class="code">QuadraticEquationSolver</code>为了这：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity2.png" id="6a26c659" width="655" height="346"></figure>    <p id="6d203663">现在已经移动了方法，让我们尝试将判别式导出到单独的计算中。这很容易-我们选择判别式计算并调用<a href="Refactorings__Extract_Method.html">Extract Method重构</a> <kbd data-rs="Ctrl+Alt+M" data-vs="Ctrl+R,M">Ctrl+Alt+M</kbd> ：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity3.png" id="6b0d6450" width="598" height="230"></figure>    <p id="f8762f7e">现在，我们要做的就是为新方法命名：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity4.png" id="9caf10fb" width="672" height="592"></figure>    <p id="341aec66">完成：</p><div class="code-block" data-lang="csharp">私人静态double CalculateDiscriminant（double a，double b，double c）{return b * b-4 * a * c; }</div>    <p id="2d3364b4">现在，让我们假设，过一会儿，我们找到了一个更安全的二次方程式求解器。要将其纳入程序，我们首先需要创建一个抽象基类<code class="code">QuadraticEquationSolverBase</code> 。我们使用“ <span class="control">重构”</span>菜单中可用的“ <a href="Refactorings__Extract_Superclass.html">提取超类”重构。</a> <kbd data-rs="Ctrl+Shift+R" data-vs="Ctrl+Shift+R">Ctrl+Shift+R</kbd> ：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity5.png" id="d95b40cd" width="591" height="308"></figure>    <p id="9928a8df">在出现的对话框中，我们选择要向上升级的成员。我们只想要<code class="code">CalculateDiscriminant</code>方法：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity6.png" id="bd226577" width="655" height="399"></figure>    <p id="4510bc0c">我们添加了对<code class="code">Calculate()</code>方法（以前称为<code class="code">Quadratic()</code> ），并得到以下基类：</p><div class="code-block" data-lang="csharp">公共抽象类QuadraticEquationSolverBase { }公共抽象元组<double, double="">Calculate（double a，double b，double c）; }</double,></div>    <p id="d66960dd">我们也摆脱了<code class="code">static</code>假设在以下位置实现<code class="code">QuadraticEquationSolverBase</code>将由我们的代码中的终身经理处理。因此，ReSharper提醒我们添加<code class="code">override</code>重命名的关键字<code class="code">Calculate</code>我们的QuadraticEquationSolver类中的方法：</p>    <figure><img alt="ReSharper的模块化" title="ReSharper的模块化" src="/help/img/dotnet/2019.2/cookbook_modularity7.png" id="41ed7588" width="622" height="161"></figure>    <p id="dccef267">现在，假设我们找到了一个更安全的二次方程式求解器。让我们实现它。首先，我们在基类上使用<span class="control">创建派生类型</span> <a href="Coding_Assistance__Context_Actions.html">上下文操作</a> ：</p>    <p id="5d2032ff">然后，我们被要求以这种类型实现成员，我们这样做：</p>    <p id="86beef22">最后，我们利用基类提供了一个实现<code class="code">CalculateDiscriminant()</code>方法：</p><div class="code-block" data-lang="csharp">class SafeQuadraticEquationSolver：QuadraticEquationSolverBase {公共替代元组<double, double="">Calculate（double a，double b，double c）{double disc = CalculateDiscriminminant（a，b，c）;如果（disc <0）抛出新的ArgumentException（“无法求解具有复数根的方程式”）；双q = -0.5 *（b +数学签名（b）*光盘）;返回新的元组<double, double="">（q / a，c / q）; }}</double,></double,></div>    <p id="d2c7740f">我们完成了！现在，二次方程求解器可以轻松使用，其配置和实例化通常由IoC容器处理。</p>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月18日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Quickly_introduce_using_statements_and_try_catch_blocks.html">快速介绍using语句并尝试... catch块</a> <a class="navigation-links__next" href="Reorder_code_without_the_copypaste_fuss.html">重新排序代码，而无需复制粘贴</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>