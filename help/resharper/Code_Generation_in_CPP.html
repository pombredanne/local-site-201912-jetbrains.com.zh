<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>C ++中的代码生成-帮助|帮助锐化器</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Code_Generation_in_CPP" data-article-props="
                {
                
            " seeals=":[=" titl=":=" procedure=",=" link=":=" ur=":" code_analysis__examples_of_quick-fixes.htm="," tex=":" examples="" of="" quick-fixe="}=" code_generation__generating_code_from_usage.htm="," generate="" from="" usag="}=" ="" data-disqus-id="Code_Generation_in_CPP_10"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Code_Generation_in_CPP.xml" data-toc="Code_Generation_in_CPP">C ++中的代码生成</h1>    <a name="cpp_support_note"></a>        <aside class="prompt" rel="Code_Generation_in_CPP.xml" id="f13cbb1e" data-type="note" data-title="">            <p id="22d8dfb8">                <a name="cpp_products"></a> <a href="/resharper-cpp/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper C ++</a>提供了C ++支持， <a href="/resharper-cpp/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper C ++</a>是一种专用产品，可以单独安装，也可以与ReSharper或<a href="/dotnet/" rel="noopener noreferrer" data-external="true" target="_blank">ReSharper Ultimate</a>并排安装。</p>        </aside>        <p id="intro">ReSharper提供了多种生成样板代码的方法。例如，您可以使用未声明的代码符号，并根据用途自动生成这些符号，生成类型成员等。</p>    <p id="c33ed3d6">当前类型的成员生成选项可用于<kbd data-rs="Alt+Insert" data-vs="Alt+Insert">Alt+Insert</kbd> （ <span class="menupath" data-skip-index="skip">ReSharper |编辑|生成代码</span> ）。这些以及许多其他代码生成动作也可以作为<a href="Coding_Assistance_in_CPP.html#contextActions">上下文动作</a>使用<kbd data-rs="Alt+Enter" data-vs="Alt+Enter">Alt+Enter</kbd> 。</p>    <a name="tip_generation_settings"></a>        <aside class="prompt" rel="Code_Generation_in_CPP.xml" id="5ac5b256" data-type="tip" data-title="">            <p id="ff7bd990">                <a name="generated_settings_raw"></a>根据您的设置，可以用不同的方式生成新成员的存根。例如，他们可以抛出新的<code class="code">NotImplementedException()</code> ，返回默认值或包含将无法编译的代码。您可以在以下位置配置这些首选项和其他首选项<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">代码编辑|的会员生成</span>页面<a name="product_settings"></a> ReSharper选项（ <kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Alt+R,,O</span></kbd> ）。</p>        </aside>        <div class="chapter"><h2 id="createFromUsage" data-toc="Code_Generation_in_CPP#createFromUsage">根据用法生成代码</h2>        <p id="intro">ReSharper允许您在声明代码符号（方法，变量，字段等）之前使用它们。当ReSharper检测到未声明的符号时，它会建议一个或多个<a href="Code_Analysis__Quick-Fixes.html">快速修复</a> <kbd data-rs="Alt+Enter" data-vs="Alt+Enter">Alt+Enter</kbd>用于根据用法生成声明，然后根据用法上下文巧妙地调整声明：</p>        <figure><img alt="从用法生成C ++字段" title="从用法生成C ++字段" src="/help/img/dotnet/2019.2/cpp_generate_from_usage.png" id="d99d004d" width="254" height="184"></figure>    </div>    <div class="chapter"><h2 id="constructors" data-toc="Code_Generation_in_CPP#constructors">生成构造函数</h2>        <a name="intro"></a>        <p id="85338dc2">构造函数生成向导将创建一个非默认构造函数，该构造函数将使用选定字段的参数。</p>        <p id="915d255d">所有生成的构造函数都遵循相同的模式，其中：</p>        <ul class="list _ul"><li class="list__item" id="6ba63255"><p>构造函数中包含的每个字段都用一个参数初始化。</p></li><li class="list__item" id="cbd80bfe"><p>参数的名称是从相应字段的名称派生的。</p></li></ul>            <figure><img alt="生成C ++类的构造函数" title="生成C ++类的构造函数" src="/help/img/dotnet/2019.2/cpp_generate_constructor.png" id="8c586d21" width="623" height="421"></figure>    </div>    <div class="chapter"><h2 id="missing_members" data-toc="Code_Generation_in_CPP#missing_members">生成缺少的成员</h2>        <p id="003e246a">此生成操作将为基本抽象类中定义的纯虚函数创建替代。</p>        <figure><img alt="为C ++类生成缺少的成员" title="为C ++类生成缺少的成员" src="/help/img/dotnet/2019.2/cpp_missing_members.png" id="ef2844a2" width="618" height="414"></figure>    </div>    <div class="chapter"><h2 id="overriding" data-toc="Code_Generation_in_CPP#overriding">生成替代成员</h2>        <p id="9b79c845">此生成操作将在派生类中创建虚拟函数的替代：</p>        <figure><img alt="为C ++类生成重写成员" title="为C ++类生成重写成员" src="/help/img/dotnet/2019.2/cpp_generate_overrides.png" id="e1cc7ae4" width="632" height="410"></figure>        <p id="6b38a31c">在“ <span class="control">替代成员”</span>对话框中，您将能够选择所需的功能，并为生成的替代配置以下首选项：</p>        <ul class="list _ul"><li class="list__item" id="1de07e9c"><p>                <span class="control">插入“覆盖”说明符</span> -如果要生成一个在基类中隐藏相应功能的函数，则可以清除此复选框。</p></li><li class="list__item" id="f7594472"><p>                <span class="control">插入“虚拟”说明符</span>可让您将生成的方法设为虚拟。</p></li></ul>    </div>    <div class="chapter"><h2 id="implementations" data-toc="Code_Generation_in_CPP#implementations">产生定义</h2>        <p id="73e410af">通过此生成操作，您可以快速为类中声明但没有定义的所有成员函数创建定义存根。</p>    </div>    <div class="chapter"><h2 id="copy_move" data-toc="Code_Generation_in_CPP#copy_move">复制和移动操作</h2>        <p id="87666bd7">此生成操作将创建副本构造函数，并<code class="code">operator=</code>定义如何复制和移动当前类对象的函数。</p>        <figure><img alt="为C ++类生成复制和移动动作" title="为C ++类生成复制和移动动作" src="/help/img/dotnet/2019.2/cpp_generate_copy_move.png" id="8df99f57" width="569" height="421"></figure>        <p id="879eeade">在“ <span class="control">生成复制和移动操作”</span>对话框中，您将能够选择在复制或移动类对象时应考虑哪些基类和类成员，并为生成的函数配置以下首选项：</p>        <ul class="list _ul"><li class="list__item" id="access"><p>                <span class="control">访问权限</span>允许您选择<code class="code">public</code> ， <code class="code">protected</code>要么<code class="code">private</code>访问修饰符。</p></li><li class="list__item" id="b87a13b1"><p>                <span class="control">复制/移动操作</span> -这些选择器使您可以选择如何创建操作。默认情况下，将生成操作的实现。但是，您可以将它们生成为<a href="http://en.wikipedia.org/wiki/C%2B%2B11#Explicitly_defaulted_and_deleted_special_member_functions" rel="noopener noreferrer" data-external="true" target="_blank">显式默认和删除的函数</a> ，仅生成声明，或跳过一个或另一个操作。</p></li><li class="list__item" id="3e276405"><p>                <span class="control">基于交换的分配</span> -选中此复选框以使用<code class="code">swap</code>在执行功能<code class="code">operator=</code> 。例如，</p><div class="code-block" data-lang="cpp">Rectangle＆operator =（Rectangle other）{using std :: swap; swap（* this，other）;返回* this; }</div>            <p></p></li></ul>    </div>    <div class="chapter"><h2 id="getters_setters" data-toc="Code_Generation_in_CPP#getters_setters">生成获取器和设置器</h2>        <p id="090cc6b8">使用ReSharper，您可以基于现有字段快速为类生成getter和setter函数：</p>        <figure><img alt="为C ++类生成getter和setter" title="为C ++类生成getter和setter" src="/help/img/dotnet/2019.2/cpp_generate_getters_setters.png" id="f5021992" width="628" height="457"></figure>        <p id="caf0664f">在“ <span class="control">生成getter和setter”</span>对话框中，您将能够选择所需的字段并为生成的函数配置以下首选项：</p>        <ul class="list _ul"><li class="list__item" id="access"><p>                <span class="control">访问权限</span>允许您选择<code class="code">public</code> ， <code class="code">protected</code>要么<code class="code">private</code>访问修饰符。</p></li><li class="list__item" id="99775aba"><p>                <span class="control">Kind</span>允许您选择是否应生成getter，setter或两者。</p></li><li class="list__item" id="7c310e2c"><p>                <span class="control">通过接受参数，</span>您可以选择如何将参数传递给生成的设置器：通过const引用还是通过值。</p></li><li class="list__item" id="7151b2e2"><p>                <span class="control">Return by</span>允许您选择所生成的getter应如何返回字段：按值，引用或const引用。</p></li><li class="list__item" id="7cc2ab62"><p>                <span class="control">虚拟</span>允许您将生成的函数虚拟化。</p></li></ul>    </div>    <div class="chapter"><h2 id="equality" data-toc="Code_Generation_in_CPP#equality">生成相等运算符</h2>        <p id="d89b4d8e">此代码生成命令可让您生成<code class="code">operator==</code>和<code class="code">operator==</code>这些函数将使用选定的字段来比较当前类的对象。</p>    </div>    <div class="chapter"><h2 id="relational" data-toc="Code_Generation_in_CPP#relational">生成关系运算符</h2>        <p id="3b2c73d4">此代码生成命令可帮助您生成<code class="code">operator<</code> ， <code class="code">operator></code> ， <code class="code">operator<=</code>和<code class="code">operator>=</code>这些函数将使用选定的字段来比较当前类的对象。</p>    </div>    <div class="chapter"><h2 id="stream_output" data-toc="Code_Generation_in_CPP#stream_output">生成流操作</h2>        <p id="5176454d">此代码生成命令使您可以生成插入运算符<code class="code">operator<<</code>它将使用选定的字段来定义如何为当前类的对象生成流输出。例如：</p>        <div class="code-block" data-lang="cpp">朋友std :: ostream＆运算符<<（std :: ostream＆os，const Rectangle＆obj）{return os <<“ width：” << obj.width <<“ height：” << obj.height; }</div>        <p id="a416d554">如有必要，可以使用<code class="code">wostream</code>代替<code class="code">ostream</code> 。为此， <span class="control">请</span>在“ <span class="control">生成流操作”</span>对话框中选择“ <span class="control">使用宽字符流</span> ”。</p>        <p id="c33c6134">生成流输出的另一个选项是为Boost序列化功能生成存根： <code class="code">save()</code>和<code class="code">load()</code>要么<code class="code">serialize()</code> 。为此，请在“ <span class="control">生成流操作”</span>对话框的“ <span class="control">操作类型”</span>选择器中选择所需的选项。</p>    </div>    <div class="chapter"><h2 id="hash" data-toc="Code_Generation_in_CPP#hash">生成哈希函数</h2>        <p id="1f363e61">此代码生成命令使您可以为类生成哈希函数。您可以选择以下两种哈希算法之一：</p>        <ul class="list _ul"><li class="list__item" id="98e967f4"><p>                <a href="http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html" rel="noopener noreferrer" data-external="true" target="_blank">boost :: hash_combine</a> ，例如：</p><div class="code-block" data-lang="cpp">#include <boost functional="" hash.hpp="">...朋友std :: size_t hash_value（const Rectangle＆obj）{std :: size_t seed = 0x315E4139; boost :: hash_combine（seed，obj.width）; boost :: hash_combine（seed，obj.height）;返回种子； }</boost></div>            <p></p></li><li class="list__item" id="57299e60"><p>                <a href="http://en.wikipedia.org/wiki/Xorshift" rel="noopener noreferrer" data-external="true" target="_blank">shift和xor</a> ，例如：</p><div class="code-block" data-lang="cpp">朋友std :: size_t hash_value（const Rectangle＆obj）{std :: size_t seed = 0x315E4139;种子^ =（种子<< 6）+（种子>> 2）+ 0x3449770D + static_cast <std::size_t>（obj.width）;种子^ =（种子<< 6）+（种子>> 2）+ 0x49751560 + static_cast <std::size_t>（obj.height）;返回种子； }</std::size_t></std::size_t></div>            <p></p></li></ul>    </div>    <div class="chapter"><h2 id="swap" data-toc="Code_Generation_in_CPP#swap">产生交换功能</h2>        <p id="b7c818b5">此代码生成命令可让您生成<code class="code">swap</code>该函数将使用选定的字段交换当前类的对象。例如：</p>        <div class="code-block" data-lang="cpp">朋友void swap（Rectangle＆lhs，Rectangle＆rhs）{使用std :: swap; swap（lhs.width，rhs.width）; swap（lhs.height，rhs.height）; }</div>    </div>        <div class="chapter"><h2 id="gmock" data-toc="Code_Generation_in_CPP#gmock">产生Google Mock方法</h2>        <p id="37821653">此代码生成操作自动创建模拟方法<code class="code">MOCK_METHODn()</code>和<code class="code">MOCK_CONST_METHODn()</code>使用<a href="https://github.com/google/googletest/tree/master/googlemock" rel="noopener noreferrer" data-external="true" target="_blank">Google Mock</a>框架创建模拟类时。<br>如果包含Google Mock头文件，则可用于派生类。</p>        <aside class="prompt" rel="37821653" id="5b997efb" data-type="tip" data-title="">            <p id="ea8b5e89">如果您使用<a href="https://code.google.com/p/googletest/" rel="noopener noreferrer" data-external="true" target="_blank">Google Test</a> Framework进行测试，则可以享受ReSharper的各种<a href="Unit_Testing_in_CPP.html">单元测试功能</a> 。</p>        </aside>        <p id="92fd41fc">在模拟类中，您不必手动编写要模拟的方法。相反，您可以调用“ <span class="control">生成GMock方法”</span>操作（也可以作为<a href="Coding_Assistance__Context_Actions.html">上下文操作</a>与<kbd data-rs="Alt+Enter" data-vs="Alt+Enter">Alt+Enter</kbd> ）。</p>        <figure><img alt="生成Google Mock方法" title="生成Google Mock方法" src="/help/img/dotnet/2019.2/generate_gmock.png" id="54933693" width="612" height="410"></figure>        <p id="0ec4c14f">默认情况下，所有基类方法均处于选中状态，如果您不想为其中的某些方法生成模拟方法，则可以清除相应的复选框。</p>        <p id="9028cb39">应用此操作后，将选定的模拟方法添加到模拟类中：</p>        <div class="code-block" data-lang="cpp">MockTurtle类：public Turtle {public：MOCK_METHOD1（Forward，void（int））; MOCK_METHOD1（Turn，void（int））; MOCK_CONST_METHOD0（GetX，int（））; MOCK_CONST_METHOD0（GetY，int（））; };</div>    </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月18日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Code_Templates_in_CPP.html">代码模板</a> <a class="navigation-links__next" href="Unit_Testing_in_CPP.html">单元测试协助</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>