<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>导航/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Features/Navigation.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Navigation">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2018-07-31T15:04:14+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Navigation">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Features/Navigation">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Features/GenerateMenu.html">生成菜单</a> <a class="navigation-links__next" href="/Features/OptionsPages.html">选项页</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Features/Navigation.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>导航</h1>
                    <p>ReSharper导航包含两个主要部分：</p>

<ul>
  <li>上下文导航（“从此处导航...”）</li>
  <li>全球导航（“转到...”）</li>
</ul>

<p>导航框架是相当可插入的，因此在大多数情况下，您要做的就是简单地提供自己的组件。您可以实现以下功能：</p>

<ul id="markdown-toc">
  <li><a href="#context-navigation" id="markdown-toc-context-navigation"><span>上下文导航</span></a></li>
  <li><a href="#feature-providers" id="markdown-toc-feature-providers"><span>功能提供者</span></a></li>
  <li><a href="#binding-to-an-action" id="markdown-toc-binding-to-an-action"><span>绑定动作</span></a></li>
  <li><a href="#example" id="markdown-toc-example"><span>例</span></a></li>
  <li><a href="#context-searches" id="markdown-toc-context-searches"><span>上下文搜索</span></a></li>
  <li><a href="#global-navigation-go-to-" id="markdown-toc-global-navigation-go-to-"><span>全球导航（“转到...”）</span></a></li>
  <li><a href="#occurrence-navigation-provider" id="markdown-toc-occurrence-navigation-provider"><span>出现导航提供者</span></a></li>
  <li><a href="#occurrence-presenter" id="markdown-toc-occurrence-presenter"><span>出现主持人</span></a></li>
  <li><a href="#occurrence-kind-provider" id="markdown-toc-occurrence-kind-provider"><span>出现种类提供者</span></a></li>
  <li><a href="#occurrence-section-provider" id="markdown-toc-occurrence-section-provider"><span>发生科提供者</span></a></li>
  <li><a href="#tree-model" id="markdown-toc-tree-model"><span>树模型</span></a></li>
  <li><a href="#occurrence" id="markdown-toc-occurrence"><span>发生</span></a></li>
</ul>

<a name="context-navigation" class="elem-anchor"></a>
<h2>上下文导航<a href="#context-navigation" class="anchor-link"><span></span></a></h2>

<p>上下文导航由两部分组成：搜索引擎和用户交互提供程序。这两个部分在ReSharper Framework中分为不同的实体。</p>

<a name="feature-providers" class="elem-anchor"></a>
<h2>功能提供者<a href="#feature-providers" class="anchor-link"><span></span></a></h2>

<p>功能提供者自己代表功能。也就是说，每个导航功能只有一个提供程序，而与该功能应使用的语言和环境数量无关。</p>

<p>每个上下文导航提供程序都实现<code class="code highlight language-text">IContextSearchProvider</code>或者<code class="code highlight language-text">INavigateFromHereProvider</code>接口。的<code class="code highlight language-text">IContextSearchProvider</code>接口定义如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IContextSearchProvider</span> <span class="p">{</span> <span class="p">[</span><span class="n">CanBeNull</span><span class="p">]</span> <span class="n">Action</span> <span class="nf">GetSearchesExecution</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">,</span> <span class="n">INavigationExecutionHost</span> <span class="n">host</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>该动作<code class="code highlight language-text">GetSearchesExecution()</code>方法返回实际上是导航功能的执行。当此方法返回时<code class="code highlight language-text">null</code> ，则表示此功能不适用于此数据上下文。的<code class="code highlight language-text">INavigationExecutionHost</code>是一个宿主对象，可用于执行某些UI活动，例如显示下拉框或高级搜索对话框。</p>

<p>的<code class="code highlight language-text">INavigateFromHere</code>界面非常类似于<code class="code highlight language-text">IContextSearchProvider</code> -它只有一种方法可返回导航执行和其他数据，以在“从此处导航”下拉菜单中显示。</p>

<p>如果您希望导航项显示在“从此处导航”菜单中，则必须实施<code class="code highlight language-text">INavigateFromHereProvider</code>接口。</p>

<a name="binding-to-an-action" class="elem-anchor"></a>
<h2>绑定动作<a href="#binding-to-an-action" class="anchor-link"><span></span></a></h2>

<p>您无需在动作处理程序的方法中编写任何代码，因为所有功能逻辑都需要在导航提供程序内部编写。将动作绑定到导航提供程序所需要做的只是从中派生自定义动作处理程序类<code class="code highlight language-text">ContextNavigationActionBase<TNavigateFromHereProvider></code> （如果您希望您的操作显示在“从此处导航”菜单中）或<code class="code highlight language-text">ContextSearchActionBase<TContextSearchProvider></code> 。</p>

<p>此外，您的提供者应饰以<code class="code highlight language-text">ContextNavigationProvider</code>属性。</p>

<aside class="note">
  <p>如果您希望功能仅显示在“从此处导航”菜单中，则无需编写动作-只需实施<code class="code highlight language-text">ContextNavigationProvider</code>实现<code class="code highlight language-text">INavigateFromHereProvider</code> 。</p>
</aside>

<p>如果您的导航并不复杂，那么您只需要了解上下文导航框架即可。</p>

<a name="example" class="elem-anchor"></a>
<h2>例<a href="#example" class="anchor-link"><span></span></a></h2>

<p>这是使用Windows资源管理器简单导航到相应文件夹的示例。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span> <span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span> <span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span> <span class="k">using</span> <span class="nn">JetBrains.Annotations</span><span class="p">;</span> <span class="k">using</span> <span class="nn">JetBrains.Application.DataContext</span><span class="p">;</span> <span class="k">using</span> <span class="nn">JetBrains.ProjectModel</span><span class="p">;</span> <span class="k">using</span> <span class="nn">JetBrains.ReSharper.Feature.Services.ContextNavigation</span><span class="p">;</span> <span class="k">using</span> <span class="nn">JetBrains.Util</span><span class="p">;</span> <span class="k">using</span> <span class="nn">DataConstants</span> <span class="p">=</span> <span class="n">JetBrains</span><span class="p">.</span><span class="n">ProjectModel</span><span class="p">.</span><span class="n">DataContext</span><span class="p">.</span><span class="n">DataConstants</span><span class="p">;</span> <span class="k">namespace</span> <span class="nn">ReSharperPlugIn6</span> <span class="p">{</span> <span class="p">[</span><span class="n">ActionHandler</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">SimpleNavigation</span> <span class="p">:</span> <span class="n">ContextNavigationActionBase</span><span class="p"><</span><span class="n">SimpleNavigationProvider</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span> <span class="p">[</span><span class="n">ContextNavigationProvider</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">SimpleNavigationProvider</span> <span class="p">:</span> <span class="n">INavigateFromHereProvider</span> <span class="p">{</span> <span class="p">[</span><span class="n">CanBeNull</span><span class="p">]</span> <span class="k">private</span> <span class="k">static</span> <span class="n">ProcessStartInfo</span> <span class="nf">GetProcessStartInfo</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="n">FileSystemPath</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">ProcessStartInfo</span><span class="p">(</span><span class="s">"explorer.exe"</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">ExistsFile</span> <span class="p">?</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">@"/select,""{0}"""</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="p">:</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="s">@"""{0}"""</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">Directory</span><span class="p">));</span> <span class="p">}</span> <span class="p">[</span><span class="n">CanBeNull</span><span class="p">]</span> <span class="k">private</span> <span class="k">static</span> <span class="n">FileSystemPath</span> <span class="nf">GetPathByContext</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="n">IDataContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">projectModelElement</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">GetData</span><span class="p">(</span><span class="n">DataConstants</span><span class="p">.</span><span class="n">PROJECT_MODEL_ELEMENT</span><span class="p">);</span> <span class="kt">var</span> <span class="n">projectItem</span> <span class="p">=</span> <span class="n">projectModelElement</span> <span class="k">as</span> <span class="n">IProjectItem</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">projectItem</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="k">if</span> <span class="p">(!</span><span class="n">projectItem</span><span class="p">.</span><span class="n">Location</span><span class="p">.</span><span class="n">Directory</span><span class="p">.</span><span class="n">ExistsDirectory</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="k">return</span> <span class="n">projectItem</span><span class="p">.</span><span class="n">Location</span><span class="p">;</span> <span class="p">}</span> <span class="k">public</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">ContextNavigation</span><span class="p">></span> <span class="nf">CreateWorkflow</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">path</span> <span class="p">=</span> <span class="nf">GetPathByContext</span><span class="p">(</span><span class="n">dataContext</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">ProcessStartInfo</span> <span class="n">processStartInfo</span> <span class="p">=</span> <span class="nf">GetProcessStartInfo</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="n">processStartInfo</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">ContextNavigation</span><span class="p">(</span> <span class="s">"&Windows Explorer"</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">NavigationActionGroup</span><span class="p">.</span><span class="n">Other</span><span class="p">,</span> <span class="p">()</span> <span class="p">=></span> <span class="p">{</span> <span class="k">try</span> <span class="p">{</span> <span class="k">using</span> <span class="p">(</span><span class="n">Process</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="n">processStartInfo</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">MessageBox</span><span class="p">.</span><span class="nf">ShowError</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span> <span class="p">}</span> <span class="p">});</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span></code></div>

<a name="context-searches" class="elem-anchor"></a>
<h2>上下文搜索<a href="#context-searches" class="anchor-link"><span></span></a></h2>

<p>如果导航很复杂，并且在不同的语言下工作方式不同，则可以使用上下文搜索为特定语言提供不同的搜索结果。</p>

<p>在这种情况下，您的提供者必须来自<code class="code highlight language-text">ContextSearchesCollector<TContextSearch></code>类，您所需要做的就是实现<code class="code highlight language-text">Execute()</code>方法。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">protected</span> <span class="k">abstract</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">TContextSearch</span><span class="p">></span> <span class="n">searches</span><span class="p">,</span> <span class="n">INavigationExecutionHost</span> <span class="n">host</span><span class="p">);</span></code></div>

<p><code class="code highlight language-text">IContextSearch</code>是供以<code class="code highlight language-text">FeaturePart</code>属性并提供特定的导航执行。该界面中只有两种方法，指示所述上下文搜索的适用性和可用性。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IContextSearch</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">IsAvailable</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">);</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>适用性方法更具全局性，意味着此上下文搜索可以针对此数据上下文工作，并将<em>覆盖</em>其派生自其的其他组件。</p>

<p>可用性意味着对于特定的数据上下文，此上下文搜索已启用并将被触发。</p>

<p>您可以通过提供自己的上下文搜索组件来更改现有ReSharper导航功能的行为。这是一个上下文搜索示例，它扩展了XAML的“转到实现”搜索：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[FeaturePart]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">XamlImplementationContextSearch</span> <span class="p">:</span> <span class="n">ContextNavigation</span><span class="p">.</span><span class="n">ContextSearches</span><span class="p">.</span><span class="n">BaseSearches</span><span class="p">.</span><span class="n">ImplementationContextSearch</span> <span class="p">{</span> <span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">IsAvailable</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ContextNavigationUtil</span><span class="p">.</span><span class="n">CheckDefaultApplicability</span><span class="p"><</span><span class="n">XamlLanguage</span><span class="p">>(</span><span class="n">dataContext</span><span class="p">);</span> <span class="p">}</span> <span class="k">protected</span> <span class="k">override</span> <span class="n">SearchImplementationsRequest</span> <span class="nf">CreateSearchRequest</span><span class="p">(</span><span class="n">IDataContext</span> <span class="n">dataContext</span><span class="p">,</span> <span class="n">IDeclaredElement</span> <span class="n">declaredElement</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Your custom logic here...</span> <span class="p">}</span> <span class="p">}</span></code></div>

<a name="global-navigation-go-to-" class="elem-anchor"></a>
<h2>全球导航（“转到...”）<a href="#global-navigation-go-to-" class="anchor-link"><span></span></a></h2>

<p><em>全局导航</em>涉及在各种全局搜索（例如， <em>转到类型</em>或<em>转到成员）中使用的功能</em> 。通常，这些搜索全部用作文本输入弹出框，当键入该弹出框时，将显示一个列表，可以进一步完善该列表，然后在选择后导航到声明的元素。此外，列表可以“变形”，因此只要按一个快捷键，“转到类型”搜索就可以突然变成“转到符号”搜索。</p>

<a name="occurrence-navigation-provider" class="elem-anchor"></a>
<h2>出现导航提供者<a href="#occurrence-navigation-provider" class="anchor-link"><span></span></a></h2>

<p>为了为特定的全局导航机制提供项目，我们需要实现一个事件导航提供程序-一个实现<code class="code highlight language-text">IOccurrenceNavigationProvider</code>接口。下图说明了此接口的层次结构：</p>

<p><img src="navigation.png" alt="IOccurrenceNavigationProvider层次结构"></p>

<p>如您所见，这四个接口成员是自我描述的，并且由基于语言的具体类进一步实现。例如， <code class="code highlight language-text">IGotoSymbolProvider</code>有CLR，CSS，HTML和JavaScript的具体实现。该接口也由<code class="code highlight language-text">ClrGotoTypeMemberProvider</code> ，它说明了一种继承机制-这很有意义，因为“转到符号”实际上包括来自“转到类型”的信息。</p>

<p>该接口非常简单，只有三个成员：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IOccurrenceNavigationProvider</span> <span class="p">:</span> <span class="n">IApplicableGotoProvider</span> <span class="p">{</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">MatchingInfo</span><span class="p">></span> <span class="nf">FindMatchingInfos</span><span class="p">(</span><span class="n">IdentifierMatcher</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">INavigationScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">CheckForInterrupt</span> <span class="n">checkCancelled</span><span class="p">,</span> <span class="n">GotoContext</span> <span class="n">gotoContext</span><span class="p">);</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">IOccurrence</span><span class="p">></span> <span class="nf">GetOccurrencesByMatchingInfo</span><span class="p">(</span><span class="n">MatchingInfo</span> <span class="n">navigationInfo</span><span class="p">,</span> <span class="n">INavigationScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">GotoContext</span> <span class="n">gotoContext</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>第一种方法<code class="code highlight language-text">FindMatchingInfos()</code> ，找到匹配的项目并返回相应的列表<code class="code highlight language-text">MatchingInfo</code>对象。一种<code class="code highlight language-text">MatchingInfo</code>只是一个数据类，描述了用于存储匹配项的必要信息-其标识符，一组<code class="code highlight language-text">IdentifierMatch</code>对象（与匹配项相对应，可能有很多）和其他一些服务信息。</p>

<p>第二种方法<code class="code highlight language-text">GetOccurrencesByMatchingInfo</code> ，则根据匹配信息返回一组事件。<em>发生</em>本质上是指向发现某物的位置的指针。由于“某物”的定义很模糊，因此发生的事情几乎可以是任何东西-文本编辑器中的范围，项目引用，while项目或文件。例如，项目文件由<code class="code highlight language-text">ProjectItemOccurrence</code> ，而后者又引用了<code class="code highlight language-text">IProjectItem</code>它指向。</p>

<p>另外，您需要实现从继承的接口成员<code class="code highlight language-text">IApplicableGotoProvider</code> ：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IApplicableGotoProvider</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">INavigationScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">GotoContext</span> <span class="n">gotoContext</span><span class="p">,</span> <span class="n">IdentifierMatcher</span> <span class="n">matcher</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>上面的方法使我们可以确定特定的提供程序是否应在给定的上下文中工作。提供者理论上可以彼此继承，并且如果您要覆盖现有提供者，则不必每次都工作（例如<code class="code highlight language-text">SolutionComponent</code>会），而是检查<code class="code highlight language-text">IsApplicable</code>结果。</p>

<p>该API现在为您提供了一个名为<code class="code highlight language-text">IGotoEverythingProvider</code> ，它恰好继承了这两个接口，并另外指定了一个排序函数，声明为</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="n">Func</span><span class="p"><</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">></span> <span class="n">ItemsPriorityFunc</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span></code></div>

<p>该界面可让您计算所显示元素的优先级，以使返回的结果越低，该元素的优先级就越高。</p>

<p>现在，要创建提供程序，只需实现接口并用<code class="code highlight language-text">[ShellFeaturePart]</code> ：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellFeaturePart]</span> <span class="k">class</span> <span class="nc">GoToYouTrackIssueProvider</span> <span class="p">:</span> <span class="n">IGotoEverythingProvider</span> <span class="p">{</span> <span class="c1">// ...</span> <span class="p">}</span></code></div>

<a name="occurrence-presenter" class="elem-anchor"></a>
<h2>出现主持人<a href="#occurrence-presenter" class="anchor-link"><span></span></a></h2>

<p>发生一系列事件是很棒的，但是在屏幕上显示之前它们是无用的。这就是突发事件主持人进来的地方。基本上，事件发生者是知道如何将特定事件作为菜单项呈现的类。除了被装饰<code class="code highlight language-text">OccurrencePresenter</code>属性，体现在<code class="code highlight language-text">IOccurrencePresenter</code>接口定义如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IOccurrencePresenter</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">Present</span><span class="p">(</span><span class="n">IMenuItemDescriptor</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">,</span> <span class="n">OccurrencePresentationOptions</span> <span class="n">occurrencePresentationOptions</span><span class="p">);</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>首先，有<code class="code highlight language-text">IsApplicable()</code>方法。此方法确定此事件演示者是否适用于特定类型的事件。这些通常是并行的，例如：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[OccurrencePresenter(Priority=0.0)]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">RangeOccurrencePresenter</span> <span class="p">:</span> <span class="n">IOccurrencePresenter</span> <span class="p">{</span> <span class="k">public</span> <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">occurrence</span> <span class="k">is</span> <span class="n">RangeOccurrence</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// other members omitted</span> <span class="p">}</span></code></div>

<p>然后有<code class="code highlight language-text">Present()</code>方法，当<code class="code highlight language-text">IOccurrence</code>需要提出。此方法的目标是对<code class="code highlight language-text">descriptor</code>参数。的<code class="code highlight language-text">IMenuItemDescriptor</code>界面很大，但是我们在这里需要关注的唯一属性是<code class="code highlight language-text">Text</code> - 这是一个<code class="code highlight language-text">RichText</code>定义，将在此情况下显示为菜单项。</p>

<p>这是一个示例实现。注意<code class="code highlight language-text">descriptor.Style</code> <em>必须</em>定义-否则，该项目将被禁用。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Present</span><span class="p">(</span><span class="n">IMenuItemDescriptor</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">,</span> <span class="n">OccurrencePresentationOptions</span> <span class="n">occurrencePresentationOptions</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">o</span> <span class="p">=</span> <span class="p">((</span><span class="n">YouTrackIssueOccurrence</span><span class="p">)</span> <span class="n">occurrence</span><span class="p">);</span> <span class="n">descriptor</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">o</span><span class="p">.</span><span class="n">IssueId</span><span class="p">;</span> <span class="n">descriptor</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="s">" - "</span><span class="p">);</span> <span class="n">descriptor</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">IssueDescription</span><span class="p">);</span> <span class="n">descriptor</span><span class="p">.</span><span class="n">Style</span> <span class="p">=</span> <span class="n">MenuItemStyle</span><span class="p">.</span><span class="n">Enabled</span><span class="p">;</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span></code></div>

<a name="occurrence-kind-provider" class="elem-anchor"></a>
<h2>出现种类提供者<a href="#occurrence-kind-provider" class="anchor-link"><span></span></a></h2>

<p>当您打开“查找用法”时，您会发现自己具有过滤信息的能力。一些示例是读取用法，写入用法，属性引用等。每个图标都有其自己的特殊图标，并在必要时可以将其过滤掉。</p>

<p>刚刚提到的元素的类型称为<em>出现类型</em> 。可以将许多种情况作为静态成员<code class="code highlight language-text">OccurrenceKind</code>类，可以创建新的类。出现类型只是一个类似于枚举的类，仅保留两位信息：其名称以及是否为主要信息。如果将事件类型设置为主要事件，则无论设置了什么过滤器，“查找结果”窗口将始终显示此类事件。其他事件不是主要事件，即仅在有这种事件类型的事件（例如，单元测试）时显示。</p>

<p>现在，我们可以讨论出现类型提供程序。这些通常是解决方案的组成部分（即用<code class="code highlight language-text">SolutionComponent</code>属性） <code class="code highlight language-text">IOccurrenceKindProvider</code>接口。该接口定义如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IOccurrenceKindProvider</span> <span class="p">{</span> <span class="n">ICollection</span><span class="p"><</span><span class="n">OccurrenceKind</span><span class="p">></span> <span class="nf">GetOccurrenceKinds</span><span class="p">(</span><span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">);</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">OccurrenceKind</span><span class="p">></span> <span class="nf">GetAllPossibleOccurrenceKinds</span><span class="p">();</span> <span class="p">}</span></code></div>

<p>的<code class="code highlight language-text">GetAllPossibleOccurrenceKinds()</code>方法返回该提供程序理论上可以给出的所有可能出现的列表。例如，在C＃中，我们可以产生接口限定，基本方法调用和调用，而在VB中，我们还具有<code class="code highlight language-text">Handles</code>条款。</p>

<p>的<code class="code highlight language-text">GetOccurrenceKinds()</code>方法返回事件种类的集合（或者您可以返回<code class="code highlight language-text">EmptyList<OccurrenceKind>.InstanceList</code> （如果没有）适用于给定事件的事件。自然，这通常是假设您将尝试投射<code class="code highlight language-text">IOccurrence</code>具体类型（例如， <code class="code highlight language-text">ReferenceOccurrence</code> ）调查其内容并据此得出发生的种类。</p>

<a name="occurrence-section-provider" class="elem-anchor"></a>
<h2>发生科提供者<a href="#occurrence-section-provider" class="anchor-link"><span></span></a></h2>

<p>当搜索结果显示在对话窗口中时，通常会通过水平线将其分为几部分。提供有关不同类型部分的信息的组件是<code class="code highlight language-text">FeaturePart</code>实现了<code class="code highlight language-text">IOccurrenceSectionProvider</code>接口。接口定义如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IOccurrenceSectionProvider</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">OccurrenceBrowserDescriptor</span> <span class="n">descriptor</span><span class="p">);</span> <span class="n">ICollection</span><span class="p"><</span><span class="n">TreeSection</span><span class="p">></span> <span class="nf">GetTreeSections</span><span class="p">(</span><span class="n">OccurrenceBrowserDescriptor</span> <span class="n">descriptor</span><span class="p">);</span> <span class="n">ICollection</span><span class="p"><</span><span class="n">GroupingSectionId</span><span class="p">></span> <span class="nf">GetGroupSectionId</span><span class="p">(</span><span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">,</span> <span class="n">OccurrenceBrowserDescriptor</span> <span class="n">descriptor</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>让我们来看一下这些方法。首先， <code class="code highlight language-text">IsApplicable()</code>根据我们正在使用的事件浏览器的类型，检查此部分提供者是否适用。这通常很简单<code class="code highlight language-text">is</code>致电，例如：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">IsApplicable</span><span class="p">(</span><span class="n">OccurrenceBrowserDescriptor</span> <span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">descriptor</span> <span class="k">is</span> <span class="n">GotoDeclaredElementsBrowserDescriptor</span><span class="p">;</span> <span class="p">}</span></code></div>

<p>第二种方法是<code class="code highlight language-text">GetTreeSections()</code> ，并且此方法返回一组<code class="code highlight language-text">TreeSection</code>此部分提供程序专用的对象。我们将讨论<code class="code highlight language-text">TreeSection</code>稍后，我们将简要讨论第三种方法。 <code class="code highlight language-text">GetGroupSectionId</code>基本上可以让我们确定一组特定的组（可以有多个） <code class="code highlight language-text">IOccurrence</code>需要出现。如中定义的默认实现<code class="code highlight language-text">OccurrenceSectionProvider</code>类（您应该从中继承，而不是手工实现接口）是使用一种特殊的方法<code class="code highlight language-text">GetSectionId()</code>根据事件的类型选择已知的部分：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="c1">// in OccurrenceSectionProvider</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">ICollection</span><span class="p"><</span><span class="n">GroupingSectionId</span><span class="p">></span> <span class="nf">GetGroupSectionId</span><span class="p">(</span><span class="n">IOccurrence</span> <span class="n">occurrence</span><span class="p">,</span> <span class="n">OccurrenceBrowserDescriptor</span> <span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span><span class="n">occurrence</span><span class="p">.</span><span class="n">OccurrenceType</span><span class="p">.</span><span class="nf">GetSectionId</span><span class="p">()};</span> <span class="p">}</span></code></div>

<a name="tree-model" class="elem-anchor"></a>
<h2>树模型<a href="#tree-model" class="anchor-link"><span></span></a></h2>

<p>现在，让我们回去谈论<code class="code highlight language-text">TreeSection</code>定义，或更确切地说，关于树模型，因为<code class="code highlight language-text">TreeSection</code>只不过是标题和容器类的容器类<code class="code highlight language-text">TreeModel</code>这就是我们感兴趣的树模型。</p>

<p>一种<code class="code highlight language-text">TreeModel</code>您可能已经猜到了，它只是经典N元树的定义。模型本身具有一组根，即一个属性<code class="code highlight language-text">Roots</code>类型的<code class="code highlight language-text">IList<TreeModelNode></code>以及用于插入，删除和更新的各种机制<code class="code highlight language-text">TreeModelNode</code>实体。</p>

<p>每<code class="code highlight language-text">TreeModelNode</code>依次有一组孩子，他们也<code class="code highlight language-text">TreeModelNode</code>自己。两者都可以排序<code class="code highlight language-text">TreeModel</code>和<code class="code highlight language-text">TreeModelNode</code>水平。请注意，节点内部的实际数据存储定义为<code class="code highlight language-text">object</code> ，即未键入。</p>

<p>记住两个<code class="code highlight language-text">TreeModel</code>和<code class="code highlight language-text">TreeModelNode</code>是抽象类，您更有可能与它们的后代一起工作，其中最基本的是<code class="code highlight language-text">TreeSimpleModel</code> 。</p>

<a name="occurrence" class="elem-anchor"></a>
<h2>发生<a href="#occurrence" class="anchor-link"><span></span></a></h2>

<p>菜单项本身就是实现<code class="code highlight language-text">IOccurrence</code>接口。该接口定义了大量的元素：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IOccurrence</span> <span class="p">{</span> <span class="n">TextRange</span> <span class="n">TextRange</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">ProjectModelElementEnvoy</span> <span class="n">ProjectModelElementEnvoy</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">DeclaredElementEnvoy</span><span class="p"><</span><span class="n">ITypeMember</span><span class="p">></span> <span class="n">TypeMember</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">DeclaredElementEnvoy</span><span class="p"><</span><span class="n">ITypeElement</span><span class="p">></span> <span class="n">TypeElement</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">DeclaredElementEnvoy</span><span class="p"><</span><span class="n">INamespace</span><span class="p">></span> <span class="n">Namespace</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">OccurrenceType</span> <span class="n">OccurrenceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="kt">bool</span> <span class="n">IsValid</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="kt">object</span> <span class="n">MergeKey</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">IList</span><span class="p"><</span><span class="n">IOccurrence</span><span class="p">></span> <span class="n">MergedItems</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">OccurrencePresentationOptions</span> <span class="n">PresentationOptions</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="kt">bool</span> <span class="nf">Navigate</span><span class="p">(</span><span class="n">ISolution</span> <span class="n">solution</span><span class="p">,</span> <span class="n">PopupWindowContextSource</span> <span class="n">windowContext</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">transferFocus</span><span class="p">,</span> <span class="n">TabOptions</span> <span class="n">tabOptions</span> <span class="p">=</span> <span class="n">TabOptions</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span> <span class="kt">string</span> <span class="nf">DumpToString</span><span class="p">();</span> <span class="p">}</span></code></div>

<p>就支持（例如，代码中存在的构造）而言，此接口的功能非常完善。如果要提供与PSI不相关的临时项目，则可以提供以下默认值：</p>

<ul>
  <li><code class="code highlight language-text">DumpToString()</code> -由您决定，这是一种调试方法。</li>
  <li><code class="code highlight language-text">TextRange</code> -只需返回一个<code class="code highlight language-text">new TextRange()</code> 。您可能需要考虑为每个查询返回一个实例。</li>
  <li><code class="code highlight language-text">MergeKey</code> -这将产生一个密钥，该密钥指示是否应合并多个项目。因此，让此属性为您不打算合并的每个项目产生唯一的值是有意义的。</li>
  <li><code class="code highlight language-text">ProjectElementEnvoy</code> ， <code class="code highlight language-text">TypeMember</code> ， <code class="code highlight language-text">TypeElement</code> ， <code class="code highlight language-text">Namespace</code> ， <code class="code highlight language-text">MergedItems</code> -只需返回<code class="code highlight language-text">null</code> 。</li>
  <li><code class="code highlight language-text">OccurrenceType</code> -- <code class="code highlight language-text">OccurrenceType.Occurrence</code> 。</li>
  <li><code class="code highlight language-text">IsValid</code> -- <code class="code highlight language-text">true</code> 。</li>
  <li><code class="code highlight language-text">PresentationOption</code> -将其定义为<code class="code highlight language-text">get/set</code>属性。</li>
</ul>

<p>有关利用各种示例<code class="code highlight language-text">IOccurrence</code>成员，请看一下其内置的ReSharper实现器。</p>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Features/GenerateMenu.html">生成菜单</a> <a class="navigation-links__next" href="/Features/OptionsPages.html">选项页</a>
                    </div>
                    <div class="last-modified">上次修改时间：2018年7月31日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>