<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>实时模板宏/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Features/LiveTemplates/Macros.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Live Template macros">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Live Template macros">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Features/LiveTemplates/Macros">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Features/LiveTemplates/Scopes.html">范围</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Features/LiveTemplates/Macros.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>实时模板宏</h1>
                    <p>当然，插件可以提供宏以扩展ReSharper已包含的列表（并且ReSharper扩展可以包括引用这些模板的实时模板，方法是将宏插件捆绑到同一扩展中，或者依赖包含该扩展的另一个扩展。宏插件。有关更多详细信息，请参见包装页面。</p>

<p>宏通过两个类实现-定义和实现。该定义描述了宏，并且实现处理了被调用的宏。</p>

<a name="macro-definition" class="elem-anchor"></a>
<h2>宏定义<a href="#macro-definition" class="anchor-link"><span></span></a></h2>

<p>宏定义是一个实现的类<code class="code highlight language-text">IMacroDefinition</code>并标有<code class="code highlight language-text">MacroDefinitionAttribute</code> 。你可以从<code class="code highlight language-text">SimpleMacroDefinition</code> ，它提供了接口的默认实现。</p>

<p>该属性源自组件模型的<code class="code highlight language-text">ShellComponentAttribute</code> ，这意味着定义类在Shell启动时实例化一次，并且在整个应用程序的生命周期内一直持续。它由三个字符串属性组成- <code class="code highlight language-text">Name</code> ， <code class="code highlight language-text">ShortDescription</code>和<code class="code highlight language-text">LongDescription</code> 。名称是宏定义的简单标识符，可以传递给<code class="code highlight language-text">MacroManager.GetMacroDefinition</code>如果您需要以编程方式检索宏定义。简短描述显示在模板编辑器显示的宏列表中，而长描述则在该列表中选择宏定义时显示。</p>

<p>简短说明也可以包含占位符，以指示可以对宏进行参数化。这仅出于显示目的-参数由宏定义类声明，如下所述。当简短描述显示在模板编辑器的宏列表中时，占位符文本以粗体显示，向用户指示可以对宏进行参数化，而对哪些部分进行参数化。</p>

<p>占位符的格式为<code class="code highlight language-text">{X:name}</code> ，其中<code class="code highlight language-text">X</code>替换为参数索引，“名称”是以粗体显示的文本。（严格来说，“名称”文本是参数的名称，这就是为什么还有参数索引的原因。该名称将传递到参数值UI，可以在其中用作例如标签，但是当前未使用。）对于一个变量，您可以具有诸如“插入对{0：type}的引用”之类的描述。这说明宏将采用一个称为“类型”的参数，并且模板编辑器中显示的宏列表将以粗体显示“类型”。可以通过增加参数索引来引用多个参数，例如：“使用{1：delimiter}分隔项目的{0：list}分隔项”可以是使用第一个参数“ list”存储字符串值分隔列表的宏。 ，使用索引1处名为“ delimiter”的参数中指定的分隔符。</p>

<p>的<code class="code highlight language-text">IMacroDefinition</code>界面有两个成员-一个<code class="code highlight language-text">Parameters</code>财产和<code class="code highlight language-text">GetPlaceholder</code>方法。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMacroDefinition</span> <span class="p">{</span> <span class="n">ParameterInfo</span><span class="p">[]</span> <span class="n">Parameters</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="kt">string</span> <span class="nf">GetPlaceholder</span><span class="p">(</span><span class="n">IDocument</span> <span class="n">document</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="n">IMacroParameterValue</span><span class="p">></span> <span class="n">parameters</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>的<code class="code highlight language-text">Parameters</code>属性返回一个数组<code class="code highlight language-text">ParameterInfo</code>描述宏所需参数类型的类。该类实质上是一个枚举，将参数声明为字符串，类型或对模板中另一个变量的引用。在模板编辑器中输入参数值时，它们用于提供不同的UI。的<code class="code highlight language-text">SimpleMacroDefinition</code>实施<code class="code highlight language-text">Parameters</code>返回一个空数组，如果需要，应将其覆盖。</p>

<p>的<code class="code highlight language-text">GetPlaceholder</code>在首次扩展模板时以及用户有机会编辑任何热点之前，将调用方法。向每个热点的宏定义查询其占位符值，然后将该值替换为扩展文本。然后，根据当前文档的语言对展开的文本进行格式化。换句话说，占位符值的目的是提供一个适当的值，该值允许精确解析和格式化所得的文本片段。例如，预期返回标识符（例如，填充变量名）的宏可以返回简单的占位符“ a”，这是有效的标识符。但是，它不应返回类似表达式的“ a-b-c”之类的内容，如果用作变量名的标识符，则将导致解析错误。中的默认实现<code class="code highlight language-text">SimpleMacroDefinition</code>返回文本“ a”，但是可以在派生类中覆盖它。</p>

<a name="macro-implementation" class="elem-anchor"></a>
<h2>宏实施<a href="#macro-implementation" class="anchor-link"><span></span></a></h2>

<p>宏的实现由实现的类处理<code class="code highlight language-text">IMacroImplementation</code>并标有<code class="code highlight language-text">MacroImplementationAttribute</code> 。与宏定义类似， <code class="code highlight language-text">SimpleMacroImplementation</code>基类提供了很好的默认实现。</p>

<p>的<code class="code highlight language-text">MacroImplementationAttribute</code>定义了几个成员：</p>

<ul>
  <li><code class="code highlight language-text">Definition</code>返回<code class="code highlight language-text">System.Type</code>的<code class="code highlight language-text">IMacroDefinition</code>正在实施的类。例如， <code class="code highlight language-text">GuidMacroImpl</code>实现“ nguid”模板的宏的类指的是<code class="code highlight language-text">typeof(GuidMacroDef)</code> 。</li>
  <li>如果<code class="code highlight language-text">IsExpandAndSkip</code>属性设置为true，这将使热点有效。该值将被扩展且不会更改，并且您无法再通过Tab键浏览到热点。效果与模板中的变量标记为不可编辑的效果相同。</li>
  <li>的<code class="code highlight language-text">ScopeProvider</code>和<code class="code highlight language-text">GetScopes</code>成员允许宏实现声明其支持的范围。这使您可以将实现限制为使用特定语言的文件，甚至限制在这些文件中的位置。的<code class="code highlight language-text">MacroImplementationAttribute</code>默认情况下，此值将范围设置为“无处不在”，这意味着宏实现不受使用位置的限制。为了覆盖此行为，您需要从<code class="code highlight language-text">MacroImplementationAttribute</code>并覆盖<code class="code highlight language-text">ScopeProvider</code>属性以返回实现的新类型<code class="code highlight language-text">IMacroImplementationScopeProvider</code> 。</li>
</ul>

<p>可以为单个定义提供多个实现，ReSharper将尝试查找范围最接近的实现，如<code class="code highlight language-text">GetScopes</code> ，以实际使用范围为准。例如，“ C＃文件”的范围将比“无处不在”的范围更近。如果有多个实现，但没有最接近的范围，则选择一个任意实现。</p>

<p>为每个热点创建一个实现类的实例。创建类时，实现类可以注入两个构造函数参数- <code class="code highlight language-text">IHotspotSession</code>和<code class="code highlight language-text">MacroParameterValueCollection</code> 。这就是参数化的实现如何掌握实时模板中指定的参数值的方式。构造函数参数可以按任何顺序排列，也可以完全不指定。但是，它们必须标有<code class="code highlight language-text">[Optional]</code>属性，因为该实现的另一个实例是在Shell启动时创建的（ <code class="code highlight language-text">MacroImplementationAttribute</code>源自于<code class="code highlight language-text">ShellCompomentAttribute</code> ），届时会话和参数集合均不可用。该实例将收到<code class="code highlight language-text">null</code>这些参数。创建附加实例是为了在实现和定义之间映射，尤其是从插件动态添加时。</p>

<p><code class="code highlight language-text">IMacroImplementation</code>定义了三种方法：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMacroImplementation</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">HandleExpansion</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span> <span class="n">HotspotItems</span> <span class="nf">GetLookupItems</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span> <span class="kt">string</span> <span class="nf">EvaluateQuickResult</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>第一次扩展模板时，以及在文本被占位符替换并重新格式化后，每个热点的<strong><code class="code highlight language-text">GetLookupItems</code></strong>方法被调用。如果返回任何值，则使用第一个替换占位符。如果未返回任何项目，则热点<strong><code class="code highlight language-text">EvaluateQuickResult</code></strong>被调用，并使用该文本代替。</p>

<p>击中时<code class="code highlight language-text">tab</code>要么<code class="code highlight language-text">shift+tab</code>在热点之间移动时，将激活每个热点，然后<code class="code highlight language-text">HandleExpansion</code>方法被调用。这使宏实现有机会处理热点变为活动状态时发生的情况，从而取代了显示项目完成列表的正常行为。例如，基本，智能和类型完成宏会调用标准代码完成组件，而不是将项目列表提供给热点管理器以显示。 <strong><code class="code highlight language-text">HandleExpansion</code></strong>应该回来<code class="code highlight language-text">true</code>如果它处理了扩展请求，或者<code class="code highlight language-text">false</code>除此以外。</p>

<p>的<code class="code highlight language-text">GetLookupItems</code>当热点变为活动状态时，也可以调用该方法（因此，如果您控制<code class="code highlight language-text">HandleExpansion</code> ，您还应该返回<code class="code highlight language-text">null</code>或此处为空列表）。返回的项目将被缓存，如果文本未更改，则将被重用，因此在多个热点之间切换不会导致多次调用。如果周围的文本发生更改，则将丢弃缓存的项目，并检索新的项目，从而允许依赖于周围的文本的宏，例如为也可以编辑的类型的变量建议名称。</p>

<p><code class="code highlight language-text">GetLookupItems</code>返回的实例<code class="code highlight language-text">HotspotItems</code> ，其中维护着<code class="code highlight language-text">ILookupItem</code>实例，用于代码完成。一般来说，这将是<code class="code highlight language-text">TextLookupItem</code>实例，以扩展为简单的文本字符串。但是，您可以使用任何<code class="code highlight language-text">ILookupItem</code>实例的<code class="code highlight language-text">ILookupItem.Accept</code>调用方法来插入文本。例如，用于插入对类型的引用的宏派生自<code class="code highlight language-text">TypeLookupItem</code>并覆盖从其调用的方法<code class="code highlight language-text">Accept</code>方法，以便为通用类型正确定位文本插入符。您也可以使用<code class="code highlight language-text">HotspotItems.Empty</code>实例，如果您没有任何查找项。该列表仅创建一次，并且在您键入时不会更改，尽管会对值进行过滤以匹配您键入的内容。</p>

<p><code class="code highlight language-text">EvaluateQuickResult</code>另一个热点更改时调用。它允许宏基于其他热点的内容或周围的文本。如果宏基于某个参数（例如模板编辑器中的常量值或对另一个热点变量的引用），则可以从该宏中检索内容。 <code class="code highlight language-text">MacroParameterValueCollection</code>传递给构造函数。要获得该值，将类似于以下内容：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[MacroImplementation(Definition = typeof(ToUpperMacroDef))]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ToUpperMacroImpl</span> <span class="p">:</span> <span class="n">SimpleMacroImplementation</span> <span class="p">{</span> <span class="k">private</span> <span class="n">IMacroParameterValueNew</span> <span class="n">myArgument</span><span class="p">;</span> <span class="k">public</span> <span class="nf">ToUpperMacroImpl</span><span class="p">([</span><span class="n">Optional</span><span class="p">]</span> <span class="n">MacroParameterValueCollection</span> <span class="n">arguments</span><span class="p">)</span> <span class="p">{</span> <span class="n">myArgument</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">.</span><span class="nf">OptionalFirstOrDefault</span><span class="p">();</span> <span class="p">}</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">EvaluateQuickResult</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">myArgument</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">myArgument</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">().</span><span class="nf">ToUpperInvariant</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>顾名思义， <code class="code highlight language-text">EvaluateQuickResult</code>需要快速执行，因为将为当前热点中键入的每个字符调用每个宏的实现。处理应保持在最低限度。</p>

<a name="ihotspotcontext" class="elem-anchor"></a>
<h2>IHotspotContext<a href="#ihotspotcontext" class="anchor-link"><span></span></a></h2>

<p>中的所有方法<code class="code highlight language-text">IMacroImplementation</code>采取<code class="code highlight language-text">IHotspotContext</code>作为争论。该接口具有三个属性：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IHotspotContext</span> <span class="p">{</span> <span class="n">IHotspotSession</span> <span class="n">HotspotSession</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">IHotspotSessionContext</span> <span class="n">SessionContext</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">DocumentRange</span> <span class="n">ExpressionRange</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span></code></div>

<ul>
  <li><strong><code class="code highlight language-text">IHotspotSession HotspotSession</code></strong> -提供有关当前会话的信息，包括诸如<code class="code highlight language-text">GoToNextHotspot</code>和<code class="code highlight language-text">EndSession</code> ， <code class="code highlight language-text">GetVariableResult</code>通过名称获取变量的值（如宏定义的简短描述中所列）。您还可以获取热点列表和当前热点（可能不是与当前宏实现相关联的热点，尤其是在<code class="code highlight language-text">EvaluateQuickResult</code> ）。</li>
  <li><strong><code class="code highlight language-text">IHotspotSessionContext SessionContext</code></strong> -实例化模板的位置的上下文，包括解决方案，文档和偏移量。</li>
  <li><strong><code class="code highlight language-text">DocumentRange ExpressionRange</code></strong> -当前热点的文档范围（再次，不一定是当前宏实现的热点）。你可以打电话<code class="code highlight language-text">ExpressionRange.GetText()</code>检索该热点的值，或<code class="code highlight language-text">HotspotSession.CurrentHotspot.CurrentValue</code> 。</li>
</ul>

<a name="helper-methods" class="elem-anchor"></a>
<h2>辅助方法<a href="#helper-methods" class="anchor-link"><span></span></a></h2>

<p>ReSharper提供了一些有用的类来实现宏，即<code class="code highlight language-text">MacroUtil</code>和<code class="code highlight language-text">IMacroUtil</code>接口。请注意，这些类无关！的<code class="code highlight language-text">MacroUtil</code> class是一个静态类，具有几个有用的方法：</p>

<ul>
  <li><strong><code class="code highlight language-text">SimpleEvaluateResult</code></strong>创建一个实例<code class="code highlight language-text">HotspotItems</code>从单个字符串值。有助于实施<code class="code highlight language-text">IMacroImplementation.EvaluateResult</code> 。</li>
  <li><strong><code class="code highlight language-text">GetLanguageType</code></strong>和<strong><code class="code highlight language-text">GetFile</code></strong>从以下实例返回信息<code class="code highlight language-text">IHotspotContext</code></li>
  <li><strong><code class="code highlight language-text">GetMacroUtil</code></strong>返回的实例<code class="code highlight language-text">IMacroUtil</code></li>
</ul>

<p>的<code class="code highlight language-text">IMacroUtil</code>接口是按每种语言实现的-有C＃，VB，JS等的实例。它包含几种方法，可以轻松地例如建议变量类型，获取当前可见的变量，将类型名称转换为<code class="code highlight language-text">IType</code>等等。它的主要目的是支持多个内置宏，因此它们可以一次实现，并且每种语言都可以为实现中特定于语言的部分添加支持。</p>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Features/LiveTemplates/Scopes.html">范围</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>