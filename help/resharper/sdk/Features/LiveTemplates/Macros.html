


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Live Template macros / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/help/resharper/sdk/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/help/resharper/sdk/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/help/resharper/sdk/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/help/resharper/sdk/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/help/resharper/sdk/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/help/resharper/sdk/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/help/resharper/sdk/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/help/resharper/sdk/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Features/LiveTemplates/Macros.html" />
    <meta property="og:site_name" content="JetBrains ReSharper" />
    <meta property="og:title" content="Live Template macros" />
    <meta property="og:description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00" />
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@JBPlatform" />
    <meta name="twitter:title" content="Live Template macros" />
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper" />
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/"></meta>
<link  rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body data-id="Features/LiveTemplates/Macros">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a data-bypass="true" href="//youtrack.jetbrains.com/issues/IJSDK">Send feedback</a></p>
                <p>&copy; 2000&ndash;2018 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Features/LiveTemplates/Scopes.html">Scopes</a>
                    </div>
                    <a data-bypass="true" href="https://github.com/JetBrains/resharper-devguide/edit/master/Features/LiveTemplates/Macros.md" class="page-link-to-github" target="_blank" rel="noopener noreferrer" title="Edit this page on GitHub">
                        <i class="github-icon"></i>
                        <span class="text">Edit page</span>
                    </a>

                    <h1>Live Template macros</h1>
                    <p>Of course, plugins can provide macros to extend the list already included with ReSharper (and ReSharper extensions can include Live Templates that refer to these templates, either by bundling the macro plugin into the same extension, or taking a dependency on another extension that contains a macro plugin. See the Packaging page for more details).</p>

<p>Macros are implemented with two classes - a definition, and an implementation. The definition describes the macro, and the implementation handles the macro being invoked.</p>

<a name="macro-definition" class="elem-anchor"></a>
<h2>Macro Definition<a href="#macro-definition" class="anchor-link"><span></span></a></h2>

<p>The macro definition is a class that implements <code class="code highlight language-text">IMacroDefinition</code> and is marked with the <code class="code highlight language-text">MacroDefinitionAttribute</code>. You can derive from <code class="code highlight language-text">SimpleMacroDefinition</code>, which provides a default implementation of the interface.</p>

<p>The attribute derives from the Component Model’s <code class="code highlight language-text">ShellComponentAttribute</code>, which means the definition class is instantiated once when the Shell starts up, and essentially lasts for the length of the lifetime of the application. It consists of three string properties - <code class="code highlight language-text">Name</code>, <code class="code highlight language-text">ShortDescription</code> and <code class="code highlight language-text">LongDescription</code>. The name is a simple identifier for the macro definition, and can be passed to <code class="code highlight language-text">MacroManager.GetMacroDefinition</code> if you need to retrieve a macro definition programmatically. The short description is displayed in the list of macros the template editor shows, and the long description is displayed when the macro definition is selected in this list.</p>

<p>The short description can also contain placeholders that indicate that a macro can be parameterised. This is only for display purposes - parameters are declared by the macro definition class, described below. When the short description is shown in the list of macros in the template editor, the placeholder text is shown in bold, indicating to the user that the macro can be parameterised, and what part is parameterised.</p>

<p>The format of the placeholder is <code class="code highlight language-text">{X:name}</code>, where the <code class="code highlight language-text">X</code> is replaced by the parameter index, and the “name” is the text that is displayed in bold. (Strictly speaking, the “name” text is the name of the parameter, which is why there is also a parameter index. The name is passed to the parameter value UI, where it could be used e.g. as a label, however, it’s not currently used.) For one variable, you can have a description such as “Insert reference to {0:type}”. This states that the macro will take one parameter, called “type”, and the list of macros shown in the template editor will display “type” in bold. Multiple parameters can be referenced by incrementing the parameter index, for example: “Delimited {0:list} of items with {1:delimiter}” could be a macro that uses the first parameter “list” to store a delimited list of string values, using the delimiter specified in the parameter called “delimiter” at index 1.</p>

<p>The <code class="code highlight language-text">IMacroDefinition</code> interface has two members - a <code class="code highlight language-text">Parameters</code> property and a <code class="code highlight language-text">GetPlaceholder</code> method.</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMacroDefinition</span>
<span class="p">{</span>
  <span class="n">ParameterInfo</span><span class="p">[]</span> <span class="n">Parameters</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">string</span> <span class="nf">GetPlaceholder</span><span class="p">(</span><span class="n">IDocument</span> <span class="n">document</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IMacroParameterValue</span><span class="p">&gt;</span> <span class="n">parameters</span><span class="p">);</span>
<span class="p">}</span>
</code></div>

<p>The <code class="code highlight language-text">Parameters</code> property returns an array of <code class="code highlight language-text">ParameterInfo</code> classes that describe the type of the parameters required by the macro. The class is essentially holds an enum, declaring the parameter as either a string, a type, or a reference to another variable in the template. They are used to provide different UI when entering parameter values in the template editor. The <code class="code highlight language-text">SimpleMacroDefinition</code> implementation of <code class="code highlight language-text">Parameters</code> returns an empty array, and should be overridden if required.</p>

<p>The <code class="code highlight language-text">GetPlaceholder</code> method is called when the template is first expanded and before the user has a chance to edit any hotspots. Each hotspot’s macro definition is queried for its placeholder value, and the value is substituted into the expanded text. The expanded text is then formatted, according to the current document’s language. In other words, the purpose of the placeholder value is to provide an appropriate value that allows the resulting text snippet to be accurately parsed and formatted. For example, a macro that is expected to return an identifier (e.g. to populate a variable name) could return a simple placeholder of “a”, which is a valid identifier. However, it shouldn’t return something like “a - b - c”, which is an expression, and if used as an identifier for a variable name, would cause a parse error. The default implementation in <code class="code highlight language-text">SimpleMacroDefinition</code> returns the text “a”, but this can be overridden in a derived class.</p>

<a name="macro-implementation" class="elem-anchor"></a>
<h2>Macro Implementation<a href="#macro-implementation" class="anchor-link"><span></span></a></h2>

<p>The macro’s implementation is handled by a class that implements <code class="code highlight language-text">IMacroImplementation</code> and is marked with the <code class="code highlight language-text">MacroImplementationAttribute</code>. In a similar manner to the macro definition, the <code class="code highlight language-text">SimpleMacroImplementation</code> base class provides a good default implementation to derive from.</p>

<p>The <code class="code highlight language-text">MacroImplementationAttribute</code> defines several members:</p>

<ul>
  <li><code class="code highlight language-text">Definition</code> returns the <code class="code highlight language-text">System.Type</code> of the <code class="code highlight language-text">IMacroDefinition</code> class that is being implemented. For example, the <code class="code highlight language-text">GuidMacroImpl</code> class that implements the macro for the “nguid” template refers to <code class="code highlight language-text">typeof(GuidMacroDef)</code>.</li>
  <li>If the <code class="code highlight language-text">IsExpandAndSkip</code> property is set to true, this effectively makes the hotspot read only. The value is expanded and not changed, and you can no longer tab to the hotspot. The effect is the same as if the variable in the template is marked as not editable.</li>
  <li>The <code class="code highlight language-text">ScopeProvider</code> and <code class="code highlight language-text">GetScopes</code> members allows a macro implementation to state which scopes it supports. This allows you to limit an implementation to files of a specific languages or even locations within these files. The <code class="code highlight language-text">MacroImplementationAttribute</code> defaults this value to set the scope to be “everywhere”, meaning the macro implementation is not limited in where it can be used. In order to override this behaviour, you would need to derive from <code class="code highlight language-text">MacroImplementationAttribute</code> and override the <code class="code highlight language-text">ScopeProvider</code> property to return a new type that implements <code class="code highlight language-text">IMacroImplementationScopeProvider</code>.</li>
</ul>

<p>Multiple implementations can be provided for a single definition, and ReSharper will attempt to find the implementation that has the closest scope, as returned by <code class="code highlight language-text">GetScopes</code>, to the actual scope in use. For example, a scope of “C# file” will be closer than a scope of “everywhere”. If there are multiple implementations, but there is no closest scope, an arbitrary implementation is chosen.</p>

<p>An instance of the implementation class is created for each hotspot. The implementation class can have two constructor parameters injected when the class is created - <code class="code highlight language-text">IHotspotSession</code> and <code class="code highlight language-text">MacroParameterValueCollection</code>. This is how a parameterised implementation gets hold of the parameter values specified in the Live Template. The constructor parameters can be in any order, or not specified at all. However, they must be marked with the <code class="code highlight language-text">[Optional]</code> attribute, because another instance of the implementation is created at shell startup time (<code class="code highlight language-text">MacroImplementationAttribute</code> derives from <code class="code highlight language-text">ShellCompomentAttribute</code>) and neither the session nor the parameter collections are available at that time. This instance will receive <code class="code highlight language-text">null</code> for those parameters. The additional instance is created to map between implementations and definitions, especially when added dynamically from a plugin.</p>

<p><code class="code highlight language-text">IMacroImplementation</code> defines three methods:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMacroImplementation</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="nf">HandleExpansion</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span>
  <span class="n">HotspotItems</span> <span class="nf">GetLookupItems</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span>
  <span class="kt">string</span> <span class="nf">EvaluateQuickResult</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</code></div>

<p>When the template is first expanded, and after the text has been replaced by placeholders and reformatted, each hotspot’s <strong><code class="code highlight language-text">GetLookupItems</code></strong> method is called. If it returns any values, the first is used to replace the placeholder. If no items are returned, the hotspot’s <strong><code class="code highlight language-text">EvaluateQuickResult</code></strong> is called, and that text is used instead.</p>

<p>When hitting <code class="code highlight language-text">tab</code> or <code class="code highlight language-text">shift+tab</code> to move between the hotspots, each hotspot is activated, and the <code class="code highlight language-text">HandleExpansion</code> method is called. This gives the macro implementation the opportunity to handle what happens when the hotspot becomes active, overriding the normal behaviour of showing a completion list of items. For example, the Basic, Smart and Type completion macros invoke the standard code completion components, rather than supplying a list of items to the hotspot manager to display. <strong><code class="code highlight language-text">HandleExpansion</code></strong> should return <code class="code highlight language-text">true</code> if it handles the expansion request, or <code class="code highlight language-text">false</code> otherwise.</p>

<p>The <code class="code highlight language-text">GetLookupItems</code> method can also get called when a hotspot becomes active (so if you take control in <code class="code highlight language-text">HandleExpansion</code>, you should also return <code class="code highlight language-text">null</code> or an empty list here). The returned items are cached, and will be reused if the text hasn’t been changed, so tabbing between multiple hotspots doesn’t cause multiple calls. If the surrounding text changes, the cached items are thrown away, and new items are retrieved, allowing for macros that depend on the surrounding text, such as suggesting names for a variable of a type that can also be edited.</p>

<p><code class="code highlight language-text">GetLookupItems</code> returns an instance of <code class="code highlight language-text">HotspotItems</code>, which maintains a list of <code class="code highlight language-text">ILookupItem</code> instances, as used in code completion. Generally speaking, this will be a list of <code class="code highlight language-text">TextLookupItem</code> instances, to expand to a simple text string. However, you can use any <code class="code highlight language-text">ILookupItem</code> instance; the <code class="code highlight language-text">ILookupItem.Accept</code> method is called to insert the text. For example, the macro to insert a reference to a type derives from <code class="code highlight language-text">TypeLookupItem</code> and overrides a method called from its <code class="code highlight language-text">Accept</code> method in order to properly position the text caret for generic types. You can also use the <code class="code highlight language-text">HotspotItems.Empty</code> instance if you don’t have any lookup items. The list is created once, and doesn’t change as you type, although the values are filtered to match what you are typing.</p>

<p><code class="code highlight language-text">EvaluateQuickResult</code> is called when another hotspot changes. It allows for a macro to be based on the contents of other hotspots, or the surrounding text. If the macro is based on a parameter, such as a constant value from the template editor, or a reference to another hotspot variable, the content can be retreived from the <code class="code highlight language-text">MacroParameterValueCollection</code> passed in to the constructor. To get the value would look something like this:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[MacroImplementation(Definition = typeof(ToUpperMacroDef))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ToUpperMacroImpl</span> <span class="p">:</span> <span class="n">SimpleMacroImplementation</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">IMacroParameterValueNew</span> <span class="n">myArgument</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">ToUpperMacroImpl</span><span class="p">([</span><span class="n">Optional</span><span class="p">]</span> <span class="n">MacroParameterValueCollection</span> <span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">myArgument</span> <span class="p">=</span> <span class="n">arguments</span><span class="p">.</span><span class="nf">OptionalFirstOrDefault</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">EvaluateQuickResult</span><span class="p">(</span><span class="n">IHotspotContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">myArgument</span> <span class="p">==</span> <span class="k">null</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">myArgument</span><span class="p">.</span><span class="nf">GetValue</span><span class="p">().</span><span class="nf">ToUpperInvariant</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<p>As the name suggests, <code class="code highlight language-text">EvaluateQuickResult</code> needs to be quick, as each macro’s implementation is called for every character typed in the current hotspot. Processing should be kept to a minimum.</p>

<a name="ihotspotcontext" class="elem-anchor"></a>
<h2>IHotspotContext<a href="#ihotspotcontext" class="anchor-link"><span></span></a></h2>

<p>All of the methods in <code class="code highlight language-text">IMacroImplementation</code> take <code class="code highlight language-text">IHotspotContext</code> as an argument. This interface has three properties:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IHotspotContext</span>
<span class="p">{</span>
  <span class="n">IHotspotSession</span> <span class="n">HotspotSession</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">IHotspotSessionContext</span> <span class="n">SessionContext</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">DocumentRange</span> <span class="n">ExpressionRange</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></div>

<ul>
  <li><strong><code class="code highlight language-text">IHotspotSession HotspotSession</code></strong> - provides information about the current session, including methods such as <code class="code highlight language-text">GoToNextHotspot</code> and <code class="code highlight language-text">EndSession</code>, <code class="code highlight language-text">GetVariableResult</code> to get the value of a variable by name (as listed in the macro definition’s short description). You can also get the list of hotspots and the current hotspot (which might not be the hotspot associated with the current macro implementation, especially in the call to <code class="code highlight language-text">EvaluateQuickResult</code>).</li>
  <li><strong><code class="code highlight language-text">IHotspotSessionContext SessionContext</code></strong> - the context of where the template is being instantiated, including the solution, documents and offsets.</li>
  <li><strong><code class="code highlight language-text">DocumentRange ExpressionRange</code></strong> - the document range of the current hotspot (again, not necessarily the hotspot for the current macro implementation). You can call <code class="code highlight language-text">ExpressionRange.GetText()</code> to retrieve the value of that hotspot, or <code class="code highlight language-text">HotspotSession.CurrentHotspot.CurrentValue</code>.</li>
</ul>

<a name="helper-methods" class="elem-anchor"></a>
<h2>Helper methods<a href="#helper-methods" class="anchor-link"><span></span></a></h2>

<p>ReSharper provides a couple of useful classes for implementing macros, namely <code class="code highlight language-text">MacroUtil</code> and the <code class="code highlight language-text">IMacroUtil</code> interface. Note that these classes aren’t related! The <code class="code highlight language-text">MacroUtil</code> class is a static class with a couple of useful methods:</p>

<ul>
  <li><strong><code class="code highlight language-text">SimpleEvaluateResult</code></strong> creates an instance of <code class="code highlight language-text">HotspotItems</code> from a single string value. Useful for implementing <code class="code highlight language-text">IMacroImplementation.EvaluateResult</code>.</li>
  <li><strong><code class="code highlight language-text">GetLanguageType</code></strong> and <strong><code class="code highlight language-text">GetFile</code></strong> return information from an instance of <code class="code highlight language-text">IHotspotContext</code></li>
  <li><strong><code class="code highlight language-text">GetMacroUtil</code></strong> returns an instance of <code class="code highlight language-text">IMacroUtil</code></li>
</ul>

<p>The <code class="code highlight language-text">IMacroUtil</code> interface is implemented per language - there is an instance for C#, VB, JS, etc. It contains several methods, that make it easy to e.g. suggest variable types, get the variables that are currently visible, convert a type name into an instance of <code class="code highlight language-text">IType</code>, etc. It’s primary purpose is to support several of the built in macros, so they can be implemented once, and each language can add support for the more language specific parts of the implementation.</p>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Features/LiveTemplates/Scopes.html">Scopes</a>
                    </div>
                    <div class="last-modified">
                        Last modified: 10 July 2017
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>

</body>
</html>

