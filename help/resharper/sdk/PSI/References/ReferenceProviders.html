


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>References / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/help/resharper/sdk/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/help/resharper/sdk/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/help/resharper/sdk/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/help/resharper/sdk/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/help/resharper/sdk/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/help/resharper/sdk/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/help/resharper/sdk/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/help/resharper/sdk/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//PSI/References/ReferenceProviders.html" />
    <meta property="og:site_name" content="JetBrains ReSharper" />
    <meta property="og:title" content="References" />
    <meta property="og:description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00" />
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@JBPlatform" />
    <meta name="twitter:title" content="References" />
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper" />
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/"></meta>
<link  rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body data-id="PSI/References/ReferenceProviders">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a data-bypass="true" href="//youtrack.jetbrains.com/issues/IJSDK">Send feedback</a></p>
                <p>&copy; 2000&ndash;2018 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/PSI/References/CodeCompletion.html">Code Completion</a>
                    </div>
                    <a data-bypass="true" href="https://github.com/JetBrains/resharper-devguide/edit/master/PSI/References/ReferenceProviders.md" class="page-link-to-github" target="_blank" rel="noopener noreferrer" title="Edit this page on GitHub">
                        <i class="github-icon"></i>
                        <span class="text">Edit page</span>
                    </a>

                    <h1>References</h1>
                    <ul id="markdown-toc">
  <li><a href="#creating-the-reference-provider" id="markdown-toc-creating-the-reference-provider"><span>Creating the reference provider</span></a></li>
  <li><a href="#creating-the-references" id="markdown-toc-creating-the-references"><span>Creating the references</span></a></li>
  <li><a href="#implementing-the-references" id="markdown-toc-implementing-the-references"><span>Implementing the references</span></a>    <ul>
      <li><a href="#resolving-results" id="markdown-toc-resolving-results"><span>Resolving results</span></a></li>
      <li><a href="#getreferencesymboltable" id="markdown-toc-getreferencesymboltable"><span>GetReferenceSymbolTable</span></a></li>
      <li><a href="#bindto-and-renaming" id="markdown-toc-bindto-and-renaming"><span>BindTo and renaming</span></a></li>
    </ul>
  </li>
</ul>

<p>Reference Providers are a very powerful extension mechanism in ReSharper. They are used to create a reference from one node in the PSI abstract syntax tree (AST) to another, either in the same file, or in separate files.</p>

<p>ReSharper uses these references in lots of different ways:</p>

<ul>
  <li>Navigation, e.g. Ctrl+Click</li>
  <li>Find Usages</li>
  <li>Rename refactorings</li>
  <li>Code Completion</li>
  <li>Highlighting invalid references (e.g. undefined methods)</li>
</ul>

<p>Given this list, one obvious usage for references is code elements, such as method or variable names. It’s easy to see how a variable name could have a reference to the variable declaration. ReSharper can resolve the reference, and use this target for navigation, or find usage results. It can tell the reference to rename the element it’s attached to, or, if the reference can’t find the target, show the attached element as an error.</p>

<p>One slightly less obvious, but just as powerful, mechanism is to attach references to other elements in the syntax tree, such as xml doc comments, or even string literals. This allows so called “magic strings” to take part in Ctrl+Click navigation, find usages, code completion and more importantly, rename refactorings. References can even be applied to parts of a tree node, which allows for references on a single word within a string literal or other node.</p>

<p>For example, references are used with ASP.NET MVC’s view and action names. Ctrl+Click on the string literal will navigate to the view, or the action’s controller method.</p>

<p><img src="mvc_ctrl_click.png" alt="Navigating to references from an MVC View method" /></p>

<aside class="note">
  <p> References are evaluated on-demand. They do not maintain a direct relationship with their target, but need to be resolved before they can be used. Resolving can fail, in which case the reference is deemed to be invalid, and the attached element marked as an error.</p>
</aside>

<p>A reference provider starts life as an instance of <code class="code highlight language-text">IReferenceProviderFactory</code>, which in turn creates an instance of <code class="code highlight language-text">IReferenceFactory</code> for a given file. The <code class="code highlight language-text">IReferenceFactory</code> then creates one or more instances of <code class="code highlight language-text">IReference</code> for any given node in the PSI tree.</p>

<a name="creating-the-reference-provider" class="elem-anchor"></a>
<h2>Creating the reference provider<a href="#creating-the-reference-provider" class="anchor-link"><span></span></a></h2>

<p>The main entry point to providing references is a class that implements <code class="code highlight language-text">IReferenceProviderFactory</code>. The class should be marked with the <code class="code highlight language-text">ReferenceProviderFactoryAttribute</code>, which is a <code class="code highlight language-text">SolutionComponentAttribute</code>, meaning the class is instantiated once per solution (and destroyed when the solution is closed). The class should implement the following members:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IReferenceProviderFactory</span>
<span class="p">{</span>
  <span class="n">IReferenceFactory</span> <span class="nf">CreateFactory</span><span class="p">(</span><span class="n">IPsiSourceFile</span> <span class="n">sourceFile</span><span class="p">,</span> <span class="n">IFile</span> <span class="n">file</span><span class="p">);</span>
  <span class="k">event</span> <span class="n">Action</span> <span class="n">OnChanged</span><span class="p">;</span>
<span class="p">}</span>
</code></div>

<p>The <strong><code class="code highlight language-text">CreateFactory</code></strong> method receives both the <code class="code highlight language-text">IPsiSourceFile</code> object that provides metadata about the file, and the <code class="code highlight language-text">IFile</code> object which is the root of the PSI tree. It can use these files to decide if it supports creating references for this file type. For example, it can look at the language of the file:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">if</span> <span class="p">(</span><span class="n">sourceFile</span><span class="p">.</span><span class="n">PrimaryPsiLanguage</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="n">CSharpLanguage</span><span class="p">&gt;())</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MyReferenceFactory</span><span class="p">();</span>
<span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</code></div>

<p>If the file language is supported, the <code class="code highlight language-text">IReferenceFactory</code> is created and returned. If not, null is returned, indicating this reference provider doesn’t provide references in this case.</p>

<p>The <code class="code highlight language-text">IReferenceProviderFactory</code> interface also provides an <strong><code class="code highlight language-text">OnChanged</code></strong> event. ReSharper subscribes to this event, and will recreate any associated references when it’s fired. This is useful if, for example, your reference provider could be disabled by a flag on an options page.</p>

<a name="creating-the-references" class="elem-anchor"></a>
<h2>Creating the references<a href="#creating-the-references" class="anchor-link"><span></span></a></h2>

<p>The <code class="code highlight language-text">IRefrenceProviderFactory</code> returns an instance of <code class="code highlight language-text">IReferenceFactory</code> for a particular PSI file. This class is responsible for creating one or more reference for a given node in the file. It has two methods:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IReferenceFactory</span>
<span class="p">{</span>
  <span class="n">IReference</span><span class="p">[]</span> <span class="nf">GetReferences</span><span class="p">(</span><span class="n">ITreeNode</span> <span class="n">element</span><span class="p">,</span> <span class="n">IReference</span><span class="p">[]</span> <span class="n">oldReferences</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">HasReference</span><span class="p">(</span><span class="n">ITreeNode</span> <span class="n">element</span><span class="p">,</span> <span class="n">ICollection</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span><span class="p">);</span>
<span class="p">}</span>
</code></div>

<p>Before references are created, the <strong><code class="code highlight language-text">HasReferences</code></strong> method is called, passing in the <code class="code highlight language-text">ITreeNode</code> that is to be the source of the reference, e.g. the variable or string literal, etc. The collection of names that is passed in is used to help validate the cached references - if the node doesn’t have any references by that name, the cached references don’t have to be recreated, even if the PSI tree has been changed and the cache is (strictly speaking) outdated.</p>

<p>The implementation of <code class="code highlight language-text">HasReferences</code> is usually very straightforward. A reference can have one or more names. Usually, it has just one name - the text of the PSI node. For example, a reference added to a method invocation would have the name of the method as the reference name. A reference might have more than one name, in the case where an element can be referred to in multiple ways, such as “TestAttribute” can be used as <code class="code highlight language-text">[TestAttribute]</code> or <code class="code highlight language-text">[Test]</code>.</p>

<p>We’ll use the example of a reference provider adding a reference between a string literal and a property name, to support nunit’s <code class="code highlight language-text">[TestCaseSource("MyProperty")]</code> attribute. Here’s the implementation of <code class="code highlight language-text">HasReferences</code>:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">HasReference</span><span class="p">(</span><span class="n">ITreeNode</span> <span class="n">element</span><span class="p">,</span> <span class="n">ICollection</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">names</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Check it's a string literal, and the text of the</span>
  <span class="c1">// string literal is in the collection of names</span>
  <span class="kt">var</span> <span class="n">literal</span> <span class="p">=</span> <span class="n">element</span> <span class="k">as</span> <span class="n">ILiteralExpression</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">literal</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">literal</span><span class="p">.</span><span class="n">ConstantValue</span><span class="p">.</span><span class="n">Value</span> <span class="k">is</span> <span class="kt">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">names</span><span class="p">.</span><span class="nf">Contains</span><span class="p">((</span><span class="kt">string</span><span class="p">)</span> <span class="n">literal</span><span class="p">.</span><span class="n">ConstantValue</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></div>

<p>Note that this implementation doesn’t do an exhaustive check - it’s looking that the node is a string literal, but not that it’s a string literal inside an attribute declaration where the attribute name is <code class="code highlight language-text">TestCaseSourceAttribute</code>. It’s simply a quick check to try and short circuit unnecessary cache revalidation.</p>

<p>If the consumer doesn’t pass in a collection of names, <code class="code highlight language-text">HasReferences</code> isn’t called, and the cached references are used, or recalculated.</p>

<p>To actually get the references, ReSharper calls <strong><code class="code highlight language-text">GetReferences</code></strong>. It passes in the PSI tree node, and an array of existing references, and expects an array of references to be returned. Taking our example of nunit’s <code class="code highlight language-text">[TestCaseSource("MyProperty"])</code>, the code to create a reference between the string literal “MyProperty” and the property on the current class called “MyProperty” would look something like:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">ClrTypeName</span> <span class="n">TestCaseSourceAttribute</span> <span class="p">=</span>
  <span class="k">new</span> <span class="nf">ClrTypeName</span><span class="p">(</span><span class="s">"NUnit.Framework.TestCaseSourceAttribute"</span><span class="p">);</span>

<span class="k">public</span> <span class="n">IReference</span><span class="p">[]</span> <span class="nf">GetReferences</span><span class="p">(</span><span class="n">ITreeNode</span> <span class="n">element</span><span class="p">,</span> <span class="n">IReference</span><span class="p">[]</span> <span class="n">oldReferences</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">literal</span> <span class="p">=</span> <span class="n">element</span> <span class="k">as</span> <span class="n">ILiteralExpression</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">literal</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">literal</span><span class="p">.</span><span class="n">ConstantValue</span><span class="p">.</span><span class="n">Value</span> <span class="k">is</span> <span class="kt">string</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">argumentExpression</span> <span class="p">=</span> <span class="n">literal</span> <span class="k">as</span> <span class="n">ICSharpExpression</span>
    <span class="kt">var</span> <span class="n">attribute</span> <span class="p">=</span> <span class="n">AttributeNavigator</span><span class="p">.</span><span class="nf">GetByConstructorArgumentExpression</span><span class="p">(</span><span class="n">argumentExpression</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">attribute</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">var</span> <span class="n">@class</span> <span class="p">=</span> <span class="n">attribute</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Reference</span><span class="p">.</span><span class="nf">Resolve</span><span class="p">().</span><span class="n">DeclaredElement</span> <span class="k">as</span> <span class="n">IClass</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">@class</span> <span class="p">!=</span> <span class="k">null</span>
        <span class="p">&amp;&amp;</span> <span class="nf">Equals</span><span class="p">(</span><span class="n">@class</span><span class="p">.</span><span class="nf">GetClrName</span><span class="p">(),</span> <span class="n">TestCaseSourceAttribute</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="kt">var</span> <span class="n">method</span> <span class="p">=</span> <span class="n">MethodDeclarationNavigator</span><span class="p">.</span><span class="nf">GetByAttribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">method</span><span class="p">.</span><span class="n">DeclaredElement</span> <span class="p">!=</span> <span class="k">null</span>
          <span class="p">&amp;&amp;</span> <span class="n">typeElement</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">typeElement</span> <span class="p">=</span> <span class="n">method</span><span class="p">.</span><span class="n">DeclaredElement</span><span class="p">.</span><span class="nf">GetContainingType</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">typeElement</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="n">IReference</span><span class="p">[]</span>
            <span class="p">{</span>
              <span class="k">new</span> <span class="nf">PropertyDataReference</span><span class="p">(</span><span class="n">typeElement</span><span class="p">,</span> <span class="n">literal</span><span class="p">)</span>
            <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">EmptyArray</span><span class="p">&lt;</span><span class="n">IReference</span><span class="p">&gt;.</span><span class="n">Instance</span><span class="p">;</span>
<span class="p">}</span>
</code></div>

<p>The process breaks down like this:</p>

<ol>
  <li>Check the node is a string literal</li>
  <li>Use <code class="code highlight language-text">AttributeNavigator</code> to find an attribute, given an argument in the constructor. This walks up the PSI tree from the string literal, looking for an attribute usage. It it fails to find the attribute, it returns null</li>
  <li>Get the class name of the attribute, by getting it’s <code class="code highlight language-text">Name</code> property, which is itself a reference to the <code class="code highlight language-text">TestCaseSourceAttribute</code> class. Resolve the reference, get the declared element and ensure the attribute is an instance of <code class="code highlight language-text">NUnit.Framework.TestCaseSourceAttribute</code></li>
  <li>Use <code class="code highlight language-text">MethodDeclarationNavigator</code> to find the method declaration that the attribute is applied to</li>
  <li>From the method declaration, get the containing type. This is required to find the property with the same value as the string literal</li>
  <li>Create a new reference using the custom class <code class="code highlight language-text">PropertyDataReference</code> (detailed in the next section), passing in the class declaration and the string literal node</li>
</ol>

<p>Note that this method doesn’t try to resolve the reference - it doesn’t look to see if the property named by the string literal exists on the type. This is handled by the reference. If it can’t be resolved, the reference is invalid, and ReSharper will mark the string literal as an unresolved error.</p>

<p>Also note that this implementation doesn’t make use of the <code class="code highlight language-text">oldReferences</code> parameter. Ideally, the reference provider should examine the old references to see if they are still valid. What this means depends on the context of the reference. In this instance, we can check that the old reference’s string literal is the same value, and the type element is still valid. In that case, we could just return the old references directly. An alternative strategy is to create the new references and compare before returning. If the old references are the same, return the old reference instances.</p>

<p>Finally, it is perfectly acceptable to return more than one reference, if there can be multiple targets for the element, or the node can be broken into substrings that can be references. For example, the MVC <code class="code highlight language-text">View()</code> method could have multiple references, one to the definition of the method <code class="code highlight language-text">View</code> and one to the view associated with the containing controller method. If there are multiple references on a single element, when hitting Ctrl+Click, ReSharper will show a popup menu with a choice of target for navigation. Similarly, a file path reference provider, which is applied to a string literal representing a file path, returns a new reference for each path segment. That is, “C:\work\projects\foo.txt” returns 4 references, one for each path segment.</p>

<p>(Also note that this is an incomplete implementation of support for <code class="code highlight language-text">TestCaseSourceAttribute</code>. It should also support the <code class="code highlight language-text">SourceType</code> value to allow the property to be defined on a different class. To do this, you would find an <code class="code highlight language-text">ITypeofExpression</code> and use that to get the type element passed to the reference.)</p>

<a name="implementing-the-references" class="elem-anchor"></a>
<h2>Implementing the references<a href="#implementing-the-references" class="anchor-link"><span></span></a></h2>

<p>The <code class="code highlight language-text">IReference</code> interface has the following structure:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IReference</span> <span class="p">:</span> <span class="n">IUserDataHolder</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">HasMultipleNames</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ResolveResultWithInfo</span> <span class="n">CurrentResolveResult</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ITreeNode</span> <span class="nf">GetTreeNode</span><span class="p">();</span>
  <span class="kt">string</span> <span class="nf">GetName</span><span class="p">();</span>
  <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetAllNames</span><span class="p">();</span>
  <span class="n">ISymbolTable</span> <span class="nf">GetReferenceSymbolTable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">useReferenceName</span><span class="p">);</span>
  <span class="n">ResolveResultWithInfo</span> <span class="nf">Resolve</span><span class="p">();</span>
  <span class="n">TreeTextRange</span> <span class="nf">GetTreeTextRange</span><span class="p">();</span>
  <span class="n">IReference</span> <span class="nf">BindTo</span><span class="p">(</span><span class="n">IDeclaredElement</span> <span class="n">element</span><span class="p">);</span>
  <span class="n">IReference</span> <span class="nf">BindTo</span><span class="p">(</span><span class="n">IDeclaredElement</span> <span class="n">element</span><span class="p">,</span> <span class="n">ISubstitution</span> <span class="n">substitution</span><span class="p">);</span>
  <span class="n">IAccessContext</span> <span class="nf">GetAccessContext</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">();</span>
<span class="p">}</span>
</code></div>

<ul>
  <li><code class="code highlight language-text">Resolve</code> and <code class="code highlight language-text">CurrentResolveResult</code> are used to find the target of the reference. They return a <code class="code highlight language-text">ResolveResultWithInfo</code> that contains the result (<code class="code highlight language-text">OK</code> or <code class="code highlight language-text">NOT_RESOLVED</code>, etc) and information, such as the <code class="code highlight language-text">IDeclaredElement</code> that is the target</li>
  <li><code class="code highlight language-text">HasMultipleNames</code> and <code class="code highlight language-text">GetAllNames</code> allow the reference to have more than one name. Normally, the reference will only have one name, which will correspond to the text of the owner element (one exception to this is a constructor initialiser, which has a name of <code class="code highlight language-text">this</code> or <code class="code highlight language-text">base</code>). However, references to attributes can have multiple names - an attribute can be used either as <code class="code highlight language-text">[Test]</code> or <code class="code highlight language-text">[TestAttribute]</code>. In this case <code class="code highlight language-text">HasMultipleNames</code> should return true, and <code class="code highlight language-text">GetAllNames</code> should include the full name and the truncated name</li>
  <li><code class="code highlight language-text">GetTreeNode</code> and <code class="code highlight language-text">GetTreeTextRange</code> return the node from the tree and the range within the tree that is the source of the reference. Usually, this is the range of the node of the tree - <code class="code highlight language-text">GetTreeNode().GetTreeTextRange()</code>. However, it is possible to return a different range here to allow for a reference to be a substring of the node, such as single word in a string literal</li>
  <li><code class="code highlight language-text">GetReferenceSymbolTable</code> should return an instance of <code class="code highlight language-text">ISymbolTable</code> that contains symbols relevant to the reference. Using the <code class="code highlight language-text">TestCaseSourceAttribute</code> example, this will return all symbols for the type that the attribute is concerned with. If you pass <code class="code highlight language-text">true</code> for the <code class="code highlight language-text">useReferenceName</code> parameter, the symbols are filtered down to match the name(s) of the reference</li>
  <li><code class="code highlight language-text">GetAccessContext</code> returns an instance of <code class="code highlight language-text">IAccessContext</code>. This can usually be deferred to a new instance of <code class="code highlight language-text">ElementAccessContext</code>, passing in the owner tree node</li>
  <li><code class="code highlight language-text">BindTo</code> allows references to take part in rename refactorings. The reference is bound to the new element in the PSI tree, created with the new name. It should update its owner element to reflect this change.</li>
</ul>

<p>Normally, it is not necessary to implement the whole interface, but derive from a base class, such as <code class="code highlight language-text">TreeReferenceBase&lt;TOwnerElement&gt;</code>. This takes the type of the owner element as a type parameter, such as <code class="code highlight language-text">TreeReferenceBase&lt;ILiteralExpression&gt;</code>. It also maintains the cached results of a call to <code class="code highlight language-text">Resolve</code>.</p>

<a name="resolving-results" class="elem-anchor"></a>
<h3>Resolving results<a href="#resolving-results" class="anchor-link"><span></span></a></h3>

<p>When implementing a class deriving from <code class="code highlight language-text">TreeReferenceBase</code>, the most interesting method to implement is <code class="code highlight language-text">ResolveWithoutCache</code>. For our <code class="code highlight language-text">TestCaseSourceAttribute</code> example, the implementation looks like this:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">override</span> <span class="n">ResolveResultWithInfo</span> <span class="nf">ResolveWithoutCache</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetReferenceSymbolTable</span><span class="p">(</span><span class="k">true</span><span class="p">).</span><span class="nf">GetResolveResult</span><span class="p">(</span><span class="nf">GetName</span><span class="p">());</span>
<span class="p">}</span>
</code></div>

<p>This defers to <code class="code highlight language-text">GetReferenceSymbolTable</code>, passing in true to filter the symbol table down to just those symbols that match the reference name. It then uses the <code class="code highlight language-text">ISymbolTable.GetResolveResult</code> method to get a <code class="code highlight language-text">ResolveResultWithInfo</code> instance for the reference name. The <code class="code highlight language-text">ResolveResultWithInfo</code> class maintains a result, plus an error type. The result gives access to the declared element, or candidates if more than one possible value was found. The error type uses the <code class="code highlight language-text">ResolveErrorType</code> enum pattern class, and can be one of many values. The most popular include <code class="code highlight language-text">ResolveErrorType.OK</code>, <code class="code highlight language-text">ResolveErrorType.IGNORABLE</code>, <code class="code highlight language-text">ResolveErrorType.NOT_RESOLVED</code> and so on. There are also sub-types of <code class="code highlight language-text">ResolveErrorType</code> that provide more explicit errors, such as <code class="code highlight language-text">CSharpResolveErrorType.OPERATOR_IS_NOT_APPLICABLE</code> or <code class="code highlight language-text">CssResolveErrorType.CLASS_NOT_RESOLVED</code>. Which value you use depends on your situation - you can either just use the value returned from the <code class="code highlight language-text">ISymbolTable</code>, or use one of the predefined errors in <code class="code highlight language-text">ResolveErrorType</code> and derived classes.</p>

<p>If the value isn’t <code class="code highlight language-text">ResolveErrorType.OK</code>, it is considered to be an invalid reference, and the owner tree node will be marked as an error.</p>

<p>Once the <code class="code highlight language-text">ResolveWithoutCache</code> method has been called, the value is stored in <code class="code highlight language-text">CurrentResolveResult</code> until the owner tree node changes.</p>

<a name="getreferencesymboltable" class="elem-anchor"></a>
<h3>GetReferenceSymbolTable<a href="#getreferencesymboltable" class="anchor-link"><span></span></a></h3>

<p>This method should return a symbol table with all symbols relevant for the reference. If the <code class="code highlight language-text">useReferenceName</code> parameter is <code class="code highlight language-text">false</code>, it should return a set of candidates that could be used as the target for the reference. For example, in our <code class="code highlight language-text">TestCaseSourceAttribute</code> reference, we could implement it like this:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">override</span> <span class="n">ISymbolTable</span> <span class="nf">GetReferenceSymbolTable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">useReferenceName</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">symbolTable</span> <span class="p">=</span> <span class="n">ResolveUtil</span>
      <span class="p">.</span><span class="nf">GetSymbolTableByTypeElement</span><span class="p">(</span><span class="n">typeElement</span><span class="p">,</span>
                                   <span class="n">SymbolTableMode</span><span class="p">.</span><span class="n">FULL</span><span class="p">,</span>
                                   <span class="n">typeElement</span><span class="p">.</span><span class="n">Module</span><span class="p">);</span>

  <span class="n">symbolTable</span> <span class="p">=</span> <span class="n">symbolTable</span><span class="p">.</span><span class="nf">Distinct</span><span class="p">().</span><span class="nf">Filter</span><span class="p">(</span><span class="n">propertyFilter</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">useReferenceName</span>
         <span class="p">?</span> <span class="n">symbolTable</span><span class="p">.</span><span class="nf">Filter</span><span class="p">(</span><span class="nf">GetName</span><span class="p">(),</span> <span class="n">exactNameFilter</span><span class="p">)</span>
         <span class="p">:</span> <span class="n">symbolTable</span><span class="p">;</span>
<span class="p">}</span>
</code></div>

<p>This uses the <code class="code highlight language-text">ResolveUtil.GetSymbolTableByElement</code> method to retrieve a full symbol table for the class that declares the property we’re looking for. We then ensure we’re dealing with a distinct set of symbols, and filter using our <code class="code highlight language-text">propertyFilter</code>. This is a field set up with a <code class="code highlight language-text">new PredicateFilter(FilterToApplicableProperties)</code>. The method <code class="code highlight language-text">FilterToApplicableProperties</code> takes in a symbol, gets the declared element and checks to see if it’s applicable - is it a property, public, has the right signature and so on.</p>

<p>Once we have our symbol table, we further filter it if <code class="code highlight language-text">useReferenceName</code> is true. If so, we only get any symbols that match the name of the reference, using a <code class="code highlight language-text">new ExactNameFilter</code>.</p>

<a name="bindto-and-renaming" class="elem-anchor"></a>
<h3>BindTo and renaming<a href="#bindto-and-renaming" class="anchor-link"><span></span></a></h3>

<p>When an item is renamed its element is recreated and replaced in the tree. The references that target it are then updated, by calling <code class="code highlight language-text">BindTo</code>, passing in the new <code class="code highlight language-text">IDeclaredElement</code> instance. The reference needs to update the owner tree node, and return a potentially new reference to reflect the change. The implementation is quite straightforward. Again, using our <code class="code highlight language-text">TestCaseSourceAttribute</code> example:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">override</span> <span class="n">IReference</span> <span class="nf">BindTo</span><span class="p">(</span><span class="n">IDeclaredElement</span> <span class="n">element</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">literalAlterer</span> <span class="p">=</span> <span class="n">StringLiteralAltererUtil</span>
    <span class="p">.</span><span class="nf">CreateStringLiteralByExpression</span><span class="p">(</span><span class="n">myOwner</span><span class="p">);</span>
  <span class="n">literalAlterer</span><span class="p">.</span><span class="nf">Replace</span><span class="p">((</span><span class="kt">string</span><span class="p">)</span> <span class="n">myOwner</span><span class="p">.</span><span class="n">ConstantValue</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
    <span class="n">element</span><span class="p">.</span><span class="n">ShortName</span><span class="p">,</span> <span class="n">myOwner</span><span class="p">.</span><span class="nf">GetPsiModule</span><span class="p">());</span>
  <span class="kt">var</span> <span class="n">newOwner</span> <span class="p">=</span> <span class="n">literalAlterer</span><span class="p">.</span><span class="n">Expression</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(!</span><span class="n">myOwner</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">newOwner</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">newOwner</span><span class="p">.</span><span class="n">FindReference</span><span class="p">&lt;</span><span class="n">PropertyDataReference</span><span class="p">&gt;()</span> <span class="p">??</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></div>

<p>This uses the <code class="code highlight language-text">StringLiteralAltererUtil</code> class to create an instance of <code class="code highlight language-text">IStringLiteralAlterer</code>. Calling <code class="code highlight language-text">Replace</code> will replace the existing string literal element in the tree. The literal alterer’s <code class="code highlight language-text">Expression</code> property is the new <code class="code highlight language-text">ILiteralExpression</code> node in the tree. If the owners are different (they might be altered in place), we look for a new reference applied to the node (ReSharper will usually set this up when the new literal expression is created) and return it, otherwise we return the current reference.</p>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/PSI/References/CodeCompletion.html">Code Completion</a>
                    </div>
                    <div class="last-modified">
                        Last modified: 10 July 2017
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>

</body>
</html>

