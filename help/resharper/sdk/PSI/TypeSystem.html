<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>类型系统/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//PSI/TypeSystem.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Type System">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Type System">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="PSI/TypeSystem">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/PSI/References.html">引用</a> <a class="navigation-links__next" href="/PSI/Caching.html">缓存</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/PSI/TypeSystem.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>类型系统</h1>
                    <ul id="markdown-toc">
  <li><a href="#iexpressiontype" id="markdown-toc-iexpressiontype"><span>IExpressionType</span></a></li>
  <li><a href="#itype" id="markdown-toc-itype"><span>类型</span></a></li>
  <li><a href="#ideclaredtype" id="markdown-toc-ideclaredtype"><span>IDeclaredType</span></a></li>
  <li><a href="#ideclaredelement" id="markdown-toc-ideclaredelement"><span>IDeclaredElement</span></a></li>
  <li><a href="#declared-element-types" id="markdown-toc-declared-element-types"><span>声明的元素类型</span></a></li>
  <li><a href="#iclrdeclaredelement" id="markdown-toc-iclrdeclaredelement"><span>IClrDeclaredElement</span></a></li>
  <li><a href="#itypeelement" id="markdown-toc-itypeelement"><span>ITypeElement</span></a></li>
</ul>

<p>任何一种面向对象的结构的操作必然涉及与<em>类型</em> ，如工作<code class="code highlight language-text">int</code> ， <code class="code highlight language-text">string</code>或者说<code class="code highlight language-text">MyType<U,V></code> 。可以预见，ReSharper具有许多数据结构，允许插件编写者识别和自省类型，无论这些类型是否可作为代码使用。</p>

<aside class="tip">
  <p>使用“ <em>浏览类型层次结构”</em> （ <em>Ctrl + E，H</em> ）命令来浏览各种<em>层次结构</em> <code class="code highlight language-text">IXxxType</code>接口。</p>
</aside>

<a name="iexpressiontype" class="elem-anchor"></a>
<h2>IExpressionType<a href="#iexpressiontype" class="anchor-link"><span></span></a></h2>

<p><img src="iexpressiontype_hierarchy.png" alt="IExpressionType的类型层次结构"></p>

<p>在“类型层次结构”的最顶部，我们有<code class="code highlight language-text">IExpressionType</code>接口。这是一个广泛的接口，涵盖了表达式可能是的任何类型，并且恰好涵盖了主要的“具体”接口<code class="code highlight language-text">IType</code> 。</p>

<p>除了<code class="code highlight language-text">IType</code> ，直接实现的接口和类<code class="code highlight language-text">IExpressionType</code>通常是特定于语言的。此类表达类型的示例包括C＃ <code class="code highlight language-text">EventType</code>或VB的<code class="code highlight language-text">IVBNothingType</code> 。</p>

<p>的<code class="code highlight language-text">IExpressionType</code>定义所有表达式类型都遵守的基本接触。因此，描述其某些成员是有意义的。</p>

<ul>
  <li><code class="code highlight language-text">IsResolved</code> -此属性告诉我们此类型是否实际上已经解析为某种东西。例如，如果表达式类型为<code class="code highlight language-text">StringBuilder</code> ，ReSharper会将其解决<code class="code highlight language-text">System.Text.StringBuilder</code> 。但是，如果表达式类型为<code class="code highlight language-text">Foo</code>此类还不存在， <code class="code highlight language-text">IsResolved</code>将是错误的。这也涵盖了<em>类型替换</em>的棘手问题，我们将在后面讨论。</li>
  <li><code class="code highlight language-text">IsUnknown</code> -确定此类型是否未知，即无法正确显示。</li>
  <li><code class="code highlight language-text">IsValid()</code> -检查类型是否引用有效的<em>声明元素</em> 。</li>
  <li><code class="code highlight language-text">IsImplicitlyConvertibleTo()</code>和<code class="code highlight language-text">IsExplicitlyConvertibleTo()</code>检查此类型是隐式还是显式可转换为某种类型（ <code class="code highlight language-text">IType</code> ）通过<em>类型转换规则</em> 。类型转换规则本身就是实现<code class="code highlight language-text">ITypeConversionRule</code>接口。例如，要使用C＃类型转换规则，可以使用<code class="code highlight language-text">CSharpTypeConversionRule.Instance</code> 。</li>
</ul>

<p>那哪里呢<code class="code highlight language-text">IExpressionType</code>用过的？好吧，最明显的例子是，如果您有一个表达式（即<code class="code highlight language-text">IExpression</code> ），您可以使用<code class="code highlight language-text">GetExpressionType()</code>获得表达式的方法<code class="code highlight language-text">IExpressionType</code> 。当然，在大多数情况下，表达式类型应该是实际的对象类型，在这种情况下，调用<code class="code highlight language-text">IExpressionType.ToIType()</code>方法。当然，它会返回<code class="code highlight language-text">null</code>如果所讨论的表达式不是<code class="code highlight language-text">IType</code> 。</p>

<p>现在让我们来看看<code class="code highlight language-text">IType</code>接口。</p>

<a name="itype" class="elem-anchor"></a>
<h2>类型<a href="#itype" class="anchor-link"><span></span></a></h2>

<p>的<code class="code highlight language-text">IType</code>接口用于表示各种类型构造-不仅是单个类型，还包括匿名类型，数组，指针等构造。</p>

<p><code class="code highlight language-text">IType</code>也是一个界面，其中有一些我们需要讨论的成员：</p>

<ul>
  <li><code class="code highlight language-text">GetPresentableName</code> -这将返回特定语言（例如C＃或VB.NET）的可显示类型的名称。在使用最短和最简洁的字符串的意义上，返回的字符串是“可表示的”。例如，一个32位整数将在C＃中显示为<code class="code highlight language-text">int</code>并不是<code class="code highlight language-text">System.Int32</code> 。</li>
  <li><code class="code highlight language-text">GetScalarType()</code>返回一个<em>声明的类型</em> ，该类型与该类型的“标量”部分相对应。所以，如果你<code class="code highlight language-text">IType</code>碰巧是<code class="code highlight language-text">int *</code> （指向<code class="code highlight language-text">int</code> ），返回<code class="code highlight language-text">IDeclaredType</code>将对应于<code class="code highlight language-text">int</code> 。</li>
  <li><code class="code highlight language-text">Classify</code>是一个属性，可帮助您确定类型是值还是引用类型。 <code class="code highlight language-text">null</code>如果无法确定，则返回。</li>
</ul>

<p>在所有实现的接口中<code class="code highlight language-text">IType</code> ，我们最感兴趣的是<code class="code highlight language-text">IDeclaredType</code> ，因此让我们讨论所有内容。</p>

<a name="ideclaredtype" class="elem-anchor"></a>
<h2>IDeclaredType<a href="#ideclaredtype" class="anchor-link"><span></span></a></h2>

<p>的<code class="code highlight language-text">IDeclaredType</code>是使用类型时最常看到的接口类型。本质上， <code class="code highlight language-text">IDeclaredType</code>是可能具有声明的类型的接口（即，它可能对应于某些<code class="code highlight language-text">ITypeElement</code> ）。声明类型的示例可能是<code class="code highlight language-text">int</code>要么<code class="code highlight language-text">Foo</code> ，前提是您有以下声明<code class="code highlight language-text">Foo</code> ， 当然。</p>

<p>界面最重要的成员是<code class="code highlight language-text">GetTypeElement()</code> ，可能会返回一个对应的<code class="code highlight language-text">ITypeElement</code>要么<code class="code highlight language-text">null</code>如果没有人。其他成员包括：</p>

<ul>
  <li><code class="code highlight language-text">GetClrName()</code> -返回CLR名称（ <code class="code highlight language-text">IClrTypeName</code> ）的类型。然后，可以使用此接口来获取类型的简称和全名，获取该类型的名称空间名称的列表，依此类推。</li>
  <li><code class="code highlight language-text">GetSubstitution()</code> -返回为此类型创建的替代。替代是用具体类型替换类型参数（即通用参数）的机制。</li>
  <li><code class="code highlight language-text">Resolve()</code>尝试解决此类型。所结果的<code class="code highlight language-text">IResolveResult</code>的<code class="code highlight language-text">IsValid()</code>可以调用方法检查解析是否成功。</li>
  <li><code class="code highlight language-text">IsSubtypeOf()</code> -确定此类型是否为其他类型的子类型<code class="code highlight language-text">IDeclaredType</code> 。</li>
</ul>

<p>但这还不是全部！除了以上成员外，还有一个<code class="code highlight language-text">DeclaredTypeExtensions</code>类，提供其他实用程序方法。例如， <code class="code highlight language-text">GetSuperTypes()</code>方法返回的枚举<code class="code highlight language-text">IDeclaredType</code>对应于此类型的父母。</p>

<p>我们已经研究了类型的层次结构，但这对我们有什么帮助？好了，现在我们对类型有所了解，我们可以开始研究另一个层次结构- <em>声明元素</em>的层次结构。</p>

<a name="ideclaredelement" class="elem-anchor"></a>
<h2>IDeclaredElement<a href="#ideclaredelement" class="anchor-link"><span></span></a></h2>

<p><img src="ideclaredelement_hierarchy.png" alt="IDeclaredElement的类型层次结构"></p>

<p>的<code class="code highlight language-text">IDeclaredElement</code>是ReSharper的über界面，用于定义ReSharper中的各种<em>物理</em>语言结构。从<em>物理</em>上讲，我们假定已经为它们构建了PSI树，换句话说，我们具有定义此元素的源代码。声明的元素不仅用于表示不同的构造（例如CLR类或CSS函数），而且还表示结构的不同方面。</p>

<p>让我们尝试从上到下的概述<code class="code highlight language-text">IDeclaredElement</code>首先查看其成员以了解其接口及其实现者。</p>

<ul>
  <li><code class="code highlight language-text">GetDeclarations()</code>返回声明（即， <code class="code highlight language-text">IDeclaration</code> s）此声明的元素包含。我们将在一段时间后声明。</li>
  <li><code class="code highlight language-text">ShortName</code>返回已声明元素的“友好名称”。</li>
  <li><code class="code highlight language-text">GetElementType</code>返回声明的元素的类型。该值通常与语言有关，即对于C＃元素，例如<code class="code highlight language-text">CSharpDeclaredElementType</code> 。</li>
  <li><code class="code highlight language-text">PresentationLanguage</code>影响用于创建此类型的语言。</li>
  <li><code class="code highlight language-text">GetSourceFiles()</code>返回的集合<code class="code highlight language-text">IPsiSourceFile</code>包含此类型定义的`。（请记住，由于<code class="code highlight language-text">partial</code>类型，类型定义可以跨越多个文件。）</li>
  <li><code class="code highlight language-text">HasDeclarationsIn()</code>使您可以检查已声明元素的任何声明是否出现在特定文件中。</li>
</ul>

<p>让我们在继承层次结构中向下钻取一层，并讨论各种声明的元素类型。</p>

<a name="declared-element-types" class="elem-anchor"></a>
<h2>声明的元素类型<a href="#declared-element-types" class="anchor-link"><span></span></a></h2>

<p>大部分类型<code class="code highlight language-text">IDeclaredElement</code>是反映平台特定或语言特定的声明元素的接口。当前，已声明CSS，HTML，JavaScript，Razor，CLR语言等元素类型。还有一些非常具体的声明元素，例如<code class="code highlight language-text">ILabel</code>之所以出现在这个阶段，仅仅是因为没有其他合适的位置。</p>

<p>在本指南的背景下，我们将看一下<code class="code highlight language-text">IClrDeclaredElement</code>接口，可预测地反映了CLR（C＃，VB.NET）语言的声明的元素。</p>

<a name="iclrdeclaredelement" class="elem-anchor"></a>
<h2>IClrDeclaredElement<a href="#iclrdeclaredelement" class="anchor-link"><span></span></a></h2>

<p>该接口包含很多内容，其主要职责是描述其实现者是CLR声明的元素。除了产生一个<code class="code highlight language-text">IPsiModule</code>句柄，它也可以通过以下方式返回其包含类型（如果有） <code class="code highlight language-text">GetContainingType()</code>或通过包含类型成员<code class="code highlight language-text">GetContainingTypeMember()</code> 。</p>

<p>这个接口对我们很有趣，因为它具有直接的后代。值得一提的是：</p>

<ul>
  <li><code class="code highlight language-text">IAttributesOwner</code> -该接口由可以用属性修饰的任何声明的元素实现。通常，您将使用此接口来操纵某些元素已附加到其上的属性。</li>
  <li><code class="code highlight language-text">IParametersOwner</code> -如果声明元素采用参数（请注意，我们所说的是<em>普通</em>参数，而不是类型参数），则此接口可帮助我们操纵它们。</li>
  <li><code class="code highlight language-text">ITypeOwner</code> -表示已声明的元素具有自己的类型。</li>
  <li><code class="code highlight language-text">ITypeParametersOwner</code> -表示此声明的元素具有类型参数。示例是类和方法。</li>
</ul>

<aside class="note">
  <p>：具体声明的元素可以实现多个接口。结果，一个声明的元素可以既是<code class="code highlight language-text">ITypeOwner</code>和<code class="code highlight language-text">ITypeParametersOwner</code> 。大多数声明的元素实现多个接口。</p>
</aside>

<a name="itypeelement" class="elem-anchor"></a>
<h2>ITypeElement<a href="#itypeelement" class="anchor-link"><span></span></a></h2>

<p>在讨论此类<em>类型时</em> ，让我们讨论CLR类型及其公开方式。沿着继承层次结构走下<code class="code highlight language-text">IClrDeclaredElement</code>我们首先遇到<code class="code highlight language-text">ITypeParametersOwner</code>如前所述，该接口由可以具有类型参数的任何构造实现。此接口仅公开一个属性，列出了<code class="code highlight language-text">ITypeParameter</code>与类型参数相对应的对象。</p>

<p>但是，更有趣的是接口继承自它。这个接口叫做<code class="code highlight language-text">ITypeElement</code> 。此接口的重要意义在于它表示CLR类型，例如类，结构，枚举或委托。该接口被诸如以下的接口继承<code class="code highlight language-text">IClass</code> ， <code class="code highlight language-text">IStruct</code> ， 等等。让我们讨论它的一些成员：</p>

<ul>
  <li><code class="code highlight language-text">NestedTypes</code> -此属性本身是<code class="code highlight language-text">ITypeElement</code>代表嵌套类型的实体。</li>
  <li><code class="code highlight language-text">Constructors</code> ， <code class="code highlight language-text">Operators</code> ， <code class="code highlight language-text">Methods</code> ，依此类推-所有这些属性都会产生适当类型成员的枚举。</li>
  <li><code class="code highlight language-text">GetMembers()</code> -帮助您将以上所有内容汇总到一个列表中<code class="code highlight language-text">ITypeMember</code>实体。</li>
  <li><code class="code highlight language-text">GetContainingNamespace()</code> -完全按照说的做，并可能返回<code class="code highlight language-text">null</code>如果类型不在名称空间之内（即，它在全局范围内）。</li>
</ul>

<p>还有一个<code class="code highlight language-text">TypeElementExtensions</code>提供其他功能的类。例如，要检查某个类型是否为另一种类型的后代（即，在继承链中某位置的另一种类型之上），可以使用<code class="code highlight language-text">IsDescendantOf()</code>方法。</p>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/PSI/References.html">引用</a> <a class="navigation-links__next" href="/PSI/Caching.html">缓存</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>