<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>用法/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/Zones/Usage.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Usage">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Usage">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Platform/Zones/Usage">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/Implementation.html">实施</a> <a class="navigation-links__next" href="/Platform/Zones/FeaturesProducts.html">功能和产品</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/Zones/Usage.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>用法</h1>
                    <p>在将每个组件添加到组件模型之前，必须将它们标记为属于一个或多个区域。区域使用区域定义类型声明，区域标记用于将组件与区域定义关联。</p>

<a name="zone-definitions" class="elem-anchor"></a>
<h2>区域定义<a href="#zone-definitions" class="anchor-link"><span></span></a></h2>

<p>区域由实现为空的类型声明<code class="code highlight language-text">IZone</code>标记界面，并用<code class="code highlight language-text">[ZoneDefinition]</code>属性。类型可以是类或接口，尽管对继承有影响，但没有任何选择意义。最简单的定义是声明一个没有依赖性的区域：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneDefinition]</span> <span class="k">public</span> <span class="k">interface</span> <span class="nc">ISimpleZone</span> <span class="p">:</span> <span class="n">IZone</span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>区域定义是分层的，可以指定对其他区域的依赖关系，该区域才能正常工作。例如， <code class="code highlight language-text">IPsiLanguageZone</code>需要<code class="code highlight language-text">PsiFeaturesImplZone</code>进而需要<code class="code highlight language-text">ITextControlsZone</code> ， <code class="code highlight language-text">IProjectModelZone</code>和<code class="code highlight language-text">IDocumentModelZone</code> 。任何需要<code class="code highlight language-text">IPsiLanguageZone</code>隐式地还需要其所有依赖项。对于要添加到组件模型的组件，此依赖关系层次结构中的所有区域定义都必须处于活动状态。</p>

<p>上面的示例声明了一个没有依赖性的区域-可以实例化属于该区域的所有组件，而无需激活任何其他区域。</p>

<p>依赖关系既可以通过继承来定义，也可以通过实现<code class="code highlight language-text">IRequire<TZone></code>接口。两种方法基本相同，除了继承还意味着依赖区域会自动激活。<a href="Activation.html"><span>激活</span></a>部分将对此进行详细讨论。一般来说，除非区域之间存在“是”关系（例如<code class="code highlight language-text">ILanguageCSharpZone</code>是<code class="code highlight language-text">IPsiLanguageZone</code> ）依赖项应使用<code class="code highlight language-text">IRequire<TZone></code>标记界面。可以适当地将两种方法混合使用。</p>

<p>如果希望继承区域定义，则可以将其实现为接口。这样，继承区域定义具有从多个区域继承的能力。如果基本区域定义是一个类，则继承区域定义只能继承单个区域。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneDefinition]</span> <span class="k">public</span> <span class="k">interface</span> <span class="nc">IMyZone</span> <span class="p">:</span> <span class="n">IZone</span><span class="p">,</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">NavigationZone</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>这个例子说明<code class="code highlight language-text">IMyZone</code>有依赖<code class="code highlight language-text">NavigationZone</code> （以及可传递的<code class="code highlight language-text">NavigationZone</code>取决于，例如PSI，结果列表和选项对话框）。</p>

<p>在使用区域定义之前，必须先激活它。通常，拥有产品将负责激活产品中的所有区域。例如， <code class="code highlight language-text">ReSharperZonesActivator</code>激活ReSharper使用的所有区域。创建仅占用区域的扩展时，不需要激活，因为消耗的区域将已经激活（或不激活，在这种情况下，扩展不应加载，也不会加载）。但是，如果扩展创建了区域定义，则必须激活它们。这可以通过使用激活器类显式地完成，也可以通过<code class="code highlight language-text">ZoneFlags.AutoEnable</code>的参数<code class="code highlight language-text">ZoneDefinitionAttribute</code>构造函数。在<a href="Activation.html"><span>激活</span></a>指南中可以找到更多详细信息，包括方法之间的差异。</p>

<a name="zone-markers" class="elem-anchor"></a>
<h2>区域标记<a href="#zone-markers" class="anchor-link"><span></span></a></h2>

<p>区域标记用于声明组件属于一个或多个区域。这意味着只有在产品中所有这些区域（以及可传递地，所有从属区域）都处于活动状态时，才能实例化该组件。</p>

<p>区域标记是一类装饰有<code class="code highlight language-text">[ZoneMarker]</code>属性，并且<strong>必须</strong>命名<code class="code highlight language-text">ZoneMarker</code> ，或名称结尾<code class="code highlight language-text">_ZoneMarker</code> 。通过实施<code class="code highlight language-text">IRequire<TZone></code>界面，或将区域定义传递给<code class="code highlight language-text">ZoneMarkerAttribute</code>构造函数。方法没有区别。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">namespace</span> <span class="nn">Foo.Bar</span> <span class="p">{</span> <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">:</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">IMyZone</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// or...</span> <span class="c1">// [ZoneMarker(typeof(IMyZone))]</span> <span class="c1">// public class ZoneMarker</span> <span class="c1">// {</span> <span class="c1">// }</span> <span class="p">}</span></code></div>

<p>此示例声明<code class="code highlight language-text">Foo.Bar</code>命名空间属于<code class="code highlight language-text">IMyZone</code>区。中的所有组件<code class="code highlight language-text">Foo.Bar</code>命名空间及以下（例如，两者<code class="code highlight language-text">Foo.Bar.ThisComponent</code>和<code class="code highlight language-text">Foo.Bar.Baz.Quux.ThatComponent</code> ）要求<code class="code highlight language-text">IMyZone</code>区域及其所有依赖项处于活动状态，否则它们不会添加到组件模型中。</p>

<p>可以将多个依赖项应用于区域标记，这意味着区域中的组件需要多个区域才能实现。例如，JavaScript单元测试运行程序将要求<code class="code highlight language-text">IUnitTestingZone</code>和<code class="code highlight language-text">ILanguageJavaScriptZone</code> 。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">namespace</span> <span class="nn">Foo.Bar.JavaScriptTestRunner</span> <span class="p">{</span> <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">:</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">IUnitTestingZone</span><span class="p">>,</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">ILanguageJavaScriptZone</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>创建具有多个依存关系的区域标记可以被视为“匿名”或“隐式”区域，由列出的依存关系组成，而不是通过区域定义类明确定义。通常，仅当构成区域的组件仅用于面向最终用户的功能时才应使用此功能。不需要明确的区域定义，因为没有人需要依赖这些组件，因此可以将区域包括在<code class="code highlight language-text">IRequire<TZone></code> 。</p>

<p>但是，如果期望组件被另一个区域使用（也就是说，该功能是内部的，面向代码的功能），则应创建一个区域定义以封装依赖性。然后，区域标记应仅需要此单个新区域定义，而无需其他定义。这为相关代码提供了可能需要的区域定义。未能做到这一点意味着在从属区域中容易发生区域依赖性重复错误。</p>

<p>换句话说，将区域的依赖关系视为实现细节。不需要依赖代码来了解您的依赖关系以消耗组件-提供区域定义。</p>

<a name="class-zone-marker" class="elem-anchor"></a>
<h3>类区域标记<a href="#class-zone-marker" class="anchor-link"><span></span></a></h3>

<p>的<code class="code highlight language-text">ZoneMarker</code>类和<code class="code highlight language-text">[ZoneMarker]</code>属性适用于名称空间中的所有类型。通过应用<code class="code highlight language-text">[ZoneMarker]</code>属性直接归于组件类。用法完全相同，可以将依赖项指定为<code class="code highlight language-text">[ZoneMarker]</code>构造函数或实现<code class="code highlight language-text">IRequire<TZone></code>每个依赖项直接在组件上。</p>

<p>一般来说，大多数注册将使用<code class="code highlight language-text">ZoneMarker</code>类将区域应用于名称空间中的所有组件。</p>

<a name="empty-zone-marker" class="elem-anchor"></a>
<h3>空区标记<a href="#empty-zone-marker" class="anchor-link"><span></span></a></h3>

<p>命名空间可以用空的区域标记标记，这意味着它可以识别区域，但不需要任何其他区域。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">namespace</span> <span class="nn">Foo.Bar</span> <span class="p">{</span> <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>中的所有组件<code class="code highlight language-text">Foo.Bar</code>现在，名称空间和下面的名称可以识别区域，但是不需要其他任何区域都处于活动状态。组件模型过滤器将始终允许这些组件通过区域过滤器。假定它们是基础结构组件，这对于正确运行产品必不可少，并且始终是必需的。</p>

<a name="example" class="elem-anchor"></a>
<h3>例<a href="#example" class="anchor-link"><span></span></a></h3>

<p>创建组件容器时，组件模型会将区域过滤器应用于每个零件，并检查每个零件是否属于一个或多个活动区域。它将遍历零件类型名称的名称空间段，并检查每个级别的区域。如果有任何区域附加到该名称空间，则所有区域都必须处于活动状态，否则该部件未包含在容器中。筛选器将遍历名称空间中的每个段，并且所有名称空间段中的所有区域都必须处于活动状态，否则不包括该部分。如果没有为零件指定区域，则不包括该区域。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="c1">// The namespace of the zone definition is irrelevant</span> <span class="na">[ZoneDefinition]</span> <span class="k">public</span> <span class="k">interface</span> <span class="nc">IMyZone</span> <span class="p">:</span> <span class="n">IDependentZone</span> <span class="p">{</span> <span class="p">}</span> <span class="k">namespace</span> <span class="nn">Foo.Bar</span> <span class="p">{</span> <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">:</span> <span class="n">IZone</span><span class="p">,</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">IMyZone</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="k">namespace</span> <span class="nn">Foo.Bar.Baz</span> <span class="p">{</span> <span class="p">[</span><span class="n">ShellComponent</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyComponent</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>鉴于以上代码，在评估<code class="code highlight language-text">MyComponent</code>零件类型，过滤器将：</p>

<ul>
  <li>在以下位置查找任何区域<code class="code highlight language-text">Foo</code>命名空间。没有定义，因此继续。</li>
  <li>在以下位置查找任何区域<code class="code highlight language-text">Foo.Bar</code>命名空间。的<code class="code highlight language-text">Foo.Bar.ZoneMarker</code>课程已套用<code class="code highlight language-text">IMyZone</code>此命名空间的区域。
    <ul>
      <li>的<code class="code highlight language-text">Foo.Bar.ZoneMarker</code>课程已套用<code class="code highlight language-text">IMyZone</code>此命名空间的区域。</li>
      <li>传递依赖<code class="code highlight language-text">IDependentZone</code>也自动应用于此名称空间。</li>
      <li>如果<code class="code highlight language-text">IMyZone</code>未激活，该零件立即被拒绝，并且<code class="code highlight language-text">MyComponent</code>不包含在容器中。</li>
      <li>执行相同的检查<code class="code highlight language-text">IDependentZone</code> 。它必须处于活动状态，否则组件将被拒绝。</li>
    </ul>
  </li>
  <li>在<code class="code highlight language-text">Foo.Bar.Baz</code>命名空间。没有定义，因此继续。</li>
  <li>没有更多的名称空间段。因为遇到了区域（并且尚未拒绝组件），所以零件已包含在容器中。如果未遇到任何区域，则拒绝该零件。</li>
</ul>



                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/Implementation.html">实施</a> <a class="navigation-links__next" href="/Platform/Zones/FeaturesProducts.html">功能和产品</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>