


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Activation / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/help/resharper/sdk/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/help/resharper/sdk/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/help/resharper/sdk/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/help/resharper/sdk/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/help/resharper/sdk/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/help/resharper/sdk/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/help/resharper/sdk/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/help/resharper/sdk/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/Zones/Activation.html" />
    <meta property="og:site_name" content="JetBrains ReSharper" />
    <meta property="og:title" content="Activation" />
    <meta property="og:description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00" />
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@JBPlatform" />
    <meta name="twitter:title" content="Activation" />
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper" />
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/"></meta>
<link  rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body data-id="Platform/Zones/Activation">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a data-bypass="true" href="//youtrack.jetbrains.com/issues/IJSDK">Send feedback</a></p>
                <p>&copy; 2000&ndash;2018 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/FeaturesProducts.html">Features and Products</a>
                        <a class="navigation-links__next" href="/Platform/Zones/HowTo.html">How to Define a Zone Marker</a>
                    </div>
                    <a data-bypass="true" href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/Zones/Activation.md" class="page-link-to-github" target="_blank" rel="noopener noreferrer" title="Edit this page on GitHub">
                        <i class="github-icon"></i>
                        <span class="text">Edit page</span>
                    </a>

                    <h1>Activation</h1>
                    <p>Components are only included into the Component Model if the zones they belong to are “active”. Zones are not activated by default, and must be activated by an activator class, which is a component decorated by the <code class="code highlight language-text">[ZoneActivator]</code> attribute, and implementing <code class="code highlight language-text">IActivate&lt;TZone&gt;</code> for each zone it activates.</p>

<p>If a zone is not activated, any components that require that zone will not be available in the application. It’s worth noting that if none of the components in an assembly are available, then the assembly itself isn’t even loaded into memory, as the catalogues that the Component Model use are based on caching and direct IL metadata reading, rather than Reflection.</p>

<aside class="note">
  <p> Components that only consume other zones do not need to handle activation. As long as the zones it requires are activated, the component will be created by the Component Model. It is the responsibility of the required zones to handle their own activation.</p>

  <p>For example, a third party extension typically does not need an activator - as long as all of the zones it depends on are active, the extension is also active. However, if the extension defines a zone (perhaps to declare a <a href="FeaturesProducts.html"><span>Feature or Product</span></a>), then that zone must be activated, or none of the components that require this zone will be activated.</p>
</aside>

<a name="implementation" class="elem-anchor"></a>
<h2>Implementation<a href="#implementation" class="anchor-link"><span></span></a></h2>

<p>An activator class implements the <code class="code highlight language-text">IActivate&lt;TZone&gt;</code> interface, which is defined as:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IActivate</span><span class="p">&lt;</span><span class="n">TZone</span><span class="p">&gt;</span>
  <span class="k">where</span> <span class="n">TZone</span> <span class="p">:</span> <span class="n">IZone</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">();</span>
<span class="p">}</span>
</code></div>

<p>The class can implement the interface multiple times, once for each zone it activates. During application startup, the ReSharper Platform will query the activator for each implementation of <code class="code highlight language-text">IActivate&lt;TZone&gt;</code> and call the <code class="code highlight language-text">ActivatorEnabled</code> method. If the class returns <code class="code highlight language-text">true</code>, the zone is marked as active.</p>

<p>When activating a zone, the ReSharper Platform activates that zone, and all zones that inherit from it. For example, if <code class="code highlight language-text">IActivate&lt;IPsiLanguageZone&gt;.ActivatorEnabled()</code> returns true, the <code class="code highlight language-text">IPsiLanguageZone</code> is now activated, as are all zone definitions that inherit from <code class="code highlight language-text">IPsiLanguageZone</code>, such as <code class="code highlight language-text">IClrPsiLanguageZone</code>, <code class="code highlight language-text">ILanguageCSharpZone</code> and <code class="code highlight language-text">ILanguageJavaScriptZone</code>.</p>

<p>Typically, a zone activator aligns with a <a href="FeaturesProducts.html"><span>Product or Feature</span></a>, and unconditionally enables the zone definition that declares the Product or Feature via the <code class="code highlight language-text">[ZoneDefinitionProduct]</code> attribute. It should also activate the zones that the Product or Feature zone requires. It is not an error to activate the same zone from multiple activators. E.g. if both ReSharper and dotPeek need the <code class="code highlight language-text">ExternalSourcesZone</code>, they should both activate it - if they don’t, and they end up being the only product installed into the ReSharper Platform, the required zone won’t be active and the Product or Feature’s requiring zones won’t be loaded.</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span>
<span class="k">class</span> <span class="nc">DotPeekZoneActivator</span> <span class="p">:</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">DotPeekProductZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">ExternalSourcesZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">NavigationZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">DaemonZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">ILanguageCSharpZone</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<p>There is usually little or no logic in the implementation of <code class="code highlight language-text">ActivatorEnabled</code>. Generally speaking, if a product is installed, it should be activated. Activation is separate to licensing, trial versions and user disabling of a product or feature - this is handled separately by the ReSharper Platform. Unlicensed, expired, or disabled zones are removed from the list of activated zones before components are filtered into the container.</p>

<p>However, it is perfectly reasonable to implement some logic in this method, for example, the <code class="code highlight language-text">InternalModeProductZoneActivator</code> class will activate the <code class="code highlight language-text">IInternalVisibilityZone</code> (for <a href="/help/resharper/sdk/Extensions/InternalMode.html"><span>Internal Mode</span></a>) only if the <code class="code highlight language-text">/Internal</code> command line argument is supplied.</p>

<a name="explicit-implementation" class="elem-anchor"></a>
<h3>Explicit implementation<a href="#explicit-implementation" class="anchor-link"><span></span></a></h3>

<p>The activator can implement the <code class="code highlight language-text">IActivate&lt;TZone&gt;</code> interfaces explicitly, to allow for different implementations for each zone:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyZone</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IZone1</span><span class="p">&gt;,</span> <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IZone2</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IZone1</span><span class="p">&gt;.</span><span class="nf">ActivatorEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">ShouldActivateZone1</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IZone2</span><span class="p">&gt;.</span><span class="nf">ActivatorEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">ShouldActivateZone2</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</code></div>

<a name="activator-class-as-component" class="elem-anchor"></a>
<h3>Activator class as component<a href="#activator-class-as-component" class="anchor-link"><span></span></a></h3>

<p>Similarly, zone activator classes are components (<code class="code highlight language-text">ZoneActivatorAttribute</code> derives from <code class="code highlight language-text">EnvironmentComponentAttribute</code>, so they are components that get created very early in the application lifecycle), which means they can accept dependencies in the constructor. For example, a Feature that is intended for use only in <a href="/help/resharper/sdk/Extensions/InternalMode.html"><span>Internal Mode</span></a> can do something like:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyInternalModeFeatureZonesActivator</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IMyInternalModeFeatureZone</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">InternalModeProductZoneActivator</span> <span class="n">internalModeActivator</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">MyInternalModeFeatureZonesActivator</span><span class="p">(</span><span class="n">InternalModeProductZoneActivator</span> <span class="n">internalModeActivator</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">internalModeActivator</span> <span class="p">=</span> <span class="n">internalModeActivator</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Only enable this zone if the internal zone is going to be enabled</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">IActivate</span><span class="p">&lt;</span><span class="n">IInternalVisibilityZone</span><span class="p">&gt;)</span><span class="n">internalModeActivator</span><span class="p">).</span><span class="nf">ActivatorEnabled</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<p>This is perhaps a contrived example - an internal only Feature would be better requiring <code class="code highlight language-text">IInternalVisibilityZone</code> in its zone, rather than handling it in this manner. However, it is an example that serves as a reminder that a zone activator is a component, and follows normal Component Model rules.</p>

<a name="component-model-considerations" class="elem-anchor"></a>
<h3>Component Model considerations<a href="#component-model-considerations" class="anchor-link"><span></span></a></h3>

<p>Since the activator class is a standard component, it naturally follows normal Component Model creation rules. This means that an activator class must itself belong to a zone that is already active!</p>

<p>In other words, the zone activator is only available if it has a zone marker. The zone marker can be an <a href="Usage.html#empty-zone-marker"><span>empty zone marker</span></a>, in which case the activator is always active, and always created. Or it can require one or more of the default active zones (see below), in which case the activator component will only be active if all of the required zones are active.</p>

<p>For example, the <code class="code highlight language-text">ReSharperZonesActivator</code> class, which lives in the <code class="code highlight language-text">JetBrains.ReSharper.Product.Application.Product</code> namespace, has the following zone marker:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">namespace</span> <span class="nn">JetBrains.ReSharper.Product.Application</span>
<span class="p">{</span>
  <span class="c1">// This zone is only active when IVisualStudioZone is active.</span>
  <span class="c1">// So any activator class in this zone is also only created when</span>
  <span class="c1">// running in Visual Studio.</span>
  <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span>
  <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">:</span> <span class="n">IRequire</span><span class="p">&lt;</span><span class="n">IVisualStudioZone</span><span class="p">&gt;</span>
  <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<p>Note the namespace of the marker is above the namespace of the activator. This means that the activator class belongs to the zone definitions declared in the marker’s dependencies, namely <code class="code highlight language-text">IVisualStudioZone</code>. So, the ReSharper product zone activator is only active when the <code class="code highlight language-text">IVisualStudioZone</code> zone is itself active. This zone is an environmental zone, and is created and activated before the environment container is composed.</p>

<aside class="warning">
  <p> If the activator class itself doesn’t have belong to an active zone, it will not be created, and therefore not activate its zones. An activator class must have a <a href="Usage.html#zone-markers"><span>zone marker</span></a>. This can be an <a href="Usage.html#empty-zone-marker"><span>empty zone marker</span></a>, in which case it will be always created, or a zone marker that requires one of the default active zones (described below), in which case it will only be active if those required zones are active.</p>
</aside>

<a name="disabling-activators" class="elem-anchor"></a>
<h3>Disabling activators<a href="#disabling-activators" class="anchor-link"><span></span></a></h3>

<p>A zone activator can take a dependency on a zone, using <code class="code highlight language-text">IRequire&lt;TZone&gt;</code> in the same way zone markers do. This allows for a zone activator to be disabled if any of these required zones are disabled, for whatever reason - unlicensed, expired or explicitly disabled by the user.</p>

<p>It is not immediately obvious why a zone activator would wish to be disabled.</p>

<p>This happens naturally if an activator’s zone marker’s dependencies aren’t satisfied. However, zone markers for zone activators are limited in that they can only require the bootstrap zones that are used when creating the environment component container (see the section on <a href="Activation.html#default-active-zones"><span>default active zones</span></a>). It also happens if any of the zones being activated are no longer licensed.</p>

<p>The main reason for wanting to disable a zone activator is so that supporting zones are not activated unnecessarily. A common pattern is for a zone activator to require a dependency on the main zone it is trying to activate. If that zone has been disabled, for whatever reason, the activator is also disabled, and supporting zones are not activated.</p>

<p>For example, the ReSharper C++ activator requires the C++ product zone, but also activates code editing, daemon and navigation zones. If the C++ product zone feature is disabled, the C++ activator would still activate code editing, daemon and navigation. If no other Features or Products used those zones, they are unnecessarily activated (and probably unlicensed). By requiring the C++ product zone, the ReSharper Platform will disabled the C++ activator if the C++ product zone is disabled. And now, the code editing, daemon and navigation zones are only activated if another activator needs them.</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span>
<span class="k">class</span> <span class="nc">CppProductZonesActivator</span> <span class="p">:</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">ILanguageCppZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">ICodeEditingZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">DaemonZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">NavigationZone</span><span class="p">&gt;,</span>
  <span class="n">IActivate</span><span class="p">&lt;</span><span class="n">ICppProductZone</span><span class="p">&gt;,</span>
  <span class="n">IRequire</span><span class="p">&lt;</span><span class="n">ICppProductZone</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<a name="default-active-zones" class="elem-anchor"></a>
<h2>Default active zones<a href="#default-active-zones" class="anchor-link"><span></span></a></h2>

<p>The ReSharper Platform provides several default zones that are automatically activated based on the current host’s environment. These zones are used to bootstrap the zone activators. An activator’s zone marker can require one or more of these zones to allow for conditionally including and excluding zone activators based on the host environment.</p>

<p>For example, if a zone needs to be run inside a particular version of Visual Studio, the zone activator’s zone marker can require the Visual Studio zone. If the current host is an appropriate version of Visual Studio, the Visual Studio zone is activated, the zone marker’s dependencies are satisfied, and the zone activator is created and finally activates the target zone.</p>

<p>The default zones derive from <code class="code highlight language-text">IHostSpecificZone</code> and are:</p>

<ul>
  <li>An environment zone, representing the current running host environment. These zones derive from <code class="code highlight language-text">IEnvironmentZone</code>
    <ul>
      <li><code class="code highlight language-text">IConsoleZone</code> when the host is a command line utility. Derived interfaces represent the different supported console applications, such as InspectCode and DuplicatesFinder.</li>
      <li><code class="code highlight language-text">IStandaloneUIZone</code> for when the host is a standalone GUI application, such as dotPeek. Again, derived interfaces represent standalone applications.</li>
      <li><code class="code highlight language-text">ITeamCityZone</code> for when the host is running inside TeamCity.</li>
      <li><code class="code highlight language-text">IVisualStudioZone</code> for when the host is Visual Studio.</li>
    </ul>
  </li>
  <li>CLR version zone - <code class="code highlight language-text">ISinceClr2Zone</code> or <code class="code highlight language-text">ISinceClr4Zone</code>. Components that are built for .net 4 should require <code class="code highlight language-text">ISinceClr4Zone</code>. Note that <code class="code highlight language-text">ISinceClr4Zone</code> has a dependency on <code class="code highlight language-text">ISinceClr2Zone</code>, so all CLR 2 components are also available for .net 4.</li>
  <li>CPU architecture zone, representing 32 and 64 bit - <code class="code highlight language-text">IIntelCpuArchitectureZone</code> and <code class="code highlight language-text">IAmd64CpuArchitectureZone</code>.</li>
  <li><code class="code highlight language-text">ITestsZone</code> to indicate that the code is running under test.</li>
</ul>

<p>The Visual Studio zones make extensive use of zone inheritance to model different versions. Each version has two interfaces, a “since” zone and a “just” zone, e.g. <code class="code highlight language-text">ISinceVs10Zone</code> and <code class="code highlight language-text">IJustVS10Zone</code>.</p>

<p>The “since” zones inherit from the previous version’s “since” zone, so <code class="code highlight language-text">ISinceVs12Zone</code> derives from <code class="code highlight language-text">ISinceVs11Zone</code>, which derives from <code class="code highlight language-text">ISinceVs10Zone</code>, etc. When running in VS12 (Visual Studio 2013), the <code class="code highlight language-text">ISinceVs12Zone</code> is active, and so is <code class="code highlight language-text">ISinceVs11Zone</code> and <code class="code highlight language-text">ISinceVs10Zone</code>. If a component uses a Visual Studio feature that works across versions, it should require the zone at which the feature was introduced. For example, if the feature was introduced in Visual Studio 2012 (VS11), the component should require <code class="code highlight language-text">ISinceVs11Zone</code>. When running in Visual Studio 2012 (VS11) or 2013 (VS12), the <code class="code highlight language-text">ISinceVs11Zone</code> is active, and the component runs. If running in Visual Studio 2010 (VS10), the <code class="code highlight language-text">ISinceVs11Zone</code> isn’t active, and the component isn’t loaded.</p>

<p>The “just” zones inherit from the <strong>current</strong> version’s “since” zone, so <code class="code highlight language-text">IJustVs12Zone</code> derives from <code class="code highlight language-text">ISinceVs12Zone</code>. If code is written that targets just a single version of Visual Studio, it should require the “just” zone. For example, if code targets just Visual Studio 2010 (VS10), it should require <code class="code highlight language-text">IJustVs10Zone</code>. When run in Visual Studio 2012 (VS11), the <code class="code highlight language-text">IJustVs10Zone</code> isn’t active, and the component isn’t loaded.</p>

<a name="inheritance-and-activation" class="elem-anchor"></a>
<h2>Inheritance and activation<a href="#inheritance-and-activation" class="anchor-link"><span></span></a></h2>

<p>When declaring a zone definition using the <code class="code highlight language-text">[ZoneDefinition]</code> attribute, dependencies can be declared either by implementing the <code class="code highlight language-text">IRequire&lt;TZone&gt;</code> interface, or by inheriting directly from an existing zone definition. There is no difference between the two with regard to dependencies - when applying a zone to a class or namespace, that zone and all of its dependencies must be active before the component is allowed.</p>

<p>The difference comes with activation. When a zone inherits from another zone definition, it is automatically activated when the base zone is activated. For example, the <code class="code highlight language-text">ReSharperZonesActivator</code> class implements <code class="code highlight language-text">IActivate&lt;IPsiLanguageZone&gt;.ActivatorEnabled()</code> and returns true. This activates the <code class="code highlight language-text">IPsiLanguageZone</code> and all zone definitions that inherit from it, including <code class="code highlight language-text">IClrPsiLanguageZone</code> and therefore <code class="code highlight language-text">ILanguageCSharpZone</code>. Any new code that is added that implements a zone inheriting from <code class="code highlight language-text">IPsiLanguageZone</code>, or <code class="code highlight language-text">IClrPsiLanguageZone</code> will also get automatically enabled.</p>

<p>Dependencies registered via <code class="code highlight language-text">IRequire&lt;TZone&gt;</code> are <strong>not</strong> automatically enabled. These zones must be enabled via another activator, or via activation of their base zone definitions.</p>

<p>The Visual Studio zones are very hierarchical (see above). The “just” zones are the zones that are activated. Because the “just” zone derives from a chain of “since” zones, when a “just” zone is activated, the derived “since” zones are also enabled. So when <code class="code highlight language-text">IJustVs12Zone</code> is activated, it’s inherited <code class="code highlight language-text">ISinceVs12Zone</code> is also activated, as are <code class="code highlight language-text">ISinceVs11Zone</code>, <code class="code highlight language-text">ISinceVs10Zone</code>, <code class="code highlight language-text">IVisualStudioZone</code>, etc.</p>

<a name="auto-enabled-zones" class="elem-anchor"></a>
<h2>Auto-enabled zones<a href="#auto-enabled-zones" class="anchor-link"><span></span></a></h2>

<p>A zone definition can be declared as auto-enabled, if it makes sense that the zone is always available, regardless of configuration, installed products, etc. This is handled with the <code class="code highlight language-text">ZoneFlags</code> parameter to the <code class="code highlight language-text">[ZoneDefinition]</code> attribute.</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneDefinition(ZoneFlags.AutoEnable)]</span>
<span class="k">public</span> <span class="k">interface</span> <span class="nc">IMyZone</span>
<span class="p">{</span>
<span class="p">}</span>
</code></div>

<p>This has the same effect as a simple implementation of <code class="code highlight language-text">IActivate&lt;TZone&gt;.ActivatorEnabled()</code> that always returns true. However, it doesn’t allow for finer control, such as activating supporting zones - it will only activate <code class="code highlight language-text">IMyZone</code>. If <code class="code highlight language-text">IMyZone</code> requires other zones to be active, an activator class should be used.</p>

<aside class="note">
  <p> A zone definition is not always necessary. It should only be used when the zone needs to be referred to externally, either by a consuming component (the zone represents a reusable API), or by the <a href="FeaturesProducts.html"><span>Products and Features</span></a> page (the zone represents a user-facing feature or product that can be disabled). If a zone definition is not required, zone markers will ensure that the components are created correctly, when all required zones are active, or with an <a href="Usage.html#empty-zone-marker"><span>empty zone marker</span></a> that is always active.</p>
</aside>

<p> </p>

<aside class="warning">
  <p> Currently (as of Wave01), auto-enabled zone definitions cannot be used for creating <a href="FeaturesProducts.html"><span>Products or Features</span></a>. The options page to control enabling/disabling Products and Features does not take auto-enabled zones into account, and requires a zone to be activated by an explicit activator class. If it doesn’t find an activator for a Product or Feature, the checkbox is greyed out and the Product or Feature cannot be disabled.</p>

  <p>(The code is checking the hierarchical nature of the Product and Feature zone definitions so that when a Feature is disabled, any dependent Features are also disabled. It is using the active zones from the activators to get this information. Because none of the activators activate the auto-enabled zone, it appears to be a deactivated zone, and so the dialog marks the checkbox as disabled, even though the Feature is still enabled.)</p>

  <p>In order to successfully appear on the Products and Features page, a zone must be activated by a zone activator. Make sure to include a valid zone marker for the activator class!</p>

  <p>This will hopefully be fixed in a future wave.</p>
</aside>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/FeaturesProducts.html">Features and Products</a>
                        <a class="navigation-links__next" href="/Platform/Zones/HowTo.html">How to Define a Zone Marker</a>
                    </div>
                    <div class="last-modified">
                        Last modified: 10 July 2017
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>

</body>
</html>

