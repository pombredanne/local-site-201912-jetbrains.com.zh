<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>激活/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/Zones/Activation.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Activation">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Activation">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Platform/Zones/Activation">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/FeaturesProducts.html">功能和产品</a> <a class="navigation-links__next" href="/Platform/Zones/HowTo.html">如何定义区域标记</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/Zones/Activation.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>激活</h1>
                    <p>如果组件所属的区域是“活动的”，则仅将它们包括在组件模型中。区域默认情况下未激活，必须由激活器类激活，该激活器类由<code class="code highlight language-text">[ZoneActivator]</code>属性并实施<code class="code highlight language-text">IActivate<TZone></code>对于每个区域，它都会激活。</p>

<p>如果未激活区域，则需要该区域的任何组件在应用程序中将不可用。值得注意的是，如果程序集中没有可用的组件，则程序集本身甚至都不会加载到内存中，因为组件模型使用的目录基于缓存和直接IL元数据读取，而不是反射。</p>

<aside class="note">
  <p>仅占用其他区域的组件不需要处理激活。只要激活了所需的区域，组件就会由组件模型创建。所需区域负责处理自己的激活。</p>

  <p>例如，第三方扩展通常不需要激活程序-只要它依赖的所有区域都处于活动状态，该扩展也会处于活动状态。但是，如果扩展定义了一个区域（可能声明了<a href="FeaturesProducts.html"><span>Feature或Product</span></a> ），则必须激活该区域，否则将不需要激活任何需要该区域的组件。</p>
</aside>

<a name="implementation" class="elem-anchor"></a>
<h2>实作<a href="#implementation" class="anchor-link"><span></span></a></h2>

<p>激活器类实现<code class="code highlight language-text">IActivate<TZone></code>接口，定义为：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IActivate</span><span class="p"><</span><span class="n">TZone</span><span class="p">></span> <span class="k">where</span> <span class="n">TZone</span> <span class="p">:</span> <span class="n">IZone</span> <span class="p">{</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">();</span> <span class="p">}</span></code></div>

<p>该类可以多次实现该接口，对于它激活的每个区域一次。在应用程序启动过程中，ReSharper平台将查询激活器以获取每个实现<code class="code highlight language-text">IActivate<TZone></code>并致电<code class="code highlight language-text">ActivatorEnabled</code>方法。如果班级返回<code class="code highlight language-text">true</code> ，该区域被标记为活动区域。</p>

<p>激活区域时，ReSharper Platform会激活该区域以及从该区域继承的所有区域。例如，如果<code class="code highlight language-text">IActivate<IPsiLanguageZone>.ActivatorEnabled()</code>返回true， <code class="code highlight language-text">IPsiLanguageZone</code>现在已激活，所有从其继承的区域定义也已激活<code class="code highlight language-text">IPsiLanguageZone</code> ， 如<code class="code highlight language-text">IClrPsiLanguageZone</code> ， <code class="code highlight language-text">ILanguageCSharpZone</code>和<code class="code highlight language-text">ILanguageJavaScriptZone</code> 。</p>

<p>通常，区域激活器与<a href="FeaturesProducts.html"><span>Product或Feature</span></a>对齐，并无条件地启用通过声明产品或Feature的区域定义。 <code class="code highlight language-text">[ZoneDefinitionProduct]</code>属性。它还应激活“产品”或“功能”区域所需的区域。从多个激活器激活相同区域不是错误。例如，如果ReSharper和dotPeek都需要<code class="code highlight language-text">ExternalSourcesZone</code> ，他们都应该激活它-如果没有激活它们，并且最终它们是ReSharper平台中安装的唯一产品，则所需区域将不会处于活动状态，并且不会加载产品或功能的所需区域。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span> <span class="k">class</span> <span class="nc">DotPeekZoneActivator</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">DotPeekProductZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">ExternalSourcesZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">NavigationZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">DaemonZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">ILanguageCSharpZone</span><span class="p">></span> <span class="p">{</span> <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>通常，实施的逻辑很少或没有逻辑<code class="code highlight language-text">ActivatorEnabled</code> 。一般来说，如果安装了产品，则应将其激活。激活与许可，试用版和用户禁用产品或功能是分开的-这由ReSharper平台单独处理。在将组件过滤到容器中之前，将从激活区域列表中删除未许可，过期或禁用的区域。</p>

<p>但是，用这种方法实现一些逻辑是完全合理的，例如， <code class="code highlight language-text">InternalModeProductZoneActivator</code>课程将激活<code class="code highlight language-text">IInternalVisibilityZone</code> （对于<a href="/help/resharper/sdk/Extensions/InternalMode.html"><span>内部模式</span></a> ）仅在<code class="code highlight language-text">/Internal</code>提供了命令行参数。</p>

<a name="explicit-implementation" class="elem-anchor"></a>
<h3>明确实施<a href="#explicit-implementation" class="anchor-link"><span></span></a></h3>

<p>激活器可以实现<code class="code highlight language-text">IActivate<TZone></code>显式接口，以允许每个区域的不同实现：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyZone</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">IZone1</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">IZone2</span><span class="p">></span> <span class="p">{</span> <span class="kt">bool</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">IZone1</span><span class="p">>.</span><span class="nf">ActivatorEnabled</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">ShouldActivateZone1</span><span class="p">();</span> <span class="p">}</span> <span class="kt">bool</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">IZone2</span><span class="p">>.</span><span class="nf">ActivatorEnabled</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">ShouldActivateZone2</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// ...</span> <span class="p">}</span></code></div>

<a name="activator-class-as-component" class="elem-anchor"></a>
<h3>激活器类作为组件<a href="#activator-class-as-component" class="anchor-link"><span></span></a></h3>

<p>同样，区域激活器类是组件（ <code class="code highlight language-text">ZoneActivatorAttribute</code>源自于<code class="code highlight language-text">EnvironmentComponentAttribute</code> ，因此它们是在应用程序生命周期的早期就创建的组件），这意味着它们可以接受构造函数中的依赖项。例如，仅在<a href="/help/resharper/sdk/Extensions/InternalMode.html"><span>内部模式下</span></a>使用的功能可以执行以下操作：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyInternalModeFeatureZonesActivator</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">IMyInternalModeFeatureZone</span><span class="p">></span> <span class="p">{</span> <span class="k">private</span> <span class="k">readonly</span> <span class="n">InternalModeProductZoneActivator</span> <span class="n">internalModeActivator</span><span class="p">;</span> <span class="k">public</span> <span class="nf">MyInternalModeFeatureZonesActivator</span><span class="p">(</span><span class="n">InternalModeProductZoneActivator</span> <span class="n">internalModeActivator</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">internalModeActivator</span> <span class="p">=</span> <span class="n">internalModeActivator</span><span class="p">;</span> <span class="p">}</span> <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Only enable this zone if the internal zone is going to be enabled</span> <span class="k">return</span> <span class="p">((</span><span class="n">IActivate</span><span class="p"><</span><span class="n">IInternalVisibilityZone</span><span class="p">>)</span><span class="n">internalModeActivator</span><span class="p">).</span><span class="nf">ActivatorEnabled</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>这可能是一个人为的示例-仅内部功能会更好<code class="code highlight language-text">IInternalVisibilityZone</code>而不是以这种方式处理它。但是，此示例提醒人们，区域激活器是组件，并且遵循正常的组件模型规则。</p>

<a name="component-model-considerations" class="elem-anchor"></a>
<h3>组件模型注意事项<a href="#component-model-considerations" class="anchor-link"><span></span></a></h3>

<p>由于激活器类是标准组件，因此自然遵循正常的组件模型创建规则。这意味着激活器类本身必须属于已经处于活动状态的区域！</p>

<p>换句话说，区域激活器仅在具有区域标记时才可用。区域标记可以是一个<a href="Usage.html#empty-zone-marker"><span>空的区域标记</span></a> ，在这种情况下，激活器始终处于活动状态并始终被创建。或者，它可能需要一个或多个默认活动区域（请参见下文），在这种情况下，只有在所有必需区域都处于活动状态时，激活器组件才会处于活动状态。</p>

<p>例如， <code class="code highlight language-text">ReSharperZonesActivator</code>类，住在<code class="code highlight language-text">JetBrains.ReSharper.Product.Application.Product</code>名称空间，具有以下区域标记：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">namespace</span> <span class="nn">JetBrains.ReSharper.Product.Application</span> <span class="p">{</span> <span class="c1">// This zone is only active when IVisualStudioZone is active.</span> <span class="c1">// So any activator class in this zone is also only created when</span> <span class="c1">// running in Visual Studio.</span> <span class="p">[</span><span class="n">ZoneMarker</span><span class="p">]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">ZoneMarker</span> <span class="p">:</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">IVisualStudioZone</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>请注意，标记的名称空间位于激活器的名称空间上方。这意味着激活器类属于标记的依赖项中声明的区域定义，即<code class="code highlight language-text">IVisualStudioZone</code> 。因此，ReSharper产品区域激活器仅在<code class="code highlight language-text">IVisualStudioZone</code>区域本身是活动的。该区域是一个环境区域，在环境容器组成之前就创建并激活了。</p>

<aside class="warning">
  <p>如果激活器类本身不属于活动区域，则不会创建该激活器类，因此不会激活其区域。激活器类必须具有<a href="Usage.html#zone-markers"><span>区域标记</span></a> 。这可以是一个<a href="Usage.html#empty-zone-marker"><span>空的区域标记</span></a> ，在这种情况下将始终创建该区域标记，或者是需要默认活动区域之一（如下所述）的区域标记，在这种情况下，仅当那些必需的区域处于活动状态时，该区域标记才处于活动状态。</p>
</aside>

<a name="disabling-activators" class="elem-anchor"></a>
<h3>禁用激活器<a href="#disabling-activators" class="anchor-link"><span></span></a></h3>

<p>区域激活器可以使用以下方式依赖区域<code class="code highlight language-text">IRequire<TZone></code>以相同的方式标记区域。如果出于任何原因禁用了这些必需的区域中的任何一个，则允许禁用区域激活器，无论是出于何种原因-用户未经许可，已过期或已明确禁用。</p>

<p>现在尚不清楚为什么要禁用区域激活器。</p>

<p>如果不满足激活者的区域标记的依赖性，则自然发生这种情况。但是，区域激活器的区域标记受到限制，因为它们仅需要在创建环境组件容器时使用的引导区域（请参阅关于<a href="Activation.html#default-active-zones"><span>默认活动区域</span></a>的部分）。如果任何被激活的区域不再获得许可，也会发生这种情况。</p>

<p>想要禁用区域激活器的主要原因是为了避免不必要地激活支持区域。一个常见的模式是区域激活器要求依赖于它试图激活的主区域。如果由于任何原因禁用了该区域，则激活器也会被禁用，并且支持区域也不会被激活。</p>

<p>例如，ReSharper C ++激活器需要C ++产品区域，但也可以激活代码编辑，后台驻留程序和导航区域。如果禁用了C ++产品区域功能，则C ++激活器仍将激活代码编辑，守护程序和导航。如果没有其他功能或产品使用这些区域，则将不必要地激活它们（并且可能是未经许可的）。通过禁用C ++产品区域，如果禁用了C ++产品区域，则ReSharper平台将禁用C ++激活器。现在，仅当另一个激活器需要它们时，才激活代码编辑，后台驻留程序和导航区域。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneActivator]</span> <span class="k">class</span> <span class="nc">CppProductZonesActivator</span> <span class="p">:</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">ILanguageCppZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">ICodeEditingZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">DaemonZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">NavigationZone</span><span class="p">>,</span> <span class="n">IActivate</span><span class="p"><</span><span class="n">ICppProductZone</span><span class="p">>,</span> <span class="n">IRequire</span><span class="p"><</span><span class="n">ICppProductZone</span><span class="p">></span> <span class="p">{</span> <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ActivatorEnabled</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">true</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span></code></div>

<a name="default-active-zones" class="elem-anchor"></a>
<h2>默认活动区域<a href="#default-active-zones" class="anchor-link"><span></span></a></h2>

<p>ReSharper平台提供了几个默认区域，这些区域会根据当前主机的环境自动激活。这些区域用于引导区域激活器。激活器的区域标记可能需要这些区域中的一个或多个，以允许基于宿主环境有条件地包括和排除区域激活器。</p>

<p>例如，如果需要在特定版本的Visual Studio中运行区域，则区域激活器的区域标记可能需要Visual Studio区域。如果当前主机是Visual Studio的适当版本，则将激活Visual Studio区域，满足区域标记的依赖性，并创建区域激活器并最终激活目标区域。</p>

<p>默认区域源自<code class="code highlight language-text">IHostSpecificZone</code>并且是：</p>

<ul>
  <li>一个环境区域，代表当前正在运行的主机环境。这些区域源自<code class="code highlight language-text">IEnvironmentZone</code>
    <ul>
      <li><code class="code highlight language-text">IConsoleZone</code>当主机是命令行实用程序时。派生的接口表示不同的受支持的控制台应用程序，例如InspectCode和DuplicatesFinder。</li>
      <li><code class="code highlight language-text">IStandaloneUIZone</code>当主机是独立的GUI应用程序（例如dotPeek）时。同样，派生的接口代表独立的应用程序。</li>
      <li><code class="code highlight language-text">ITeamCityZone</code>当主机在TeamCity中运行时。</li>
      <li><code class="code highlight language-text">IVisualStudioZone</code>当主机是Visual Studio时。</li>
    </ul>
  </li>
  <li>CLR版本区域- <code class="code highlight language-text">ISinceClr2Zone</code>要么<code class="code highlight language-text">ISinceClr4Zone</code> 。为.net 4构建的组件应要求<code class="code highlight language-text">ISinceClr4Zone</code> 。注意<code class="code highlight language-text">ISinceClr4Zone</code>有依赖<code class="code highlight language-text">ISinceClr2Zone</code> ，因此所有CLR 2组件也可用于.net 4。</li>
  <li>CPU体系结构区域，代表32和64位- <code class="code highlight language-text">IIntelCpuArchitectureZone</code>和<code class="code highlight language-text">IAmd64CpuArchitectureZone</code> 。</li>
  <li><code class="code highlight language-text">ITestsZone</code>表示代码正在测试中。</li>
</ul>

<p>Visual Studio区域广泛使用区域继承来对不同版本进行建模。每个版本都有两个界面，一个“自”区和一个“正”区，例如<code class="code highlight language-text">ISinceVs10Zone</code>和<code class="code highlight language-text">IJustVS10Zone</code> 。</p>

<p>“ since”区域继承自先前版本的“ since”区域，因此<code class="code highlight language-text">ISinceVs12Zone</code>源自于<code class="code highlight language-text">ISinceVs11Zone</code> ，源于<code class="code highlight language-text">ISinceVs10Zone</code>等等。在VS12（Visual Studio 2013）中运行时， <code class="code highlight language-text">ISinceVs12Zone</code>是活跃的，所以也是<code class="code highlight language-text">ISinceVs11Zone</code>和<code class="code highlight language-text">ISinceVs10Zone</code> 。如果组件使用的Visual Studio功能可以跨版本使用，则它应该要求引入该功能的区域。例如，如果功能是在Visual Studio 2012（VS11）中引入的，则组件应要求<code class="code highlight language-text">ISinceVs11Zone</code> 。在Visual Studio 2012（VS11）或2013（VS12）中运行时， <code class="code highlight language-text">ISinceVs11Zone</code>处于活动状态，组件运行。如果在Visual Studio 2010（VS10）中运行， <code class="code highlight language-text">ISinceVs11Zone</code>处于不活动状态，并且未加载组件。</p>

<p>“ just”区域继承自<strong>当前</strong>版本的“ since”区域，因此<code class="code highlight language-text">IJustVs12Zone</code>源自于<code class="code highlight language-text">ISinceVs12Zone</code> 。如果编写的代码仅针对Visual Studio的单个版本，则它应该需要“ just”区域。例如，如果代码仅针对Visual Studio 2010（VS10），则应要求<code class="code highlight language-text">IJustVs10Zone</code> 。在Visual Studio 2012（VS11）中运行时， <code class="code highlight language-text">IJustVs10Zone</code>处于不活动状态，并且未加载组件。</p>

<a name="inheritance-and-activation" class="elem-anchor"></a>
<h2>继承与激活<a href="#inheritance-and-activation" class="anchor-link"><span></span></a></h2>

<p>使用声明区域定义时<code class="code highlight language-text">[ZoneDefinition]</code>属性，可以通过实现<code class="code highlight language-text">IRequire<TZone></code>接口，或直接从现有区域定义中继承。两者之间的依赖关系没有区别-将区域应用于类或名称空间时，在允许组件之前，该区域及其所有依赖关系必须处于活动状态。</p>

<p>区别在于激活。当区域从另一个区域定义继承时，激活基本区域时会自动将其激活。例如， <code class="code highlight language-text">ReSharperZonesActivator</code>类工具<code class="code highlight language-text">IActivate<IPsiLanguageZone>.ActivatorEnabled()</code>并返回true。这激活了<code class="code highlight language-text">IPsiLanguageZone</code>以及从其继承的所有区域定义，包括<code class="code highlight language-text">IClrPsiLanguageZone</code>因此<code class="code highlight language-text">ILanguageCSharpZone</code> 。添加的任何实现区域继承的新代码<code class="code highlight language-text">IPsiLanguageZone</code> ， 要么<code class="code highlight language-text">IClrPsiLanguageZone</code>也会自动启用。</p>

<p>通过注册的依赖项<code class="code highlight language-text">IRequire<TZone></code> <strong>没有</strong>自动启用。这些区域必须通过另一个激活器或通过其基本区域定义的激活来启用。</p>

<p>Visual Studio区域非常分层（请参见上文）。“正好”区域是被激活的区域。因为“正当”区域是从“正”区域链中派生的，所以当激活“正”区域时，也会启用派生的“正”区域。所以什么时候<code class="code highlight language-text">IJustVs12Zone</code>被激活，它是继承的<code class="code highlight language-text">ISinceVs12Zone</code>也被激活<code class="code highlight language-text">ISinceVs11Zone</code> ， <code class="code highlight language-text">ISinceVs10Zone</code> ， <code class="code highlight language-text">IVisualStudioZone</code>等</p>

<a name="auto-enabled-zones" class="elem-anchor"></a>
<h2>自动启用的区域<a href="#auto-enabled-zones" class="anchor-link"><span></span></a></h2>

<p>如果区域定义始终可用，而与配置，安装的产品等无关，则可以将区域定义声明为自动启用。 <code class="code highlight language-text">ZoneFlags</code>的参数<code class="code highlight language-text">[ZoneDefinition]</code>属性。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ZoneDefinition(ZoneFlags.AutoEnable)]</span> <span class="k">public</span> <span class="k">interface</span> <span class="nc">IMyZone</span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>这与简单实现的效果相同<code class="code highlight language-text">IActivate<TZone>.ActivatorEnabled()</code>总是返回true。但是，它不允许进行更精细的控制，例如激活支撑区域-它只会激活<code class="code highlight language-text">IMyZone</code> 。如果<code class="code highlight language-text">IMyZone</code>需要激活其他区域，应使用激活器类。</p>

<aside class="note">
  <p>区域定义并非总是必需的。仅当需要从外部（通过使用组件（该区域表示可重用的API）或通过“ <a href="FeaturesProducts.html"><span>产品和功能”</span></a>页面（该区域表示面向用户的功能或可以通过以下方式使用的<a href="FeaturesProducts.html"><span>产品</span></a> ））引用该区域时，才应使用该区域：禁用）。如果不需要区域定义，则当所有必需区域都处于活动状态时，或使用始终处于活动状态的<a href="Usage.html#empty-zone-marker"><span>空区域标记</span></a>时，区域标记将确保正确创建组件。</p>
</aside>

<p> </p>

<aside class="warning">
  <p>当前（自Wave01起），自动启用的区域定义不能用于创建<a href="FeaturesProducts.html"><span>产品或功能</span></a> 。用于控制启用/禁用产品和功能的选项页面未考虑自动启用的区域，而是要求区域由显式的激活器类激活。如果找不到产品或功能的激活器，则该复选框为灰色，并且不能禁用该产品或功能。</p>

  <p>（该代码正在检查“产品”和“功能”区域定义的层次结构性质，以便在禁用功能时，也会禁用所有从属功能。它使用激活器的活动区域来获取此信息。由于没有一个激活器激活自动启用的区域，因此它似乎是一个已禁用的区域，因此即使该功能仍处于启用状态，该对话框也会将该复选框标记为已禁用。）</p>

  <p>为了成功出现在“产品和功能”页面上，必须由区域激活器激活区域。确保为激活器类包括有效的区域标记！</p>

  <p>希望这将在以后的浪潮中得到解决。</p>
</aside>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Zones/FeaturesProducts.html">功能和产品</a> <a class="navigation-links__next" href="/Platform/Zones/HowTo.html">如何定义区域标记</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>