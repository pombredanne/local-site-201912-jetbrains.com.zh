


<!doctype html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Component Model / ReSharper  DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/help/resharper/sdk/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/help/resharper/sdk/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/help/resharper/sdk/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/help/resharper/sdk/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/help/resharper/sdk/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/help/resharper/sdk/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/help/resharper/sdk/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/help/resharper/sdk/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/ComponentModel.html" />
    <meta property="og:site_name" content="JetBrains ReSharper" />
    <meta property="og:title" content="Component Model" />
    <meta property="og:description" content="Documentation for writing extensions for ReSharper" />
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00" />
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@JBPlatform" />
    <meta name="twitter:title" content="Component Model" />
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper" />
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png" />
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/"></meta>
<link  rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body data-id="Platform/ComponentModel">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label for="search-box__input" class="search-box__label">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="Search ReSharper  DevGuide">
                    </label>
                    <div class="search-box__clear" title="Clear"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a data-bypass="true" href="//youtrack.jetbrains.com/issues/IJSDK">Send feedback</a></p>
                <p>&copy; 2000&ndash;2018 <a href="//www.jetbrains.com">JetBrains</a> s.r.o.<br>
                    All rights reserved.</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper DevGuide</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Lifetime.html">Lifetime</a>
                        <a class="navigation-links__next" href="/Platform/Zones.html">Zones</a>
                    </div>
                    <a data-bypass="true" href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/ComponentModel.md" class="page-link-to-github" target="_blank" rel="noopener noreferrer" title="Edit this page on GitHub">
                        <i class="github-icon"></i>
                        <span class="text">Edit page</span>
                    </a>

                    <h1>Component Model</h1>
                    <ul id="markdown-toc">
  <li><a href="#shell-components" id="markdown-toc-shell-components"><span>Shell Components</span></a></li>
  <li><a href="#solution-components" id="markdown-toc-solution-components"><span>Solution Components</span></a></li>
  <li><a href="#component-cleanup" id="markdown-toc-component-cleanup"><span>Component cleanup</span></a></li>
  <li><a href="#dependency-failures" id="markdown-toc-dependency-failures"><span>Dependency failures</span></a></li>
  <li><a href="#lazy-and-optional-acquisition" id="markdown-toc-lazy-and-optional-acquisition"><span>Lazy and optional acquisition</span></a></li>
  <li><a href="#other-component-types" id="markdown-toc-other-component-types"><span>Other component types</span></a>    <ul>
      <li><a href="#derived-component-types" id="markdown-toc-derived-component-types"><span>Derived component types</span></a></li>
      <li><a href="#parts" id="markdown-toc-parts"><span>Parts</span></a></li>
    </ul>
  </li>
</ul>

<p>ReSharper has a very composable architecture, which allows for a loosely coupled, easily extensible design. Functionality is implemented in terms of components that advertise themselves to the Component Model, which in turn is responsible for lifetime management, as well as wiring up the inter-dependencies of the components. The Component Model will look for classes marked with specific attributes, which declare the lifetime scope of the component. Dependencies are declared as constructor arguments. At the appropriate time, the Component Model will create new instances of the components, ensuring all dependencies are created first, and passed into the constructor.</p>

<aside class="note">
  <p> If you are familiar with the concept of <a href="http://en.wikipedia.org/wiki/Inversion_of_control" data-external="true" target="_blank" rel="noopener noreferrer"><span>Inversion of Control</span></a> and <a href="http://en.wikipedia.org/wiki/Dependency_injection" data-external="true" target="_blank" rel="noopener noreferrer"><span>Dependency Injection</span></a>, ReSharper’s Component Model follows these patterns, and implements an IoC Container to automatically create and wire up dependendencies</p>
</aside>

<p>This loosely coupled design allows for easily extending ReSharper - new components can easily be advertised to the Component Model, and services are available for consumption by declaring constructor arguments. It is not possible to integrate with ReSharper without using and understanding the Component Model.</p>

<p>Conceptually, the Component Model is very similar to Microsoft’s <a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx" data-external="true" target="_blank" rel="noopener noreferrer"><span>Managed Extensibility Framework (MEF)</span></a> although there are some fundamental differences, such as the ability to live load and unload new components, during runtime.</p>

<p>ReSharper defines many component types. The two most interesting are <code class="code highlight language-text">ShellComponent</code> and <code class="code highlight language-text">SolutionComponent</code>. More details about other component types can be found in the discussion about <code class="code highlight language-text">Parts</code> in <a href="ComponentModel/ContainersPartsCatalogues.html"><span>Containers, Parts and Catalogues</span></a>.</p>

<a name="shell-components" class="elem-anchor"></a>
<h2>Shell Components<a href="#shell-components" class="anchor-link"><span></span></a></h2>

<p>A <strong>Shell Component</strong> is a class that gets created when ReSharper starts. Shell components are typically marked with the <code class="code highlight language-text">[ShellComponent]</code> attribute. It has essentially the same lifetime as ReSharper itself. Shell components are effectively singletons, and are most useful when creating a service that is not solution specific. For example, Live Template macro definitions are shell components. They do not use or depend on anything related to a solution, and do not change for the lifetime of the shell.</p>

<p>To define a shell component, simply write:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></div>

<p>ReSharper will create an instance of this class when the shell starts up.</p>

<p>If a component needs to talk to other components, it can simply add them as a constructor argument, and the Component Model will ensure that the dependent component is created first, and passed in on construction. The dependent component must have the same lifetime scope or longer, so a shell component can only request another shell component.</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SomeOtherClass</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">SomeOtherClass</span><span class="p">(</span><span class="n">MyClass</span> <span class="n">myClass</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">myClass</span> <span class="p">=</span> <span class="n">myClass</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></div>

<p>Constructor injection is the preferred means of accessing dependencies. However, there are some cases where this isn’t possible - for example, Action handlers aren’t created by the Component Model. In this case, you can use the Service Locator pattern and ask for the dependency:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">void</span> <span class="nf">SomeMethod</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Shell.Instance is a static property</span>
  <span class="kt">var</span> <span class="n">myClass</span> <span class="p">=</span> <span class="n">Shell</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MyClass</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></div>

<p>Note, however, that <code class="code highlight language-text">Shell.Instance.GetComponent</code> will only return shell components, not solution components.</p>

<a name="solution-components" class="elem-anchor"></a>
<h2>Solution Components<a href="#solution-components" class="anchor-link"><span></span></a></h2>

<p><strong>Solution Components</strong> are components that are tied to the lifetime of a solution. They are created each time a new solution is opened, and use the <code class="code highlight language-text">[SolutionComponent]</code> attribute. Again, constructor injection is the preferred means of satisfying dependencies. A <code class="code highlight language-text">SolutionComponent</code> can depend on both <code class="code highlight language-text">SolutionComponent</code> and <code class="code highlight language-text">ShellComponent</code> instances, because shell components have a longer lifetime than solution components.</p>

<p>You can also use the Service Locator pattern to ask for solution components. There are several ways of getting at the solution level Component Model, usually with a <code class="code highlight language-text">GetComponent</code> or <code class="code highlight language-text">GetComponents</code> extension method. For example, the <code class="code highlight language-text">IDataContext</code> object passed to action handlers can be used to retrieve components, or the <code class="code highlight language-text">ISolution</code> and <code class="code highlight language-text">IProject</code> interfaces have extension methods. Again, when asking for a component directly, you can ask for a solution component or shell component. For example:</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="kt">var</span> <span class="n">solution</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">GetData</span><span class="p">(</span><span class="n">JetBrains</span><span class="p">.</span><span class="n">ProjectModel</span><span class="p">.</span><span class="n">DataContext</span><span class="p">.</span><span class="n">DataConstants</span><span class="p">.</span><span class="n">SOLUTION</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">dtm</span> <span class="p">=</span> <span class="n">solution</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">DocumentTransactionManager</span><span class="p">&gt;();</span>
</code></div>

<p>One very important object that can be injected or asked for is <code class="code highlight language-text">ISolution</code>. This allows a solution level component to get at its current context - the solution it’s been created for.</p>

<a name="component-cleanup" class="elem-anchor"></a>
<h2>Component cleanup<a href="#component-cleanup" class="anchor-link"><span></span></a></h2>

<p>A component is tied to a particular lifetime - the lifetime of the shell for <code class="code highlight language-text">ShellComponent</code> instances and the lifetime of the solution for <code class="code highlight language-text">SolutionComponent</code> instances. When the solution is closed, or the shell terminates, the component is now out of scope, and is available for garbage collection. If you need to do any explicit cleanup that can’t be handled by garbage collection, you can implement <code class="code highlight language-text">IDisposable</code> and the Component Model will call <code class="code highlight language-text">Dispose</code> for you.</p>

<p>Alternatively, you should inject an instance of <code class="code highlight language-text">Lifetime</code> into your constructor, and register callbacks with it. The <code class="code highlight language-text">Lifetime</code> object is terminated at the end of the lifetime scope of the component, and will call any registered callbacks at that time. <code class="code highlight language-text">Lifetime</code> is a very powerful construct for lifetime management, and is <a href="Lifetime.html"><span>documented separately</span></a>.</p>

<p>You should ensure that you are not holding any references that are outside the scope of your component. For example, a shell component should not acquire and cache an instance of <code class="code highlight language-text">ISolution</code>, or any other solution component, as this will cause memory leaks.</p>

<a name="dependency-failures" class="elem-anchor"></a>
<h2>Dependency failures<a href="#dependency-failures" class="anchor-link"><span></span></a></h2>

<p>One downside to wiring up an application through the Component Model is that errors can cascade. For example, a shell component with a constructor that takes a solution component cannot be created, and the Component Model will throw an exception. But a second shell component that depends on this failed first shell component will now fail to be created, and so on, potentially destabilising the entire application. Care should be taken to require dependencies appropriately, and not cause exceptions in constructors.</p>

<p>Troubleshooting can initially seem very difficult, due to the cascading errors, all of which will throw exceptions. The important exception is the first one, which will tell you which component failed during creation. The failure will be related to one of the constructor parameters, so each parameter should be checked - is the parameter type a component? Does it come from the same or higher scope (i.e. is a shell component trying to depend on a solution component)? Does the parameter have the correct cardinality (single instance vs. collection)?</p>

<p>ReSharper 9.0 adds better diagnostics for troubleshooting component model failures, describing which parameter caused the issue, and adding more context to the exception’s <code class="code highlight language-text">Data</code> dictionary. This data is only available in a <a href="/help/resharper/sdk/Extensions/Tools.html"><span>checked build</span></a>.</p>

<a name="lazy-and-optional-acquisition" class="elem-anchor"></a>
<h2>Lazy and optional acquisition<a href="#lazy-and-optional-acquisition" class="anchor-link"><span></span></a></h2>

<p>Dependencies can be declared as lazy or optional.</p>

<p>A lazy dependency will only be resolved at the time of use, rather than at the time of creation of the owning component. Simply use <code class="code highlight language-text">JetBrains.Util.Lazy&lt;ComponentType&gt;</code> instead of <code class="code highlight language-text">ComponentType</code> when querying or injecting a component. Note that this does not work with the BCL’s <code class="code highlight language-text">System.Lazy</code> type, as this is a .net 4 type, and ReSharper is a .net 3.5 application (although it runs in .net 4 when hosted in VS2010 and VS2012).</p>

<p>An optional dependency is resolved at component creation time (same as normal components), but can be missing, and if so, will be null. You declare an optional dependency by requesting <code class="code highlight language-text">Optional&lt;ComponentType&gt;</code> instead of <code class="code highlight language-text">ComponentType</code>.</p>

<a name="other-component-types" class="elem-anchor"></a>
<h2>Other component types<a href="#other-component-types" class="anchor-link"><span></span></a></h2>

<p>ReSharper supports several types of component, not just shell and solution components. For completeness, it also supports <code class="code highlight language-text">EnvironmentComponent</code>, <code class="code highlight language-text">ShellInstanceComponent</code> and <code class="code highlight language-text">ProjectComponent</code>.</p>

<p>A <code class="code highlight language-text">ShellComponent</code> has the same lifetime as ReSharper, but this might not be the same lifetime as Visual Studio - if someone suspends and resumes ReSharper, all shell components are released and then recreated. An environment component is created when ReSharper first starts up and lasts for the duration of the hosting application (such as Visual Studio), regardless of suspend and resume. It is intended for ReSharper’s integration infrastructure, and generally speaking, should not be used by plugin authors.</p>

<p><code class="code highlight language-text">ShellInstanceComponent</code> is also an infrastructure component, created as the solution is opened. Again, there should be little need for it to be used by plugins, use <code class="code highlight language-text">ShellComponent</code> instead.</p>

<p><code class="code highlight language-text">ProjectComponent</code> allows for a class to be created for each project that’s loaded. This means, unlike shell and solution components, it’s not a singleton - there will be one instance for each loaded project. If a project is unloaded or removed, the component is released. If a new project is added to the current solution, a new component is created. The Component Model can inject an instance of <code class="code highlight language-text">IProject</code> to give the component some context. It’s generally used for project level settings and properties (e.g. project level Live Templates, or C# language level). It is rarely used other than this.</p>

<a name="derived-component-types" class="elem-anchor"></a>
<h3>Derived component types<a href="#derived-component-types" class="anchor-link"><span></span></a></h3>

<p>There are other component attribute types that derive from <code class="code highlight language-text">ShellComponentAttribute</code> and <code class="code highlight language-text">SolutionComponentAttribute</code> (e.g. <code class="code highlight language-text">PsiComponentAttribute</code> and <code class="code highlight language-text">CodeCleanupModuleAttribute</code>). These are treated the same as normal shell or solution components, except the derived attributes allow for grouping, or passing information to consumers. One other use is to mark the attribute with annotations to aid implementation. For example, any class with an attribute that has the <code class="code highlight language-text">MeansImplicitUse</code> attribute will be marked as in use by ReSharper, even if <code class="code highlight language-text">new</code> is not explicitly called on it. Similarly, a class with an attribute that has the <code class="code highlight language-text">BaseTypeRequired</code> annotation will show a warning if that class does not derive from the named base type.</p>

<a name="parts" class="elem-anchor"></a>
<h3>Parts<a href="#parts" class="anchor-link"><span></span></a></h3>

<p>Components such as shell and solution components, and derived types such as code cleanup module components are the most common usage of the Component Model in ReSharper, supporting known lifetime and usage requirements. However, they are not the only usage. The Component Model implements an Inversion of Control container, populated with “parts”, and shell and solution components are implemented as nested components of parts identified by the <code class="code highlight language-text">[ShellComponent]</code> and <code class="code highlight language-text">[SolutionComponent]</code> attributes. Other components create their own containers for custom lifetime and usage handling. See the <a href="ComponentModel/ContainersPartsCatalogues.html"><span>Containers, Parts and Catalogues</span></a> section for more details.</p>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Lifetime.html">Lifetime</a>
                        <a class="navigation-links__next" href="/Platform/Zones.html">Zones</a>
                    </div>
                    <div class="last-modified">
                        Last modified: 10 July 2017
                    </div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>

</body>
</html>

