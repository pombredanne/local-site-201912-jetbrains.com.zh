<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>组件模型/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/ComponentModel.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Component Model">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Component Model">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Platform/ComponentModel">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Lifetime.html">终生</a> <a class="navigation-links__next" href="/Platform/Zones.html">区域</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/ComponentModel.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>组件模型</h1>
                    <ul id="markdown-toc">
  <li><a href="#shell-components" id="markdown-toc-shell-components"><span>外壳组件</span></a></li>
  <li><a href="#solution-components" id="markdown-toc-solution-components"><span>解决方案组件</span></a></li>
  <li><a href="#component-cleanup" id="markdown-toc-component-cleanup"><span>组件清理</span></a></li>
  <li><a href="#dependency-failures" id="markdown-toc-dependency-failures"><span>依赖失败</span></a></li>
  <li><a href="#lazy-and-optional-acquisition" id="markdown-toc-lazy-and-optional-acquisition"><span>懒惰和可选的获取</span></a></li>
  <li><a href="#other-component-types" id="markdown-toc-other-component-types"><span>其他组件类型</span></a>    <ul>
      <li><a href="#derived-component-types" id="markdown-toc-derived-component-types"><span>派生组件类型</span></a></li>
      <li><a href="#parts" id="markdown-toc-parts"><span>部分</span></a></li>
    </ul>
  </li>
</ul>

<p>ReSharper具有非常可组合的体系结构，可以实现松耦合，易于扩展的设计。功能是根据向组件模型公告自己的组件来实现的，组件模型又负责生命周期管理以及连接组件之间的相互依赖关系。组件模型将查找带有特定属性的类，这些类声明了组件的生存期范围。依赖性被声明为构造函数参数。在适当的时候，组件模型将创建组件的新实例，确保首先创建所有依赖项，并将其传递给构造函数。</p>

<aside class="note">
  <p>如果您熟悉<a href="http://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener noreferrer" data-external="true" target="_blank"><span>控制反转</span></a>和<a href="http://en.wikipedia.org/wiki/Dependency_injection" rel="noopener noreferrer" data-external="true" target="_blank"><span>依赖注入</span></a>的概念，那么ReSharper的组件模型将遵循以下模式，并实现一个IoC容器以自动创建和<a href="http://en.wikipedia.org/wiki/Dependency_injection" rel="noopener noreferrer" data-external="true" target="_blank"><span>关联</span></a>依赖关系</p>
</aside>

<p>这种松散耦合的设计允许轻松扩展ReSharper-可以轻松地将新组件发布到组件模型，并且可以通过声明构造函数参数来使用服务。如果不使用和理解组件模型，则无法与ReSharper集成。</p>

<p>从概念上讲，组件模型与Microsoft的<a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx" rel="noopener noreferrer" data-external="true" target="_blank"><span>托管可扩展性框架（MEF）</span></a>非常相似，尽管它们之间存在一些根本差异，例如在运行时动态加载和卸载新组件的能力。</p>

<p>ReSharper定义了许多组件类型。最有趣的两个是<code class="code highlight language-text">ShellComponent</code>和<code class="code highlight language-text">SolutionComponent</code> 。有关其他组件类型的更多详细信息，请参见<code class="code highlight language-text">Parts</code>在<a href="ComponentModel/ContainersPartsCatalogues.html"><span>容器，零件和目录中</span></a> 。</p>

<a name="shell-components" class="elem-anchor"></a>
<h2>外壳组件<a href="#shell-components" class="anchor-link"><span></span></a></h2>

<p><strong>Shell组件</strong>是ReSharper启动时创建的类。外壳组件通常标有<code class="code highlight language-text">[ShellComponent]</code>属性。它与ReSharper本身的寿命基本相同。Shell组件实际上是单例，并且在创建非特定于解决方案的服务时最有用。例如，实时模板宏定义是外壳程序组件。它们不使用也不依赖与解决方案相关的任何东西，并且在外壳的整个生命周期内都不会改变。</p>

<p>要定义一个外壳组件，只需编写：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span> <span class="c1">// ...</span> <span class="p">}</span></code></div>

<p>当外壳启动时，ReSharper将创建此类的实例。</p>

<p>如果某个组件需要与其他组件通信，则可以简单地将它们添加为构造函数参数，并且组件模型将确保首先创建相关组件，然后将其传入构造中。从属组件必须具有相同的生存期范围或更长的生存期，因此一个外壳程序组件只能请求另一个外壳程序组件。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">SomeOtherClass</span> <span class="p">{</span> <span class="k">private</span> <span class="n">MyClass</span> <span class="n">myClass</span><span class="p">;</span> <span class="k">public</span> <span class="nf">SomeOtherClass</span><span class="p">(</span><span class="n">MyClass</span> <span class="n">myClass</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">myClass</span> <span class="p">=</span> <span class="n">myClass</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>构造函数注入是访问依赖项的首选方法。但是，在某些情况下，这是不可能的-例如，动作处理程序不是由组件模型创建的。在这种情况下，您可以使用服务定位器模式并要求依赖项：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">void</span> <span class="nf">SomeMethod</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Shell.Instance is a static property</span> <span class="kt">var</span> <span class="n">myClass</span> <span class="p">=</span> <span class="n">Shell</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">GetComponent</span><span class="p"><</span><span class="n">MyClass</span><span class="p">>();</span> <span class="p">}</span></code></div>

<p>但是请注意， <code class="code highlight language-text">Shell.Instance.GetComponent</code>仅返回外壳组件，而不返回解决方案组件。</p>

<a name="solution-components" class="elem-anchor"></a>
<h2>解决方案组件<a href="#solution-components" class="anchor-link"><span></span></a></h2>

<p><strong>解决方案组件</strong>是与解决方案生命周期相关的组件。每次打开新解决方案时都会创建它们，并使用<code class="code highlight language-text">[SolutionComponent]</code>属性。同样，构造函数注入是满足依赖关系的首选方法。一种<code class="code highlight language-text">SolutionComponent</code>可以同时依靠<code class="code highlight language-text">SolutionComponent</code>和<code class="code highlight language-text">ShellComponent</code>实例，因为外壳组件的寿命比解决方案组件的寿命长。</p>

<p>您还可以使用服务定位器模式来请求解决方案组件。有几种方法可以在解决方案级别获得组件模型，通常使用<code class="code highlight language-text">GetComponent</code>要么<code class="code highlight language-text">GetComponents</code>扩展方法。例如， <code class="code highlight language-text">IDataContext</code>传递给动作处理程序的对象可用于检索组件，或者<code class="code highlight language-text">ISolution</code>和<code class="code highlight language-text">IProject</code>接口具有扩展方法。同样，直接要求组件时，您可以要求解决方案组件或外壳组件。例如：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="kt">var</span> <span class="n">solution</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">GetData</span><span class="p">(</span><span class="n">JetBrains</span><span class="p">.</span><span class="n">ProjectModel</span><span class="p">.</span><span class="n">DataContext</span><span class="p">.</span><span class="n">DataConstants</span><span class="p">.</span><span class="n">SOLUTION</span><span class="p">);</span> <span class="kt">var</span> <span class="n">dtm</span> <span class="p">=</span> <span class="n">solution</span><span class="p">.</span><span class="n">GetComponent</span><span class="p"><</span><span class="n">DocumentTransactionManager</span><span class="p">>();</span></code></div>

<p>可以注入或要求的一个非常重要的对象是<code class="code highlight language-text">ISolution</code> 。这使解决方案级别的组件可以使用其当前上下文（即为其创建的解决方案）。</p>

<a name="component-cleanup" class="elem-anchor"></a>
<h2>组件清理<a href="#component-cleanup" class="anchor-link"><span></span></a></h2>

<p>组件与特定的生命周期息息相关-外壳的生命周期<code class="code highlight language-text">ShellComponent</code>实例和解决方案的生命周期<code class="code highlight language-text">SolutionComponent</code>实例。当解决方案关闭或外壳终止时，该组件现在不在范围内，可用于垃圾回收。如果您需要进行垃圾收集无法处理的任何显式清理，则可以实施<code class="code highlight language-text">IDisposable</code>然后组件模型将调用<code class="code highlight language-text">Dispose</code>为了你。</p>

<p>或者，您应该注入一个实例<code class="code highlight language-text">Lifetime</code>到您的构造函数中，并向其注册回调。的<code class="code highlight language-text">Lifetime</code>对象在组件的生存期结束时终止，并会在那时调用所有已注册的回调。 <code class="code highlight language-text">Lifetime</code>是用于生命周期管理的非常强大的结构，并且需要<a href="Lifetime.html"><span>单独记录</span></a> 。</p>

<p>您应该确保不保留超出组件范围的任何引用。例如，shell组件不应获取并缓存以下实例： <code class="code highlight language-text">ISolution</code>或任何其他解决方案组件，因为这会导致内存泄漏。</p>

<a name="dependency-failures" class="elem-anchor"></a>
<h2>依赖失败<a href="#dependency-failures" class="anchor-link"><span></span></a></h2>

<p>通过组件模型连接应用程序的一个缺点是错误可能会级联。例如，无法创建带有采用解决方案组件的构造函数的Shell组件，并且组件模型将引发异常。但是依赖于这个失败的第一个shell组件的第二个shell组件现在将无法创建，依此类推，从而可能破坏整个应用程序的稳定性。应该注意适当地要求依赖，并且不要在构造函数中引起异常。</p>

<p>由于级联错误，故障排除最初看起来非常困难，所有这些错误都会引发异常。重要的例外是第一个，它将告诉您在创建过程中哪个组件失败。失败将与构造函数参数之一有关，因此应检查每个参数-参数类型是组件吗？它是否来自相同或更高的范围（即外壳组件是否试图依赖解决方案组件）？参数是否具有正确的基数（单个实例与集合）？</p>

<p>ReSharper 9.0添加了更好的诊断程序，用于对组件模型故障进行故障排除，描述了引起问题的参数，并为异常的原因添加了更多上下文。 <code class="code highlight language-text">Data</code>字典。此数据仅在已<a href="/help/resharper/sdk/Extensions/Tools.html"><span>检查的版本中</span></a>可用。</p>

<a name="lazy-and-optional-acquisition" class="elem-anchor"></a>
<h2>懒惰和可选的获取<a href="#lazy-and-optional-acquisition" class="anchor-link"><span></span></a></h2>

<p>依赖项可以声明为惰性或可选。</p>

<p>惰性依赖关系将仅在使用时解决，而不在创建拥有组件时解决。只需使用<code class="code highlight language-text">JetBrains.Util.Lazy<ComponentType></code>代替<code class="code highlight language-text">ComponentType</code>查询或注入组件时。请注意，这不适用于BCL <code class="code highlight language-text">System.Lazy</code>类型，因为它是.net 4类型，而ReSharper是.net 3.5应用程序（尽管在VS2010和VS2012中托管时，它在.net 4中运行）。</p>

<p>可选依赖项在组件创建时已解决（与普通组件相同），但可能会丢失，如果是，则为null。您通过请求来声明可选的依赖项<code class="code highlight language-text">Optional<ComponentType></code>代替<code class="code highlight language-text">ComponentType</code> 。</p>

<a name="other-component-types" class="elem-anchor"></a>
<h2>其他组件类型<a href="#other-component-types" class="anchor-link"><span></span></a></h2>

<p>ReSharper支持多种类型的组件，而不仅仅是外壳和解决方案组件。为了完整性，它还支持<code class="code highlight language-text">EnvironmentComponent</code> ， <code class="code highlight language-text">ShellInstanceComponent</code>和<code class="code highlight language-text">ProjectComponent</code> 。</p>

<p>一种<code class="code highlight language-text">ShellComponent</code>具有与ReSharper相同的生存期，但是可能与Visual Studio的生存期不同-如果有人暂停并恢复ReSharper，则将释放所有外壳组件，然后重新创建它们。ReSharper首次启动时会创建一个环境组件，该组件持续到托管应用程序（例如Visual Studio）的持续时间，无论是否挂起和继续。它用于ReSharper的集成基础结构，通常来说，插件作者不应该使用它。</p>

<p><code class="code highlight language-text">ShellInstanceComponent</code>也是在解决方案打开时创建的基础结构组件。同样，插件几乎不需要使用它，使用<code class="code highlight language-text">ShellComponent</code>代替。</p>

<p><code class="code highlight language-text">ProjectComponent</code>允许为每个加载的项目创建一个类。这意味着，与shell和解决方案组件不同，它不是单例-每个加载的项目都会有一个实例。如果项目被卸载或删除，则组件被释放。如果将新项目添加到当前解决方案，则会创建一个新组件。组件模型可以注入一个实例<code class="code highlight language-text">IProject</code>给组件一些上下文。通常用于项目级别的设置和属性（例如，项目级别的Live Templates或C＃语言级别）。除此之外，很少使用。</p>

<a name="derived-component-types" class="elem-anchor"></a>
<h3>派生组件类型<a href="#derived-component-types" class="anchor-link"><span></span></a></h3>

<p>还有其他组件属性类型可以从中派生<code class="code highlight language-text">ShellComponentAttribute</code>和<code class="code highlight language-text">SolutionComponentAttribute</code> （例如<code class="code highlight language-text">PsiComponentAttribute</code>和<code class="code highlight language-text">CodeCleanupModuleAttribute</code> ）。除派生的属性允许分组或将信息传递给使用者外，这些属性与常规外壳或解决方案组件相同。另一用途是用注释标记属性，以帮助实现。例如，任何具有以下属性的类<code class="code highlight language-text">MeansImplicitUse</code>该属性将被ReSharper标记为正在使用，即使<code class="code highlight language-text">new</code>没有显式调用它。同样，具有属性的类具有<code class="code highlight language-text">BaseTypeRequired</code>如果该类不是从命名的基本类型派生的，则注释将显示警告。</p>

<a name="parts" class="elem-anchor"></a>
<h3>部分<a href="#parts" class="anchor-link"><span></span></a></h3>

<p>诸如Shell和解决方案组件之类的组件以及诸如代码清理模块组件之类的派生类型是ReSharper中组件模型的最常见用法，支持已知的生存期和使用要求。但是，它们不是唯一的用法。组件模型实现了一个由“零件”填充的“控制反转”容器，而外壳和解决方案组件被实现为由组件标识的零件的嵌套组件。 <code class="code highlight language-text">[ShellComponent]</code>和<code class="code highlight language-text">[SolutionComponent]</code>属性。其他组件创建自己的容器以自定义生命周期和使用情况。有关更多详细信息<a href="ComponentModel/ContainersPartsCatalogues.html"><span>，</span></a>请参见“ <a href="ComponentModel/ContainersPartsCatalogues.html"><span>容器，零件和目录”</span></a>部分。</p>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Platform/Lifetime.html">终生</a> <a class="navigation-links__next" href="/Platform/Zones.html">区域</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>