<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>容器，零件和目录/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//Platform/ComponentModel/ContainersPartsCatalogues.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Containers, Parts and Catalogues">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Containers, Parts and Catalogues">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="Platform/ComponentModel/ContainersPartsCatalogues">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Platform/VisualStudio/ComponentModel.html">组件模型和Visual Studio界面</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/Platform/ComponentModel/ContainersPartsCatalogues.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>容器，零件和目录</h1>
                    <aside class="note">
  <p>这是对组件模型的实施的高级深入研究。为了使用组件模型，解决方案或外壳组件，没有必要理解这一点。</p>
</aside>

<ul id="markdown-toc">
  <li><a href="#containers" id="markdown-toc-containers"><span>货柜</span></a></li>
  <li><a href="#registering-part-types" id="markdown-toc-registering-part-types"><span>注册零件类型</span></a></li>
  <li><a href="#chaining-containers" id="markdown-toc-chaining-containers"><span>连锁容器</span></a></li>
  <li><a href="#registering-resolvers" id="markdown-toc-registering-resolvers"><span>注册解析器</span></a></li>
  <li><a href="#composition" id="markdown-toc-composition"><span>组成</span></a></li>
  <li><a href="#resolving-instances" id="markdown-toc-resolving-instances"><span>解决实例</span></a></li>
  <li><a href="#cardinality" id="markdown-toc-cardinality"><span>基数</span></a></li>
  <li><a href="#overriding-and-replacing-components" id="markdown-toc-overriding-and-replacing-components"><span>覆盖和替换组件</span></a></li>
  <li><a href="#catalogue-sets" id="markdown-toc-catalogue-sets"><span>目录集</span></a></li>
  <li><a href="#catalogues" id="markdown-toc-catalogues"><span>产品目录</span></a></li>
</ul>

<p>组件模型旨在创建松耦合的可组合应用程序。Shell和解决方案组件只是做到这一点的一个示例，它们在基础架构之上实现，从而可以为组件创建和生存期提供更大的灵活性和自定义处理。换句话说，组件模型是一个完整<a href="http://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener noreferrer" data-external="true" target="_blank"><span>的控制反转</span></a>框架。</p>

<p>在应用程序启动时，ReSharper将创建多个“容器”。它们是环境容器，外壳容器，以及打开溶液时的溶液容器。这些容器是基于目录集（即目录集合）创建的，其中目录是程序集和导出类型（称为“零件”）的集合。默认情况下，零件被识别为装饰有类型的类型，该属性从<code class="code highlight language-text">PartAttribute</code> 。都<code class="code highlight language-text">ShellComponentAttribute</code>和<code class="code highlight language-text">SolutionComponentAttribute</code>间接地<code class="code highlight language-text">PartAttribute</code> 。</p>

<p>容器负责根据零件类型创建对象实例。在零件类型的构造函数中声明的所有依赖关系也会被创建并传递。容器还负责这些零件的寿命管理，终止每个零件的使用寿命。 <code class="code highlight language-text">Lifetime</code>或打电话<code class="code highlight language-text">Dispose</code>当容器本身终止时。组成容器时将创建所有对象实例。</p>

<p>通常，最终用户代码不需要此基础结构。将代码标记为外壳或解决方案组件通常就足够了。但是，有时有必要以其他方式管理寿命或构造，并且可以使用单独的容器来完成。例如，PSI的<code class="code highlight language-text">DaemonStageManager</code>类创建自己的容器来管理处理分析突出显示的类，以便正确处理阶段的正确分组和排序。它根据应用程序的目录集创建容器，过滤用装饰符装饰的零件<code class="code highlight language-text">[DaemonStage]</code>属性。声明为<code class="code highlight language-text">[SolutionComponent]</code> ，这意味着容器及其所有组件也适用于解决方案寿命。</p>

<a name="containers" class="elem-anchor"></a>
<h2>货柜<a href="#containers" class="anchor-link"><span></span></a></h2>

<p>的<code class="code highlight language-text">ComponentContainer</code> class是容器的实现，负责将零件解析为对象实例。它需要一个集合<code class="code highlight language-text">IComponentDescriptor</code>实例，每个实例都知道如何创建单个零件。当容器“组成”时，将迭代组件描述符，并创建组件，从而像以前一样解决依赖关系。</p>

<p>组成容器后，容器可以通过将零件类型传递到列表中来解决零件类型请求。 <code class="code highlight language-text">IValueResolvers</code>可以将零件类型请求映射到一个或多个组件描述符实例。描述符解析后，将使用描述符的缓存对象实例。值解析器的工作是允许为不在组件描述符中的类型创建新的描述符，例如， <code class="code highlight language-text">IEnumerable<TPart></code> ， <code class="code highlight language-text">IViewable<TPart></code>要么<code class="code highlight language-text">Lazy<TPart></code> 。</p>

<p>创建一个容器只需调用即可<code class="code highlight language-text">new</code> ，传入<code class="code highlight language-text">Lifetime</code>以及用于诊断的ID。的<code class="code highlight language-text">Lifetime</code>是容器的控制寿命-当<code class="code highlight language-text">Lifetime</code>终止，容器终止，所有组件描述符和值解析器也终止。作为其一部分，所有组件实例也将终止，并且任何<code class="code highlight language-text">Dispose</code>方法被调用。</p>

<p>构造函数的第三个参数是的实例<code class="code highlight language-text">IInitializationStrategy</code> 。用于控制组成容器时如何创建零件。稍后再详细介绍。</p>

<a name="registering-part-types" class="elem-anchor"></a>
<h2>注册零件类型<a href="#registering-part-types" class="anchor-link"><span></span></a></h2>

<p>在组成容器之前，它必须知道如何为所请求的零件创建组件实例。这是由<code class="code highlight language-text">IComponentDescriptor</code>实例，每个实例都描述了如何创建单个零件。这些组件描述符通过以下方法之一传递到容器：</p>

<ul>
  <li><code class="code highlight language-text">RegisterSource(IViewable<IEnumerable<IComponentDescriptor>> componentSource)</code>注册组件描述符序列的可观察集合。此可观察的集合可以随时添加或删除新的描述符集合。</li>
  <li><code class="code highlight language-text">RegisterDescriptors(IList<IComponentDescriptor> descriptors)</code>和<code class="code highlight language-text">RegisterDescriptors(Lifetime, IList<IComponentDescriptor> descriptors)</code> 。后者允许将描述符绑定到<code class="code highlight language-text">Lifetime</code> ，并在<code class="code highlight language-text">Lifetime</code>终止。</li>
</ul>

<p>组件模型提供了以下几种实现<code class="code highlight language-text">IComponentDescriptor</code> ，包括以单例形式创建的零件，通过工厂方法创建的零件以及包装在其中的零件<code class="code highlight language-text">Lazy<T></code> 。而不是使用<code class="code highlight language-text">RegisterDescriptors</code>直接使用方法，通常更容易在<code class="code highlight language-text">ComponentContainerEx</code> ：</p>

<ul>
  <li><code class="code highlight language-text">Register(this ComponentContainer, Type type)</code> ， <code class="code highlight language-text">Register<T>(this ComponentContainer)</code>和<code class="code highlight language-text">Register<T>(this ComponentContainer, Lifetime)</code>向容器注册类型，可以选择向<code class="code highlight language-text">Lifetime</code>以允许从容器中删除类型。添加到容器的描述符是的实例<code class="code highlight language-text">SingletonTypeComponentDescriptor</code> ，它创建该类型的单例实例。</li>
  <li><code class="code highlight language-text">Register(this ComponentContainer, object instance)</code>注册一个现有的对象实例。</li>
  <li><code class="code highlight language-text">Register(this ComponentContainer, Func<IValueResolveContext, T> factory)</code>注册一个带有可解析上下文的工厂，并返回一个对象。返回的值被视为单例。</li>
</ul>

<p>但是，提供描述符的最简单方法是使用<code class="code highlight language-text">RegisterSource</code>具有的实例的方法<code class="code highlight language-text">CatalogueComponentSource</code> 。此类转换实现的目录集<code class="code highlight language-text">IPartsCatalogueSet</code>到组件描述符的集合中。由于它也是<code class="code highlight language-text">IViewable</code>在组件描述符集合中，每当将新目录添加到目录集中时，它都会广播组件描述符的新集合。</p>

<p>源代码也使用<code class="code highlight language-text">IPartsSelector</code>和一个集合<code class="code highlight language-text">IPartsCatalogueFilter</code>实例。两项都从目录集中过滤零件，但出于不同的目的。</p>

<p>的<code class="code highlight language-text">IPartsSelector</code>用于选择可以创建的零件。通常，这是静态实例<code class="code highlight language-text">PartsSelector</code>类：</p>

<ul>
  <li><code class="code highlight language-text">PartsSelector.Leafs</code>仅选择叶子部分。这允许通过派生类覆盖零件。如果基类和派生类都被标识为一部分（通常是由于<code class="code highlight language-text">[Part]</code>派生属性），则在解析基本接口时，这两个类均符合条件。仅选择叶部分将去除基类，并且仅选择派生类。</li>
  <li><code class="code highlight language-text">PartsSelector.LeafsAndHides</code>仅选择叶子零件，但也允许零件替换另一个零件。如果零件实现<code class="code highlight language-text">IHideImplementation<TPart></code>然后有类型的部分<code class="code highlight language-text">TPart</code>未选择。这允许在不派生的情况下覆盖实现。</li>
  <li><code class="code highlight language-text">PartsSelector.All</code>选择所有部分，叶子和非叶子。如果基本和派生组件实例都可以解析所请求的接口，则可能导致抛出组件模型。</li>
  <li><code class="code highlight language-text">PartsSelector.Default</code> 。与...相同<code class="code highlight language-text">PartsSelector.LeafsAndHides</code> 。</li>
</ul>

<p>的集合<code class="code highlight language-text">IPartsCatalogueFilter</code>可用于过滤要创建的零件，例如，使用<code class="code highlight language-text">CatalogueAttributeFilter</code>过滤<code class="code highlight language-text">SolutionComponentAttribute</code>部分。</p>

<p>注册源的最简单方法是使用<code class="code highlight language-text">RegisterCatalogue</code>的扩展方法<code class="code highlight language-text">CatalogueComponents</code> ：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">void</span> <span class="nf">Register</span><span class="p">(</span><span class="n">ComponentContainer</span> <span class="n">container</span><span class="p">,</span> <span class="n">IPartsCatalogSet</span> <span class="n">catalogSet</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Register a catalog set with an attribute filter for MyPartAttribute</span> <span class="n">container</span><span class="p">.</span><span class="n">RegisterCatalogue</span><span class="p"><</span><span class="n">MyPartAttribute</span><span class="p">>(</span><span class="n">catalogSet</span><span class="p">);</span> <span class="p">}</span></code></div>

<p>请注意，如果在组成容器之后添加了新的组件描述符，则将重新组成容器，并且新实例将立即实例化并可用。</p>

<a name="chaining-containers" class="elem-anchor"></a>
<h2>连锁容器<a href="#chaining-containers" class="anchor-link"><span></span></a></h2>

<p>容器可以“链接”到另一个容器。解析类型时，如果找不到，则将调用链接的容器。这允许满足存在于当前容器外部的依赖关系。例如，解决方案容器具有<code class="code highlight language-text">SolutionAttribute</code>基于零件的零件，但是其中一些解决方案零件将需要依赖关系，这些零件是外壳零件。通过将解决方案容器链接到外壳容器，可以从外壳容器中满足那些依赖关系。</p>

<p>链接由<code class="code highlight language-text">ChainTo</code>扩展方法：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="n">ComponentContainer</span> <span class="nf">Create</span><span class="p">(</span><span class="n">CatalogComponentSource</span> <span class="n">source</span><span class="p">,</span> <span class="n">ComponentContainer</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">ComponentContainer</span><span class="p">(</span><span class="n">lifetime</span><span class="p">,</span> <span class="s">"myContainer"</span><span class="p">)</span> <span class="p">.</span><span class="nf">RegisterSource</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">.</span><span class="nf">ChainTo</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span> <span class="p">}</span></code></div>

<a name="registering-resolvers" class="elem-anchor"></a>
<h2>注册解析器<a href="#registering-resolvers" class="anchor-link"><span></span></a></h2>

<p>每个零件类型都作为一个实例注册到容器中<code class="code highlight language-text">IComponentDescriptor</code> 。该接口继承了<code class="code highlight language-text">IValueDescriptor</code>介面，提供<code class="code highlight language-text">GetValue</code>获取描述符的实际对象实例的方法。</p>

<p>每个注册的描述符都可以创建特定类型对象的实例，但是没有用于返回实现公共接口的部件列表的描述符-例如，如果某个组件想要获取所有可以处理代码完成的对象实例，可以添加一个构造函数依赖项<code class="code highlight language-text">IEnumerable<ICodeCompletionItemsProvider></code> ，或获取处理容器重新组合的实时列表， <code class="code highlight language-text">IViewable<ICodeCompletionItemsProvider></code> 。</p>

<p>这些类型的请求由一组可扩展的值解析器处理，以实现<code class="code highlight language-text">IValueResolver</code>接口。这些值解析器接受零件类型的请求，并返回的实例。 <code class="code highlight language-text">IValueDescriptor</code> 。例如，默认组件解析器仅在已注册的组件描述符中查找零件类型，然后将其返回。</p>

<p>解析时，容器将通过一组已知的解析器链接对类型的请求：</p>

<ul>
  <li><code class="code highlight language-text">EnumerableValueResolver</code>这将返回一个<code class="code highlight language-text">IEnumerable<TPart></code>所有类型的组件实例<code class="code highlight language-text">TPart</code></li>
  <li><code class="code highlight language-text">ViewableValueResolver</code>返回现场<code class="code highlight language-text">IViewable<TPart></code>其中将包含在重组容器时发现的任何新组件实例（也许新目录已添加到目录集中）。</li>
  <li>默认组件解析器，它仅在组件描述符列表中查找零件。</li>
  <li><code class="code highlight language-text">DelegatingContainerValueResolver</code>将处理任何有关<code class="code highlight language-text">IComponentContainer</code>通过查看当前上下文并找到父容器</li>
  <li><code class="code highlight language-text">LifetimeValueResolver</code>将满足任何要求<code class="code highlight language-text">Lifetime</code>通过创建一个价值解析器来管理<code class="code highlight language-text">LifetimeDefinition</code> 。当要求输入值时，它将创建一个<code class="code highlight language-text">Lifetime</code>实例。当容器终止时，所有值解析器终止，并且任何<code class="code highlight language-text">LifetimeDefinition</code>此处的实例也将终止。这就是<code class="code highlight language-text">Lifetime</code>传递给组件构造函数的对象是托管的。</li>
  <li><code class="code highlight language-text">LoggerValueResolver</code>会解决<code class="code highlight language-text">ILogger</code>通过推迟到<code class="code highlight language-text">Logger.GetLogger()</code>使用请求类型的标准名称。</li>
  <li><code class="code highlight language-text">LazyValueResolver</code>会解决<code class="code highlight language-text">Lazy<TPart></code>要求。返回的<code class="code highlight language-text">Lazy<T></code>使用时会延迟解析所请求的部分。请注意，这要求<code class="code highlight language-text">JetBrains.Util.Lazy<T></code>并且不支持<code class="code highlight language-text">System.Lazy<T></code> （由于ReSharper是.net 3.5应用程序， <code class="code highlight language-text">System.Lazy<T></code>是.net 4类型。ReSharper将抛出一个明确的异常是<code class="code highlight language-text">System.Lazy<T></code>用来。</li>
  <li><code class="code highlight language-text">OptionalValueResolver</code>会解决<code class="code highlight language-text">Optional<T></code>要求。返回的目标<code class="code highlight language-text">Optional<T></code>立即被评估，但可以返回null而不会引发异常。</li>
</ul>

<p>的<code class="code highlight language-text">ComponentContainer.RegisterResolver</code>方法允许注册要插入的自定义解析器，以及实现容器链接的方式。</p>

<a name="composition" class="elem-anchor"></a>
<h2>组成<a href="#composition" class="anchor-link"><span></span></a></h2>

<p>通过简单地调用即可简单地处理合成<code class="code highlight language-text">Compose</code> 。容器将通过每个<code class="code highlight language-text">IComponentDescriptor</code>到<code class="code highlight language-text">IInitializationStrategy.Schedule</code>传递给容器构造函数的策略方法。如果未通过任何策略，则<code class="code highlight language-text">InitializationStrategyDefault</code>使用类，它立即调用<code class="code highlight language-text">GetValue()</code>在描述符上，它立即创建并缓存组件实例。</p>

<p>另外，在创建容器时，您可以传入<code class="code highlight language-text">DelayedInitializationStrategy</code> ，它会安排每次呼叫<code class="code highlight language-text">IComponentDescriptor</code>到目前<code class="code highlight language-text">Dispatcher</code> ，作为背景优先操作。这意味着它将在应用程序的<code class="code highlight language-text">Dispatcher</code>下一个空闲。请注意，初始化仍将在当前线程上进行。</p>

<aside class="note">
  <p>该策略对于应用程序启动非常有用，因为它意味着应用程序在启动期间不再阻塞。但是，应谨慎使用！使用默认策略，所有对象都在实例化之前被实例化。 <code class="code highlight language-text">Compose</code>方法完成。用<code class="code highlight language-text">DelaredInitializationStrategy</code> ，致电<code class="code highlight language-text">Compose</code>在实例化所有对象之前完成。</p>

  <p>但是，尝试解析仍在排队等待延迟初始化的零件，只会创建并缓存对象实例，从而解决所有依赖关系。因此，使用延迟初始化的组件是安全的。</p>
</aside>

<p>组件可以通过设置<code class="code highlight language-text">Requirement</code>属性的属性：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent(Requirement = InstantiationRequirement.Immediate)]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyImmediateComponent</span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>已为应用程序启动添加了此功能，该功能自动应用于外壳容器，而不应用于其他容器。因此， <code class="code highlight language-text">Requirement</code>属性仅在<code class="code highlight language-text">ComponentAttribute</code> ，而不是<code class="code highlight language-text">PartsAttribute</code> 。但是，（警告-实施细节！）反射代码以寻找<code class="code highlight language-text">Requirement</code>属性是松散类型的，并且可以与在<code class="code highlight language-text">PartsAttribute</code>派生类型。</p>

<a name="resolving-instances" class="elem-anchor"></a>
<h2>解决实例<a href="#resolving-instances" class="anchor-link"><span></span></a></h2>

<p>构成容器后，可以使用中的扩展方法检索对象实例。 <code class="code highlight language-text">ComponentContainerEx</code> 。这些方法包括：</p>

<ul>
  <li><code class="code highlight language-text">GetViewable<T></code>返回一个<code class="code highlight language-text">IViewable<T></code>所有当前实例的可观察集合<code class="code highlight language-text">T</code>在容器中。它还将通知从组件源添加到容器的任何新实例。</li>
  <li><code class="code highlight language-text">GetComponents<T></code>返回一个<code class="code highlight language-text">IEnumerable<T></code>当前所有实例中<code class="code highlight language-text">T</code>在容器中。这不是“实时”集合-添加的任何新实例都不会反映在枚举中。</li>
  <li><code class="code highlight language-text">GetComponent<T></code>返回一个的实例<code class="code highlight language-text">T</code> 。如果存在多个实例，则将抛出此方法。</li>
  <li><code class="code highlight language-text">TryGetComponent<T></code>尝试返回的实例<code class="code highlight language-text">T</code> ，如果它存在于容器中。如果不存在，则out参数为null，该方法返回<code class="code highlight language-text">false</code> 。</li>
  <li><code class="code highlight language-text">HasComponent<T></code>看看是否有一个实例<code class="code highlight language-text">T</code>存在于容器中。</li>
</ul>

<p>这些方法无需花很多精力来管理实例<code class="code highlight language-text">IValueResolveContext</code>打电话时<code class="code highlight language-text">ComponentContainer.Resolve</code>得到一个实例<code class="code highlight language-text">IValueDescriptor</code> 。如果返回描述符（容器将返回<code class="code highlight language-text">null</code>如果描述符不可用）， <code class="code highlight language-text">IValueDescriptor.GetValue</code>方法被调用，返回值。通常，在组成容器时已经创建了该值，并返回了缓存的值。</p>

<p>的<code class="code highlight language-text">T</code>传递给这些方法的可以是所需实例的类型层次结构中的任何类型。它可以是派生程度最高的类，抽象基类或已实现的接口。</p>

<a name="cardinality" class="elem-anchor"></a>
<h2>基数<a href="#cardinality" class="anchor-link"><span></span></a></h2>

<p>通常，由于使用了容器，因此容器将仅由层次结构中派生最多的类型组成。 <code class="code highlight language-text">LeafsAndHides</code>零件选择器。但是，这并不表示容器中有多少个特定基本类型或接口的实例可用。例如，给出以下内容：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IFoo</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">Foo1</span> <span class="p">:</span> <span class="n">IFoo</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">Foo2</span> <span class="p">:</span> <span class="n">IFoo</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MostDerived</span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>容器将提供两个实例<code class="code highlight language-text">IFoo</code> -- <code class="code highlight language-text">Foo1</code>和<code class="code highlight language-text">Foo2</code> 。但是，只有实现<code class="code highlight language-text">Base</code> -的<code class="code highlight language-text">MostDerived</code>类。</p>

<p>在构造函数中使用依赖项时，务必要做到这一点。例如，以下构造函数将失败，因为存在多个实例<code class="code highlight language-text">IFoo</code>可以满足参数：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MyComponent</span><span class="p">(</span><span class="n">IFoo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>每个组件描述符被分配一个“基数”-单个或多个。基数是在第一次解析组件时设置的。如果正在解决单个实例，例如使用<code class="code highlight language-text">IFoo</code>在上面的示例中，基数设置为“单个”。如果<code class="code highlight language-text">IEnumerable<T></code>要么<code class="code highlight language-text">IViewable<T></code>正在解决， <code class="code highlight language-text">T</code>设置为“多个”。</p>

<p>运行检查的构建时，只要解决了组件，基数都会被验证，如果请求的基数与组件的基数不匹配，则会记录错误并引发异常。当不运行检查的构建时，不会进行此验证，并且组件模型将尝试解析该组件。当请求具有单个基数的组件的多个实例时，此操作将成功（它将返回一个项的集合），但是，当尝试解析具有多个基数的组件的单个实例（应返回哪个？）时，它肯定会失败。</p>

<a name="overriding-and-replacing-components" class="elem-anchor"></a>
<h2>覆盖和替换组件<a href="#overriding-and-replacing-components" class="anchor-link"><span></span></a></h2>

<p>如上所示，仅将类型的最派生实例添加到容器中。这使得第三方代码可以覆盖属于ReSharper平台的类型。尽管这很有用，但不鼓励这样做，因为只有一个第三方可以覆盖某个组件-如果第二个第三方尝试覆盖同一个组件，则会向该组件引入多个叶实例，并且解析将失败。</p>

<p>也可以完全替换一个组件，而无需派生该组件。如果组件实现<code class="code highlight language-text">IHideImplementation<T></code> ，然后<code class="code highlight language-text">LeafsAndHides</code>选择器将替换现有的实现<code class="code highlight language-text">T</code>在具有当前组件的容器中。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ShellComponent]</span> <span class="k">public</span> <span class="k">void</span> <span class="n">AnotherComponent</span> <span class="p">:</span> <span class="n">IFoo</span> <span class="p">{</span> <span class="p">}</span> <span class="na">[ShellComponent]</span> <span class="k">public</span> <span class="k">void</span> <span class="n">MyComponent</span> <span class="p">:</span> <span class="n">IFoo</span><span class="p">,</span> <span class="n">IHideImplementation</span><span class="p"><</span><span class="n">AnotherComponent</span><span class="p">></span> <span class="p">{</span> <span class="p">}</span></code></div>

<p>虽然两者<code class="code highlight language-text">AnotherComponent</code>和<code class="code highlight language-text">MyComponent</code>实行<code class="code highlight language-text">IFoo</code> ， 只要<code class="code highlight language-text">MyComponent</code>被添加到容器中，因为它显式声明它隐藏了实现<code class="code highlight language-text">AnotherComponent</code> 。请注意，它隐藏了特定的实现类，并且没有隐藏的所有实现。 <code class="code highlight language-text">T</code> 。</p>

<a name="catalogue-sets" class="elem-anchor"></a>
<h2>目录集<a href="#catalogue-sets" class="anchor-link"><span></span></a></h2>

<p>容器零件类型的主要来源是目录集，该目录集本质上是可观察的目录集，实现了<code class="code highlight language-text">IPartsCatalogueSet</code>接口。</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IPartsCatalogueSet</span> <span class="p">{</span> <span class="n">IViewable</span><span class="p"><</span><span class="n">IPartsCatalogue</span><span class="p">></span> <span class="n">Catalogues</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="n">IViewable</span><span class="p"><</span><span class="n">IPartsCatalogue</span><span class="p">></span> <span class="n">CataloguesPreview</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>可观察的集合<code class="code highlight language-text">Catalogues</code>是目录集已知的当前目录的列表，但是它也会通知订户将新目录添加到该集中。这允许重新组合目录集，因此可以重新组合基于此目录集的所有容器。</p>

<p>的<code class="code highlight language-text">CataloguesPreview</code>属性是与<code class="code highlight language-text">Catalogues</code>属性，除了新目录会先添加到此集合中。这允许在处理新目录之前将新目录通知给查看者，从而在容器处理新类型之前进行工作。</p>

<p>在应用程序启动时， <code class="code highlight language-text">JetEnvironment</code>类负责设置目录集。它创建一个实例<code class="code highlight language-text">FullProductCatalogueSet</code> ，传入组成产品的所有程序集的列表。该目录集最初是由单个目录创建的，该目录由所有这些程序集组成，并且包含以下列类型装饰的类型列表<code class="code highlight language-text">[Part]</code>派生属性。该目录集是应用程序可用的所有部分的未经过滤的集合。请注意，尚未创建任何组件实例。</p>

<p>它还暴露了<code class="code highlight language-text">EnvironmentPartCatalogSet</code> ，这是<code class="code highlight language-text">PartsCatalogueSet</code> 。这是过滤后的视图<code class="code highlight language-text">FullProductCatalogSet</code>去除不属于<a href="/help/resharper/sdk/Platform/Zones.html"><span>区域的</span></a>任何部分。该目录集用于填充组件容器。</p>

<a name="catalogues" class="elem-anchor"></a>
<h2>产品目录<a href="#catalogues" class="anchor-link"><span></span></a></h2>

<p>一个<code class="code highlight language-text">IPartsCatalogue</code>是一个类，用于维护和公开有关目录中程序集以及将被视为零件的所有类型的元数据集合。默认情况下，零件被定义为装饰有以下类型的属性的任何类型： <code class="code highlight language-text">PartAttribute</code> ，但这不是必需的，并且组件模型可以使用任何类型。但是，ReSharper的容器仅支持<code class="code highlight language-text">[Part]</code>装饰零件。</p>

<p>有关程序集和类型的元数据不是来自反射，而是直接从程序集的IL中有效读取并进行缓存。</p>

<p>默认实现<code class="code highlight language-text">PartsCatalogue</code>维护程序集和类型的简单列表，而<code class="code highlight language-text">AttributedIndexedPartsCatalogue</code>优化属性定义的零件，并按属性索引每种零件类型，从而可以更快地访问所有零件，例如<code class="code highlight language-text">[SolutionComponent]</code>部分。</p>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        
                        <a class="navigation-links__next" href="/Platform/VisualStudio/ComponentModel.html">组件模型和Visual Studio界面</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>