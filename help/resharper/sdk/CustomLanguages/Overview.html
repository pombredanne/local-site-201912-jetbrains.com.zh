<html lang="en-US" ><head>
    <meta charset="UTF-8">
    <title>自定义语言/ ReSharper DevGuide</title>
    <link rel="stylesheet" href="/help/resharper/sdk/app/app.css">
    <link rel="shortcut icon" href="/help/resharper/sdk/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-57x57.png" sizes="57x57">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-60x60.png" sizes="60x60">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-72x72.png" sizes="72x72">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-114x114.png" sizes="114x114">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-120x120.png" sizes="120x120">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-144x144.png" sizes="144x144">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-152x152.png" sizes="152x152">
    <link rel="apple-touch-icon" href="/help/resharper/sdk/apple-touch-icon-180x180.png" sizes="180x180">
    <link rel="mask-icon" href="/help/resharper/sdk/apple-mask-icon.svg" color="black">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-square70x70logo" content="/help/resharper/sdk/mstile-70x70.png">
    <meta name="msapplication-TileImage" content="/help/resharper/sdk/mstile-144x144.png">
    <meta name="msapplication-square150x150logo" content="/help/resharper/sdk/mstile-150x150.png">
    <meta name="msapplication-wide310x150logo" content="/help/resharper/sdk/mstile-310x150.png">
    <meta name="msapplication-square310x310logo" content="/help/resharper/sdk/mstile-310x310.png">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.jetbrains.com/help/resharper/sdk//CustomLanguages/Overview.html">
    <meta property="og:site_name" content="JetBrains ReSharper">
    <meta property="og:title" content="Custom Languages">
    <meta property="og:description" content="Documentation for writing extensions for ReSharper">
    <meta property="og:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta property="article:modified_time" content="2017-07-10T19:28:42+00:00">
    <!-- <meta property="article:section" content="" /> 
    <meta property="article:tag" content="" /> -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@JBPlatform">
    <meta name="twitter:title" content="Custom Languages">
    <meta name="twitter:description" content="Documentation for writing extensions for ReSharper">
    <meta name="twitter:image" content="https://www.jetbrains.com/help/resharper/sdk/jetbrains.png">
    <meta class="swiftype" name="product" data-type="string" content="/help/resharper/sdk/">
<link rel="stylesheet" href="/help/resharper/sdk/app/styles.css"></head>
<body  data-id="CustomLanguages/Overview">
<div class="wrapper">
    <section class="panel _nav">
        <header class="panel__header">
            <div class="container">
                <form class="search-box">
                    <label class="search-box__label" for="search-box__input">
                        <input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper DevGuide">
                    </label>
                    <div class="search-box__clear" title="明确"></div>
                </form>
            </div>
        </header>
        <nav class="panel__content">
            <div class="container _nav">
                <menu class="nav-tree"></menu>
            </div>
            <div class="container _footer panel__footer">
                <p><a href="//youtrack.jetbrains.com/issues/IJSDK" data-bypass="true">发送反馈</a></p>
                <p>©2000–2018 <a href="//www.jetbrains.com">JetBrains</a> sro<br>版权所有。</p>
            </div>
        </nav>
    </section>

    <main class="panel _main" role="main">
        <header class="panel__header">
            <div class="container">
                <h3>ReSharper开发指南</h3>
                
                <div class="panel-trigger"></div>
            </div>
        </header>
        <section class="panel__content">
            <div class="container">
                <article class="article" data-shortcut-switcher="false">
                    <div class="navigation-links _top" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Products/InspectCode.html">InspectCode插件</a> <a class="navigation-links__next" href="/CustomLanguages/Registration.html">注册自定义语言</a>
                    </div>
                    <a href="https://github.com/JetBrains/resharper-devguide/edit/master/CustomLanguages/Overview.md" class="page-link-to-github" rel="noopener noreferrer" title="在GitHub上编辑此页面" data-bypass="true" target="_blank">
                        <i class="github-icon"></i> <span class="text">编辑页面</span>
                    </a>

                    <h1>自订语言</h1>
                    <p>在本指南的这一部分中，我们将研究为一种新语言开发ReSharper支持。我们将看以下内容：</p>

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction"><span>介绍</span></a></li>
  <li><a href="#tools" id="markdown-toc-tools"><span>工具类</span></a></li>
  <li><a href="#cslex" id="markdown-toc-cslex"><span>CsLex</span></a></li>
  <li><a href="#parsergen" id="markdown-toc-parsergen"><span>解析器</span></a></li>
  <li><a href="#language-definition" id="markdown-toc-language-definition"><span>语言定义</span></a></li>
  <li><a href="#project-file-type" id="markdown-toc-project-file-type"><span>项目文件类型</span></a></li>
  <li><a href="#project-file-language-service" id="markdown-toc-project-file-language-service"><span>项目文件语言服务</span></a></li>
  <li><a href="#psi-properties" id="markdown-toc-psi-properties"><span>PSI属性</span></a></li>
  <li><a href="#language-service" id="markdown-toc-language-service"><span>语言服务</span></a></li>
</ul>

<a name="introduction" class="elem-anchor"></a>
<h2>介绍<a href="#introduction" class="anchor-link"><span></span></a></h2>

<p>ReSharper支持多种语言，还支持多种语言（例如， <code class="code highlight language-text">.cshtml</code>文件是C＃和HTML的混合物）。插件编写者可以使用现有的基础结构来支持ReSharper中的新语言。语言实现可以是插件，也可以是插件的一部分，在大多数情况下，不需要任何特殊操作即可被ReSharper识别和识别。</p>

<aside class="note">
  <p>尽管可以使用任何.NET兼容的编程语言来提供新的语言支持，但是提供的解析/词法分析工具仅支持C＃编程语言。</p>
</aside>

<a name="tools" class="elem-anchor"></a>
<h2>工具类<a href="#tools" class="anchor-link"><span></span></a></h2>

<p>语言的解析和词法分析需要专门的工具。这就是为什么从7.0版本开始，ReSharper SDK附带了一组工具和目标文件以及一个完全可行的示例来支持一种新语言。包括以下项目：</p>

<ul>
  <li><strong>CsLex-</strong>用于为不同语言创建词法分析器的工具。</li>
  <li><strong>爪哇</strong> -包含IKVM的基础设施，它允许基于Java的解析器发电机的运行。</li>
  <li><strong>MSBuild-</strong>包含可用于自动进行词法分析器和解析器构造的构建任务。</li>
  <li><strong>parserGen-</strong>用于创建与ReSharper兼容的解析器的工具。</li>
</ul>

<p>除了这些工具外，SDK还附带了完整语言插件示例，位于<code class="code highlight language-text">Samples/PsiPlugin</code>夹。此示例是用于支持的语言插件的完整实现<code class="code highlight language-text">.psi</code>文件，它们是解析器定义的文件，由<code class="code highlight language-text">parserGen</code> 。结果，有兴趣使用插件的开发人员<code class="code highlight language-text">parserGen</code>对于新语言开发，建议编译安装<code class="code highlight language-text">PsiPlugin</code> ，这可以大大简化使用解析器定义文件的过程。</p>

<p>让我们逐一浏览这些工具，因为所有工具对于组合语言插件至关重要。</p>

<a name="cslex" class="elem-anchor"></a>
<h2>CsLex<a href="#cslex" class="anchor-link"><span></span></a></h2>

<p><code class="code highlight language-text">CsLex</code>是SDK中附带的<a href="http://www.cybercom.net/~zbrad/DotNet/Lex/" rel="noopener noreferrer" data-external="true" target="_blank"><span>可免费使用的</span></a>词法分析器生成器。 CsLex可以在<code class="code highlight language-text">Tools/CsLex</code>文件夹，其中包括以下文件：</p>

<ul>
  <li><code class="code highlight language-text">CsLex.Targets</code>包含一组需要包含在其中的目标<code class="code highlight language-text">.csproj</code>文件使用<code class="code highlight language-text"><Import></code>指示：</li>
</ul>

<div class="code-block" data-lang="xml"><code class="code-block__wrapper"><span class="nt"><Import</span> <span class="na">Project=</span><span class="s">"$(ReSharperSdkTools)\CsLex\CsLex.Targets"</span> <span class="nt">/></span></code></div>

<ul>
  <li><code class="code highlight language-text">CsLex.Tasks</code>包含一个的定义<code class="code highlight language-text">CsLex</code>构建任务。它会自动包含在<code class="code highlight language-text">CsLex.Targets</code></li>
  <li><code class="code highlight language-text">lex.exe</code>是生成词汇定义的可执行文件。 <code class="code highlight language-text">lex.xml</code>是该工具的XML文档。您无需直接与这两个文件进行交互，因为构建任务将为您完成这些工作。</li>
</ul>

<p>为了生成词法结构，您的项目需要具有<code class="code highlight language-text">.lex</code>文件。您可以在<a href="http://www.cybercom.net/~zbrad/DotNet/Lex/Lex.htm" rel="noopener noreferrer" data-external="true" target="_blank"><span>CsLex文档页面中</span></a>了解有关词汇定义文件格式的更多信息，但是您的定义还需要具有ReSharper特定的元素。要了解有关这些元素的更多信息，请查看<code class="code highlight language-text">psi.lex</code>样本中的文件<code class="code highlight language-text">PsiPlugin</code> SDK附带的</p>

<p>的<code class="code highlight language-text">.lex</code>文件的构建动作为<code class="code highlight language-text">CsLex</code> 。编译后，CsLex从中生成一个<code class="code highlight language-text">_lex.cs</code>包含生成的词法分析器的文件。</p>

<p>词法分析器的组成部分之一是unicode定义文件<code class="code highlight language-text">Unicode.lex</code> 。虽然此文件当前位于<code class="code highlight language-text">Tools/parserGen</code>文件夹，其目的是提供有关词法分析器可以使用以正确区分标识符的各种unicode游侠的详细信息。为了使用此文件，需要将其复制到<code class="code highlight language-text">/obj</code>项目内的文件夹。最简单的方法是将以下MSBuild指令添加到项目中：</p>

<div class="code-block" data-lang="xml"><code class="code-block__wrapper"><span class="nt"><Target</span> <span class="na">Name=</span><span class="s">"BeforeBuild"</span><span class="nt">></span> <span class="nt"><MakeDir</span> <span class="na">Directories=</span><span class="s">"$(MSBuildProjectDirectory)\obj"</span> <span class="nt">/></span> <span class="nt"><Copy</span> <span class="na">SourceFiles=</span><span class="s">"$(ReSharperSdkTools)\parserGen\Unicode.lex"</span> <span class="na">DestinationFolder=</span><span class="s">"$(MSBuildProjectDirectory)\obj"</span> <span class="nt">/></span> <span class="nt"></Target></span></code></div>

<a name="parsergen" class="elem-anchor"></a>
<h2>解析器<a href="#parsergen" class="anchor-link"><span></span></a></h2>

<p><code class="code highlight language-text">parserGen</code>是一个解析器生成器，用于为各种语言定义解析器。它生活在<code class="code highlight language-text">tools/parserGen</code>文件夹，碰巧是用Java编写的，这就是为什么还有一个<code class="code highlight language-text">tools/Java</code>提供IKVM绑定的SDK中的文件夹。让我们简要地分析parserGen附带的一些<em>非Java</em>文件：</p>

<ul>
  <li><code class="code highlight language-text">ParserGen.Targets</code>和<code class="code highlight language-text">ParserGen.Tasks</code>分别包含MSBuild目标和构建任务。插件编写者需要将以下内容添加到<code class="code highlight language-text">.csproj</code>文件：</li>
</ul>

<div class="code-block" data-lang="xml"><code class="code-block__wrapper"><span class="nt"><Import</span> <span class="na">Project=</span><span class="s">"$(ReSharperSdkTools)\parserGen\ParserGen.Targets"</span> <span class="nt">/></span></code></div>

<ul>
  <li><code class="code highlight language-text">ParserGenTask.dll</code>提供一个.NET填充程序以使用基于Java的<code class="code highlight language-text">ParserGen</code>构建任务。</li>
  <li><code class="code highlight language-text">Unicode.lex</code>是一个实际上与词法分析器构造有关的文件。（往上看。）</li>
</ul>

<p>解析器以专有格式定义在文件中，带有<code class="code highlight language-text">.psi</code>扩展名和指定的构建任务<code class="code highlight language-text">ParserGen</code> 。正是这种格式<code class="code highlight language-text">PsiPlugin</code>提供支持，因此您应该编译并安装<code class="code highlight language-text">PsiPlugin</code>如果您打算与<code class="code highlight language-text">.psi</code>文件。虽然没有正式的文档，但我们建议您查看<code class="code highlight language-text">psi.psi</code>语法文件<code class="code highlight language-text">PsiPlugin</code>有关语法定义的详细示例。</p>

<a name="language-definition" class="elem-anchor"></a>
<h2>语言定义<a href="#language-definition" class="anchor-link"><span></span></a></h2>

<p>首先，您需要创建一个继承自<code class="code highlight language-text">KnownLanguage</code> 。对此类的约束（我们称之为<code class="code highlight language-text">MyLanguage</code>在这里）应该：</p>

<ul>
  <li>被宣布<code class="code highlight language-text">public</code></li>
  <li>有一个公共静态非<code class="code highlight language-text">readonly</code> ，a的未初始化字段<code class="code highlight language-text">MyLanguage</code>类型</li>
  <li>必须具有无参数的构造函数</li>
  <li>应该有一套<code class="code highlight language-text">protected</code>允许语言继承的构造函数。</li>
</ul>

<p>的<code class="code highlight language-text">MyLanguage</code>班级也必须标有<code class="code highlight language-text">[LanguageDefinition]</code>属性。此属性采用两个参数：</p>

<ul>
  <li>第一个也是唯一的必需参数是语言的名称。</li>
  <li><em>（可选）</em> <code class="code highlight language-text">Edition</code>参数指定此语言支持的ReSharper版本。如果您需要将语言限制为特定的R＃版本，请使用<code class="code highlight language-text">ReSharperEditions.Ids</code>这里列举。提醒：R＃当前有三个版本-C＃，VB.NET和完整版。</li>
</ul>

<p>这是C＃语言的语言定义示例：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[LanguageDefinition(Name, Edition = ReSharperEditions.Ids.Csharp)]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">CSharpLanguage</span> <span class="p">:</span> <span class="n">KnownLanguage</span> <span class="p">{</span> <span class="k">public</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"CSHARP"</span><span class="p">;</span> <span class="p">[</span><span class="n">CanBeNull</span><span class="p">]</span> <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">CSharpLanguage</span> <span class="n">Instance</span><span class="p">;</span> <span class="k">private</span> <span class="nf">CSharpLanguage</span><span class="p">()</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="s">"C#"</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="k">protected</span> <span class="nf">CSharpLanguage</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="k">protected</span> <span class="nf">CSharpLanguage</span><span class="p">([</span><span class="n">NotNull</span><span class="p">]</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">NotNull</span><span class="p">]</span> <span class="kt">string</span> <span class="n">presentableName</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">presentableName</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<a name="project-file-type" class="elem-anchor"></a>
<h2>项目文件类型<a href="#project-file-type" class="anchor-link"><span></span></a></h2>

<p>现在，我们需要告诉ReSharper如何支持特定类型的项目。这是另一个主要包含元数据的类，主要用于指示与特定语言对应的文件扩展名。就像语言定义类一样，这个类（我们称它为<code class="code highlight language-text">MyLanguageProjectFileType</code> ）要求：</p>

<ul>
  <li>宣布<code class="code highlight language-text">public</code></li>
  <li>它有一个<code class="code highlight language-text">public</code> ， <code class="code highlight language-text">static</code> ，非<code class="code highlight language-text">readonly</code>类型字段<code class="code highlight language-text">MyLanguageProjectFileType</code></li>
  <li>它具有无参数的构造函数。此构造函数调用其基类的构造函数，并传递此项目文件类型支持的文件扩展名数组。</li>
  <li>它有一套<code class="code highlight language-text">protected</code>继承方法</li>
</ul>

<p>此外，项目文件类型类必须用<code class="code highlight language-text">ProjectFileTypeDefinition</code>属性。此属性具有以下参数：</p>
<ul>
  <li>的<code class="code highlight language-text">Type</code>参数需要语言名称（根据语言定义）</li>
  <li><em>（可选）</em> <code class="code highlight language-text">Edition</code>参数确定支持此项目文件类型的R＃版本。</li>
  <li><em>（可选）</em> <code class="code highlight language-text">Internal</code>布尔参数确定是否仅在内部模式下支持此项目文件类型。插件编写者不应定义此参数。</li>
</ul>

<p>这是HTML文件的项目文件类型类的示例：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="na">[ProjectFileTypeDefinition(Name)]</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">HtmlProjectFileType</span> <span class="p">:</span> <span class="n">KnownProjectFileType</span> <span class="p">{</span> <span class="k">public</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">"HTML"</span><span class="p">;</span> <span class="k">public</span> <span class="k">new</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">HtmlProjectFileType</span> <span class="n">Instance</span><span class="p">;</span> <span class="k">private</span> <span class="nf">HtmlProjectFileType</span><span class="p">()</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="s">"Html"</span><span class="p">,</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span><span class="n">HTML_EXTENSION</span><span class="p">,</span> <span class="n">HTM_EXTENSION</span><span class="p">})</span> <span class="p">{</span> <span class="p">}</span> <span class="k">protected</span> <span class="nf">HtmlProjectFileType</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="k">protected</span> <span class="nf">HtmlProjectFileType</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">presentableName</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">resentableName</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="k">protected</span> <span class="nf">HtmlProjectFileType</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">presentableName</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p"><</span><span class="kt">string</span><span class="p">></span> <span class="n">extensions</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">presentableName</span><span class="p">,</span> <span class="n">extensions</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">HTML_EXTENSION</span> <span class="p">=</span> <span class="s">".html"</span><span class="p">;</span> <span class="k">public</span> <span class="k">const</span> <span class="kt">string</span> <span class="n">HTM_EXTENSION</span> <span class="p">=</span> <span class="s">".htm"</span><span class="p">;</span> <span class="p">}</span></code></div>

<a name="project-file-language-service" class="elem-anchor"></a>
<h2>项目文件语言服务<a href="#project-file-language-service" class="anchor-link"><span></span></a></h2>

<p>让我们创建一个项目文件语言服务。该实体用于告诉我们需要为特定文件构造哪种语言树。例如， <code class="code highlight language-text">XamlProjectFileLanguageService</code>将创建XAML文件的XAML树是项目的一部分，如果不是，则仅创建XML树。</p>

<p>项目文件语言服务是一个实现<code class="code highlight language-text">IProjectFileLanguageService</code>介面并饰以<code class="code highlight language-text">ProjectFileType</code>与项目文件类型有关的属性。该属性采用单个参数- <code class="code highlight language-text">typeof(MyLanguageProjectFileType)</code>我们创造了耳环。</p>

<p>现在，我们正在深入进行语言开发，这是我们定义整体语言服务（公开词法分析器，解析器和其他补充信息的服务）之前的最后一站。让我们通过我们的成员<code class="code highlight language-text">MyProjectFileLanguageService</code>实施。</p>

<ul>
  <li>首先，我们需要一个公共构造函数，该构造函数将采用<code class="code highlight language-text">MyProjectFileType</code>类型。我们需要存储此参数，以便以后返回。</li>
  <li>的<code class="code highlight language-text">LanguageType</code>属性恰好是我们通常返回上述存储值的位置。</li>
  <li>的<code class="code highlight language-text">Icon</code>属性需要返回此类文件的图标。如果您在内部将图标存储为嵌入式资源，请使用<code class="code highlight language-text">ImageLoader.GetImage("icon.resource.name", null)</code>返回图标。</li>
  <li>
    <p>的<code class="code highlight language-text">GetPsiLanguageType()</code>方法需要<code class="code highlight language-text">IProjectFile</code>参数。如果<code class="code highlight language-text">LanguageType</code>此参数的属性与我们的语言匹配，然后我们返回<code class="code highlight language-text">Instance</code>我们语言的领域。否则，我们返回<code class="code highlight language-text">UnknownLanguage.Instance</code> 。这是一个例子：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="n">PsiLanguageType</span> <span class="nf">GetPsiLanguageType</span><span class="p">(</span><span class="n">IProjectFile</span> <span class="n">projectFile</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">projectFile</span><span class="p">.</span><span class="n">LanguageType</span><span class="p">.</span><span class="n">Is</span><span class="p"><</span><span class="n">MyLanguageProjectFileType</span><span class="p">>())</span> <span class="k">return</span> <span class="n">MyLanguage</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="n">UnknownLanguage</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span> <span class="p">}</span></code></div>
  </li>
  <li>
    <p>还有一个超载<code class="code highlight language-text">GetPsiLanguageType()</code>需要一个方法<code class="code highlight language-text">ProjectFileType</code>作为参数。此方法的实现与上面的类似：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="n">PsiLanguageType</span> <span class="nf">GetPsiLanguageType</span><span class="p">(</span><span class="n">ProjectFileType</span> <span class="n">languageType</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">languageType</span><span class="p">.</span><span class="n">Is</span><span class="p"><</span><span class="n">MyLanguageProjectFileType</span><span class="p">>())</span> <span class="k">return</span> <span class="n">MyLanguage</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="n">UnknownLanguage</span><span class="p">.</span><span class="n">Instance</span><span class="p">;</span> <span class="p">}</span></code></div>
  </li>
  <li>
    <p>的<code class="code highlight language-text">GetMixedLexerFactory()</code>方法返回混合词法分析器工厂。混合词法分析器（“ <em>混合”</em>是指文件中可能包含多种语言）是由语言服务返回的，我们尚未定义。此方法的典型实现如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="n">ILexerFactory</span> <span class="nf">GetMixedLexerFactory</span><span class="p">(</span><span class="n">IBuffer</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">IPsiSourceFile</span> <span class="n">sourceFile</span><span class="p">,</span> <span class="n">PsiManager</span> <span class="n">manager</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">MyLanguage</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">LanguageService</span><span class="p">().</span><span class="nf">GetPrimaryLexerFactory</span><span class="p">();</span> <span class="p">}</span></code></div>
  </li>
</ul>

<aside class="note">
  <p>在上面的代码中， <code class="code highlight language-text">LanguageService()</code>是驻留在<code class="code highlight language-text">PsiLanguageTypeExtensions</code>类。</p>
</aside>

<ul>
  <li>的<code class="code highlight language-text">GetPreprocessorDefines()</code>方法用于返回一组<code class="code highlight language-text">PreProcessingDirective</code>定义。如果您的语言没有预处理指令，在这种情况下，您可以简单地返回<code class="code highlight language-text">EmptyArray<PreProcessingDirective>.Instance</code> 。</li>
  <li>
    <p>的<code class="code highlight language-text">GetPsiProperties()</code>方法用于返回此文件的PSI属性类型的新实例，如下所示：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="n">IPsiSourceFileProperties</span> <span class="nf">GetPsiProperties</span><span class="p">(</span><span class="n">IProjectFile</span> <span class="n">projectFile</span><span class="p">,</span> <span class="n">IPsiSourceFile</span> <span class="n">sourceFile</span><span class="p">)</span> <span class="p">{</span> <span class="n">Assertion</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">projectFile</span><span class="p">.</span><span class="n">LanguageType</span><span class="p">.</span><span class="nf">IsProjectFileType</span><span class="p">(</span><span class="n">LanguageType</span><span class="p">),</span> <span class="s">"projectFile.LanguageType == LanguageType"</span><span class="p">);</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">MyLanguagePsiProperties</span><span class="p">(</span><span class="n">projectFile</span><span class="p">,</span> <span class="n">sourceFile</span><span class="p">);</span> <span class="p">}</span></code></div>
  </li>
</ul>

<p>我们还没有看到PSI Properties类，所以接下来要讲。</p>

<a name="psi-properties" class="elem-anchor"></a>
<h2>PSI属性<a href="#psi-properties" class="anchor-link"><span></span></a></h2>

<p>成功的语言支持所需的另一个服务实体是PSI属性实体。为了理解为什么需要它，重要的是要理解在处理文件时，我们实际上是在两个不同的实体上进行操作： <code class="code highlight language-text">IProjectFile</code>和<code class="code highlight language-text">IPsiSourceFile</code> ：</p>

<ul>
  <li><code class="code highlight language-text">IProjectFile</code>是项目模型的一部分，即，它在所在项目的上下文中保存有关文件的信息。除其他事项外，它产生有关其<code class="code highlight language-text">ProjectFileType</code> （我们之前已经对此进行了定义），并且还会产生一个<code class="code highlight language-text">IProjectFileProperties</code>值，包含在Visual Studio中打开“属性”窗口（或按F4）时看到的文件属性的类型。</li>
  <li><code class="code highlight language-text">IPsiSourceFile</code>是PSI的一部分。它也产生一个<code class="code highlight language-text">ProjectFileType</code>作为其属性之一，但它也产生一种语言（ <code class="code highlight language-text">PsiLanguageType</code>继承者，例如<code class="code highlight language-text">MyLanguage</code> ）以及一组<code class="code highlight language-text">IPsiSourceFileProperties</code> 。这些属性对应于代码模型，即表示文件的AST。</li>
</ul>

<p>因此，PSI Properties实体是一种胶水，它以<code class="code highlight language-text">IProjectFile</code>和一个<code class="code highlight language-text">IPsiSourceFile</code>并设法将两者绑定在一起。</p>

<p>PSI属性类是从<code class="code highlight language-text">DefaultPsiProjectFileProperties</code> ，并且通常位于上述语言服务类型的内部类中。此类具有两个参数-项目文件和PSI源文件。通常，其构造函数只是将它们传递给父级：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">private</span> <span class="k">class</span> <span class="nc">MyLanguageFileProperties</span> <span class="p">:</span> <span class="n">DefaultPsiProjectFileProperties</span> <span class="p">{</span> <span class="k">public</span> <span class="nf">MyLanguageFileProperties</span><span class="p">(</span><span class="n">IProjectFile</span> <span class="n">projectFile</span><span class="p">,</span> <span class="n">IPsiSourceFile</span> <span class="n">sourceFile</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">projectFile</span><span class="p">,</span> <span class="n">sourceFile</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>上面是一个最小的实现。通常，PSI属性类型包含基类定义的某些属性的替代。这里有一些这样的属性：</p>

<ul>
  <li><code class="code highlight language-text">ShouldBuildPsi</code>确定是否需要为此文件构建PSI树。默认情况下，值为<code class="code highlight language-text">true</code>对于任何不是的类型<code class="code highlight language-text">null</code>或未知。在某些不值得构建PSI的情况下，例如在您拥有不属于项目的XAML文件的情况下，应覆盖此属性。</li>
  <li><code class="code highlight language-text">ProvidesCodeModel</code>确定文件是否提供代码模型。并非所有文件都可以-例如，XML文件不可以。默认情况下，其值为<code class="code highlight language-text">ShouldBuildPsi</code> 。</li>
  <li><code class="code highlight language-text">IsNonUserFile</code>确定这是用户是否拥有的文件。通常，它的价值为<code class="code highlight language-text">\!IsCompile</code> ，即取决于文件的生成操作。</li>
  <li><code class="code highlight language-text">IsGeneratedFile</code>确定是否生成此文件。默认情况下，R＃尝试从提供的信息中获取此信息。 <code class="code highlight language-text">projectFile</code> 。</li>
</ul>

<a name="language-service" class="elem-anchor"></a>
<h2>语言服务<a href="#language-service" class="anchor-link"><span></span></a></h2>

<p>我们终于可以创建语言服务了，这是一个最终使我们可以使用AST语言的实体。这是一个继承自的类<code class="code highlight language-text">LanguageService</code> 。此类的要求是：</p>

<ul>
  <li>必须声明<code class="code highlight language-text">public</code></li>
  <li>它必须具有<em>至少</em>采用语言定义的公共构造函数（即， <code class="code highlight language-text">MyLanguage</code>类型）和<code class="code highlight language-text">IConstantValueService</code> 。</li>
  <li>它必须使用上述参数调用基本构造函数。</li>
</ul>

<aside class="note">
  <p>完成上述操作后，请在打开具有所选扩展名的文件时检查断点是否真正触发。空的上述实现应足以使ReSharper识别与功能有关的语言服务。</p>
</aside>

<p>语言服务是所有活动发生的地方。特别是，语言服务公开了词法分析器和解析器，以及特定语言可能需要或可能不需要的许多补充服务。</p>

<p>我们从词法分析器开始我们的语言实现。语言服务类型具有两个与词法分析器创建有关的成员。</p>

<p>首先是<code class="code highlight language-text">GetPrimaryLexerFactory()</code>方法。此方法返回一个词法分析器工厂，该工厂只是一个实现<code class="code highlight language-text">ILexerFactory</code>接口及其对象<code class="code highlight language-text">CreateLexer()</code>方法返回词法分析器的实例（稍后我们将对其进行定义）：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">private</span> <span class="k">class</span> <span class="nc">MyLanguageLexerFactory</span> <span class="p">:</span> <span class="n">ILexerFactory</span> <span class="p">{</span> <span class="k">public</span> <span class="n">ILexer</span> <span class="nf">CreateLexer</span><span class="p">(</span><span class="n">IBuffer</span> <span class="n">buffer</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">MyLanguageLexer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span></code></div>

<p>这样，执行<code class="code highlight language-text">MyLanguageService.GetPrimaryLexerFactory()</code>减少为：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">public</span> <span class="k">override</span> <span class="n">ILexerFactory</span> <span class="nf">GetPrimaryLexerFactory</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">MyLanguageLexerFactory</span><span class="p">();</span> <span class="p">}</span></code></div>

<p>当然，我们还没有提到<code class="code highlight language-text">ILexer</code> 。在我们开始实际制作词法分析器之前，还值得一提<code class="code highlight language-text">LanguageService</code>成员- <code class="code highlight language-text">CreateFilteringLexer()</code>方法。现在，顾名思义，过滤词法分析器是过滤（即忽略）某些标记类型的词法分析器。过滤词法分析器继承自<code class="code highlight language-text">FilteringLexer</code>类。除了必须拥有<code class="code highlight language-text">ILexer</code>作为传递给其基类的构造函数参数，它具有一个称为<code class="code highlight language-text">Skip()</code>您需要覆盖的内容。</p>

<p>的<code class="code highlight language-text">Skip()</code>方法很简单：需要一个<code class="code highlight language-text">TokenNodeType</code>并确定这是否是需要跳过的令牌类型。要跳过的典型令牌通常包括空格，换行符，注释或某些预处理程序指令内的代码。现在，为此提供支持的最简单方法是创建一个<code class="code highlight language-text">NodeTypeSet</code>您打算跳过的所有令牌中，如下所示：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">internal</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">NodeTypeSet</span> <span class="n">TokensToSkip</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NodeTypeSet</span><span class="p">(</span> <span class="k">new</span> <span class="n">NodeType</span><span class="p">[]</span> <span class="p">{</span> <span class="n">MyLanguageTokenType</span><span class="p">.</span><span class="n">WHITE_SPACE</span><span class="p">,</span> <span class="n">MyLanguageTokenType</span><span class="p">.</span><span class="n">NEW_LINE</span> <span class="p">}</span> <span class="p">);</span></code></div>

<p>有了这个定义， <code class="code highlight language-text">Skip()</code>方法可以如下：</p>

<div class="code-block" data-lang="csharp"><code class="code-block__wrapper"><span class="k">protected</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Skip</span><span class="p">(</span><span class="n">TokenNodeType</span> <span class="n">tokenType</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">MyLanguageService</span><span class="p">.</span><span class="n">TokensToSkip</span><span class="p">[</span><span class="n">tokenType</span><span class="p">];</span> <span class="p">}</span></code></div>


                    <div class="navigation-links _bottom" data-swiftype-index="false">
                        <a class="navigation-links__prev" href="/Products/InspectCode.html">InspectCode插件</a> <a class="navigation-links__next" href="/CustomLanguages/Registration.html">注册自定义语言</a>
                    </div>
                    <div class="last-modified">上次修改时间：2017年7月10日</div>
                </article>

                <section class="disqus">
                    <div id="disqus_thread"></div>
                </section>
            </div>
        </section>
    </main>
</div>

<script src="/help/resharper/sdk/app/app.js" data-baseurl="/help/resharper/sdk/"></script>




</body></html>