<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>代码检查：可能的意外参考比较-帮助|帮助锐化器</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body list="" type=""  data-id="PossibleUnintendedReferenceComparison" data-article-props="
                {
                
            " seeals=":[=" titl=":=" concept=",=" link=",=" ur=":" finding_code_issues.htm="," tex=":" find="" issues="" with="" inspectio="}=" code_analysis__code_inspections.htm="," code="" inspection="}=" design_time_inspection.htm="," detect="" in="" design="" tim="}=" external="" https:="" ="" msdn.microsoft.com="" en-us="" library="" ms173147.asp="," msdn:="" guidelines="" for="" overriding="" equals()="" and="" operator="=" (c#="" programming="" guide="}=" http:="" stackoverflow.com="" questions="" 12263715="" possible-unintended-reference-compariso="," stackoverflow:="" possible="" unintended="" reference="" compariso="}=" ="text"="stackoverflow:=" }="" ]}="" ]="" possibleunintendedreferencecomparison_1=""><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索ReSharper帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>ReSharper 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="PossibleUnintendedReferenceComparison.xml" data-toc="PossibleUnintendedReferenceComparison">代码检查：可能的意外参考比较</h1>    <a name="tip_disable"></a>        <aside class="prompt" rel="PossibleUnintendedReferenceComparison.xml" id="384c3c9c" data-type="tip" data-title="">            <p id="37dc0df4">您可以配置此检查：</p>            <ul class="list _ul"><li class="list__item" id="0de12356"><a href="Code_Analysis__Configuring_Warnings.html#disable">禁用它以忽略所有相关问题</a></li><li class="list__item" id="420d33fb"><a href="Code_Analysis__Configuring_Warnings.html#suppress">在代码中的任何位置都禁止显示它以忽略特定问题</a></li><li class="list__item" id="ec748d09"><a href="Code_Analysis__Configuring_Warnings.html#change_severity">更改其严重性级别，以使检测到的问题更少或更明显</a>                </li></ul>        </aside>        <p id="186f8244">在使用等号运算符的情况下，C＃编译器会发出“可能的意外参考比较”警告（ <a href="https://msdn.microsoft.com/en-us/library/f6dtw2ah.aspx" rel="noopener noreferrer" data-external="true" target="_blank">CS0252</a> / <a href="https://msdn.microsoft.com/en-us/library/etywy2s3.aspx" rel="noopener noreferrer" data-external="true" target="_blank">CS0253</a> ） <code class="code">==</code>要么<code class="code">!=</code> ）在彼此继承的类型的对象上，并且只有一种类型会覆盖这些运算符。</p>    <p id="41e2edf1">在其中一种类型中覆盖相等运算符的事实意味着，在比较此类对象时， <i id="2ddbde1b">期望值相等</i> 。将这些对象与不覆盖等于运算符的类型的对象进行比较，将导致使用<code class="code">System.Object</code> ，它检查<i id="8fadc5ad">引用是否相等</i> 。因此发出警告，因为在这种情况下比较对象引用很可能是错误的。</p>    <p id="d5e0e1e0">尽管ReSharper知道这些警告并为它们提供<a href="Design_time_Inspection.html">设计时通知</a> ，但它又向前走了一步，并检测到可能的意外参考比较的另一种情况-当仅一种比较类型覆盖时<code class="code">Equals()</code> 。<a href="https://msdn.microsoft.com/en-us/library/ms173147.aspx" rel="noopener noreferrer" data-external="true" target="_blank">MSDN文档</a>说： <i id="7d0b8a6a">任何代表值的类，基本上任何值类型或一组值作为一个组，例如复数类，都应覆盖Equals。</i>        因此，如果<code class="code">Equals()</code>不针对第二个对象的类型覆盖，则比较结果回落到<code class="code">Equals()</code>在<code class="code">System.Object</code> ，它执行参考身份检查，这对于值类型而言可能是不希望的。</p>    <p id="bac3d52c">这是说明两种情况的代码清单：</p>    <div class="code-block" data-lang="csharp">类MyType {}类TypeWithEquals：MyType {公共重写bool Equals（object obj）{抛出新的NotImplementedException（）; }}类TypeWithEqOperators：MyType {公共静态布尔运算符==（左边的TypeWithEqOperators，右边的TypeWithEqOperators）{抛出新的NotImplementedException（）; } public static bool运算符！=（TypeTypeEqOperators左，TypeWithEqOperators右）{抛出新的NotImplementedException（）; }}类Test {public Test（TypeWithEquals withEquals，TypeWithEqOperators withEqOperators，MyType parentObject）{bool a = withEqOperators == parentObject; // CS0253 bool b = withEquals == parentObject; //没有编译器警告，但是ReSharper在此处发出自己的警告}}</div>    <p id="70d453e4">此检查的另一种情况是使用相等运算符比较接口类型（ <code class="code">==</code>要么<code class="code">!=</code> ）。由于这些运算符是静态的，因此编译器将默认为<code class="code">System.Object.ReferenceEquals()</code> —即引用比较—即使在接口实现中将相等运算符覆盖为值比较。<br>ReSharper寻找覆盖相等运算符和/或的接口实现。 <code class="code">Equals()</code> ，并且如果检测到这样的实现，则会发出警告：</p>    <div class="code-block" data-lang="csharp">接口ISomeInterface {}类SomeImplementation：ISomeInterface {公共重写bool Equals（object obj）=> throw new NotImplementedException（）;公共重写int GetHashCode（）=>抛出新的NotImplementedException（）; } void ATest（ISomeInterface x，ISomeInterface y）{bool a = x == y; //可能的意外参考比较}</div>    <p id="41c8b978">请注意，此检查将在整个解决方案（包括引用的库）中查找接口实现，其位置并不总是很明显。在下面的示例中，ReSharper将检测到的实现<code class="code">ICollection<object></code>覆盖<code class="code">Equals()</code>在mscorlib中并发出警告，即使您自己没有实现<code class="code">ICollection<object></code>覆写<code class="code">Equals()</code>或相等运算符。</p>    <div class="code-block" data-lang="csharp">void SomeTest（ICollection <object>x，ICollection <object>y）{bool a = x == y; //可能的意外参考比较}</object></object></div>    <p id="e067e979">尽管这种情况似乎有点防御性，但如果您使用非静态方法比较接口，则代码可能会更直接，更安全。也就是说，您可以使用<code class="code">ReferenceEquals()</code>如果您要检查引用是否相等，或者<code class="code">Equals()</code>如果您希望它在实现或任何特定方法中被覆盖，例如<code class="code">Enumerable.SequenceEqual()</code> ，它检查集合是否包含相同顺序的相等对象。</p>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月18日</div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>