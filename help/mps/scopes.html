<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>范围-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Scopes.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="scopes.xml" data-toc="Scopes.html">范围</h1>   <p id="5d59adf8">我们将研究两种定义自定义语言元素范围的方法- <i id="a6f53b1d">继承（分层）方法</i>和<i id="d1f02286">引用</i>方法。我们选择<a href="/help/mps/2019.1/mps-calculator-language-tutorial.html" rel="noopener noreferrer" data-external="true" target="_blank">计算器教程</a>语言作为我们实验的测试平台。您可以找到MPS分发随附的示例项目集中包含的<i id="9c5b92ca">计算器教程</i>项目。</p>   <h2 id="twoways">两种方式</h2>   <p id="a8524e09">所有参考都需要知道允许的目标集。这样，只要用户要提供参考值，MPS就可以填充完成菜单。如果现有引用引用了超出范围的元素，则可以针对该集合进行验证并将其标记为无效。默认情况下，当未为参考定义范围时，当前模型以及导入的模型中的所有目标都在范围内，因此可用于参考。</p>   <p id="2ee191ba">MPS提供了两种定义范围的方法：</p>   <ul class="list _ul"><li class="list__item" id="6a3f487c"><p>继承的范围</p></li><li class="list__item" id="d538dee0"><p>参考范围</p></li></ul>   <p id="1e3aec06">引用作用域提供了较低的标准，而继承作用域则允许根据模型中节点的层次结构逐步构建作用域。</p>   <aside class="tip sideblock" rel="1e3aec06" id="7399ac99" data-title="">      <p id="f26e6e39">MPS中最古老的作用域类型称为“ <i id="48e5ba3c">搜索作用域”</i> ，由于上面介绍的作用域API发生了显着变化，因此不赞成使用上述两种类型。<i id="ec5aba8b">引用范围</i>可以视为与新API兼容的<i id="ffbf8faf">搜索范围</i>的最接近替代。</p>   </aside>   <h2 id="inheritedscopes">继承的范围</h2>   <p id="918dc61c">我们将首先描述范围解析的新的分层（ <i id="6add73cb">继承</i> ）机制。此机制将范围解析委托给实现<i id="31c7dcdf">ScopeProvider</i>的祖先。</p>   <ol class="list _decimal"><li class="list__item" id="28e7b88a"><p>MPS开始寻找最接近实现<i id="eb089911">ScopeProvider</i>的参考节点的祖先，谁可以为当前种类提供范围。</p></li><li class="list__item" id="ca42cdf8"><p>如果<i id="4e8ac4d4">ScopeProvider</i>返回<i id="a0963f69">null</i> ，则MPS继续搜索更远的祖先。</p></li><li class="list__item" id="568e6679">每个<i id="3efaa412">ScopeProvider</i>可以<ul class="list _ul"><li class="list__item" id="ec38626a"><p>构建并返回<i id="a1f4a7e3">Scope</i>实现（稍后将详细介绍）</p></li><li class="list__item" id="cd7665e0"><p>委托给<b id="23862e63">父范围</b> </p></li><li class="list__item" id="7b21d022"><p>将自己的元素添加到<b id="a112ad8b">父范围</b>            </p></li><li class="list__item" id="0a881004"><p>从<b id="9debcb33">父作用域</b>隐藏元素（有关如何使用作用域的更多信息将在后面讨论）</p></li></ul>      </li></ol>   <p id="c4648192">必须在<i id="20c2234e">ScopeProvider中</i>显式进行获取<b id="5b11a0b9">父作用域</b>的<i id="20c2234e">调用</i> 。</p>   <p id="0f28bd6b">因此，我们的<i id="2c43b6fe">InputFieldReference会</i>搜索<i id="2c854b12">InputField</i>节点，并依靠其祖先构建这些列表。</p>   <p id="7d5ae6f6">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc1.png"><img alt="Sc1" title="Sc1" src="/help/img/idea/2019.2/Sc1.png" id="a6935b2f" width="500" height="888"></a></figure>   <p></p>   <p id="6eef061c">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc2.png"><img alt="Sc2" title="Sc2" src="/help/img/idea/2019.2/Sc2.png" id="9714be73" width="300" height="304"></a></figure>   <p></p>   <p id="61a88db8">一旦我们已经指定了一个<i id="a5d6fe99">InputField</i>搜索时<i id="ef8aa8bf">InputFieldReference</i>范围是<i id="4bfa5102">继承的</i> ，我们必须表明， <i id="b9be131c">计算器</i>是一个<i id="98c47751">ScopeProvider。</i>这样可以确保<i id="cbb2b6d3">Calculator</i>在为所有作为其后代放置的<i id="26d36005">InputFieldReferences</i>的作用域建立范围时具有发言权。</p>   <p id="b6414ff2">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc3.png"><img alt="Sc3" title="Sc3" src="/help/img/idea/2019.2/Sc3.png" id="b1fefd4a" width="500" height="778"></a></figure>   <p></p>   <p id="51074eb0">每当查询了<i id="014a0020">InputField</i>的范围，我们的情况下， <i id="8377e6f2">计算器</i>应该返回其所有<i id="a2c1abf9">InputFields</i>的列表。因此，在“ <i id="19868e49">计算器”</i>的“ <i id="bacc46f8">行为”</i>方面，我们重写（ <i id="8dfddb44">Control + O</i> ） <i id="d3e71257">getScope（）</i>方法：</p>   <p id="383acfcb">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Co1111.png"><img alt="Co1111" title="Co1111" src="/help/img/idea/2019.2/Co1111.png" id="25c34f93" width="300" height="1160"></a></figure>   <p></p>   <p id="5c8e5096">如果未解决<i id="50a3493b">Scope</i> ，我们需要导入包含它的模型（ <i id="ab4909fc">Control + R</i> ）（ <i id="71765334">jetbrains.mps.scope</i> ）：</p>   <p id="719b0b54">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc5.png"><img alt="Sc5" title="Sc5" src="/help/img/idea/2019.2/Sc5.png" id="6c7b53bb" width="900" height="1212"></a></figure>   <p></p>   <p id="1c0d5188"><i id="526908b6">getScope（）</i>方法采用两个参数：</p>   <ul class="list _ul"><li class="list__item" id="eb79c904"><p>         <b id="a13a6016">种类</b> -可能目标的概念以供参考</p></li><li class="list__item" id="921f2481"><p>         <b id="18fbec17">子</b> -电流（本）ScopeProvider，从该请求来的子节点，所以实际参考是<b id="d386c399">子</b>节点的后代中</p></li></ul>   <p id="3f990dc2">我们还需要<i id="430d9ceb">BaseLanguage，</i>因为我们需要对一些功能进行编码。<i id="cec8429d">jetbrains.mps.lang。</i>需要导入<i id="f9a5981b">smodel</i>语言才能查询节点。这些语言应该已经自动为您导入。如果没有，则可以使用<i id="74ba80a1">Control + L</i>快捷方式导入它们。<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc6.png"><img alt="Sc6" title="Sc6" src="/help/img/idea/2019.2/Sc6.png" id="811d3235" width="600" height="1060"></a></figure>   <p></p>   <p id="0fa1f9c9">现在，我们可以完成范围定义代码，从本质上讲，它从计算器内部返回所有输入字段：<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Sc8.png"><img alt="Sc8" title="Sc8" src="/help/img/idea/2019.2/Sc8.png" id="365418ba" width="900" height="612"></a></figure>   <p></p>   <p id="6ec6b024">      <i id="7809ffbc">快速提示：注意使用SimpleRoleScope类。它是可以帮助您构建自己的自定义范围的几个帮助程序类之一。通过导航到SimpleRoleScope（Control + N）并打开包含的包结构（Alt + F1）来检出它们。</i>   </p>   <h3 id="scopehelperimplementations">范围助手实现</h3>   <p id="ea5fd636">MPS附带了一些帮助程序<i id="bf0fecc3">作用域</i>实现，涵盖了许多可能的场景，您可以使用它们来简化定义作用域的任务：</p>   <ul class="list _ul"><li class="list__item" id="07f71304"><p>         <i id="6058cd7b">ListScope-</i>表示传递给其构造函数的节点</p></li><li class="list__item" id="018a2865"><p>         <i id="7c80315a">DelegatingScope-</i>传递给其构造函数的Scope实例的委托，通常由需要在现有范围周围添加功能的范围进行扩展，例如LazyScope</p></li><li class="list__item" id="695280c3"><p>         <i id="f3f395a8">CompositeScope-</i>委托给一组（包装的）Scope实例</p></li><li class="list__item" id="c0df7a47"><p>         <i id="aca105ae">FilteringScope-</i>委托给单个Scope实例，用谓词过滤其节点（isExcluded方法）</p></li><li class="list__item" id="b67cbb60"><p>         <i id="2c7fe98e">FilteringByNameScope-</i>委托给单个Scope实例，通过名称黑名单过滤其节点，该黑名单作为构造函数参数获取</p></li><li class="list__item" id="c753abd7"><p>         <i id="c5052b2f">EmptyScope-</i>没有节点的范围</p></li><li class="list__item" id="3876234a"><p>         <i id="b2c41991">SimpleRoleScope-</i>一个范围，提供与给定角色匹配的节点的所有子节点</p></li><li class="list__item" id="7f69cf54"><p>         <i id="4a321117">ModelsScope-</i>包含所提供的模型集中包含给定概念的所有节点的范围</p></li><li class="list__item" id="e9370ecb"><p>         <i id="24424780">ModelPlusImportedScope-</i>与ModelsScope类似，但包含由给定模型导入的所有模型</p></li></ul>   <p id="d2143b27">例如，可以使用<i id="0496a85f">ListScope通过</i>以下方式重写<i id="d82e7553">getScope（）</i>方法：</p>   <p id="d858301b">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Scopex1001.png"><img alt="范围x1001" title="范围x1001" src="/help/img/idea/2019.2/Scopex1001.png" id="38b20bd9" width="500" height="347"></a></figure>   <p></p>   <h3 id="variablereference">可变参考</h3>   <p id="dfe3f20b">在<i id="13c57857">BaseLanguage中可以找到更高级的示例<i id="13c57857">。VariableReference</i>使用<i id="0cdf0d02">继承的作用域</i>作为其<i id="22f0e8ae">variableDeclaration</i>参考。</i></p><i id="13c57857">   <p id="a95345c4">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/scp1.png"><img alt="scp1" title="scp1" src="/help/img/idea/2019.2/scp1.png" id="ae9d09a0" width="500" height="948"></a></figure>   <p></p>   <p id="417ca750"><i id="6ccb8e41">ForStatement</i> ， <i id="7dee9c3e">LocalVariableDeclaration</i> ， <i id="6dcf113c">BaseMethodDeclaration</i> ， <i id="eb6cc54a">Classifier</i>等概念以及其他一些概念将变量声明添加到范围中，从而实现了<i id="68c0ef73">ScopeProvider</i> 。<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/scp2.png"><img alt="scp2" title="scp2" src="/help/img/idea/2019.2/scp2.png" id="90322a57" width="900" height="1058"></a></figure>   <p></p>   <p id="ff803b6e">例如， <i id="a4a07a43">ForStatement</i>使用<i id="c4dd12c5">Scopes.forVariables</i>帮助函数来构建一个范围，该<b id="aabde3f0">范围</b>使用在for循环中声明的所有变量来丰富<b id="aabde3f0">父范围</b> ，从而可能在<b id="fd65802a">父范围中</b>隐藏相同名称的变量。<b id="4ae4d25b">来自</b>表达式可以检测到我们当前正在解析其范围的引用是否位于子树的给定部分中。</p>   <aside class="tip sideblock" rel="ff803b6e" id="4cbccd64" data-title="">      <ul class="list _ul"><li class="list__item" id="99666df0"><p><b id="415f9759">父范围</b>构造将创建<i id="130900cc">LazyParentScope（）</i>的实例，并有效地委派给模型中的祖先，该模型实现<i id="a4d9e143">ScopeProvider</i> ，以提供范围。</p></li><li class="list__item" id="2539aa8a"><p><b id="6aa3d51e">来自</b>构造函数的委托将委托给<i id="4f8df3bc">ScopeUtils.comeFrom（）</i> ，以检查是否正在为给定角色中的当前节点的直接子代计算范围。</p></li><li class="list__item" id="63fb153e"><p><b id="b423bc17">具有</b>构造的<b id="b423bc17">复合物</b> （用作<i id="7846d884"><expr>具有父作用域的</expr>复合物</i> ）将创建提供的作用域表达式和父作用域的组合作用域。</p></li></ul>   </aside>   <h2 id="usingreferencescope">使用参考范围</h2>   <p id="15d9a4e6">也可以使用参考范围以更快但可扩展性较小的方式实现范围：<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/rsc1.png"><img alt="rsc1" title="rsc1" src="/help/img/idea/2019.2/rsc1.png" id="88d1bba6" width="900" height="954"></a></figure>   <p></p>   <p id="5bb0e539">您可以将范围解析代码直接插入到约束定义中，而不是委托<i id="97fe073c">ScopeProvider</i>类型的祖先来进行解析。</p>   <aside class="tip sideblock" rel="5bb0e539" id="b4a4d53c" data-title="">      <p id="372aa834">您可能需要导入（ <i id="c7e9c53b">Control / Cmd + R</i> ） <i id="1aaeee85">jetbrains.mps.scope</i>模型才能使用<i id="cef2c726">SimpleRoleScope</i> 。</p>   </aside>   <p id="bce9fa97">      <br>      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/rsc2.png"><img alt="rsc2" title="rsc2" src="/help/img/idea/2019.2/rsc2.png" id="0ed5dfca" width="900" height="400"></a></figure>   <p></p>   <p id="267d15a7">现在，由<i id="afd9500f">InputFieldReference</i>本身定义了范围，而不是原来在<i id="fa181f84">Calculator的getScope（）</i>方法内部的代码。引用范围的函数应该返回<i id="ea53f183">Scope</i>实例，就像<i id="74961fbb">ScopeProvider.getScope（）</i>方法一样。<i id="6a938b99">范围</i>本质上是潜在参考目标的列表，以及用文本值解决这些目标的逻辑。</p>   <p id="2438b76f">提醒您，有几种预定义的<i id="b7d42699">Scope</i>实现和相关的辅助工厂方法可供您使用：</p>   <ul class="list _ul"><li class="list__item" id="74582340"><p>         <i id="726e6107">SimpleRoleScope-</i>简单地添加所有连接到提供的节点并处于指定角色的节点</p></li><li class="list__item" id="70187c80"><p>         <i id="9c58edd1">ModelPlusImportedScope-</i>提供导入模型的参考目标。允许用户按<i id="20025e93">ctrl + R / cmd + R</i> （包含模型的导入）将目标添加到作用域。</p></li><li class="list__item" id="9ae46375"><p>         <i id="47ee39a0">FilteringScope-</i>允许您从另一个范围中排除某些元素。具有FilteringScope的子类具有重写isExcluded（）方法。</p></li><li class="list__item" id="b07c1540"><p>         <i id="6c217195">DelegatingScope-</i>委托另一个范围。意味着要重写以自定义原始范围的行为。</p></li></ul>   <p id="d03601df">您还可以在<i id="e0c342f6">范围</i>模型中环顾四周：<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/scp3.png"><img alt="scp3" title="scp3" src="/help/img/idea/2019.2/scp3.png" id="4476a284" width="300" height="996"></a></figure>   <p></p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="mps-calculator-language-tutorial.html">MPS计算器语言教程</a> <a class="navigation-links__next" href="description-comments.html">说明注释</a></div></i></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>