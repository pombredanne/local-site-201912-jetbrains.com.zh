<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>如何-集成到MPS Make框架-帮助|帮助MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="HowTo+--+Integrating+into+the+MPS+Make+Framework.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="howto-integrating-into-the-mps-make-framework.xml" data-toc="HowTo+--+Integrating+into+the+MPS+Make+Framework.html">如何-集成到MPS Make框架</h1>   <h2 id="buildfacets">建立构面</h2>   <h2 id="overview">总览</h2>   <p id="9f87f19d">像基本上任何构建或生成系统一样，MPS make执行一系列步骤或<b id="eaece24f">目标</b>以构建工件。必要制造步骤的全局排序是从为每个构建目标指定的相对优先级中得出的（目标A必须在B之前运行，而B必须在C之前运行，因此全局顺序为A，B，C）。</p>   <p id="b614e724">完整的构建过程可能会解决一些问题，例如，将模型生成为文本，编译这些模型，将其部署到服务器和/或从graphviz源文件生成.png文件。在MPS中，此类不同的构建方面是通过构建<b id="a8be406d">方面</b>实现的。方面是解决共同关注的目标的集合。</p>   <p id="903f78cf">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/facet10.png"><img alt="facet10" title="facet10" src="/help/img/idea/2019.2/facet10.png" id="a70a9889" width="300" height="668"></a></figure>   <p></p>   <aside class="tip sideblock" rel="903f78cf" id="80ab4c08" data-title="">      <p id="3af8eca5">         <b id="823d6c0a">避免不必要的文件覆盖</b>      </p>      <p id="e8e2dc76">生成过程不会覆盖保存的文件内容与刚生成的文件相同的文件。您可以依靠这样的事实，即只有修改后的文件才能在磁盘上更新。</p>   </aside>   <p id="42cf70d7">构面内的目标可以交换配置参数。例如，声明为在整个制造过程中尽早运行的目标可以收集配置参数，并将其传递给第二个方面，然后使用该参数。实现此方面内参数交换的机制称为属性。此外，目标可以在制作过程中使用查询从用户那里获取信息。</p>   <p id="ff1f00b7">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/facet11.png"><img alt="facet11" title="facet11" src="/help/img/idea/2019.2/facet11.png" id="b2bfe264" width="300" height="934"></a></figure>   <p></p>   <p id="b4736d85">整个制作过程是沿着管道和过滤器模式组织的。目标充当过滤器，处理传递给它们的数据流。在目标之间流动的数据称为<b id="1c0b798c">资源</b> 。有不同类型的资源，它们全部表示为不同的Java接口和元组：</p>   <p id="429ce283">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/facet12.png"><img alt="facet12" title="facet12" src="/help/img/idea/2019.2/facet12.png" id="bf07e573" width="300" height="438"></a></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="a3d1d01d"><p>         <i id="47a70d19">MResource</i>包含用户创建的MPS模型，这些模型包含在项目的解决方案和语言中</p></li><li class="list__item" id="058cf53e"><p>         <i id="d06f290f">GResource</i>表示生成过程的结果，其中包括输出模型，即输出完成后模型的最终状态。这些是瞬态模型，可以使用“ <b id="48d7a963">保存瞬态模型”</b>构建选项进行检查</p></li><li class="list__item" id="6c025b86"><p>         <i id="ebbdf19d">TResource</i>表示text-gen的结果</p></li><li class="list__item" id="19032224"><p>         <i id="07eac263">CResource</i>表示Java类的集合</p></li><li class="list__item" id="22fa5a6e"><p>         <i id="ee22f9cc">DResource</i>表示模型的增量更改的集合（ <i id="52e55b08">IDelta</i> ）</p></li><li class="list__item" id="28cc408e"><p>         <i id="e8f0f5a4">TextGenOutcomeResource</i>表示由textgen生成的文本文件</p></li></ul>   <p id="21d95ca5"> </p>   <aside class="warning " rel="21d95ca5" id="9d413f36" data-title="">      <p id="256837ab">这些资源接口已被弃用：</p>      <ul class="list _ul"><li class="list__item" id="13882c8a"><p>            <i id="9d09c125">IMResource</i>包含由用户创建的MPS模型，这些模型包含在项目的解决方案和语言中</p></li><li class="list__item" id="790e94e4"><p>            <i id="8eaf2763">IGResource</i>表示生成过程的结果，其中包括输出模型，即输出完成后模型的最终状态。这些是瞬态模型，可以使用“ <b id="fe09f5c7">保存瞬态模型”</b>构建选项进行检查</p></li><li class="list__item" id="1118a9cf"><p>            <i id="4fdfcfaf">ITResource</i>表示在生成过程结束时textgen生成的文本文件</p></li><li class="list__item" id="aa49782e">            <i id="adb744c7">资源</i>         </li></ul>   </aside>   <p id="21c004f0">构建目标指定一个接口。根据管道和过滤器模式，该接口描述流入和流出制造商的数据的类型。<br>目标。根据上述资源类型以及针对这些资源的目标处理类型进行指定。定义了以下四个处理策略：</p>   <ul class="list _ul"><li class="list__item" id="17b37bd4"><p>转换是默认设置。此策略使用输入资源类型的实例，并产生输出资源类型的实例（例如，它可能<br>消耗<code class="code">MResources</code>并产生<code class="code">TResources</code> ）</p></li><li class="list__item" id="64f50d5e"><p>消耗消耗声明的输入，但不产生输出。 *生产不消耗任何东西，但是产生输出</p></li><li class="list__item" id="6c0aa49b"><p>传递不访问任何资源，既不产生也不消耗。</p></li></ul>   <p id="22e2958d">请注意，制作过程比模型生成更粗糙。换句话说，有一个方面可以运行所有模型生成器。如果需要<br>要将其他目标“插入”到MPS生成过程中（而不是在模型生成之前或之后执行某些操作），这需要重构<br>的<code class="code">generate</code>方面。这超出了本讨论的范围。</p>   <h2 id="buildinganexamplefacet">构建示例构面</h2>   <p id="124e25ae">作为为MPS构建C基本语言的<b id="c95682e2">mbeddr.com</b>项目的一部分，实际的C编译器必须集成到MPS构建过程中。更多<br>具体来说，使用C基本语言编写的程序包含一种生成<code class="code">Makefile</code> 。这个<code class="code">Makefile</code>必须执行一次，所有<br>相应的.c和.h文件已经生成，即在MPS制作过程的最后。</p>   <p id="b3f18994">为此，我们使用两个目标构建了一个make facet。第一个检查输入模型，并收集可能包含目录的目录的绝对路径。<br>       <code class="code">Makefile</code>在textgen之后。然后，第二个目标检查是否确实存在一个名为<code class="code">Makefile</code>在此目录中，然后在此处运行make。他们俩<br>目标通过属性交换目录，如上面概述中所述。</p>   <aside class="tip sideblock" rel="b3f18994" id="90a78e6a" data-title="">      <p id="58243931">与MPS发行版捆绑在一起的<i id="089af142">sampleFacet</i>示例项目提供了一个简单的方面定义，您可以将其作为使用make facet进行冒险的起点。</p>   </aside>   <h3 id="thefirsttarget:collectingdirectories">第一个目标：收集目录</h3>   <p id="0a40671d">方面生活在<code class="code">plugins</code>语言定义的方面。确保在插件模型中包含{{jetbrains.mps.make.facets}语言，<br>因此您可以创建<code class="code">FacetDeclaration</code> 。构面作为模型制作过程的一部分执行，如果该模型<code class="code">uses</code>那种语言<br>声明方面。</p>   <p id="79c79bd5">构面称为<code class="code">runMake</code> 。这取决于<code class="code">TextGen</code>和<code class="code">Generate</code> 。必须指定对这两个方面的依赖关系，这样我们才能声明目标相对于这些方面中目标的优先级。</p>   <div class="code-block" data-lang="none">构面runMake扩展<none>必需：TextGen，Generate</none></div>   <p id="5bce70b9">第一个目标称为<code class="code">collectPaths</code> 。为了与输入模型保持联系，将其指定为{{transform IMResource-> IMResource}。的<br>方面规定优先事项<code class="code">after configure</code>和<code class="code">before generate</code> 。后者是显而易见的，因为我们想先了解模型<br>生成为文本。从前的优先级本质上说，我们希望此目标在初始化make过程之后运行（换句话说：if<br>您想要“在开始时”做某事，请使用这两个优先级。）</p>   <div class="code-block" data-lang="none">目标collectPathes覆盖<none>{资源策略：转换IMResource-> IMResource依赖项：配置后生成</none></div>   <p id="4b9f0d8e">然后我们声明一个属性<code class="code">pathes</code>我们用它来存储有关包含make文件的模块以及其中目录的路径的信息<br>生成的代码将驻留。</p>   <div class="code-block" data-lang="none">属性：list <[string，string]>路径；</div>   <p id="d09a328f">现在让我们看一下目标的实现代码。这是基本结构。我们首先初始化<code class="code">pathes</code>清单。然后，我们迭代<br>输入（这是资源的集合），并对每个输入进行一些操作（在下面说明）。然后，我们使用<code class="code">output</code>用于输出输入的语句<br>数据，即我们只是通过任何进入目标的东西。我们使用<code class="code">success</code>声明以成功完成此目标（使用<code class="code">success</code>      <br>最后是可选的，因为这是默认设置）。如果出现问题， <code class="code">failure</code>语句可用于成功终止目标。</p>   <div class="code-block" data-lang="none">（输入）-> void {路径=新的链表<[字符串，字符串]>; input.forEach（{〜inpt =>（模块，模型）res =（（模块，模型））inpt; //做事情。见下文。}）;输出输入;成功; }</div>   <p id="49962134">实际处理是针对MPS数据结构的直接Java编程：</p>   <div class="code-block" data-lang="none">res.models.forEach（{〜model =>字符串路径= res.module.getGeneratorOutputPath（）+“ /” + model.getLongName（）。replaceAll（“ \\。”，“ /”）;字符串locationInfo = res。 module.getModuleFqName（）+“ /” + model.getLongName（）; pathes.add（[path，locationInfo]）;}）;</div>   <p id="9fe0a245">我们使用<code class="code">getGeneratorOutputPath</code>获取特定模块生成其代码的路径的方法（可由用户在<br>模型属性）。然后，我们获得模型的点名称，并将点替换为斜杠，因为这是该模块中模型的生成文件所在的位置<br>结束（检查任何示例MPS项目以查看此内容）。然后，我们存储模块名称和模型名称（以斜杠分隔），以改进<br>在第二个目标中记录消息（通过变量<code class="code">locationInfo}). We add the two strings to the {{pathes</code>采集。这个<code class="code">pathes</code>属性<br>由构面中的第二个目标查询。</p>   <h3 id="thesecondtarget:runningmake">第二个目标：运行Make</h3>   <p id="ee372858">这个用<code class="code">pass through</code>政策，因为它不必处理资源。它需要的所有输入都可以从<code class="code">collectPaths</code>上面讨论的目标。第二个目标运行<code class="code">after collectPaths}, {{after textGen</code>和<code class="code">before reconcile</code> 。显然，必须在之后运行<code class="code">collectPaths}, since it uses the property data populated by it. It has to run after {{textGen}, otherwise the make files aren't there yet. And it has to run before {{reconcile}, because basically everything has to run before {{reconcile</code>    </p>   <div class="code-block" data-lang="none">目标callMake覆盖<none>资源策略：传递依赖项：在textGen之后的collectPathes之后，在协调之前</none></div>   <p id="9229eff2">现在让我们看一下实现代码。我们首先从<code class="code">collectPathes.pathes</code>实际包含一个<br>       <code class="code">Makefile</code> 。如果没有找到，我们返回<code class="code">success</code> 。</p>   <div class="code-block" data-lang="none">sequence <[string，string]> modelDirectoriesWithMakefile = collectPathes.pathes。where（{〜it => new File（it [0] +“ / Makefile”）。exists（）;}）;如果（modelDirectoriesWithMakefile.isEmpty）{成功； }</div>   <p id="f52b17c9">然后，我们使用进度指示器语言来设置进度条，其中包含与包含make文件的目录一样多的工作单元。</p>   <div class="code-block" data-lang="none">开始工作“运行制作”，涵盖剩余总工作量的所有单位，期望modelDirectoriesWithMakefile.size单位；</div>   <p id="16b9ffc7">然后，我们遍历{{modelDirectoriesWithMakefile}集合中的所有条目。在循环中，我们前进进度指示器，然后使用Java<br>标准的API来运行make文件。</p>   <div class="code-block" data-lang="none">modelDirectoriesWithMakefile中的foreach dirInfoTuple {试试{前进1个单位的“ run make”，并带有注释“ run make for” + dirInfoTuple [1];流程= Runtime.getRuntime（）。exec（“ make”，新字符串[0]，新文件（dirInfoTuple [0]））;如果（process.waitFor（）> 0）{错误“失败，退出代码为” + process.exitValue（）+“ for dirInfoTuple [1]； } else {info“使dirInfoTuple [1]成功完成。 }} catch（Exception ex）{error ex.getMessage（），ex; }}</div>   <p id="d6a7e738">要包装目标，我们使用<code class="code">finish</code>声明来清理进度条。</p>   <div class="code-block" data-lang="none">完成“运行”；</div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="common-language-patterns.html">常见语言模式操作</a> <a class="navigation-links__next" href="howto-adding-additional-tools-aka-views.html">方法-添加其他工具（即视图）</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>