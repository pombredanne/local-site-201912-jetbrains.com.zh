<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>生成语言-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Build+Language.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="build-language.xml" data-toc="Build+Language.html">构建语言</h1>   <h2 id="whatismpsbuildlanguage?">什么是MPS构建语言？</h2>   <p id="f6adf46f">构建语言是可扩展的构建自动化DSL，用于以声明的方式定义构建。生成到<a href="http://ant.apache.org" rel="noopener noreferrer" data-external="true" target="_blank">Ant中</a> ，它利用了Ant执行力，同时保持源代码整洁，并且没有混乱和无关紧要的细节。它组织为一堆MPS语言，其底部是ANT，它允许以不同的抽象级别表示构建过程的每个部分。如果遵循语言约定，则只需一行代码即可指定构建复杂工件（如MPS插件）的过程，但是与此同时，没有什么可以阻止您更深入地研究和自定义细节，例如文件管理或清单属性。</p>   <p id="eb9df039">与许多构建自动化工具一样，项目定义是脚本的核心。此外，与大多数其他工具不同， <i id="5dc3cea7">构建语言</i>使您可以完全控制输出目录的布局。预期的生成结果是在生成脚本中单独定义的，而不是某些（第三方）插件的一部分。<br>每个构建脚本均由三部分组成。首先是<b id="dfada1e0">依赖关系</b> ，它已经内置了一些必需的东西。例如，考虑库或第三方语言。接下来是<b id="b3cd7830">项目结构</b> 。它包含存储库中所有内容的声明，将要构建的内容以及所需的构建参数。请注意，在此处声明项目不会触发其构建，除非需要它，即从脚本的最后一部分- <b id="445cad31">输出布局</b>引用。输出可能像一组简单的文件夹和复制的文件一样简单，或者与压缩的工件（如打包的插件或MPS语言）相比更为复杂。例如，要从Java源代码构建jar文件，您需要在项目结构中声明一个Java模块，并在输出布局中引用该模块的相应jar文件。</p>   <p id="a4beac36">多亏了MPS， <i id="f42a1cf1">构建语言才</i>带有简洁的文本符号和出色的编辑体验，包括完成和即时验证。扩展语言（或插件，如果我们坚持使用其他构建工具的术语），则在语言之上添加了其他抽象。根据我们的经验，与开发Maven或Gradle插件相比，创建一个新的过程非常容易。</p>   <h2 id="buildscriptstructure">构建脚本结构</h2>   <p id="7e857d42">请参见下面的生成脚本示例，该脚本为Intellij IDEA生成了一个插件：</p>   <p id="9eeac185">      </p><figure><img alt="samplesScript" title="samplesScript" src="/help/img/idea/2019.2/samplesScript.png" id="52b12ce9" width="859" height="798"></figure>   <p></p>   <p id="c05ed1da">让我们仔细看看。脚本的标题由常规脚本信息组成：脚本名称（屏幕截图中的<i id="d312468f">Complex</i> ），生成文件的文件（ <i id="5a8648a8">build.xml</i> ）和脚本的基本目录（在屏幕截图中可以看到的是相对于脚本位置<i id="ec0413ad">../../</i>以及完整路径）。</p>   <p id="958d7adb">该脚本的主体包括以下部分：</p>   <ul class="list _ul"><li class="list__item" id="80665c66"><p>         <i id="c7238196">use plugins</i>包含脚本中<i id="c7238196">使用的插件</i>列表。Build Language中的插件类似于Gradle中的插件：它们是对该语言的扩展，提供了许多任务来做有用的事情，例如编译Java代码，运行单元测试，打包模块等。在屏幕截图中，使用了两个插件： <i id="42232ea9">java</i>和<i id="f8ac8d15">mps</i> ，这意味着脚本可以构建java和mps代码。</p></li><li class="list__item" id="da4dd43f"><p>         <i id="a04c5b58">宏</i>部分定义了项目中使用的路径宏和变量（ <i id="93dcc121">idea_home</i>和<i id="4109ae59">plugins_home</i> ）以及它们的默认值，这些默认值可以在脚本执行期间被覆盖。</p></li><li class="list__item" id="869f80e6"><p>         <i id="29d39e62">依赖项</i>定义了对其他构建脚本的脚本依赖项。如果脚本引用其他构建脚本中定义的内容，则必须在“依赖关系”部分中指定此脚本。屏幕截图上的示例脚本取决于其他两个脚本<i id="f3550afa">IDEA</i>和<i id="2c27d96c">mpsPlugin</i> 。这些由MPS提供，因此要使用它们，必须为其指定<i id="deaa1ff8">工件位置</i> ，即，蚂蚁可以在其中找到其工作结果的位置（在示例中， <i id="b3c12ab0">idea_home</i>应指向Intellij IDEA jars和<i id="3b4d9f42">plugins_home</i>的位置。应该指向IDEA的MPS插件的位置）。一个人也可以依赖同一MPS项目中的某些构建脚本。在那种情况下，不需要工件位置，并且假设所需的脚本将在当前脚本之前构建（有一个目标<i id="b4e62cae">buildDependents</i>会这样做）。</p></li><li class="list__item" id="ce44bc88"><p>         <i id="edab08a3">项目结构</i>部分包含<i id="edab08a3">项目</i>的描述，即项目具有哪些模块，源代码位于何处，模块的类路径等。屏幕快照中的示例项目由一个名为<i id="902cc74c">Complex</i>的单个<i id="57d16ae1">想法插件</i>组成，并包含一组MPS模块。</p></li><li class="list__item" id="594ebdf5"><p>         <i id="6c132652">默认布局</i>定义了如何将项目打包到发行版中。屏幕截图上的示例项目打包到一个名为<i id="1a33dcac">Complex.zip</i>的zip文件中。</p></li><li class="list__item" id="5176c3cb"><p>         <i id="41e636d8">其他方面</i>定义了与项目相关的其他一些内容，例如，各种设置，要运行的集成测试等等。</p></li></ul>   <h2 id="macros">巨集</h2>   <p id="b28eb883">宏有两种类型：</p>   <ul class="list _ul"><li class="list__item" id="ed5af07a"><p>         <b id="58d8f27b">文件夹</b> -代表文件系统中的物理文件夹，如果保留为空（ <i id="4f51783f">默认值</i> ），则尝试从MPS中定义的同名<b id="0324e075">路径变量中</b>检索该值</p></li><li class="list__item" id="71fd9b0b"><p>         <b id="d5279952">Var-</b>表示值的自定义变量</p></li></ul>   <p id="a348711c"><b id="0e043283">Vars</b>可以通过以下几种方式之一进行初始化：</p>   <ul class="list _ul"><li class="list__item" id="6e091abc"><p>引用以前的宏</p></li><li class="list__item" id="2564322e"><p>         <b id="e0eecb10">date-</b>日期值，应指定遵循Java日期格式规则的<b id="3e6af029">模式</b>参数，例如yyyy-MM-dd，将运行构建脚本的时间的日期值插入宏</p></li><li class="list__item" id="b0577cd9"><p>         <b id="fe5109b7">从文件加载</b> -从指定的属性<b id="fe5109b7">文件中</b>读取指定的属性值</p></li><li class="list__item" id="d0a07e2c"><p>         <b id="e75f78ee">text-</b>纯文本值</p></li></ul>   <h2 id="built-inplugins">内置插件</h2>   <p id="06080ddd">Build Language提供了几个内置插件。</p>   <h3 id="javaplugin">Java插件</h3>   <p id="601d6c73">Java插件增加了编译和打包Java代码的功能。源代码表示为Java模块和Java库。</p>   <p id="65469df7">Java模块定义其内容（源文件夹位置）以及对其他模块，库和jar的依赖关系。在内容部分，java模块可以具有：</p>   <ul class="list _ul"><li class="list__item" id="f312c91c"><p>         <i id="7475ead9">文件夹</i> –磁盘上源文件夹的路径；</p></li><li class="list__item" id="52a574a4"><p>         <i id="292db3d3">资源</i> –资源文件集。包括资源文件夹的路径和选择器列表（ <i id="c7aae136">include</i> ， <i id="39b19ea0">exclude</i>或<i id="33fad652">include</i> ）。</p></li><li class="list__item" id="114d3045"><p>         <i id="c0b2bf99">内容根</i> –具有多个内容文件夹的根。</p></li></ul>   <p id="95eadb6a">在“依赖关系”部分，java模块可以具有：</p>   <ul class="list _ul"><li class="list__item" id="85576cc6"><p>         <i id="aa158361">classpath</i> –具有<i id="aa158361">classpath</i>的任意xml；</p></li><li class="list__item" id="65580fd6"><p>         <i id="520052a3">外部jar</i> –来自其他构建脚本布局的jar文件；</p></li><li class="list__item" id="a1bc1e89"><p>         <i id="b4ab0000">文件夹中的外部jar</i> –从其他构建脚本布局的文件夹中按名称引用的jar文件；</p></li><li class="list__item" id="4d481cec"><p>         <i id="0abad473">jar</i> –通往本地jar的路径；</p></li><li class="list__item" id="dae6eaec"><p>         <i id="720c6599">库</i> –对Java库的引用；</p></li><li class="list__item" id="dcc2b01f"><p>         <i id="1af10771">module</i> –对Java模块的引用。</p></li></ul>   <p id="2f0ea7af">每个Java模块都会根据源模块的依赖关系生成到依赖于其他目标的自己的ant目标。为了编译循环模块依赖性，执行两步编译：</p>   <ol class="list _decimal"><li class="list__item" id="5443f6d4"><p>一个“循环”目标将循环中的所有模块一起编译。</p></li><li class="list__item" id="0d9bf3cc"><p>循环中的每个模块都是使用classpath中“循环”目标的编译结果编译的。</p></li></ol>   <p id="424e0c36">Java库由jar（由路径指定或作为对其他项目布局的引用）和类文件夹组成。可用元素为：</p>   <ul class="list _ul"><li class="list__item" id="2e8f10b2"><p>         <i id="29a4c6ec">classes文件夹</i> –包含<i id="29a4c6ec">类的文件</i>夹；</p></li><li class="list__item" id="0782f0ee"><p>         <i id="e522e9fe">外部jar</i> –来自其他构建脚本布局的jar文件；</p></li><li class="list__item" id="fdec63bf"><p>         <i id="6e8924c8">来自以下位置的外部jar</i> –来自其他Buils脚本布局的文件夹中的jar的集合；</p></li><li class="list__item" id="bd322640"><p>         <i id="9e90bbb7">jar</i> –通往本地jar的路径；</p></li><li class="list__item" id="b5dd42b7"><p>         <i id="7f87bb7f">jars</i> –包含jar和选择器列表（ <i id="b9eb1cc7">include</i> ， <i id="e3437127">exclude</i>或<i id="c51d60d2">include</i> ）的本地文件夹的路径。</p></li></ul>   <p id="18d521e7">Java模块的编译设置在<i id="def20e7d">java options</i>中指定。构建脚本中可以有多个Java选项，其中只有一个是默认选项。每个模块都可以指定自己的Java选项以进行编译。</p>   <h4 id="javatargets">Java目标</h4>   <p id="145f401d">Java插件添加了以下目标：</p>   <ul class="list _ul"><li class="list__item" id="51901b49"><p>         <i id="5b85ba16">compileJava</i>编译项目中的所有Java模块。</p></li><li class="list__item" id="b3a5c961"><p>         <i id="257398a8">processResources</i>扩展点，用于其他资源处理。</p></li><li class="list__item" id="d0882d2e"><p>         <i id="71f1c517">类</i>负责项目中的所有编译和资源处理。它取决于目标<i id="0e9c7476">compileJava</i> ， <i id="c2ba0f25">processResources</i> 。</p></li><li class="list__item" id="db3f3543"><p>         运行单元测试的<i id="657e0eff">测试</i>扩展点目标。</p></li><li class="list__item" id="fcb8551c"><p>         <i id="aa6a7e8b">检查</i>将对项目的正确性进行所有测试和检查。这取决于目标<i id="c6adb92a">测试</i> 。</p></li></ul>   <h3 id="mpsplugin">MPS插件</h3>   <p id="1e3ec61e">MPS插件使脚本中的构建语言能够构建mps模块。为了使用MPS插件，必须将<i id="1fe56ee4">jetbrains.mps.build.mps</i>语言添加到使用的语言中。</p>   <h4 id="mpsmodulesandgroups">MPS模块和组</h4>   <p id="97324c1f">MPS插件可以将模块添加到项目结构中。屏幕截图上有一个在构建脚本中声明的语言示例。</p>   <p id="80f5c388">      </p><figure><img alt="样本语言" title="样本语言" src="/help/img/idea/2019.2/sampleLanguage.png" id="d5284fcc" width="620" height="302"></figure>   <p></p>   <p id="5095742b">请注意，有许多关于在构建脚本中指定的模块的信息，其中大多数信息显示在<b id="a30ea584">Inspector工具窗口中</b> ： <i id="23cb33a3">uuid</i>和<i id="702de745">完全限定名称</i> ，描述符文件的<i id="e8771f73">完整路径</i> ， <i id="8a4f3ddb">依赖项</i> ， <i id="3d28ca30">运行时</i> （对于语言）等。打包模块时需要此信息。因此，每次对此模块进行任何更改（例如添加依赖项）时，都必须同时更改构建脚本。当然，有许多工具可以轻松实现。在脚本中编写和管理mps模块的典型过程如下所示：</p>   <ol class="list _decimal"><li class="list__item" id="793a28fc"><p>将模块添加到脚本中。可以指定要添加的模块类型（解决方案，语言或devkit）以及模块描述符文件的路径。然后，意图“ <i id="01e01f26">从文件中加载所需信息</i> ”可用于读取该文件并自动填充其余模块规范。<br>          </p><figure><img alt="loadRequired" title="loadRequired" src="/help/img/idea/2019.2/loadRequired.png" id="59dfddf9" width="559" height="162"></figure>      <p></p></li><li class="list__item" id="f0ccc47c"><p>反映模块中所做的更改。可以使用“ <b id="8b44d888">模型检查器”</b>使用构建脚本检查模型，以查找其是否与模块文件一致。模型检查器将在脚本中显示所有问题，并允许您使用“执行快速修复”按钮进行修复。可以使用相同的“从文件加载所需信息”来代替模型检查器，以分别修复每个模块。<br>          </p><figure><img alt="模型检查器" title="模型检查器" src="/help/img/idea/2019.2/modelChecker.png" id="08ceec52" width="1090" height="183"></figure>      <p></p></li></ol>   <p id="2213827d">关于构建脚本中的MPS模块声明，要记住的另一件事是，它们不依赖于MPS中加载的模块。所有信息均取自磁盘上的模块描述符文件，而构建脚本可能无法使用模块本身。</p>   <p id="8ec40ec1">可以将MPS模块添加到<i id="996b2c76">mps组</i>中，以构建构建脚本。MPS组只是一组命名的模块，可以从外部进行引用，例如，可以将一个模块组作为一个单元添加到IDEA插件中。</p>   <h3 id="moduleresources">模块资源</h3>   <p id="c60ea865">模块所需的资源（图像，图标等）应使用<b id="8d17a6ef">资源</b>内容根目录指定：</p>   <p id="e1f4a3b9">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Resources.png"><img alt="资源资源" title="资源资源" src="/help/img/idea/2019.2/Resources.png" id="33ad8fba" width="500" height="752"></a></figure>   <p></p>   <h4 id="howgeneratingandcompilingmpsmodulesworksinternally">MPS模块的内部生成和编译方式</h4>   <p id="28dad572">正如上面所写，有关模块的许多信息都提取到构建脚本中并存储在其中。这要求用户只要模块依赖项发生更改，就可以正确更新脚本。对于<i id="f5191b88">Solution</i> ，提取到脚本的是重新导出和未重新导出的依赖项。对于一种语言，除了依赖关系外，还提取运行时解决方案和扩展语言。</p>   <p id="3d9ef41b">使用构建脚本“构建”模块包括两个部分：生成此模块和编译模块源。对于将其源代码存储在版本控制系统中并使其与模型保持同步的项目，生成是可选步骤。为了生成，创建了一个目标，该目标生成了构建脚本中的所有模块。模块分为“块”（可以一起生成的模块组），并且<i id="daa11826">generate</i>任务一个一个地生成块。例如，一种语言和用该语言编写的解决方案无法一起生成，因此它们会分成不同的块。除了要生成的块列表之外， <i id="8ff732a3">生成</i>任务还提供了要加载的想法插件列表以及生成所需的其他构建脚本中的模块列表。插件和模块的列表是根据依赖关系计算得出的，因此它们的正确性对于成功生成至关重要。这是从MPS和构建脚本生成模块之间的主要区别：从MPS生成模块时，生成器将加载并可用项目中的所有模块。从构建脚本生成模块时，生成器仅具有模块依赖项中明确指定的内容。因此，构建脚本可以用作某种模块依赖关系正确性的验证器。</p>   <p id="0e9a921d">模块的编译有所不同：对于每个MPS模块，都会生成一个Java模块，因此最后，每个MPS模块都由一个普通的ant javac任务（或在<i id="37bbaf08">Java Options</i>中选择的其他类似任务）进行编译。</p>   <p id="2df38919">因此，为了生成和编译，必须收集模块的依赖项并将其嵌入到生成的build xml文件中。在从模块描述符文件生成构建脚本的过程中收集使用的语言和devkit。其他信息存储在构建脚本节点中。在下面的图片中，显示了一个名为“ myproject”的项目的模块结构，该项目使用了一些名为“ mylibrary”的第三方MPS库。</p>   <p id="d677d93a">      </p><figure><img alt="普通模块结构" title="普通模块结构" src="/help/img/idea/2019.2/normal-module-structure.png" id="1a4c5f81" width="982" height="362"></figure>   <p></p>   <p id="28468798">箭头说明了模块之间的依赖系统。紫色箭头表示提取到构建脚本的依赖项，蓝色箭头表示未提取的依赖项。可以很容易地观察到，为了从<b id="c351ba3c">我的项目中</b>编译和生成模块，不需要了解库内部的“蓝色箭头”。这意味着在myproject构建脚本生成过程中，我的库中的实际模块文件甚至可能不存在。生成器需要的所有信息都包含在构建脚本中。这确实非常方便：在构建生成过程中无需下载整个库并指定其完整位置，因此生成过程通过不从项目依赖项中加载所有模块描述符来节省时间和内存。</p>   <h4 id="sourcesandtests">来源和测试</h4>   <p id="8634e52c">当MPS解决方案包含测试模型（即，原型为“ @tests”的模型）时，它们将生成到默认情况下未编译的文件夹“ tests_gen”中。要编译测试，需要在构建脚本中指定解决方案具有测试模型。这是在检查器中手动完成的。解决方案有三个选项可用：“带有源”（默认），“带有测试”和“带有源和测试”。<br>       </p><figure><img alt="withTests" title="withTests" src="/help/img/idea/2019.2/withTests.png" id="bc88af16" width="775" height="324"></figure>   <p></p>   <h4 id="mpssettings">MPS设置</h4>   <p id="25d38376">      <i id="8743e56b">mps设置</i>允许更改构建脚本的MPS特定参数。在“其他方面”部分的构建脚本中最多可以存在一个<i id="cfce77b7">mps设置</i>实例。可以更改的参数：</p>   <ul class="list _ul"><li class="list__item" id="ee34dc45"><p>         <i id="d6bf12f1">bootstrap</i> –将此标志设置为“ true”表示脚本中的模块之间存在一些自举依赖性。通常，该标志设置为false。有关详细信息，请参见<a href="removing-bootstrapping-dependency-problems.html">消除引导程序依赖性问题</a> 。</p></li><li class="list__item" id="18df3acb"><p>         <i id="95dac4e7">测试生成</i> –如果设置为true，构建脚本将测试模块生成以及生成的文件与磁盘上文件之间的差异。可以在<i id="c128b0d2">排除</i>部分的差异中<i id="c128b0d2">排除</i>文件。</p></li><li class="list__item" id="b392ff9e"><p>         <i id="a75de637">generation最大堆大小（以mb为单位）</i> –用于生成和生成测试的最大堆大小。</p></li></ul>   <h4 id="testingmodulesgeneration">测试模块生成</h4>   <p id="5bba1be5">将其生成的源文件保留在版本控制中的项目可以使用生成脚本检查这些生成的文件是否为最新。在<i id="f5cbcafd">mps</i>设置<i id="f5cbcafd">中将测试生成</i> <i id="309ff122">设置</i>为true之后，在生成的构建脚本的<i id="63d344cc">测试</i>目标中会出现最<i id="a687f5de">慢的</i>任务调用。与<i id="f6b1a263">生成</i>任务类似， <i id="ed3847e2">gentest</i>在脚本中加载模块，它们与其他构建脚本的依赖关系以及所需的<i id="ed3847e2">Idea</i>插件。对于每个模块，最<i id="baac55b0">简单的</i>任务调用两个测试：“％MODULE_NAME％。Test.Generating”和“％MODULE_NAME％。Test.Diffing”。当模块在生成过程中出错时，Test.Generating失败；当生成的文件与磁盘上的文件不同（从版本控制中检出）时，Test.Diffing失败。测试结果和统计信息格式化为TeamCity构建服务器支持的xml文件。</p>   <h4 id="ideaplugins">IDEA插件</h4>   <p id="6b21cc95">      <i id="ccae8056">idea插件</i>构造为其中装有MPS模块的IntelliJ IDEA或MPS定义了一个插件。在屏幕截图中，您可以看到此类插件的示例。</p>   <p id="f4d07656">      </p><figure><img alt="blxx1" title="blxx1" src="/help/img/idea/2019.2/blxx1.png" id="ac2e5854" width="500" height="610"></figure>   <p></p>   <p id="08c133ec">插件声明的第一部分包含各种描述插件的信息：其名称和描述，文件夹的名称，插件供应商等。此处的重要字符串是<b id="db225d2e">插件ID</b> ，它位于关键字<i id="a98086e3">idea plugin之后</i> 。这是所有其他插件的唯一标识符。关于如何构造<i id="406fca44">plugin.xml</i>文件，有三个选项。它既可以仅使用构建脚本的“ <b id="097806b4">创意插件”</b>部分中包含的信息，也可以使用<b id="35c4276a">提供的</b> <i id="b4b825e4">plugin.xml</i>文件的内容来丰富信息，也可以仅使用<b id="d6b5d2a3">定制的</b> <i id="3cfb26ec">plugin.xml</i>文件。</p>   <p id="ec64eec9">      </p><figure><img alt="blxx2" title="blxx2" src="/help/img/idea/2019.2/blxx2.png" id="24304a64" width="500" height="286"></figure>   <p></p>   <p id="ec74e475"><b id="e24399f9">想法插件</b>的下一部分是实际的插件内容–插件中包含的一组模块或模块组。</p>   <p id="96b3d306">最后一部分专门介绍其他插件对插件的依赖性。规则是，如果我们在插件“ pluginA”中有一个“ moduleA”，这取决于“ pluginB”中的“ moduleB”，那么“ pluginB”上应该有一个“ pluginA”依赖项。存在类型系统检查，它将识别并报告此类问题。</p>   <p id="0232a1e5">最后指定插件的<b id="697072e4">布局</b> 。有两种方法可以打包插件：</p>   <ul class="list _ul"><li class="list__item" id="6f9c5e87"><p>自动打包-所有提供的语言和解决方案都放在插件根目录下的“ languages”文件夹中</p></li><li class="list__item" id="04ffc77d">         <p id="ac43a739">手动打包-开发人员必须手动定义整个插件布局</p>      </li></ul>   <p id="16cb65a3">      </p><figure><img alt="blxx3" title="blxx3" src="/help/img/idea/2019.2/blxx3.png" id="3aacb84a" width="500" height="290"></figure>   <p></p>   <h4 id="mpstargets">MPS目标</h4>   <p id="d4d180cd">MPS插件提供以下目标：</p>   <ul class="list _ul"><li class="list__item" id="e7e4ba24"><p>         <i id="6927c47c">generate-</i>生成包含在<i id="4f59fb3f">项目结构中</i>的mps模块。</p></li><li class="list__item" id="3cbb6766"><p>         <i id="b683b034">cleanSources-</i>清除生成的代码（仅适用于没有自举依赖项的模块）。请参阅文章“ <a href="removing-bootstrapping-dependency-problems.html">消除引导程序依赖性问题”中</a>有关引导程序依赖性的更多信息。</p></li><li class="list__item" id="f1f23b19"><p>         <i id="ce7ebbd4">声明-MPS任务</i> -声明MPS任务，如<i id="d5bafb1b">生成</i>或<i id="d386be5a">copyModels</i>实用的目标。</p></li><li class="list__item" id="8cd4b720"><p>         <i id="09bfd0d3">makeDependents-</i>调用<i id="3b14da36">generate</i>目标来暂时关闭此脚本的依赖项（如果存在），然后调用<i id="115e3d77">汇编</i>将它们放在一起。确保每个脚本仅在其所有依赖项均已构建后才执行。</p></li></ul>   <h3 id="moduletestingplugin">模块测试插件</h3>   <p id="acaaec3e">由<i id="cbfc8f37">jetbrains.mps.build.mps.tests语言</i>提供的<i id="bf704abd">模块测试</i>插件向构建脚本添加了在MPS解决方案中执行<i id="4f53b866">NodeTestCases</i>和<i id="fb501a7a">EditorTestCases</i>的功能。在将所有模块编译并打包到一个发行版中后（即针对打包的代码），将执行测试，因此将在紧密模拟代码实际使用的环境中调用测试。</p>   <h4 id="testmodulesconfigurations">测试模块配置</h4>   <p id="1581b436">具有测试的解决方案/模块组被分为<i id="7ae2ed5b">测试模块配置</i> ，这是一组在同一环境中一起执行的具有测试的解决方案。所有必需的依赖项（即模块和插件）均已加载到该环境中。<br>在屏幕快照中，您可以看到名为执行的测试模块配置，其中包含解决方案<i id="c49ce50c">jetbrains.mps.execution.impl.tests</i>和模块组<i id="df02ba1b">debugger-tests</i> 。<br>      </p><figure><img alt="blxx5" title="blxx5" src="/help/img/idea/2019.2/blxx5.png" id="eff54556" width="500" height="976"></figure>   <p></p>   <p id="cc70ca59">将解决方案包含在测试模块配置中是一个先决条件。应将解决方案指定为包含测试（通过在检查器中选择“带有测试”或“带有源和测试”）。一个模块组应至少包含一个带有测试的模块。</p>   <p id="f065ef76">测试结果和统计信息格式化为xml文件（TeamCity支持）。</p>   <p id="80450b8b">测试模块运行配置构建支持指定其他想法插件的可能性，这些想法插件应在MPS ant测试执行期间加载。MPS ant测试执行所需的插件有时无法自动计算。在某些情况下，测试需要特定的可用插件，而MPS构建语言引擎无法从包含测试的模块中推断出信息。在这种情况下，可以手动指定所需的插件。</p>   <p id="29af0bea">      </p><figure><img alt="blxx4" title="blxx4" src="/help/img/idea/2019.2/blxx4.png" id="e1c7f0fd" width="500" height="288"></figure>   <p></p>   <h3 id="mps-runnerplugin">MPS-runner插件</h3>   <p id="c08e6eda">由<i id="557e501b">jetbrains.mps.build.mps.runner</i>提供的<i id="c735423a">MPS-runner</i>插件可启用新的构建脚本条目- <b id="1541e732">解决方案中的运行代码</b> 。通过将其指向保存Java代码的解决方案，构建脚本将能够在构建过程中运行它。</p>   <p id="961a34a4">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Runner.png"><img alt="亚军" title="亚军" src="/help/img/idea/2019.2/Runner.png" id="6b3e745a" width="500" height="146"></a></figure>   <p></p>   <p id="0f16d104">调用位于项目“沙盒”解决方案中的Java类的简约构建脚本可能看起来像这样：</p>   <p id="be9fddd3">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Runner1.png"><img alt="亚军1" title="亚军1" src="/help/img/idea/2019.2/Runner1.png" id="72fc499e" width="500" height="1526"></a></figure>   <p></p>   <p id="dba47094"><b id="41db34a6">解决方案</b>指令中的<b id="41db34a6">运行代码</b>允许在将运行代码的MPS实例中启用选定的插件。相应的插件及其依赖项将被启用。</p><figure><a class="lightbox" href="/help/img/idea/2019.2/RunnerWithPlugins.png"><img alt="RunnerWithPlugins" title="RunnerWithPlugins" src="/help/img/idea/2019.2/RunnerWithPlugins.png" id="62270b92" width="500" height="170"></a></figure>   <p></p>   <h3 id="controlovertherepository">控制存储库</h3>   <p id="ee7db116">MPS ant任务使用几个新标记（ <i id="2047a865">模块</i> ， <i id="d4bbf4ec">模块</i>和<i id="8c082e9e">allmpsmodules）</i>提供对存储库内容的完全控制。</p>   <p id="74ecf6f7">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migrate.png"><img alt="迁移" title="迁移" src="/help/img/idea/2019.2/Migrate.png" id="3c2c3cee" width="500" height="220"></a></figure>   <p></p>   <h2 id="how-to's">怎么做</h2>   <p id="9aa456df">以下文章介绍了如何构建语言插件：</p>   <ul class="list _ul"><li class="list__item" id="a45f8baa">         <a href="building-intellij-idea-language-plugins.html">构建IntelliJ IDEA语言插件</a>      </li><li class="list__item" id="1ba31018">         <a href="building-mps-language-plugins.html">构建MPS语言插件</a>      </li><li class="list__item" id="509d7625">         <a href="building-standalone-ides-for-your-languages.html">构建独立的IDE</a>      </li></ul>   <p id="954d76d1">有关使用MPS进行构建的文章：</p>   <ul class="list _ul"><li class="list__item" id="a58ca686">         <a href="removing-bootstrapping-dependency-problems.html">消除引导依赖性问题</a>      </li></ul><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="pattern.html">模式操作</a> <a class="navigation-links__next" href="howto-mps-and-ant.html">方法-MPS和蚂蚁</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>