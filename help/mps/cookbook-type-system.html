<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>食谱-类型系统-帮助| MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Cookbook+-+Type+System.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="cookbook-type-system.xml" data-toc="Cookbook+-+Type+System.html">食谱-类型系统</h1>   <h2 id="inferencerules">推理规则</h2>   <p id="76fb2aaa">在设计语言类型时，本菜谱应为您提供快速解答和指南。为深入的类型系统的描述请参考<a href="typesystem.html">类型系统</a>的用户指南的部分。</p>   <h3 id="equality">平等</h3>   <p id="736119ab">当节点的类型应始终为特定的具体类型时，请使用类型方程式。使用<i id="62f9489d">typeof</i>命令声明所需节点的类型应等于特定类型。</p>   <div class="code-block" data-lang="none">排除typeof_StringLiteral {适用于概念=串文字作为nodeToCheck适用始终覆盖假DO {typeof运算<string>（nodeToCheck）：==：; }}</string></div>   <p id="484ab9d5">注释引号用于引用类型。 <i id="cb5e7007"><string></string></i>等效于键入<i id="e3a7d62f">new node <stringtype>（）</stringtype></i> 。元素的类型等于其他元素的类型。例如，要表示括号保留被包装元素的类型，请使用<i id="367c0bad">ParenthesizedExpression</i>概念</p>   <p id="18b1217e">声明：</p>   <div class="code-block" data-lang="none">规则typeOf_ParenthesizedExpression {适用于概念=括号化表达，因为parExpr适用总是覆盖false do { }}</div>   <h3 id="inequality">不等式</h3>   <p id="7acb0d55">当类型应为子类型或其他类型的超类型时，请使用<i id="2e95a23c">infer typeof</i>命令。参见三元运算符作为示例：</p>   <div class="code-block" data-lang="none">规则typeOf_TernaryOperator {适用于概念= TernaryOperatorExpression适用总是脚趾覆盖假DO {推断的<boolean>typeof（toe.condition）：<=：;推断typeof（toe）：> =：typeof（toe.ifTrue）;推断typeof（toe）：> =：typeof（toe.ifFalse）; }}</boolean></div>   <p id="47b3db6e"><i id="b3ebd4f3">ForEachStatement</i>概念说明了如何解决相当<i id="b3ebd4f3">复杂</i>的场景。循环变量的类型必须等于迭代集合中元素的类型，而集合的类型必须是<i id="982d6489">elementType</i>类型的元素序列或数组的子类型。</p>   <div class="code-block" data-lang="none">规则typeof_ForEachStatement {适用于概念= ForEachStatement，因为forEachStatement适用总是会覆盖false do {节点<foreachvariable>变量= forEachStatement.variable;节点<expression>inputSequence = forEachStatement.inputSequence;如果（inputSequence.isNotNull && variable.isNotNull）{var elementType;推断<join(sequence><%( elementtype)%="">| ％（elementType）％[]）>：> =：typeof（inputSequence）; typeof（variable）：==：elementType; }}}</join(sequence><%(></expression></foreachvariable></div>   <p id="2d44d994">注意，我们使用<i id="a5d8ffb2">var elementType</i>声明一个变量，然后将其用于将集合元素的类型和循环变量的类型联系在一起。此外， <i id="a1d689d6">％（...）％</i>划定了所谓的反引号，它使您可以将本地上下文中的值提供给要处理的AST或将其取回。</p>   <h2 id="replacementrules">更换规则</h2>   <p id="f9c182e5">替换规则向类型系统指示了用一种类型替换另一种类型的可能性。例如， <i id="4178d299">NullType</i>是所有类型的子类型（原始类型除外），因此类型系统可以简单地删除<i id="b590e871">NullType</i>和<i id="e9618afa">BaseConcept</i>之间的不等式。</p>   <div class="code-block" data-lang="none">替换规则any_type_supertypeof_nulltype适用于concept = NullType as nullType <：concept = BaseConcept as baseConcept自定义条件：（）-> boolean {！（baseConcept.isInstanceOf（RuntimeTypeVariable））; }规则{如果（baseConcept.isInstanceOf（PrimitiveType）|| baseConcept.isInstanceOf（PrimitiveTypeDescriptor））} {错误“空类型不是原始类型的子类型”-> equationInfo.getNodeWithError（）; }}</div>   <p id="1e21086a">替换规则也很容易声明协方差和逆方差。例如，序列的协方差在MPS中声明如下：</p>   <div class="code-block" data-lang="none">替换规则sequence_subtypeOf_sequence适用于concept =左侧的SequenceType <：concept =右侧的SequenceType自定义条件：真实规则{if（right.elementType.isNotNull）{推断left.elementType：<=：right.elementType; }}</div>   <p id="8379d8b9">原先声称左集合是右集合的子类型的规则被替换为确保左集合中的元素类型是右集合的元素类型的子类型的规则。</p>   <h2 id="subtypingrules">子类型化规则</h2>   <p id="d54622b4">子类型化规则允许您指定特定类型在类型层次结构中的位置。规则返回类型的集合，它将其标识为其直接超类型。例如，以下规则声明<i id="51525c6c">Long</i>变量可以强制转换为<i id="be179aff">Float</i> 。</p>   <div class="code-block" data-lang="none">子类型规则long_extends_float {弱=假适用于概念= LongType，因为longType规则{返回<float>; }}</float></div>   <p id="d4ace056">MPS在这里声明<i id="2ca46db5">LinkedList</i>是<i id="d3936904">List</i> ， <i id="c0c84209">Deque</i>或<i id="7fa19eeb">Stack</i>的子类型：</p>   <div class="code-block" data-lang="none">子类型化规则supertypesOf_linkedlist {弱=假适用于概念= LinkedListType as llt规则{nlist <> res = new nlist <>; res.add（ <list><%( llt.elementtype)%="">>）; res.add（ <deque><%( llt.elementtype)%="">>）; res.add（ <stack><%( llt.elementtype)%="">>）;返回资源； }}</stack><%(></deque><%(></list><%(></div>   <h2 id="comparisonrules">比较规则</h2>   <p id="8c9062c9">当两种类型应该可互换时，请使用比较规则进行定义。例如，以下规则使<i id="871f08e1">NullType</i>可与任何类型（原始类型除外）进行比较：</p>   <div class="code-block" data-lang="none">比较规则any_type_comparable_with_nulltype适用于concept = BaseConcept作为baseConcept，concept = NullType作为nullType规则{if（baseConcept.isInstanceOf（PrimitiveType）|| baseConcept.isInstanceOf（PrimitiveTypeDescriptor））{返回false; }返回true;弱=假</div>   <p id="cbb790a7">同样，来自<i id="c1f488bb">BaseLanguage</i>的<i id="f239eb87">MapType</i>和来自Java的<i id="0d9d3b68">Map</i>接口（此处通过模式中的<i id="90b92aaa">ClassifierType</i>概念<i id="c1f488bb">引用</i> ）应该具有可比性：</p>   <div class="code-block" data-lang="none">比较规则map_type_comparableWith_Map适用于concept = MapType作为mapType，> Map <# KEY, # VALUE> <as classifierMapType规则{return true;弱=真</div>   <h2 id="substitutetyperules">替代类型规则</h2>   <p id="3509a91b">这些指示类型系统用定义的替换项替换表示类型的节点。</p>   <p id="6a778fb1">例如，一个人可能决定对不同的程序配置使用不同的类型，例如使用<code class="code">int</code>要么<code class="code">long</code>取决于任务是否需要使用一种类型或另一种类型。这与简单地使用生成器来产生正确的“实现”类型不同，因为替换是在执行类型检查时完成的，因此可以尽早发现可能的错误。</p>   <p id="03086d15">以最简单的形式，类型替换可以通过创建一个实例来使用<code class="code">Substitute Type Rule</code>在类型系统模型中。</p>   <div class="code-block"><code class="code-block__wrapper">substitute type rule substituteType_MyType { applicable for concept = MyType as mt substitute {   if (mt.isConditionSatisfied()) { return new node<IntegerType>; } null; } } </code></div>   <p id="d60fa447">的<code class="code">Substitute Type Rule</code>适用于表示类型的节点。只要类型检查器引入了新类型，它就会搜索适用的替换规则并执行它们。该规则必须返回`node <>`的实例作为替换值，或者返回null值，在这种情况下，原始节点用于表示类型（默认行为）。</p>   <p id="545af228">覆盖类型检查器使用的类型的另一种可能性是使用节点属性。如果原始类型节点包含一个节点属性，则类型检查器将尝试首先查找适用于该属性的替代类型规则。这样一来，即使对于语言，也可以覆盖类型节点，这种实现是密封的。</p>   <div class="code-block"><code class="code-block__wrapper">substitute type rule substituteType_SubstituteAnnotation { applicable for concept = SubstituteAnnotation as substituteAnnotation substitute { if (substituteAnnotation.condition.isSatisfied(attributedNode)) { return substituteAnnotation.substitute; } null;  } }</code></div>   <p id="d9e65028">上面的规则是为属性节点定义的，它是作为显式参数传递给规则的属性节点。该规则可以检查替换类型节点的条件是否满足，还可以通过以下方式访问代表原始类型的属性节点<code class="code">attributedNode</code>表达。</p>   <h2 id="checkingandquick-fixes">检查和快速修复</h2>   <p id="8e664c61">检查规则成为MPS代码分析过程的一部分，并将在编辑器中以交互方式向用户报告找到的问题。例如，这是对多余类型转换的检查：</p>   <div class="code-block" data-lang="none">检查规则CheckExcessTypeCasts {适用于概念= CastExpression，因为expr会覆盖任何内容{if（isStrongSubtype（expr.expression.type：<< expr.type））{信息“ Typecast表达式是多余的”-> expr； }}}</div>   <p id="5c054b1d">现在，您可以定义一个快速修复程序，在报告上述问题时，该修复程序将弹出给用户。然后，用户可以快速调用快速修复程序来更正所报告的问题。</p>   <div class="code-block" data-lang="none">快速修复RemoveExcessTypeCast参数：node <castexpression>castExpr字段：<< ... >> description（node）-> string {“ Remove Excess Typecast”; } execute（node）-> void {castExpr.replace with（castExpr.expression）; }</castexpression></div>   <p id="89a3b91d">将快速修复程序链接到所报告的错误，您需要将快速修复程序指定为<b id="ba7400a6">与信息消息链接的意图（可选）</b> ：</p>   <p id="41d3ce11">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/checkingRules153.png"><img alt="检查规则153" title="检查规则153" src="/help/img/idea/2019.2/checkingRules153.png" id="f55ca254" width="500" height="900"></a></figure>   <p></p>   <p id="e7cd0ab6">此外，您可以将参数传递给快速修复，并<b id="bcb25d31">立即</b>将其标记为<b id="04ea5402">apply</b> ，在这种情况下，一旦在编辑器中发现错误，快速修复将自动应用。</p>   <h2 id="when-concrete,overloadedoperations">当混凝土，超载操作</h2>   <p id="b2b45e8c">当混凝土块计算出节点的类型后，可以使用它来进行类型检查。在下面的示例中，我们正在检查操作的计算类型是否匹配基于操作员覆盖规则的<i id="5ebff9d2">操作类型</i>命令建议的<i id="5ebff9d2">类型</i> ：</p>   <div class="code-block" data-lang="none">规则typeof_BinaryOperation {适用于概念= BinaryOperation，因为操作会覆盖false do {当具体（typeof（operation.leftExpression）为rightType时）{当具体（typeof（operation.rightExpression）为rightType时）{node <> opType =操作类型（operation， leftType，rightType）;如果（opType.isNotNull）{typeof（operation）：==：opType; } else {错误“操作不适用于这些操作数”->操作； }}}}}</div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="howto-adding-additional-tools-aka-views.html">HowTo-添加其他工具（又名Views）</a> <a class="navigation-links__next" href="building-an-interpreter-cookbook.html">构建解释器食谱</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>