<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>HowTo-与数据流引擎集成-帮助|帮助MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="HowTo+--+Integration+with+the+Data+Flow+Engine.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="howto-integration-with-the-data-flow-engine.xml" data-toc="HowTo+--+Integration+with+the+Data+Flow+Engine.html">HowTo-与数据流引擎集成</h1>   <h2 id="dataflow">数据流</h2>   <p id="13bb5328">数据流分析支持检测无法轻易发现的错误<br>具有静态约束或类型检查的“查看模型”。例子包括<br>死代码检测，方法主体的某些分支中缺少返回值或<br>静态发现<code class="code">null</code>值并防止空指针异常。</p>   <p id="7c61ffc4">数据流分析的基础是所谓的数据流图。这是<br>描述程序代码中数据流的数据结构。对于<br>例如，在<code class="code">int i = 42; j = i + 1;</code> 42是从init开始“流动”的<br>将表达式中的局部变量声明为变量<code class="code">i</code>然后，<br>将j加1之后。数据流分析包括两个任务：<br>程序的数据流图，然后对该数据流进行分析<br>图形以检测程序中的问题。</p>   <p id="e056206d">MPS带有用于数据流图的预定义数据结构，用于DSL的DSL。<br>定义如何从语言概念中得出图形（因此，<br>程序），定义图表上自己的分析的框架以及<br>可以集成到您的语言中的一组默认分析。我们将看<br>本节中所有这些成分。</p>   <p id="f16e6410">要使用数据流图，可以在Java程序中选择一个方法，然后<br>然后使用方法上的上下文菜单；选择{{Language Debug-> Show Data<br>流程图}}。这将以图形方式呈现数据流图，并构成一个<br>建立自己的数据流图和分析时的良好调试工具。</p>   <h2 id="buildingadataflowgraph">建立数据流图</h2>   <h3 id="simple,lineardataflow">简单的线性数据流</h3>   <p id="72681379">在本节中，我们看一下<br>必须编写以创建类似于C和C的语言的数据流图<br>Java（实际上是针对mbeddr.com C基本语言的）。</p>   <p id="8855f9c0">在语言定义的“ <b id="75a06bef">数据流”</b>方面指定了<b id="75a06bef">数据流</b> 。<br>在这方面，您可以为您的语言添加数据流生成器（DFB）<br>概念。这些程序可为以下实例建立数据流图<br>程序中的那些概念。首先，这是DFB的<br>      <code class="code">LocalVariableDeclaration</code> 。</p>   <div class="code-block" data-lang="none">LocalVariableDeclaration {的数据流构建器{（node）-> void {if（node.init！= null）{node.init的代码写入node = node.init}否则{nop}}}</div>   <p id="f645c8ac">让我们详细检查一下。该框架通过了<code class="code">node</code>变量为<br>引用此DFB所针对概念的当前实例的一种方式<br>定义（ <code class="code">LocalVariableDecaration</code>这里）。如果<br>      <code class="code">LocalVariableDecaration</code>有一个init表达式（它是可选的！），然后<br>初始化表达式的DFB必须执行。的<code class="code">code for</code>声明<br>这样做：它“调用”作为其参数传递的节点的DFB。然后<br>我们执行一个实际的数据流定义： <code class="code">write node = node.init</code>      <br>指定在当前节点上执行写访问（还有一个<br>      <code class="code">read</code>声明;支持检测写前读取错误）。的<br>语句还表达了init表达式中的任何值现在<br>在节点本身中。</p>   <p id="6ccb58d5">如果没有<code class="code">init</code>表达式，我们仍然要标记<br>      <code class="code">LocalVariableDeclaration</code>访问的节点—程序流已经到来<br>跨此节点。后续分析报告所有具有以下内容的程序节点：<br>      DFB未将其作为<b id="5205f7fa">无效</b>代码进行访问。因此，即使节点没有其他<br>对程序数据流的影响，必须使用标记为已访问<code class="code">nop</code> 。</p>   <p id="a39ce129">为了说明一个<code class="code">read</code>声明，可以看看<br>      <code class="code">LocalVariableRef</code>读取它的变量的表达式<br>参考。其数据流定义为<code class="code">read node.var}, where {{var</code> }是<br>指向引用变量的引用名称。这里是<br>码：</p>   <div class="code-block" data-lang="none">LocalVarRef {（节点）-> void {读取node.var}}的数据流生成器</div>   <p id="b114e2ac">为<code class="code">AssignmentStatement</code> ，数据流如下：</p>   <div class="code-block" data-lang="none">AssigmentStatement {（节点）-> void {node.rvalue的代码，写入node.lvalue = node.rvalue}}的数据流生成器</div>   <p id="14f0585c">请注意，我们如何首先执行DFB <code class="code">rvalue</code>然后“流动”<br>      <code class="code">rvalue</code>进入<code class="code">lvalue</code> —任务的目的。</p>   <p id="40303674">为一个<code class="code">StatementList</code> ，我们只需将列表标记为已访问，然后执行<br>每个语句的DFB：</p>   <div class="code-block" data-lang="none">node.statements中的nop foreach语句{语句代码}</div>   <p id="9ea6dff1">最后，对于C函数（至少现在），忽略参数，DFB只是<br>称呼DFB为身体， <code class="code">StatementList</code> 。</p>   <p id="27918c06">现在，我们准备检查数据流图是否具有简单功能。<br>下面是该函数的图形。</p>   <p id="389a2676">      </p><figure><img alt="dfgexample" title="dfgexample" src="/help/img/idea/2019.2/dfgexample.jpg" id="9c2a4ebf" width="485" height="336"></figure>   <p></p>   <p id="1ead647f">数据流分析通常仅限于一种功能，方法或类似方法<br>概念。为了表示其中一个的结束，我们应该使用<code class="code">ret</code>      <br>声明。为了说明这一点，这是DFB的DFB <code class="code">ReturnStatement</code> ：</p>   <div class="code-block" data-lang="none">如果（node.expression！= null）{node.expression的代码} ret</div>   <h3 id="branching">分枝</h3>   <p id="4fb38954">如上所述，线性数据流相对<br>直截了当（无双关语）。但是，最有趣的数据流<br>分析与循环和分支有关。因此，指定正确的DFB<br>像<code class="code">if</code> ， <code class="code">switch</code>和<code class="code">for</code>很重要这也不是<br>简单\点</p>   <p id="7b9d463e">让我们逐步看一下DFB的<code class="code">IfStatement</code> 。我们开始<br>有义务<code class="code">nop</code>使该节点成为已访问节点。然后我们运行DFB<br>条件，因为在任何情况下都会对此进行评估。然后变成<br>有趣：根据条件是真还是假，我们要么运行<br>的<code class="code">thenPart} or we jump to where the {{else if</code>零件开始。这是<br>到目前为止的代码：</p>   <div class="code-block" data-lang="none">node.condition的nop代码if在elseIfBlock之后跳转// elseIfBlock是为node.thenPart定义的更高版本代码。</div>   <p id="1e6d25f9">的<code class="code">ifjump</code>语句意味着我们可以跳转到指定的标签（即<br>然后执行{{else if}}）。如果没有（我们只是“跑过去”<br>      <code class="code">ifjmp}), then we execute the {{thenPart</code> 。如果我们执行<br>      <code class="code">thenPart}, we are finished with the whole {{IfStatement</code> –不<br>      <code class="code">else if}s or {{else</code>零件是相关的，所以我们在当前<br>节点（ <code class="code">IfStatement</code> ），我们就完成了。但是，还有一个额外的<br>抓住：在<code class="code">thenPart}, there may be a {{return</code>声明。所以我们可能<br>从未真正到达<code class="code">jump after node</code>声明。这就是为什么<br>用花括号括起来：这表示花括号中的代码是可选的。如果<br>数据流不会访问它，那很好（通常是因为我们从<br>在我们有机会执行此代码之前的方法）。</p>   <p id="5f049b11">让我们继续<code class="code">else if}s. We arrive at the {{elseIfBlock</code>标签<br>如果条件为假，即以上<code class="code">ifjump</code>真的发生了。我们<br>然后遍历{{elseIf}}，并执行其DFB。之后，我们运行<br>的代码<code class="code">elsePart</code> ，如果有的话。以下代码只能是<br>了解我们是否知道，如果我们执行{{else if}}中的一个，那么我们<br><b id="56003c59">整体</b>跳下<code class="code">IfStatement</code> 。这是在DFB中为<br>的<code class="code">ElseIfPart</code> ，我们将在下面说明。这是其余的代码<br>为了<code class="code">IfStatement</code>的DFB：</p>   <div class="code-block" data-lang="none">在node.elseIfs中标记elseIfBlock foreach elseIf {elseIf的代码} if（node.elsePart！= null）{node.elsePart的代码}</div>   <p id="8e5b3b22">现在，我们可以检查DFB的<code class="code">ElseIfPart</code> 。我们首先运行DFB<br>条件。然后我们可能会跳到那之后<code class="code">else if</code> ，因为<br>条件可能为假，我们想尝试下一个<code class="code">else if</code> ， 如果有<br>一。或者，如果条件为真，则为主体运行DFB<br>的<code class="code">ElseIfPart</code> 。然后可能发生两件事：要么我们跳到之后<br>整个<code class="code">IfStatement} (after all, we have found an {{else if</code>那是<br>是），否则我们什么也不做，因为当前<code class="code">else if</code>      <br>包含一个return语句。因此，我们必须再次将花括号用于<br>整体跳到<code class="code">if</code> 。这是代码：</p>   <div class="code-block" data-lang="none">node.condition的代码if在node.body的节点代码之后跳转{在node.ancestor之后的跳转<concept =="" ifstatement="">}</concept></div>   <p id="df28bbed">结果数据流程图如下所示。</p>   <p id="a5884901">      </p><figure><img alt="ifdfg" title="ifdfg" src="/help/img/idea/2019.2/ifdfg.jpg" id="7b2e5bae" width="329" height="403"></figure>      <br>      <b id="f835adb1">循环</b>   <p></p>   <p id="a7a613f8">为了结束数据流图的构建，我们可以采用<br>看着那（这<code class="code">for</code>环。这与再次分支有关，因为<br>总而言之，循环可以重构为分支和跳转。这是DFB的<br>      <code class="code">for</code>环：</p>   <div class="code-block" data-lang="none">node.iterator标签的起始代码node.condition的起始代码if节点的node代码之后的跳转。node.incr的body代码的启动后跳转</div>   <p id="94362c14">我们首先执行DFB <code class="code">iterator</code> （这是一种<br>      <code class="code">LocalVariableDeclaration</code> ，因此上面的DFB可以正常工作）。然后我们定义一个<br>标签<code class="code">start</code>因此我们可以从更远的地方跳到这个地方。然后我们<br>执行<code class="code">condition}. Then we have an {{ifjmp</code>到整个循环之后<br>（涵盖条件为false且循环结束的情况）。在里面<br>在其他情况下（条件仍然为真），我们执行<code class="code">body</code>      <br>和<code class="code">incr} part of the {{for</code>循环然后我们跳到<br>      <code class="code">start</code>我们在上面定义的标签。</p>   <h2 id="integratingdataflowchecksintoyourlanguage">将数据流检查集成到您的语言中</h2>   <p id="b4e0a513">数据流检查从以下位置触发<code class="code">NonTypesystemRules</code> 。有一点<br>需要编写程序代码，因此我们创建一个类<br>      <code class="code">DataflowUtil</code>在类型系统方面模型中。</p>   <div class="code-block" data-lang="none">公共类DataflowUtil扩展了<none>工具<none>。 public DataflowUtil（node <> root）{//构建程序对象并将其存储prog = DataFlow.buildProgram（root）; } @CheckingMethod public void checkForUnreachableNodes（）{//获取所有不可达的指令（预定义的功能<instruction><instruction>）。 //删除那些在法律上可能无法到达的序列<instruction>allWithoutMayBeUnreachable = allUnreachableInstructions.where（{〜instruction =>！（布尔值。TRUE.equals（指令getUserObject（“ mayBeUnreachable”））））; }）; //获取与不可访问指令序列相对应的程序节点<node><>> unreachableNodes = allWithoutMayBeUnreachable。select（{〜指令=>（（（节点<>）指令.getSource（））;}）; //输出每个unreachableNodes中每个unreachableNode的每个不可达节点的错误{error“ unreachable code”-> unreachableNode; }}}</node><></instruction></instruction></instruction></none></none></div>   <p id="87f5e327">该类在构造函数中构造一个{{Program}对象。{{程式<br>是围绕数据流图的包装，并提供对图的访问<br>关于图形上的一组预定义分析。我们将利用其中之一<br>在这里<code class="code">checkForUnreachableNodes</code>方法。此方法提取所有<br>图中无法访问的节点（请参见上面的代码中的注释）和报告<br>他们的错误。为了能够使用<code class="code">error</code>声明，我们必须<br>用注释方法<code class="code">@CheckingMethod</code>注解。</p>   <p id="b371b180">要实际运行检查，我们从<code class="code">NonTypesystemRule</code>      <br>对于C函数：</p>   <div class="code-block" data-lang="none">检查规则check_DataFlow {适用于concept =函数作为fct覆盖false做{new DataflowUtil（fct.body）.checkForUnreachableNodes（）; }}</div>   <p id="502a5526">检查<code class="code">Program</code>类，您可以看到现有的其他数据集<br>流程分析：未初始化的读取（写入前读取），无法访问的指令<br>（无效代码）和未使用的分配。我们将看看如果不是那样该怎么办<br>在下一节中足够了。</p>   <h2 id="buildingyourownanalyzers">建立自己的分析仪</h2>   <p id="43123625">数据流分析是一个不平凡的话题。要进行有意义的分析，您将<br>可能需要本主题的背景知识，或阅读相关主题<br>文献。</p>   <p id="f09bef80">对于定制数据流分析的实际集成，我们将提供<br>以后再增加一篇文章。</p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="dataflow.html">数据流</a> <a class="navigation-links__next" href="generator-cookbook.html">生成器食谱</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>