<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>关闭-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Closures.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="closures.xml" data-toc="Closures.html">关闭</h1>   <h2 id="introduction">介绍</h2>   <p id="b2d0bb05">闭包是基础语言的便捷扩展。它们不仅使代码更简洁，而且可以将它们用作承载编程功能范式的工具。您可以将函数视为程序中的一等公民-将它们存储在变量中，将它们作为参数传递给方法，或者让方法和函数返回其他函数。<i id="95460629">MPS闭包支持</i>允许您以自己的语言使用闭包。实际上，MPS本身例如在<i id="e267a446">collections语言中</i>大量使用了闭包。</p>   <p id="0aeaf316">      <br>该语言宽松地遵循Java闭包的“ BGGA”建议规范。但是，您不需要Java 7即可运行带有MPS闭包的代码。实际的实现使用匿名内部类，因此从1.5开始的任何最新版本的Java都将运行生成的代码而不会出现问题。仅要求<i id="b8b85782">闭包运行时</i> jar文件位于生成的解决方案的类路径上。</p>   <h2 id="functiontype">功能类型</h2>   <p id="e1b742f4">{Type1，Type2 ... => ReturnType}</p>   <p id="557feae9">让我们从一个简单的函数类型声明示例开始。它声明一个不接受任何参数且不返回任何值的函数。</p>   <div class="code-block" data-lang="none">{=>无效}</div>   <h4 id="subtypingrules">子类型化规则</h4>   <p id="664101a8">函数类型的返回类型是协变的，而参数类型是协变的。</p>   <p id="d878875a">例如，假设我们定义了一个接受{String => Number}的方法：</p>   <div class="code-block" data-lang="none">public void accept_Number_from_String（{String => Number}函数）{...}</div>   <p id="86aa8a76">我们可以将{Object => Integer}（接受Object并返回int的函数）的实例传递给此方法：</p>   <div class="code-block" data-lang="none">this.accept_Number_from_String（{Object o => o.hashCode（）;}）;</div>   <p id="a214457e">简而言之，只要您保留超类型签名中的承诺，就可以使用不同的实际类型的参数和返回值。</p>    <h2 id="closureliteral">关闭字面量</h2>   <p id="5d0cfc87">只需输入以下结构即可创建闭包文字： <i id="9aacfdf0">{ <parameter decls="">=>}</parameter></i> 。不需要<i id="0a5bbc23">“新”</i>运算符。</p>   <p id="8f008caf">根据以下一个或多个规则计算结果类型：</p>   <ul class="list _ul"><li class="list__item" id="be3b3826"><p>最后一条语句，如果它是一个ExpressionStatement；</p></li><li class="list__item" id="769d102c"><p>返回带有表达式的语句；</p></li><li class="list__item" id="ed1e3021"><p>收益声明。</p></li></ul>   <p id="5cc16f50">注意：不可能在单个闭包文字中组合<i id="13fef58b">返回</i>和<i id="6d31667a">收益</i> 。</p>   <h2 id="closureinvocation">闭包调用</h2>   <p id="83f3b6d5"><i id="051c8362">invoke</i>操作是可以在闭包上<i id="051c8362">调用</i>的唯一方法。而不是进入</p>   <div class="code-block" data-lang="none">Closure.invoke（p1，p2）;</div>   <p id="afebcc51">要调用闭包，建议使用此操作的简化版本-括住参数列表的括号。</p>   <div class="code-block" data-lang="none">闭包（p1，p2）;</div>   <p id="c6829a87">调用闭包看起来就像是常规方法调用。</p>   <p id="a627daee">闭包文字定义的一些示例。</p>   <div class="code-block" data-lang="none">{int => int} fib = {int n => n <= 1吗？n：invoke（n-1）+ invoke（n-2）; } {int => int}事实= {int n => int res = 1; };而（n> 1）{res = res * n--; } res; {=>序列<int>}闭包= {=>产生1;};</int></div>   <h3 id="recursion">递归</h3>   <p id="957b7281">没有递归的函数式编程就像没有水的咖啡，因此显然，您有一种自然的方法，可以从其体内递归调用闭包：</p>   <div class="code-block" data-lang="none">{int => long}事实= {int n => if（n == 1）{返回1L； } else {return n * invoke（n-1）; }; println（“ Factorial of 10 =” + fact（10））;</div>   <p id="3a4bdf42">闭包主体内的独立<i id="ddf2fb6f">调用</i>将调用当前闭包。</p>   <h2 id="closureconversion">闭包转换</h2>   <p id="cd167186">      <br>出于实用目的，可以在需要单方法接口实例的地方使用闭包文字，反之亦然。</p>   <div class="code-block" data-lang="none">公共接口Worker {字符串doWork（int数量）; } ...工人工人= {int数量=>“完成” +数量+“工作”;};</div>   <p id="360d5e7b">生成的代码与使用匿名类时的代码完全相同：</p>   <div class="code-block" data-lang="none">Worker worker = new Worker（）{public String doWork（int amount）{返回“完成” +数量+“工作”； };</div>   <p id="7e4bf962">考虑一下Java需要<i id="f8121879">Runnable</i> ， <i id="e03a7370">Callable</i>或各种观察者或侦听器类的实例的所有地方：</p>   <div class="code-block" data-lang="none">println（“从主线程报告” + Thread.currentThread（））;最终Runnable runnable = {=> println（“从线程报告” + Thread.currentThread（））; };线程t =新线程（可运行）； t.start（）;</div>   <aside class="note " rel="8cd41ce8" id="351331e6" data-title="">      <p id="bb789b67">以下更改适用于即将发布的1.5版本的MPS。</p>   </aside>   <p id="b6935074">与接口一样，也可以将完全包含一个抽象方法的抽象类改编成闭包文字。例如，当可以将用作函数的现有接口更改为实现新接口的抽象类时，这可以帮助顺利过渡到新的API。</p>   <h2 id="yieldstatement">收益声明</h2>   <p id="7903a55c">yield语句允许闭包填充集合。如果在闭包文字的正文中遇到yield语句，则会产生以下结果：</p>   <ul class="list _ul"><li class="list__item" id="cb469bde"><p>如果yield语句表达式的类型为Type，则闭包文字的结果类型为sequence <type>；</type></p></li><li class="list__item" id="a438b46b"><p>主体中的所有控制语句在生成时都会在无限的do-while循环内转换为switch语句；</p></li><li class="list__item" id="d2e4def2"><p>禁止使用return语句，并且忽略最后一个ExpressionStatement的值。</p></li></ul>   <div class="code-block" data-lang="none">sequence <int>sequence =新序列<int>（{=> yield 1;}）；产量2;产量3;</int></int></div>   <h2 id="functionsthatreturnfunctions">返回函数的函数</h2>   <p id="1619974e">针对功能性心脏的一些功能性编程：</p>   <div class="code-block" data-lang="none">{int，int => int} add = {int x，int y => x + y; }; {int => int} plusThree = {int x => x + 3; }; {int => int} curriedPlusThree = this。咖喱（加，3）;断言plusThree。 invoke（1）等于curriedPlusThree。调用（1）;</div>   <p id="f8f48914">curry（）方法的定义如下：</p>   <div class="code-block" data-lang="none">公共{int => int}咖喱（final {int，int => int} fun，final int y）{返回{int x => fun。调用（x，y）; }; }</div>   <h2 id="runtime">运行</h2>   <p id="5bd1598d">为了运行由闭包语言生成的代码，必须将闭包运行时库添加到解决方案的类路径中。该jar文件包含支持函数类型和某些实用程序类的变量所需的综合接口。它位于： <span class="filepath">％MPS_HOME％/ core / baseLanguage / jetbrains.mps.baseLanguage.closures.runtime.jar</span>   </p>   <h2 id="differencesfromthebggaproposal">与BGGA提案的差异</h2>   <ul class="list _ul"><li class="list__item" id="cf640075"><p>不会弄乱控制流程。这意味着不支持打破封闭文字边界的控制流语句。</p></li><li class="list__item" id="d7e480f8"><p>没有“提前返还”的问题：由于MPS允许在人体任何地方使用返还。</p></li><li class="list__item" id="e461341f"><p><i id="b3707c6a">收益</i>声明。</p></li></ul>   <hr id="4daa8a2b">   <p id="63304eaa">      <br>[1] <a href="http://www.javac.info/" rel="noopener noreferrer" data-external="true" target="_blank">Java编程语言的闭包</a>   </p>   <p id="b4569b9e">      <br>[2] <a href="http://www.javac.info/closures-v05.html" rel="noopener noreferrer" data-external="true" target="_blank">部分支持BGGA封闭规范的版本0.5</a>   </p>   <p id="f716d9c8">      <br>[3]这不再成立：作为优化措施，仅支持闭包文字到接口的转换。</p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="implementing-generators-for-baselanguage-s-extensions.html">为BaseLanguage的扩展</a> <a class="navigation-links__next" href="collections-language.html">集合语言</a> <a class="navigation-links__prev" href="implementing-generators-for-baselanguage-s-extensions.html">实现生成器</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>