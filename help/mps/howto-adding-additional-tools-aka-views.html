<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>操作方法-添加其他工具（又名“视图”）-帮助|帮助MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="HowTo+--+Adding+additional+Tools+%28aka+Views%29.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="howto-adding-additional-tools-aka-views.xml" data-toc="HowTo+--+Adding+additional+Tools+%28aka+Views%29.html">如何-添加其他工具（又名视图）</h1>   <h2 id="addingadditionaltools(akaviews)">添加其他工具（即视图）</h2>   <p id="b98e9939">本文档介绍了如何构建新<b id="6d9cd240">工具</b> （对于Eclipse<br>用户，MPS中的工具就像是Eclipse中的视图）。这可以用作<br>在MPS中构建任意其他工具的示例。本文强调<br>工具开发的方面：如何向语言和菜单添加新工具<br>系统，以及如何将视图与当前编辑的内容进行同步。</p>   <p id="c91229fb">在所有其他方面，工具都只是Swing UI程序。所以对于实施<br>复杂的视图，需要Java Swing经验。在本教程中，我们将<br>不要过多地关注使用Swing构建树状视图的复杂性-<br>令人惊讶的是不平凡的努力！</p>   <h2 id="theoutlinetoolitself">大纲工具本身</h2>   <p id="a2fca668">MPS插件语言支持新工具的定义。创建一个新的<br>的实例<code class="code">Tool</code>并设置名称。您也可以给它一个不同的<br>标题和图标。默认位置（底部，左侧，右侧，顶部）也可以是<br>定义。</p>   <p id="2ced0110">现在，我们向工具添加三个字段。第一个用来记住<br>项目，第二个将工具连接到MPS的消息总线，第三个<br>一个记得<code class="code">ToolSynchronizer. The ToolSynchronizer</code>更新<br>大纲视图，以防活动编辑器发生更改。消息总线是IDEA<br>平台的事件分发基础架构。我们用它来获得通知<br>当前活动的编辑器中的选择更改。关于这两个的更多信息。</p>   <div class="code-block" data-lang="none">私人项目项目；私有MessageBusConnection messageBusConn;专用ToolSynchronizer同步器；</div>   <p id="599dd256">然后，我们准备实现工具的三种主要方法： <code class="code">init</code> ，<br>       <code class="code">dispose and getComponent</code> 。这是代码（带注释，请<br>阅读它们！）：</p>   <div class="code-block" data-lang="none">init（project）-> void {this.project = project; } dispose（project）-> void {//与消息总线断开连接-在getComponent（）中连接，如果（this.messageBusConn！= null）this.messageBusConn.disconnect（）; } getComponent（）-> JComponent {//使用自定义单元格渲染器创建新的JTree（用于渲染自定义图标）JTree tree = new JTree（new Object [0]）; tree.setCellRenderer（new OutlineTreeRenderer（tree.getCellRenderer（）））; //创建一个新的同步器。它需要树来通知它更新。this.synchronizer =新的ToolSynchronizer（tree）; //连接到消息总线。同步器接收编辑器更改事件//，并将其推送到树上。同步器实现// FileEditorChangeListener才能使其正常运行this.messageBusConn = this.project.getMessageBus（）。connect（）; this.messageBusConn.subscribe（FileEditorManagerListener。FILE_EDITOR_MANAGER，this.synchronizer）; //我们最后返回一个带有树的ScrollPane返回new JScrollPane（tree）; }</div>   <h2 id="anactiontoopenthetool">打开工具的动作</h2>   <p id="24ce84de">操作是MPS UI中的命令。我们必须添加一个动作才能打开<br>轮廓视图。动作存在于语言的插件方面。动作可以<br>按预期定义键盘快捷键，标题和图标。他们还宣布<br>动作参数。这些定义了哪些上下文需要可用<br>执行动作。这样可以确定菜单中是否存在该操作，<br>并支持将该上下文传递到动作本身。在我们的情况下<br>上下文包括当前打开的项目以及当前打开的项目<br>文件编辑器。</p>   <div class="code-block" data-lang="none">操作上下文参数（始终可见= false）项目项目键：必需PROJECT FileEditor编辑器键：FILE_EDITOR</div>   <p id="c31af102">在里面<code class="code">execute</code>创建和打开“大纲”工具的操作方法。<br>的<code class="code">setOutline</code>方法是使用它的普通方法。<br>其产量。它只是存储传入的编辑器。</p>   <div class="code-block" data-lang="none">execute（event）-> void {工具<outline>轮廓= this.project.tool <outline>; outline.setEditor（this.editor）; outline.openTool（true）; }</outline></outline></div>   <h2 id="anactiongroup">行动小组</h2>   <p id="488a15be">菜单项通过组添加。为了能够将“打开轮廓动作”添加到<br>菜单系统，我们必须定义一个新组。组定义其内容<br>（操作，再加上两个分隔符），它确定了<br>菜单应该去。组也存在于插件方面。</p>   <div class="code-block" data-lang="none">组OutlineGroup弹出：错误的内容<---> OpenOutlineAction <--->修改添加到位置customTools的工具中</div>   <h2 id="managingthetoollifecycle">管理工具生命周期</h2>   <p id="4e5198ce">该工具必须与MPS的其余部分完美配合。它必须听一些<br>事件并做出适当反应。有两个专用于此任务的侦听器。的<br>       <code class="code">EditorActivationListener</code>跟踪潜在的许多开放式编辑器中的哪个<br>当前处于活动状态，因为大纲视图必须显示任何内容的大纲<br>用户当前正在使用编辑器。它也负责连接<br>处理选择状态和模型更改的其他侦听器（请参阅<br>下面）。的<code class="code">ModelLifecycleListener</code>跟踪模型的生命周期事件<br>由当前活动的编辑器进行编辑。该型号可以在<br>例如，通过<b id="beefd035">还原更改</b> VCS操作对其进行编辑。</p>   <h3 id="editoractivationandfocus">编辑器激活和关注</h3>   <p id="b96ac6c8">的<code class="code">EditorActivationListener</code>跟踪潜在的许多未平仓交易<br>编辑器当前处于活动状态。它被实例化并连接到MPS消息<br>由以下代码创建的工具生成总线（已如上所示）：</p>   <div class="code-block" data-lang="none">this.messageBusConn = this.project.getMessageBus（）。connect（）; this.messageBusConn.subscribe（FileEditorManagerListener。FILE_EDITOR_MANAGER，this.synchronizer）;</div>   <p id="86a001ad">在其构造函数中，它记住大纲树。然后建立一个新的轮廓<br>树选择侦听器，侦听用户所做的选择更改<br>       <b id="d2f2f93e">在树上</b> 。</p>   <div class="code-block" data-lang="none">this.outlineSelectionListener = new OutlineSelectionListener（this）; tree.addTreeSelectionListener（this.outlineSelectionListener）;</div>   <p id="59a6b349">然后，它设置一个侦听器来跟踪模型的生命周期（加载，卸载，<br>替换），并与事件收集器关联（均在下面进行说明）。</p>   <div class="code-block" data-lang="none">modelLifecycleListener = new ModelLifecycleListener（tree）; eventsCollector =新的ModelChangeListener（tree）;</div>   <p id="3e6c6fed">的<code class="code">EditorActivationListener implements FileEditorManagerListener</code> ，所以<br>它必须实现以下三种方法：</p>   <div class="code-block" data-lang="none">void fileOpened（FileEditorManager p0，VirtualFile p1）; void fileClosed（FileEditorManager p0，VirtualFile p1）; void selectionChanged（FileEditorManagerEvent p0）;</div>   <p id="8440425a">就我们而言，我们对<code class="code">selectionChanged</code>事件，因为我们将<br>必须清理并挂接其他所有听众。这里是<br>实施。</p>   <div class="code-block" data-lang="none">public void selectionChanged（FileEditorManagerEvent event）{//由于我们访问模型读取动作，因此需要执行读取动作{FileEditor oldEditor = event.getOldEditor（）; //抓取旧的编辑器，如果有一个if（oldEditor，则将其清理干净！= null）{this.cleanupOldEditor（oldEditor）; } //调用帮助程序方法来设置新的编辑器this.newEditorActivated（event.getNewEditor（））; }}</div>   <p id="7a0f6c66">的<code class="code">cleanupOldEditor</code>方法从旧版本中删除现有的侦听器<br>无效的编辑器：</p>   <div class="code-block" data-lang="none">private void cleanupOldEditor（FileEditor oldEditor）{//从IDEA级别降级到MPS详细信息，//获取NodeEditor组件IEditor oldNodeEditor =（（（MPSFileNodeEditor）oldEditor）.getNodeEditor（）;如果（oldNodeEditor！= null && this.editorSelectionListener！= null）{//从旧的编辑器oldNodeEditor.getCurrentEditorComponent（）。getSelectionManager（）中删除选择侦听器。removeSelectionListener（this.editorSelectionListener）; //获取由旧编辑器编辑的模型的描述符//并删除模型侦听器（清理！）SModelDescriptor描述符= oldNodeEditor.getEditorContext（）。getModel（）。getModelDescriptor（）; descriptor.removeModelListener（modelLifecycleListener）; //从事件收集器中删除由旧编辑器编辑的模型// //我们不再感兴趣。eventsCollector.remove（descriptor）; }}</div>   <p id="727cdcb7">下一个方法将基础结构连接到新选择的编辑器及其<br>基础模型。注意我们如何使用<code class="code">SNodePointer</code>每当我们保持<br>对节点的引用。这充当代理并处理解析节点<br>模型的情况被替换，并包含对实际节点的“弱引用”，<br>因此，如果模型被卸载，则可以进行垃圾回收。这对<br>避免内存泄漏！</p>   <div class="code-block" data-lang="none">public void newEditorActivated（FileEditor fileEditor）{如果（fileEditor！= null）{//记住当前编辑器this.currentEditor =（（（MPSFileNodeEditor）fileEditor）; //获取该新编辑器的根节点...SNode rootNode = this.currentEditor.getNodeEditor（）。getCurrentlyEditedNode（）。getNode（）; // ...将其包装在SNodePointer中...SNodePointer treeRoot =新的SNodePointer（rootNode）; //并创建一个新的大纲树模型OutlineModel model = new OutlineModel（treeRoot）; tree.setModel（model）; //创建一个新的选择侦听器，并使用新选择的编辑器将其连接// this.editorSelectionListener = new EditorSelectionListener（tree，outlineSelectionListener）; SelectionManager selectionManager = this.currentEditor.getNodeEditor（）。getCurrentEditorComponent（）。getSelectionManager（）; selectionManager.addSelectionListener（this.editorSelectionListener）; //这是检测模型（（MPSFileNodeEditor）fileEditor）.getNodeEditor（）的重新加载所必需的。getEditorContext（）。getModel（）。getModelDescriptor（）。addModelListener（modelLifecycleListener）; eventsCollector.add（this.currentEditor.getNodeEditor（）。getEditorContext（）。getModel（）。getModelDescriptor（））; } else {tree.setModel（new OutlineModel（null））; }}</div>   <h3 id="trackingthemodellifecycle">追踪模型生命周期</h3>   <p id="4ad4efea">的<code class="code">ModelLifecycleListener extends the SModelAdapter</code>提供的课程<br>由MPS。我们对模型的替换很感兴趣，因此<br>       <code class="code">modelReplaced</code>方法。只要当前持有的模型是<br>例如在VCS rever操作期间，用新的替换。</p>   <p id="13608843">在实现中，我们为相同的根创建一个新的新树模型。而<br>该代码看起来有点荒谬，请注意，我们使用<code class="code">SNodePointer</code>      <br>内部自动重新解析新模型中的代理节点。<br>我们还将自己作为侦听器添加到新模型的描述符中，以进行通知<br>后续模型替换事件。</p>   <div class="code-block" data-lang="none">@Override public void modelReplaced（SModelDescriptor descriptor）{tree.setModel（new OutlineModel（（（（OutlineModel）tree.getModel（））。getRealRoot（）））; descriptor.addModelListener（this）; }</div>   <h2 id="synchronizingnodeselections">同步节点选择</h2>   <h3 id="trackingeditorselection">跟踪编辑器选择</h3>   <p id="211435c6">这是将树的选择（和扩展状态）更新为<br>当前活动的编辑器中的选定节点发生更改。我们已经确定<br>（上方）大纲视图的树与当前活动的树同步<br>编辑。</p>   <p id="645bf8ee">该课程扩展了MPS' <code class="code">SingularSelectionListenerAdapter</code>因为我们是<br>只对单节点选择感兴趣。我们覆盖<br>       <code class="code">selectionChangedTo</code>方法如下：</p>   <div class="code-block" data-lang="none">protected void selectionChangedTo（EditorComponent component，SingularSelection selection）{//不执行任何操作-如果（disabled）{return } //读取动作，因为我们访问模型的读取动作{// //当前选择SNode selectedNode = selection.getSelectedNodes（）。get（0）; // ...仅当它已更改时...如果（selectedNode！= lastSelection）{lastSelection = selectedNode; //禁用树选择侦听器，以再次防止循环//永无止境更新treeSelectionListener.disable（）; //选择树tree.setSelectionPath（（（（OutlineModel）tree.getModel（））中的实际节点。gtPathTo（selectedNode））; treeSelectionListener.enable（）; }}}</div>   <h3 id="trackingchangesinthemodelstructure">跟踪模型结构的变化</h3>   <p id="e310705e">如果添加了节点，则必须更新大纲视图中的树结构，<br>在编辑器中更改（重命名），移动或删除。树木变化事件可以<br>为了避免开销，MPS将它们收集到与<br>更粗粒度的命令。通过使用MPS' <code class="code">EventsCollector</code>基类，我们<br>发生大量事件时可以得到通知，然后<br>检查事件列表中是否有我们感兴趣的访问者。</p>   <p id="9f872280">的<code class="code">ModelChangeListener</code>执行此任务。为此，我们必须实施<br>的<code class="code">eventsHappened</code>方法。我们获得事件列表，并使用内部<br>扩展的类<code class="code">SModelEventVisitorAdapter</code>参观活动并做出反应<br>给那些我们感兴趣的人。</p>   <div class="code-block" data-lang="none">protected void eventsHappened（list <smodelevent>list）{super.eventsHappened（list）;列表中的foreach evt {evt.accept（new ModelChangeVisitor（））; }}</smodelevent></div>   <p id="c7658fbd">的<code class="code">ModelChangeVisitor</code>内部类，作为通知的访客<br>树，覆盖<code class="code">visitPropertyEvent</code>找出有关其节点的节点<br>当前批次中的属性已更改。然后通知所有听众<br>树模型。</p>   <div class="code-block" data-lang="none">公共无效visitPropertyEvent（SModelPropertyEvent事件）{OutlineModel outlineModel =（（（OutlineModel）tree.getModel（））;在outlineModel.getListeners（）中的foreach l（l.treeNodesChanged（new TreeModelEvent（this，outlineModel.getPathTo（event.getNode（））））; }}</div>   <p id="239b6c4a">它还会覆盖<code class="code">visitChildEvent</code>得到孩子的通知<br>节点的添加/删除。除了API中的<code class="code">JTree</code>有一点<br>令人讨厌的是，下面的注释代码应该清楚其功能：</p>   <div class="code-block" data-lang="none">@Override public void visitChildEvent（SModelChildEvent event）{//获取模型OutlineModel outlineModel =（（（OutlineModel）tree.getModel（））; //我们稍后将需要以下数组用于JTree API。Object [] child = new Object [] {event.getChild（）}; int [] childIndex = new int [] {event.getChildIndex（）}; //我们创建到父级的树路径，通知所有侦听器//添加或删除子级TreePath path = outlineModel.getPathTo（event.getParent（））; if（path == null）{返回； } //向树模型的侦听器通知outlineModel.getListeners（）中的每个l发生了什么{if（event.i⚓（） } else if（event.isRemoved（））{l.treeNodesRemoved（new TreeModelEvent（this，path，childIndex，child））; }}}</div>   <h3 id="thewayback:trackingtreeselection">归途：跟踪树选择</h3>   <p id="2ba82d28">追踪<code class="code">JTree</code>选择是通过实现Swing的<br>       <code class="code">TreeSelectionListener and overwriting it's valueChanged</code>方法<br>以下方式：</p>   <div class="code-block" data-lang="none">public void valueChanged（TreeSelectionEvent event）{//如果禁用则不执行任何操作---防止循环更新！如果（！（disableEditorUpdate））{JTree树=（（JTree）event.getSource（））;如果（editorActivationListener.currentEditor！= null && tree.getLastSelectedPathComponent（）instanceof SNodePointer）{//获取选定的树节点SNodePointer指针=（（SNodePointer）树。getLastSelectedPathComponent（））; //禁用编辑器选择侦听器，以防止//循环不断地更新// //在编辑器editorActivationListener.currentEditor.getNodeEditor（）中更新选择。getCurrentEditorComponent（）。selectNode（pointer.getNode（））; editorActivationListener.editorSelectionListener.enable（）; }}}</div>   <h2 id="swing'sartifacts:treemodelandrenderer">Swing的工件：树模型和渲染器</h2>   <p id="aa1ec3e9">在本节中，我想描述几个有趣的MPS特定方面<br>Swing工件的实现。</p>   <h3 id="treecellrenderer">树单元渲染器</h3>   <p id="4469c4b0">树单元渲染器负责渲染树中的单元。它<br>使用<code class="code">getPresentation method on the nodes, and the IconManager</code>至<br>获取相应节点的图标（缓存的版本）。</p>   <div class="code-block" data-lang="none">公共组件getTreeCellRendererComponent（JTree树，对象对象，选择的布尔值，布尔值展开，布尔值叶，整数行，布尔值hasFocus）{if（SNodePointer的对象instance）{字符串表示； DefaultTreeCellRenderer组件；读取动作{SNode节点=（（（SNodePointer）对象）.getNode（）;表示= node.getPresentation（）;组件=（（（DefaultTreeCellRenderer）renderer.getTreeCellRendererComponent（树，表示，选择，扩展，叶子，行，hasFocus）））; component.setIcon（IconManager.getIconFor（node））; }}其他{返回renderer.getTreeCellRendererComponent（树，对象，选定，展开，叶子，行，hasFocus）； }}</div>   <h3 id="treemodel">树模型</h3>   <p id="894f3e53">树模型很有趣，因为我们只在树中包括那些孩子<br>其概念已用注释的节点<br>       <code class="code">ShowConceptInOutlineAttribute</code>属性。它存储在<br>       <code class="code">storeInOutline</code>角色。在树模型中，我们必须过滤<br>存在此属性的节点。这是各自的帮助方法：</p>   <div class="code-block" data-lang="none">私有列表findAllChildrenWithAttribute（SNodePointer指针）{列表结果= new ArrayList（）; SNode节点= pointer.getNode（）; if（node == null）{返回新的ArrayList（）; } foreach child in node.getChildren（）{SNode属性= AttributeOperations.getNodeAttribute（child.getConceptDeclarationNode（），“ showInOutline”）;如果（属性！= null）{result.add（child）;返回结果； }</div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="howto-integrating-into-the-mps-make-framework.html">HowTo-集成到MPS Make Framework</a> <a class="navigation-links__next" href="cookbook-type-system.html">手册-类型系统</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>