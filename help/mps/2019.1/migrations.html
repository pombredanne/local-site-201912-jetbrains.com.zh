<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><meta charset="UTF-8"><title>Migrations - Help | MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v2/app.css"></head><body data-id="Migrations.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search MPS Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.1 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="primary" value="primary_default" selected>Windows/Linux Default</option><option data-group="primary" value="primary_default_for_gnome">GNOME</option><option data-group="primary" value="primary_default_for_kde">KDE</option><option data-group="primary" value="primary_default_for_xwin">XWin</option><option data-group="primary" value="primary_emacs">Emacs</option><option data-group="primary" value="primary_visual_studio">Visual Studio</option><option data-group="primary" value="primary_netbeans">NetBeans</option><option data-group="primary" value="primary_eclipse">Eclipse</option><option data-group="secondary" value="secondary_mac_os_x_10.5_">Default (Mac OS X 10.5+)</option><option data-group="secondary" value="secondary_mac_os_x">Mac OS X</option><option data-group="secondary" value="secondary_eclipse_mac_os_x">Eclipse (Mac OS X)</option><option data-group="secondary" value="secondary_intellij_idea_classic_os_x">IntelliJ IDEA Classic (Mac OS X)</option><option data-group="secondary" value="secondary_xcode">Xcode</option><option data-group="secondary" value="secondary_visual_studio">Visual Studio</option><option data-group="secondary" value="secondary_resharper">ReSharper</option><option data-group="secondary" value="secondary_resharper_osx">ReSharper (Mac OS X)</option><option data-group="secondary" value="secondary_emacs">Emacs (Mac OS X)</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Migrations.html" id="migrations.xml">Migrations</h1>   <p id="8c3b577b">After a language has been published and users have started using it, the language authors have to be careful with further changes to the language definition. In particular, removing concepts or adding and removing properties, children and references to concepts will introduce incompatibilities between the previous and the next language version. This impacts the users of the language if they update to the next language version, since they may discover that their model no longer matches the language definitions and get appropriate errors reported from their models.</p>   <p id="7f2e7418">MPS&nbsp;<b id="2aadc797">tracks versions of languages</b> used in projects and provides automatic migrations to upgrade the usages of a language to the most recent versions. The language designers can create maintenance "migration" code to run automatically against the user code and thus change the user's code so that it complies with the changes made to the language definition. This is called&nbsp;<b id="5d3bfb0c">language migration</b>.</p>   <p id="7b988e36">The full language migration story has several aspects:</p>   <ul class="list _ul"><li class="list__item" id="d1ad8934"><p>Language designers can write scripts for migrating the user code and bundle them with the language</p></li><li class="list__item" id="3959fb5f"><p>MPS automatically tracks language versions used in the client code</p></li><li class="list__item" id="3da05d79"><p>MPS controls that the user's project is up-to-date with all language changes</p></li><li class="list__item" id="28068f63"><p>MPS runs the necessary migrations, when necessary</p></li></ul>   <p id="f87088f9">There are two types of migrations available in MPS:</p>   <ul class="list _ul"><li class="list__item" id="ccd3e73f"><p>         <b id="567823b0">Language migrations</b> - migrations that upgrade the project to comply with the next version of the&nbsp;language&nbsp;definition. Each language migration is attached to a version of the language definition.</p></li><li class="list__item" id="1d120197"><p>         <b id="ad6408a3">Project migrations</b> -&nbsp;these are not triggered by language usages, but instead they themselves define&nbsp;the conditions, under which&nbsp;they should be run. These migrations are always applied to the whole project.</p></li></ul>   <h2 id="languageversion">Language version</h2>   <p id="8047cdde">Languages store a version number in their module definition (.mpl) file. This number increases when a new migration is created in a language's "migration" aspect</p>   <p id="cbce4806">Modules that use languages contain a version number associated with each used language reference&nbsp;in the module (.msd, .mpl) file. These represent the language version used by the module. The number changes when the corresponding migration is run against this module to migrate it to a later language version.</p>   <p id="dd8613b9">The version number of a language can be viewed and modified manually in the&nbsp;<b id="ff197a80">Properties</b> dialog for a language:</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migrationx1003.png"><img alt="Migrationx1003" title="Migrationx1003" src="/help/img/idea/2019.1/Migrationx1003.png" id="4eb21b94" width="500" height="335"></a></figure>      <p id="848f40c1">Notice that there are two numbers available:</p>   <ul class="list _ul"><li class="list__item" id="3272cb24"><p>Language version - updated each time the structure of the &nbsp;language changes</p></li><li class="list__item" id="a24fff69"><p>Module version - updated each time the references to the nodes in the module were migrated.&nbsp;If you perform a migration on a module with sources, e.g. moving nodes, you need a migration, which will be run on <b id="967a1d40">references</b> or on <b id="d8f82103">depending modules</b>. <i id="8eee74d0">Module version</i>&nbsp;tracks that.</p></li></ul>   <h2 id="migrationassistant">Migration assistant</h2>   <p id="0be0c273">When MPS detects that the modules within the currently open project refer to versions of languages older than the ones present, a&nbsp;<b id="25016091">Migration assistant</b> is run. It prompts the user whether the migrations should be run in order to update the project to the most recent versions of the languages.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migration1003.png"><img alt="Migration1003" title="Migration1003" src="/help/img/idea/2019.1/Migration1003.png" id="55f6b308" width="500" height="442"></a></figure>      <p id="22b7f1fe">A detailed list of the migrations that will be run is presented to the user:</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migration1.png"><img alt="Migration1" title="Migration1" src="/help/img/idea/2019.1/Migration1.png" id="f3fa56ae" width="500" height="1168"></a></figure>      <p id="f5d3f9cf">If the user triggers the migration, the project is fully migrated. In case of problems preventing the migration, a list of problems together with the list of not migrated code is presented to the user.</p>   <h2 id="defininglanguagemigrations">Defining language migrations</h2>   <p id="e1aa7502">Migrations are defined as <b id="86ba906a">Migration Classes</b>&nbsp;in the <b id="246de736">migrations aspect</b>&nbsp;of your language definition. Migration Classes are nodes of the <i id="4a0f4c7c">MigrationScript</i>&nbsp;concept defined in the <i id="49455c95">jetbrains.mps.lang.migration</i>&nbsp;language.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migration1001.png"><img alt="Migration1001" title="Migration1001" src="/help/img/idea/2019.1/Migration1001.png" id="109deb28" width="500" height="796"></a></figure>      <h3 id="numberingoflanguagesandmigrations">Numbering of languages and migrations</h3>   <ul class="list _ul"><li class="list__item" id="e6e162f1"><p>The name of each migration script holds a number</p></li><li class="list__item" id="69241203"><p>Each migration script defines a <b id="0a38f8bc">from version</b>&nbsp;property</p></li></ul>   <p id="78ffb455">When a new migration script is created, the language version is increased by 1 and the <i id="3f2f8a2f">fromVersion</i> field in the migration is set to <b id="e29f9905">old value of the language version</b>. We can now say that the created migration script performs the migration <b id="b02eddad">from an old version to a new one</b>.</p>   <h4 id="numberingoflanguagesandmigrationstipsandtricks">Numbering of languages and migrations tips and tricks</h4>   <ul class="list _ul"><li class="list__item" id="fdfdc288"><p>No migrations can be "missed". If a language contains a migration from version X and from version Y, it should also contain a migration for each versions between&nbsp;X and Y. If a migration is not found for some version, this means that no user is able to migrate from version X. Generation of such languages will end up with an error.</p></li><li class="list__item" id="bf8f0662"><p>It's not necessary to store all migrations for a language. If some language was "published" and it's necessary to remove some of the older migrations, they could be removed. The from-versions of migrations left should form a range A..B, where A is any older version and B = &lt;current version&gt; - 1</p></li><li class="list__item" id="49c61265"><p>If a migration is created by mistake and wasn't published (meaning no user has run it on his project), it can be freely removed. After removing the migration, execute "Correct Language version" from the language's context menu - this action allows to synchronize the language's version with the last migration's version.&nbsp;<b id="41a11447">BE VERY CAREFUL</b>&nbsp;when doing this.</p></li></ul>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migration1002.png"><img alt="Migration1002" title="Migration1002" src="/help/img/idea/2019.1/Migration1002.png" id="d3d03c2c" width="300" height="1350"></a></figure>      <h3 id="structureofamigration">Structure of a migration</h3>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Migrationx1002.png"><img alt="Migrationx1002" title="Migrationx1002" src="/help/img/idea/2019.1/Migrationx1002.png" id="19592497" width="300" height="341"></a></figure>      <p id="49348f0f">There are several optional elements that migrations may provide:</p>   <ul class="list _ul"><li class="list__item" id="77b8cbc5"><p>         <b id="11270b36">execute after</b>&nbsp;- to put an ordering constraint among migration scripts</p></li><li class="list__item" id="8f4e29ab"><p>         <b id="b9e4f82a">produces annotation data</b>&nbsp;-&nbsp;specifies the&nbsp;<i id="ce7aa357">ConceptDeclaration</i>&nbsp;that will be used to hold the migration data produced by this script and possibly consumed by a later migration script.</p></li><li class="list__item" id="6b0f6e52"><p>         <b id="570615da">requires annotation data</b>&nbsp;- specifies the <i id="3bb64b05">ConceptDeclaration</i>&nbsp;that will be used to represent the migration data produced by an earlier migration script. It also gives the data a logical name to represent it within this migration script.</p></li><li class="list__item" id="8f0e24f1"><p>         <span class="text-line-through" id="51db35dc">            <b id="28eb3761">produces data (deprecated)</b>         </span> - legacy variant of transferring migration data, uses external files instead of node annotations.</p></li><li class="list__item" id="260c23fa"><p>         <span class="text-line-through" id="afc4d6a9">            <b id="154d2f29">requires data (deprecated)</b>         </span> - legacy variant of tranferring migration data.</p></li><li class="list__item" id="4202dccd"><p>         <b id="2387ce23">description</b>&nbsp;- a helpful textual description of the script</p></li><li class="list__item" id="1be678bb"><p>         <b id="e73d27c4">execute method</b>&nbsp;- each migration defines an <i id="58a719ff">execute()</i>&nbsp;method, which performs the actual model conversion for user models. The method receives the user module as a parameter and may refer to the defined elements in the&nbsp;<b id="4a79021a">required annotation data</b>&nbsp;section.</p></li></ul>         <b id="6b2f0075">Data production and consumption</b>      <p id="9fa1f03a">The ability to pass data among migration scripts is useful in <b id="74bdc661">partitioning the migration process</b>. One migration script may, for example, migrate nodes from an old concept to a new one, while a following migration script will migrate all references to the original nodes to point to the new nodes. For this to work, the first script has to store <b id="6efbaf34">ids</b> of the old and new nodes and publish the mapping as its <i id="650df97c">produced data</i>. The second migration script will consume the data as <i id="0c966f9a">required data</i>. Each time a reference to an old node has to be updated, the data will be used to find an id of the new node. Technically, producing data is simply attaching a special attribute containing data to any node that is close enough to the place to which the data is related. If there is no specific place to put annotation because it is related to the whole model, the data node will be attached as a new root in the current model.</p>   <p id="2ae0e577">Migration scripts producing nodes with data should declare the concept of such nodes and use the&nbsp;<b id="7b2936ce">         <i id="dfe06ac0">putData</i>         <i id="e18ed2f1">()</i>      </b>&nbsp;construction to insert each of such annotations into the model:</p>         <figure><img alt="producedata" title="producedata" src="/help/img/idea/2019.1/producedata.png" id="075e9d19" width="530" height="113"></figure>      <br>      <p id="b849611a">Nodes containing data can be retrieved by some other migration script running on another module depending on the module for which the data was produced:<br>   </p>         <figure><img alt="requiredata" title="requiredata" src="/help/img/idea/2019.1/requiredata.png" id="3ae0408c" width="700" height="201"></figure>      <h3 id="orderingofmigrationscripts">Ordering of migration scripts</h3>   <p id="aa1c7c68">The implicit dependencies between migration scripts expressed through the <b id="00630d9e">requires annotation data</b>&nbsp;and <b id="58da5b53">produces annotation data</b>&nbsp;sections will take care of proper ordering of migration scripts. When script is migrating some module, it can use data stored for this module and all its dependencies, so consuming script will start migrating the module only after having run all the required producers on all dependencies of the module. There is no need to express those dependencies explicitly.</p>   <p id="fdad45df">However, in cases when it is necessary to execute some script only after some other scripts has been executed against the same module (without taking care about dependencies), such ordering constraint can be expressed through the&nbsp;<b id="251b5028">execute after</b> section. If, for example, some property was moved from one concept to its superconcept, which happens to be declared in another language, the migration can be expressed with two migration scripts. The first script, applicable to the subconcept, copies the property value from the old deprecated property to the new one. The second script is applicable to the superconcept, it initiates the new property for such instances of the superconcept, which are not instances of the subconcept, with some default value. And let us suppose that the second script does some other initialization which depends on value of the moved property. So, the second script should be executed only after the first one, and that&nbsp;on every module.</p>   <h3 id="languagesfordefiningmigrations">Languages for defining migrations</h3>   <p id="c6053c14">The&nbsp;<i id="64ec85fe">jetbrains.mps.lang.migration</i>&nbsp;language defines all concepts specific to migration scripts. When defining your migrations, you can use&nbsp;<i id="0ab807a3">BaseLanguage</i>&nbsp;together with the&nbsp;<i id="518a8d06">jetbrains.mps.lang.smodel</i>&nbsp;and <i id="d90e6467"></i>      <i id="8371ea38">.query</i> languages to manipulate the models. The&nbsp;<i id="f9371fe8">ofType&lt;model&gt;</i>&nbsp;construct may be of particular use to obtain models contained in the passed-in&nbsp;<i id="db28fca0">SModule:</i>   </p>   <div class="code-block" data-lang="none">sequence&lt;SModel&gt; models = m.getModels();&amp;nbsp;
models.ofType&lt;model&gt;.selectMany({~model =&gt; model.nodes(BaseDocComment); }).forEach({~node =&gt; ... });</div>   <p id="4383c0fa">&nbsp;</p>   <p id="760f1454">A typical migration first excludes the migration aspect models from migration and then scans for nodes that need to be migrated. A new node is created and initialised with the values and children of the old node. The old node is then replaced with the new node. Setting the id of the new node to the value of the id of the old node will allow references to this node to be migrated without loosing their target:</p>   <div class="code-block" data-lang="none">void execute(SModule m) { 
  sequence&lt;model&gt; models = ((sequence&lt;model&gt;) m.getModels()).where({~it =&gt; !it.isAspectModel(migration); }); 
  models.selectMany({~m =&gt; m.nodes(OldComponent); }).forEach({~oldNode =&gt; 
    node&lt;NewComponent&gt; newNode = &lt;NEW component $( oldNode.name )$ {&gt;;
    *( oldNode.member )*
    ((SNode) newNode/).setId(((SNode) oldNode/).getNodeId());
    oldNode.replace with(newNode); 
  }); 
}</div>   <p id="62ae432e">Schematically:</p>   <ol class="list _decimal"><li class="list__item" id="fc58b385"><p>The transformation is applied to some node. As a result, we have a reference to old node (call in No), and a new node (Nn).</p></li><li class="list__item" id="6bd810c0"><p>IDs of No's descendants are preserved automatically: if a was-descendant node is a descendant of the output node after the transformation, it already has the same id.</p></li><li class="list__item" id="6bbd974d">ID of No: MPS determines whether No is a descendant of an output node.&nbsp;<ol class="list _decimal"><li class="list__item" id="d63f24a3"><p>If yes, we already have the target for references that pointed to the No (this is for "wrap" cases - the node is "wrapped" in another node as a result of the transformation)</p></li><li class="list__item" id="ab346445"><p>If no, the Nn gets the ID of No (that's for the case when we changed the concept of a node, but the old node is semantically equivalent to the new one)</p></li></ol>      </li><li class="list__item" id="a6351d1f"><p>No is replaced with Nn in the containing model.</p></li></ol>   <aside class="tip sideblock" data-title="" rel="a3abf092" id="15c58008">      <p id="c1e12f04">It's sometimes much simpler to decompose a complex migration into a sequence of transform-migrations rather then writing the data-persisting logic and pass it and produced/required data.</p>   </aside>   <h2 id="conceptreplacement">Concept replacement</h2>   <p id="841c6eac">If a language designer decides to remove a language concept and perhaps replace it with a new one, she should not remove the concept definition from the language immediately. Instead, the concept should be deprecated first and a migration script should be provided to migrate the user code away from the deprecated concept.</p>   <aside class="tip sideblock" data-title="" rel="841c6eac" id="98fe14a3">      <p id="b43fd4ac">It is generally a good strategy to move the concepts that are being deprecated into a separate <b id="6ed629d6">virtual folder</b>&nbsp;to keep them separate from the concepts that form the current way of using the language. Changing a virtual package of a concept has no impact on the using references in user models.</p>   </aside>   <p id="11572527">The deprecated concept can be completely removed (but does not need to) in the version following after the one, in which it was deprecated. The migration scripts that refer to the deprecated concept have then be removed, too.</p>   <h2 id="definingprojectmigrations">Defining project migrations</h2>   <p id="101aa46e">Project migrations are not typically used by language developers, but rather by the MPS team to describe changes in the model file format, in the module dependencies system and other project-wide things.</p>   <p id="36503d4e">Project migration are run against the whole project, so it's up to the MPS developer to think about how his migration will work when a part of a project changes. E.g. the user can update her project from the VCS, and in this case it may be not enough to know, that the project was migrated once; updated modules may still have to be migrated.<br> MPS does not guarantee the order, in which project migrations will be run, so you basically can't write mutually dependent project migrations.</p>   <p id="0c974c6b">Nevertheless, users can write their own project migrations. There's no special language for project migrations, so they are basically written as <i id="e7a8507b">Java/BaseLanguage</i> classes and are contributed through plugin.xml. So' further we'll suppose that you already have an MPS plugin and write the project migration in it.</p>   <p id="a79d09a6">Note that if a project migration is written in a solution, this solution must have the&nbsp;<b id="c3ce0f7c">IdeaPlugin</b> enabled in the&nbsp;<b id="e44c642b">Facets tab</b>&nbsp;of the&nbsp;<b id="95cc0c8e">Solution Properties dialog</b> and the plugin id set in the&nbsp;<b id="5c48fa0d">Idea Plugin tab</b>.</p>   <h3 id="addinganewprojectmigration">Adding a new project migration</h3>   <ul class="list _ul"><li class="list__item" id="984b6d6b"><p>Create a class for the migration implementing the <i id="f60e60f0">ProjectMigration</i> interface. For most cases, it's convenient to inherit from the <i id="57ebd670">BaseProjectMigration</i> class.</p></li><li class="list__item" id="58fb7ca9"><p>Create an <i id="6077760d">ApplicationComponent</i> that will contribute the new migrations. Do not forget to register it in <i id="a148868b">plugin.xml</i>      </p></li><li class="list__item" id="cfba0908"><p>Contribute all your project migrations from created <i id="4acdb960">ApplicationComponent</i> using the&nbsp;<i id="5500efac">ProjectMigrationsRegistry.addProjectMigration()</i> method</p></li></ul>   <h3 id="savingdatafromprojectmigrations.">Saving data from project migrations.</h3>   <p id="49d7a2b6">Project migrations can use the&nbsp;<i id="360feef4">MigrationProperties</i> project component&nbsp;to persist their data. The persisted data is stored in the .mps folder of the project and so it is shared between project's developers through VCS.</p>   <h2 id="multiplebranches">Multiple branches</h2>   <p id="417c4d11">Migrating projects that use multiple branches has a few additional challenges. Check out the <a href="using-migrations-with-branching.html">Using Migration with branching</a> documentation for details.</p>   <h2 id="migrationanttask">Migration Ant Task</h2>   <p id="2dace83b">There's an ant task to run all migrations in a project from an ant script. This task can be used for automatic testing of migrations and/or for checking whether a project has been migrated.&nbsp;</p>   <p id="648e1065">This task requires the MPS home path to be set by</p>   <ol class="list _decimal"><li class="list__item" id="be94fa5b"><p>defining mpshome task attribute <b id="6053ab48">or</b>      </p></li><li class="list__item" id="9dd5a329"><p>defining <i id="ba74a06a">mps_home</i> environment property&nbsp;<b id="75095064">or</b>      </p></li><li class="list__item" id="aa95d89b"><p>defining <i id="fd65fd84">mps.home</i>&nbsp;environment property - this is the preferred way</p></li></ol>   <p id="dd5acd83">Home path is the path to the folder that contains the build.txt file. E.g. under Mac OS this will end with "/Contents/"</p>   <p id="3e929dda">Repository contents may be specified using the &lt;repository&gt; tag:</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/Screen-Shot-2017-10-25-at-20-56-56.png"><img alt="Screen Shot 2017 10 25 at 20 56 56" title="Screen Shot 2017 10 25 at 20 56 56" src="/help/img/idea/2019.1/Screen-Shot-2017-10-25-at-20-56-56.png" id="f61519b7" width="600" height="174"></a></figure>      <p id="cf456026">If a plugin is needed for a project to migrate, this can be specified in the &lt;migrate&gt; ant task. The corresponding plugin will be enabled, together with its dependencies.   <figure><a class="lightbox" href="/help/img/idea/2019.1/MigratePlugins.png"><img alt="MigratePlugins" title="MigratePlugins" src="/help/img/idea/2019.1/MigratePlugins.png" id="9bd1f0dc" width="1696" height="182"></a></figure>   </p>   <h2 id="examples">Examples</h2>   <p id="90f1711d">For concrete examples on how to define migrations you can check out the <b id="0d51f8e9">migrations sample project</b>&nbsp;that comes bundled with MPS. You will see migration scripts&nbsp;to migrate two simple mutually interconnected languages. One of them uses data to pass information about migrated nodes between two migration scripts, while the other relies of node id manipulation.</p>   <h2 id="changesmadebymigrationsinlocalhistoryview">Changes made by migrations in Local History view</h2>   <p id="e2898ec2">Migrations cooperate with the&nbsp;<b id="a35d3837">Local History</b>&nbsp;functionality.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/lh1.png"><img alt="lh1" title="lh1" src="/help/img/idea/2019.1/lh1.png" id="afbb1e52" width="300" height="612"></a></figure>      <p id="cac43000">After running migrations, it's possible to review all the changes made to the project by each of the migration. Open the Local History view for the project's folder, a module or a model, select any two changes and press&nbsp;<i id="b79b8a85">Ctrl + D</i>&nbsp;to see the difference.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/lh2.png"><img alt="lh2" title="lh2" src="/help/img/idea/2019.1/lh2.png" id="4ee36274" width="300" height="618"></a></figure>      <figure><a class="lightbox" href="/help/img/idea/2019.1/lh3.png"><img alt="lh3" title="lh3" src="/help/img/idea/2019.1/lh3.png" id="cc98886b" width="500" height="746"></a></figure>      <p id="830a9775">It's also possible to revert a change or a group of changes from the Local History view as well as from the Diff dialogs.</p>   <h2 id="migrationassistantinintellijidea">Migration assistant in IntelliJ IDEA</h2>   <p id="ce327730">The&nbsp;IntelliJ IDEA plugin can also run language migrations. Just like in MPS itself, the <b id="3b5ebea8">Migration assistant</b> will update models in IDEA projects to match the currently installed versions of used languages.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/IDEA-Migration1.png"><img alt="IDEA Migration1" title="IDEA Migration1" src="/help/img/idea/2019.1/IDEA-Migration1.png" id="9154deb1" width="500" height="2100"></a></figure>      <h2 id="discoveringdeprecatedcode">Discovering deprecated code</h2>   <p id="da88834b">Deprecation is a recommended mechanism to indicate to the users of a language that an element will be removed in one of the next versions of your language. MPS provides several handy finders to help users eliminate deprecated code.&nbsp;<b id="ff80f754">Find Usages of Deprecated</b>&nbsp;can find all usages of deprecated elements. The report of the found usages groups the entries by the expected version of the code removal. This makes it easier to recognise their severity and prioritise their elimination.</p>         <figure><img alt="Migx" title="Migx" src="/help/img/idea/2019.1/Migx.png" id="b47d7c66" width="900" height="1800"></figure>      <p id="08b378ec">&nbsp;</p><div class="last-modified" data-skip-index="skip">Last modified: 5 July 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="textgen.html">TextGen</a><a class="navigation-links__next" href="using-migrations-with-branching.html">Using Migrations with branching</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>