<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><meta charset="UTF-8"><title>Regular expressions - Help | MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v2/app.css"></head><body data-id="Regular+expressions.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search MPS Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.1 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="primary" value="primary_default" selected>Windows/Linux Default</option><option data-group="primary" value="primary_default_for_gnome">GNOME</option><option data-group="primary" value="primary_default_for_kde">KDE</option><option data-group="primary" value="primary_default_for_xwin">XWin</option><option data-group="primary" value="primary_emacs">Emacs</option><option data-group="primary" value="primary_visual_studio">Visual Studio</option><option data-group="primary" value="primary_netbeans">NetBeans</option><option data-group="primary" value="primary_eclipse">Eclipse</option><option data-group="secondary" value="secondary_mac_os_x_10.5_">Default (Mac OS X 10.5+)</option><option data-group="secondary" value="secondary_mac_os_x">Mac OS X</option><option data-group="secondary" value="secondary_eclipse_mac_os_x">Eclipse (Mac OS X)</option><option data-group="secondary" value="secondary_intellij_idea_classic_os_x">IntelliJ IDEA Classic (Mac OS X)</option><option data-group="secondary" value="secondary_xcode">Xcode</option><option data-group="secondary" value="secondary_visual_studio">Visual Studio</option><option data-group="secondary" value="secondary_resharper">ReSharper</option><option data-group="secondary" value="secondary_resharper_osx">ReSharper (Mac OS X)</option><option data-group="secondary" value="secondary_emacs">Emacs (Mac OS X)</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Regular+expressions.html" id="regular-expressions.xml">Regular expressions</h1>   <h2 id="regularexpressionslanguageoverview">Regular expressions language overview</h2>   <h3 id="introduction">Introduction</h3>   <p id="ab2a29c2">Regular expressions language – the language that greatly simplifies text manipulation – is one of the most used domain specific languages today. Almost every developer has used it at least once. Some languages, like Perl and Python, have built in support for it; some, like Java, use it through libraries. Java, the language which we use to implement MPS, does not have language level support for regular expressions, so it was natural for us to implement DSL for them, so we would be able to use a DSL instead of a regular expression library. This language is a good example of an MPS language. Having read this introduction, you will be able to understand how to create and use languages in MPS.</p>   <h4 id="examples">Examples</h4>   <p id="1249d42f">We assume you have MPS already installed.<br> This document uses many examples. You can find them in a regular expression language project (/platform/regexp) under the <i id="aac30961">jetbrains.mps.regexp.examples</i> solution:<br>       <figure><img alt="worddav54fd8999f157b75ecce5d51ca9bff681" title="worddav54fd8999f157b75ecce5d51ca9bff681" src="/help/img/idea/2019.1/worddav54fd8999f157b75ecce5d51ca9bff681.png" id="60b50c83" width="298" height="107"></figure>   </p>   <h3 id="languageoverview">Language overview</h3>   <p id="d6d7520d">Let's take a look at a simple regular expression application. Suppose we want to get a user name and domain name from an email address. Here is code that prints out a user name and a domain name by analyzing an email address with a regular expression (you can find this example in the <i id="c6fbbc4c">EmailExample</i> class):<br>       <figure><img alt="worddav6357b7cf6d2db641dc49ad95d2b20ce6" title="worddav6357b7cf6d2db641dc49ad95d2b20ce6" src="/help/img/idea/2019.1/worddav6357b7cf6d2db641dc49ad95d2b20ce6.png" id="b967e780" width="580" height="115"></figure>      <br> The regular expression that is used in this match regexp statement does the following. First, it reads one or more word characters (\w+) and saves them in a "user" variable. After that, it reads the "@" character. Then we read a list of words which are separated by a period ("." character) and save it in a domain variable (\w+(.\w+)). If a match is found, the program prints out user and domain to <i id="f6a65366">System.out</i>. <br> Here is a syntax tree for this example's regular expression:<br>       <figure><img alt="worddave83ccb1d63a90d30c3ac013f61241197" title="worddave83ccb1d63a90d30c3ac013f61241197" src="/help/img/idea/2019.1/worddave83ccb1d63a90d30c3ac013f61241197.png" id="4da84e73" width="397" height="261"></figure>   </p>   <h3 id="languagestructure">Language structure</h3>   <p id="fbf729d4">When we create a language in MPS, we usually start by defining its abstract syntax. Abstract syntax in MPS is called language structure. To do this, we use a structure language. Structure language is an XML Schema counterpart from XML language, or a DDL counterpart from SQL. Let's take a look at the regular expressions language structure.</p>   <h4 id="overview">Overview</h4>   <p id="b85d6b8f">The MPS regular expressions language contains several parts:</p>   <ul class="list _ul"><li class="list__item" id="149eaa0d"><p>Regular expressions: concepts used to specify regular expressions. They include concepts for string literals, symbol classes, and "or" and "sequence" regular expressions.</p></li><li class="list__item" id="c6f443f9"><p>BaseLanguage (BaseLanguage is a Java-like language, used internally by MPS as a target language for generators) integration: this part includes concepts used to embed regular-expressions-related code into BaseLanguage. For example, it includes <i id="d0f8f685">MatchStatement</i>, <i id="3b0d8195">ReplaceStatement</i>, and <i id="03eb0bab">SplitStatement</i>.</p></li><li class="list__item" id="a644c074"><p>Regular expressions library support. When we work with regular expressions, we want to reuse them, and so we created special concepts for this task.</p></li></ul>   <h4 id="regularexpressions">Regular expressions</h4>   <p id="81991ca7">All regular expressions concepts in our language are placed into "Regexp" folder in its structure model:<br>       <figure><img alt="worddavc3eea13ac43a8310f50d2743e3c07435" title="worddavc3eea13ac43a8310f50d2743e3c07435" src="/help/img/idea/2019.1/worddavc3eea13ac43a8310f50d2743e3c07435.png" id="5df55931" width="309" height="268"></figure>      <br> Let's consider them in detail. We have a single base concept for all of them: Regexp:<br>       <figure><img alt="worddavb1c8d5e9a555626d4a7c6f326b4391ba" title="worddavb1c8d5e9a555626d4a7c6f326b4391ba" src="/help/img/idea/2019.1/worddavb1c8d5e9a555626d4a7c6f326b4391ba.png" id="9cb17637" width="484" height="360"></figure>      <br> It is derived from <i id="60e95620">BaseConcept</i> concept. All MPS concepts are derived from it. This concept also has the abstract concept property, which means that it is created to form a concepts hierarchy, not to be used in language to define regular expressions. It is similar to the 'abstract' modifier in Java classes.<br> Let's consider the concepts that are derived from it. You can see them in a hierarchy view. You can see this view by pressing <b id="13f12188">Ctrl + H</b> on the concept declaration. For the <i id="9190f1b0">Regexp</i> concept, we will see the following: <br>       <figure><img alt="worddav641bbd1e055f8a1257d7e09e8545a4b5" title="worddav641bbd1e055f8a1257d7e09e8545a4b5" src="/help/img/idea/2019.1/worddav641bbd1e055f8a1257d7e09e8545a4b5.png" id="0e10f539" width="440" height="597"></figure>      <br>       <i id="69a9c106">StringRegexp</i> represents an arbitrary string which can be matched against text (you can find all examples of regular expression that we consider in this section in the <i id="e9362dba">Regexps</i> root node):<br>       <figure><img alt="worddav60b32b2dae9e635eaec0472fce900e33" title="worddav60b32b2dae9e635eaec0472fce900e33" src="/help/img/idea/2019.1/worddav60b32b2dae9e635eaec0472fce900e33.png" id="a5120e8d" width="156" height="67"></figure>      <br> Let's take a look at its concept declaration (you can quickly navigate to a concept declaration by pressing <b id="ae9a3a14">Ctrl + Shift + S</b> when an instance of a concept is selected in an editor):<br>       <figure><img alt="worddavc394a4e587c8986c177d7a7e08981894" title="worddavc394a4e587c8986c177d7a7e08981894" src="/help/img/idea/2019.1/worddavc394a4e587c8986c177d7a7e08981894.png" id="c2ea1eeb" width="294" height="301"></figure>      <br> In its declaration, we see a property text with a string type, which is used to store text that will be shown in the editor. Also, this concept declares a concept property "alias." Concept properties differ from simple properties. Simple properties correspond to Java instance fields, and concept properties correspond to Java static fields. The value of a concept property <i id="f907db32">alias</i> will be shown in completion menu, when we press <b id="e48b9dc5">Ctrl + Space</b>:<br>       <figure><img alt="worddavf9496c8f18b0eb7b37640d05e82a8bf6" title="worddavf9496c8f18b0eb7b37640d05e82a8bf6" src="/help/img/idea/2019.1/worddavf9496c8f18b0eb7b37640d05e82a8bf6.png" id="7323976a" width="405" height="154"></figure>      <br> Binary regular expressions are created to represent regular expressions that combine two different regular expressions into one. <i id="09b50e8d">BinaryRegexp</i> concept is declared as abstract and has two concrete sub concepts: <i id="217e2039">OrRegexp</i> and <i id="11488e92">SeqRegexp</i>. Here are examples of their instances:<br>       <figure><img alt="worddav293aaafcd17556c2b1f82ba50ef99148" title="worddav293aaafcd17556c2b1f82ba50ef99148" src="/help/img/idea/2019.1/worddav293aaafcd17556c2b1f82ba50ef99148.png" id="2379d6de" width="122" height="66"></figure>       <figure><img alt="worddava8acebee034eb28ab80b57e485b5aebd" title="worddava8acebee034eb28ab80b57e485b5aebd" src="/help/img/idea/2019.1/worddava8acebee034eb28ab80b57e485b5aebd.png" id="e9d9eaab" width="152" height="68"></figure>      <br> Here is its concept declaration:<br>       <figure><img alt="worddav37de03cf815e63b6dab3fbf5daf43f86" title="worddav37de03cf815e63b6dab3fbf5daf43f86" src="/help/img/idea/2019.1/worddav37de03cf815e63b6dab3fbf5daf43f86.png" id="00d7eba1" width="488" height="327"></figure>      <br> It defines two links: one to store the left part and another to store the right part. The word 'aggregation' means that the regular expression under this link will be a part of a declared concept instance. i.e. if we look at the syntax tree, we will see a child regular expression under the parent <i id="dbf22321">BinaryRegexp</i>: <br>       <figure><img alt="worddav4ad0a0fbd213cbdb7725a1851aaf03bf" title="worddav4ad0a0fbd213cbdb7725a1851aaf03bf" src="/help/img/idea/2019.1/worddav4ad0a0fbd213cbdb7725a1851aaf03bf.png" id="e38b9f1b" width="279" height="53"></figure>      <br>       <i id="5e36b8e8">Dot</i> regexp represents a regexp which matches any character. <i id="1856fc92">LineEndRegexp</i> matches only at the end of a line. <i id="797f9b5e">LineStartRegexp</i> matches only at the start of a line. <i id="67266f47">ParensRegexp</i> are used to group other regular expressions in order to make an enclosing regular expression more readable. <br>       <figure><img alt="worddav24e21f44c149abcb3659dfd9d06e62aa" title="worddav24e21f44c149abcb3659dfd9d06e62aa" src="/help/img/idea/2019.1/worddav24e21f44c149abcb3659dfd9d06e62aa.png" id="3d5d9ba7" width="134" height="68"></figure>       <figure><img alt="worddav642ced80a263561d8c469346025b4836" title="worddav642ced80a263561d8c469346025b4836" src="/help/img/idea/2019.1/worddav642ced80a263561d8c469346025b4836.png" id="1a8e18d2" width="143" height="73"></figure>       <figure><img alt="worddav94705c1fc94ecb5145b425d14f42afcf" title="worddav94705c1fc94ecb5145b425d14f42afcf" src="/help/img/idea/2019.1/worddav94705c1fc94ecb5145b425d14f42afcf.png" id="4851bd0a" width="153" height="71"></figure>      <br> There are a lot of sets of symbols which are often used, but they are quite verbose to enter. So we have character classes that make it possible to enter [A-Z] instead of (A|B|CZ). We have two kinds of them: negative and positive. Both of them extend abstract <i id="506294d7">SymbolClassRegexp</i>: <br>       <figure><img alt="worddav802b499d6a7435f7a89accadba5698b3" title="worddav802b499d6a7435f7a89accadba5698b3" src="/help/img/idea/2019.1/worddav802b499d6a7435f7a89accadba5698b3.png" id="cebfd0cf" width="203" height="68"></figure>       <figure><img alt="worddava11126417379b10b2d63b7b458305019" title="worddava11126417379b10b2d63b7b458305019" src="/help/img/idea/2019.1/worddava11126417379b10b2d63b7b458305019.png" id="7e275c9d" width="215" height="71"></figure>      <br> Many of these character classes are used in several places, so they can be referenced in a simpler way with <i id="ed4ed6b3">PredefinedSymbolClassRegexp</i>. Instead of [A-Z] we can write "\w": <br>       <figure><img alt="worddav133f90af8072c5fb9dfe57c7158c29a9" title="worddav133f90af8072c5fb9dfe57c7158c29a9" src="/help/img/idea/2019.1/worddav133f90af8072c5fb9dfe57c7158c29a9.png" id="50adecc1" width="225" height="66"></figure>      <br> This concept is declared in the following way:<br>       <figure><img alt="worddav622ddc5598027e3c18f2fbd3f4bf8d24" title="worddav622ddc5598027e3c18f2fbd3f4bf8d24" src="/help/img/idea/2019.1/worddav622ddc5598027e3c18f2fbd3f4bf8d24.png" id="d29d4bb4" width="543" height="268"></figure>      <br> Here we have <i id="b4dfc419">symbolClass</i> link declaration, which has a reference stereotype (aggregation, which we mentioned above, is also a link stereotype). Reference stereotype means, that an instance of this concept won't contain the referenced node as a child. Instead the referenced node can be stored in any place in the model.<br> Also we have a lot of different <i id="3e2985a2">UnaryRegexps</i> which are derived from an abstract concept <i id="6584f465">UnaryRegexp</i>. They include +, * and other regexp operations: <br>       <figure><img alt="worddav302fe26fe89dcd25ad86915228449271" title="worddav302fe26fe89dcd25ad86915228449271" src="/help/img/idea/2019.1/worddav302fe26fe89dcd25ad86915228449271.png" id="9e771b48" width="141" height="64"></figure>       <figure><img alt="worddav196774bebcf4832840530e8a598b777a" title="worddav196774bebcf4832840530e8a598b777a" src="/help/img/idea/2019.1/worddav196774bebcf4832840530e8a598b777a.png" id="7cbc422d" width="141" height="70"></figure>      <br> When we work with a text it is often useful to remember some match, and reference it later. To facilitate this task we have <i id="7e088ff4">MatchParensRegexp</i> that remembers a string which it matches, and <i id="631b93fb">MatchVariableReferenceRegexp</i> that references a string matched before. The following code matches a pair of the same xml tags with a text inside it: <br>       <figure><img alt="worddav480b88108c470d3412e1c3ca338bf95d" title="worddav480b88108c470d3412e1c3ca338bf95d" src="/help/img/idea/2019.1/worddav480b88108c470d3412e1c3ca338bf95d.png" id="82b330e7" width="351" height="69"></figure>   </p>   <h4 id="baselanguageintegration">BaseLanguage integration</h4>   <p id="197738b6">Regular expressions have a little use if they can't be integrated in the BaseLanguage code. So in regular expressions language we have special concepts which make it possible to write regular-expression-related constructs in a program which is written in BaseLanguage.<br> If you want to add new constructs to BaseLanguage you usually extend either <i id="a7a9db7e">Expression</i> or <i id="6daee6e2">Statement</i> concept from BaseLanguage. <i id="108481f7">Expression</i> concept represents expressions like "1+2", "a == b". <i id="f3694f3b">Statement</i> concept represents control structures like "if() { }", "while() { }". In the regular expressions language we create both new expressions and statements.<br> Let's first take a look at the statements and than at the expressions:<br>       <i id="1511e960">MatchRegexpStatement</i> is used when you want to check whether a specified string matches a regular expression (you can find the examples for this section in <i id="7e6ac0b4">BaseLanguageIntegration</i> class in <i id="ad9e5158">jetbrains.mps.regexp.examples</i> model): <br>       <figure><img alt="worddav7ca0d21a461360dc9e35c6d2732b1467" title="worddav7ca0d21a461360dc9e35c6d2732b1467" src="/help/img/idea/2019.1/worddav7ca0d21a461360dc9e35c6d2732b1467.png" id="8fd7f3a2" width="420" height="72"></figure>      <br> We have an interesting feature here: you can reference named matches in the <i id="21fc902b">MatchRegexpStatement</i> block. These match variables work in other statements which are defined in the regular expressions language. <br>       <i id="4cc2f467">FindMatchStatement</i> checks whether a specified string contains a match for a specified regular expression. It is similar to <i id="8a6f6eca">MatchRegexpStatement</i>. <br>       <figure><img alt="worddav49147cbc3846c222907f8ab55c1ed548" title="worddav49147cbc3846c222907f8ab55c1ed548" src="/help/img/idea/2019.1/worddav49147cbc3846c222907f8ab55c1ed548.png" id="d5aef002" width="355" height="53"></figure>      <br>       <i id="990b61df">ForEachMatchStatement</i> allows you to iterate over all matches of a specified regular expression in a specified string: <br>       <figure><img alt="worddavb00b56a3a457bcfa3bd5c194d9f07a2a" title="worddavb00b56a3a457bcfa3bd5c194d9f07a2a" src="/help/img/idea/2019.1/worddavb00b56a3a457bcfa3bd5c194d9f07a2a.png" id="7848e481" width="375" height="52"></figure>      <br> When we work with a string, we often want to replace all matches of a regular expression with a specified text. In regular expressions language you can do this with the help of <i id="7f1b7453">ReplaceWithRegexpExpression</i>: <br>       <figure><img alt="worddav0324d85e995d77bce18cb1796cbb79a9" title="worddav0324d85e995d77bce18cb1796cbb79a9" src="/help/img/idea/2019.1/worddav0324d85e995d77bce18cb1796cbb79a9.png" id="a4312fc9" width="370" height="54"></figure>      <br> It is also often practical to split a string with some regular expression. For example, to extract parts of a string which are separated by one or more whitespace symbols we can write this <i id="3b44f4f1">SplitExpression</i>: <br>       <figure><img alt="worddav8693e20963fbd910cdc6f17e65500d23" title="worddav8693e20963fbd910cdc6f17e65500d23" src="/help/img/idea/2019.1/worddav8693e20963fbd910cdc6f17e65500d23.png" id="ac4aba1d" width="353" height="96"></figure>      <br> When we reference a match in a block, the <i id="c30a922f">MatchVariableReference</i> concept is used. It is also derived from the <i id="f4cfe1be">Expression</i> concept.</p>   <h4 id="librarysupport">Library support</h4>   <p id="1884f295">When we work with regular expressions, we want to use some of them in many places. To define these reusable regular expressions, we have a special concept – <i id="c2175f6f">Regexps</i>. It contains zero or more named regular expressions:<br>       <figure><img alt="worddavb1831b4d7d4be636b5f539589a7abd8c" title="worddavb1831b4d7d4be636b5f539589a7abd8c" src="/help/img/idea/2019.1/worddavb1831b4d7d4be636b5f539589a7abd8c.png" id="0455f00b" width="279" height="200"></figure>   </p>   <h4 id="accessorymodels">Accessory models</h4>   <p id="566fbf54">In many languages we have the following problem: we have a lot of very similar entities, which can be used in any model that is written with this language (like predefined symbol class regular expression). We could create a concept for every such entity. But MPS has a better solution: you can create a special model, called an accessory model, and declare all these entities in it with your language.<br> We have the <i id="e104db58">PredefinedSymbolClass</i> concept which is used to declare a symbol class. Also, we have the <i id="12742e41">PredefinedSymbolClasses</i> container concept, which contains these symbol classes. If you look into the accessory model of the regular expressions language, you will see this:<br>       <figure><img alt="worddav26add762091c9a627c43395111298b8a" title="worddav26add762091c9a627c43395111298b8a" src="/help/img/idea/2019.1/worddav26add762091c9a627c43395111298b8a.png" id="6b7f18d2" width="414" height="331"></figure>   </p>   <h3 id="editor">Editor</h3>   <p id="c004c1ae">After defining the concept structure, we usually create an editor for it. To accomplish this task, we use the editor language. It is quite straightforward to use, so let's consider its most common constructs.<br> All editor-related code is placed in an editor model. You can find it under a language node in a project tree:<br>       <figure><img alt="worddavc1136b6cec7f424fb0462579c99c0799" title="worddavc1136b6cec7f424fb0462579c99c0799" src="/help/img/idea/2019.1/worddavc1136b6cec7f424fb0462579c99c0799.png" id="090faea8" width="342" height="145"></figure>      <br> Here is an editor of <i id="197628a7">StringLiteralRegexp</i>:<br>       <figure><img alt="worddav9af071cf04fc04a21f5fda7ba65302a4" title="worddav9af071cf04fc04a21f5fda7ba65302a4" src="/help/img/idea/2019.1/worddav9af071cf04fc04a21f5fda7ba65302a4.png" id="3b1c3d49" width="307" height="139"></figure>      <br> It contains a horizontal collection, the container which you might use to group other constructs inside it, and {text}, which is used to include an editor for an instance property.<br> Here is an editor for <i id="e9d2ef4f">MatchVariableReferenceRegexp</i>:<br>       <figure><img alt="worddavde451156ae66510919af6563b7264e39" title="worddavde451156ae66510919af6563b7264e39" src="/help/img/idea/2019.1/worddavde451156ae66510919af6563b7264e39.png" id="5f3cebdf" width="360" height="137"></figure>      <br> It also consists of a horizontal collection, but this time we have a richer set of constructs inside it. "(ref" and ")" are constants, which always contain the same text. "-&gt;{name}" is used to reference the property "name" of match link's target.<br> Here is an editor for <i id="68c78bdd">Regexps</i>:<br>       <figure><img alt="worddav79e6df4b7ef387a833fa176607b56cd2" title="worddav79e6df4b7ef387a833fa176607b56cd2" src="/help/img/idea/2019.1/worddav79e6df4b7ef387a833fa176607b56cd2.png" id="1193f013" width="403" height="224"></figure>      <br> It contains a vertical collection with nested horizontal collections. Also, it contains a "(&gt;  &lt;)" construct. It is used to include editors for all the nodes in the role "regexp".</p>   <h3 id="scopes">Scopes</h3>   <p id="90f34853">After declaring references in structure, we have default substitute menus for them. These default menus include all the nodes of a reference type in the current model and all of its imported models. Sometimes it works, but sometimes we have to narrow down the scope of these menus (For example, if you have a lot of match variables named "name" in different parts of a model, it's a good idea to follow the Java scoping rules for these variables.) To handle this task, we have constraints language's scopes.<br> Scopes are placed in a constraints model under a language node:<br>       <figure><img alt="worddavaeb22e88a30788c4c39df5434c19093d" title="worddavaeb22e88a30788c4c39df5434c19093d" src="/help/img/idea/2019.1/worddavaeb22e88a30788c4c39df5434c19093d.png" id="7d819958" width="336" height="143"></figure>      <br> Let's consider a scope for <i id="9a6478b6">MatchVariableReference</i>:<br>       <figure><img alt="worddavc378d6ee860a2581a4e9dbdc23fae9d8" title="worddavc378d6ee860a2581a4e9dbdc23fae9d8" src="/help/img/idea/2019.1/worddavc378d6ee860a2581a4e9dbdc23fae9d8.png" id="a0fb1436" width="622" height="201"></figure>      <br> Scope consists of a referent set handler, a scope condition (labeled "can create"), and a scope constructor. Usually, only a scope constructor is specified. Scope constructor has to return an object that implements the <i id="c5de484c">ISearchScope</i> interface. Usually, an instance of the class <i id="d2ab17bd">SimpleSearchScope</i> is returned; it has a constructor which takes a list of nodes, i.e. we return a list of nodes which are visible in a specified place.</p>   <h3 id="actions">Actions</h3>   <p id="4c1f7644">Default editors in MPS aren't very easy to use. To improve this default behavior, different constructs from the actions language and the editor language can be used.<br> When we enter code in a text-based language, we usually do it from left to right. We might start from "2", then enter "2+", and finally we might have "2+2". It is also possible to enter code in MPS in this way with the aid of a mechanism called 'right transform.'<br> To define a right transform action, you have to create a right transform actions root in the actions model and add some right transform actions to it. Let's consider a right transform action from the regular expressions language which transforms one regular expression to the unary regular expression, that is, it transforms "a" into "a+", "a*", and so on (like constraints, editor and structure, you can find the actions model under the language node in your project tree):<br>      <figure><img alt="worddavced409801e815e076620cb81669d28df" title="worddavced409801e815e076620cb81669d28df" src="/help/img/idea/2019.1/worddavced409801e815e076620cb81669d28df.png" id="99fb8805" width="586" height="244"></figure>      <br> Each right transform has an applicable concept – the type of concept this action can be applied to. Also, it has a condition and the most important part: a right transform menu. There are different types of right transform menus. The menu on the picture above adds one menu item for each non-abstract <i id="aaf4b7c2">UnaryRegexp</i> sub concept. The handler of this menu part transforms an expression into a unary expression.</p>   <h3 id="typesystem">Type System</h3>   <p id="4af5d485">Many languages have a type system. It allows you to check a model against it, and can be used to improve editing experience and simplify the generator. For example, if we know the type of a particular expression, we are able to calculate which methods can be applied to it. MPS has a special language for type systems, called HELGINS. In languages with a very simple structure, it's possible to live without it, but when we have a complex language or want to integrate with BaseLanguage, we have to create a type system, at least for BaseLanguage integration concepts.<br> In HELGINS, types are represented as MPS nodes. So, if you have a sublanguage for types, like BaseLanguage does, you can use it for type checking.<br> Let's consider a couple of rules from the regular expressions language. <br>       <figure><img alt="worddavfbd103e572784a29f920f075b0b64b55" title="worddavfbd103e572784a29f920f075b0b64b55" src="/help/img/idea/2019.1/worddavfbd103e572784a29f920f075b0b64b55.png" id="7fff7269" width="396" height="145"></figure>      <br> In this code we define a type called <i id="a6585639">String</i> (<i id="75440630">String</i> here is an instance of <i id="63934110">ClassifierType</i> from BaseLanguage, which is used in method parameter types, local variables and other places). To do so, we use the GIVETYPE statement.<br> Let's take a look at a more complex rule: <br>       <figure><img alt="worddav1a274d8e26272ef9d52b6c7f7458bfff" title="worddav1a274d8e26272ef9d52b6c7f7458bfff" src="/help/img/idea/2019.1/worddav1a274d8e26272ef9d52b6c7f7458bfff.png" id="49ebebe1" width="396" height="176"></figure>      <br> In this rule, we require that an expression that we match against a regular expression in <i id="406ea36f">FindMatchStatement</i> be a subtype of <i id="bf3cf288">String</i> type. We do this by specifying a type equation. The sign ":&lt;=:" denotes a subtype; expression TYPEOF denotes a type of expression in parenthesis.<br> To calculate types, HELGINS uses a sophisticated algorithm which saves you a lot of time. You don't have to worry about the order in which types are calculated; all you have to do is to specify type equations in typing rules, and HELGINS will solve them for you.<br> Of course, the rules in our language are very simple, and if you want to know more about HELGINS, you have to take a look at rules in languages like BaseLanguage or the model language.</p>   <h3 id="generator">Generator</h3>   <p id="29c3b37f">Almost any language created with MPS has a generator. Generators in MPS convert the high-level language code into code in a lower level language. The key component of a generator is its mapping configuration. It tells us what to do with a language.<br> Let's consider a mapping configuration of the regular expressions language:<br>       <figure><img alt="worddavf77db0d024ca925203b56a14931eb487" title="worddavf77db0d024ca925203b56a14931eb487" src="/help/img/idea/2019.1/worddavf77db0d024ca925203b56a14931eb487.png" id="d75e76f9" width="622" height="328"></figure>      <br> It contains one mapping rule and several reduction rules. Each rule has an applicable concept; for each instance of this concept, the rule will be applied. Mapping rules create a new root node on each application. A reduction rule replaces a node to which it is applied with a new node. Each rule has an associated template used to create an output node.<br> Let's take a look at an instance of such a template:<br>       <figure><img alt="worddavc1fd76f76c7cffb01f1f0e716bd309a7" title="worddavc1fd76f76c7cffb01f1f0e716bd309a7" src="/help/img/idea/2019.1/worddavc1fd76f76c7cffb01f1f0e716bd309a7.png" id="96cfaa16" width="623" height="384"></figure>      <br> Templates contain MPS code with macros and template fragments.<br> The code outside of a template fragment is not used during generation, and is used only to create a context for code inside a template fragment. For example, if we know that our code will be placed inside a method with a parameter named node, we might create a method with such a parameter around the template fragment. During generation, MPS will recognize your intention, and this variable will be automatically resolved.<br> Macros are used to specify variable parts of code. For example, variable matcher on a picture above has a property macro on it. This property macro generates a unique name for this variable, so we will be able to use nested match blocks. MPS has different kinds of macros: different kinds of node macros, property macros, and reference macros. All of these concepts are declared in the <i id="22d85a81">jetbrains.mps.TLBase</i> language.</p>   <h3 id="furtherreading">Further reading</h3>   <p id="feb4e545">We have taken a look at the regular expressions language. It uses many MPS language development features, but of course not all of them. The best way to learn how to use MPS is to look at another language, like the base language and bootstrap languages. There are several tools in MPS which can be used to understand how MPS works.<br> One of them is <i id="c66dbd0d">find usages</i>. You can invoke it by choosing <b id="e58ff635">Find Usages</b> from the editor popup menu, or by pressing <b id="6e7a36a0">Alt + F7</b> on a node in an editor.<br>       <figure><img alt="worddav49f451933a7d937ef0e3fc0fdcb6f70f" title="worddav49f451933a7d937ef0e3fc0fdcb6f70f" src="/help/img/idea/2019.1/worddav49f451933a7d937ef0e3fc0fdcb6f70f.png" id="20235331" width="405" height="106"></figure>      <br> The second one is <i id="fd98c35f">find concept instances</i>. When you come across a concept, and you don't know how to use it, the best way to learn it is to find its instances and try to understand what those instances do.<br>       <figure><img alt="worddav8b182bc2907aa0f4261f0c1176d60061" title="worddav8b182bc2907aa0f4261f0c1176d60061" src="/help/img/idea/2019.1/worddav8b182bc2907aa0f4261f0c1176d60061.png" id="3219e335" width="405" height="121"></figure>      <br> MPS distribution also contains a documentation system in the /help folder. Some of it is out of date, some quite incomplete, but it can be used to learn MPS.</p><div class="last-modified" data-skip-index="skip">Last modified: 5 July 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="custom-persistence-cookbook.html">Custom Persistence Cookbook</a><a class="navigation-links__next" href="dataflow.html">Dataflow</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>