<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><meta charset="UTF-8"><title>SModel language Queries - Help | MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v2/app.css"></head><body data-id="SModel+language+Queries.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search MPS Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.1 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="primary" value="primary_default" selected>Windows/Linux Default</option><option data-group="primary" value="primary_default_for_gnome">GNOME</option><option data-group="primary" value="primary_default_for_kde">KDE</option><option data-group="primary" value="primary_default_for_xwin">XWin</option><option data-group="primary" value="primary_emacs">Emacs</option><option data-group="primary" value="primary_visual_studio">Visual Studio</option><option data-group="primary" value="primary_netbeans">NetBeans</option><option data-group="primary" value="primary_eclipse">Eclipse</option><option data-group="secondary" value="secondary_mac_os_x_10.5_">Default (Mac OS X 10.5+)</option><option data-group="secondary" value="secondary_mac_os_x">Mac OS X</option><option data-group="secondary" value="secondary_eclipse_mac_os_x">Eclipse (Mac OS X)</option><option data-group="secondary" value="secondary_intellij_idea_classic_os_x">IntelliJ IDEA Classic (Mac OS X)</option><option data-group="secondary" value="secondary_xcode">Xcode</option><option data-group="secondary" value="secondary_visual_studio">Visual Studio</option><option data-group="secondary" value="secondary_resharper">ReSharper</option><option data-group="secondary" value="secondary_resharper_osx">ReSharper (Mac OS X)</option><option data-group="secondary" value="secondary_emacs">Emacs (Mac OS X)</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="SModel+language+Queries.html" id="smodel-language-queries.xml">SModel language Queries</h1>      <h2 id="comparison">Comparison</h2>   <p id="6b0596d6">The&nbsp;<i id="1581fdbd">:eq:</i> and&nbsp;<i id="c2af3475">:ne:</i> operators can be used to compare nodes for equality. The operators are null-safe and will compare the whole sub-trees represented by the two&nbsp;compared nodes.</p>   <h2 id="queries">Queries</h2>   <h3 id="gettingnodesbyname">Getting nodes by name</h3>   <p id="4d7c4ad5">Use the <i id="cfa34318">node-ptr/.../</i> construct to obtain a reference to a node using its name.</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/ndptr1.png"><img alt="ndptr1" title="ndptr1" src="/help/img/idea/2019.1/ndptr1.png" id="4a9dd242" width="700" height="232"></a></figure>      <p id="394a4bd0">To check that a node is a specific one, there is the "is"&nbsp;operation available.</p>   <div class="code-block"><code class="code-block__wrapper">equals.is(Object-&gt;equals);</code></div>   <p id="d7577bd8">To get a pointer to a node, use the&nbsp;<b id="1bfb59da">pointer</b> construct:</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/ndptr2.png"><img alt="ndptr2" title="ndptr2" src="/help/img/idea/2019.1/ndptr2.png" id="1bdeacea" width="500" height="112"></a></figure>      <h3 id="gettingconceptsbyname">Getting concepts by name</h3>   <p id="436eb8dd">Use the&nbsp;<i id="73c092f3">concept/.../</i> construct to obtain a concept declaration by specifying its name:</p>   <div class="code-block" data-lang="none">concept&lt;CommandList&gt; myConcept = concept/CommandList/;
&nbsp;</div>   <p id="dec14c8a">The&nbsp;<i id="4df44320">concept switch</i> construct can be used to branch off the logic depending on the concept at hands:</p>         <figure><a class="lightbox" href="/help/img/idea/2019.1/ConceptSwitch.png"><img alt="ConceptSwitch" title="ConceptSwitch" src="/help/img/idea/2019.1/ConceptSwitch.png" id="82053843" width="700" height="340"></a></figure>         <h3 id="featuresaccess">Features access</h3>   <p id="509b6423">The SModel language can be used to access the following features:</p>   <ul class="list _ul"><li class="list__item" id="a98916ca"><p>properties</p></li><li class="list__item" id="dbe3fa30"><p>children</p></li><li class="list__item" id="fca261a3"><p>references</p></li></ul>   <p id="b8148235">To access them, the following syntax is used:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt;.featureName.</div>   <p id="c736e878">If the feature is a property, then the type of whole expression is the property's type. If the feature is a reference or a child of 0..1 or 1 cardinality, then the type of this expression is <b id="206c9404">node&lt;LinkTarget&gt;</b>, where <b id="188e16d6">LinkTarget</b> is the target concept in the reference or child declaration. If the feature is a child of 0..n cardinality, then the type of this expression is <b id="e5d99548">nlist&lt;LinkTarget&gt;</b>.</p>   <p id="724a5ce3">You can use so-called <i id="6ad389dd">implicit select</i> to access features of the child nodes. For example, the following query:</p>   <div class="code-block" data-lang="none">thisNode.children.grandChildren</div>   <p id="43743f33">will be automatically transformed by MPS to something like:</p>   <div class="code-block" data-lang="none">thisNode.children.selectMany({~it =&gt; it.grandChildren; })</div>   <p id="7c13036a">resulting in a plain collection of all non-null model elements accessible through the specified chain of link declarations.</p>      <h3 id="nullchecks">Null checks</h3>   <p id="4bf7ad57">Since nulls are treated liberally in MPS, we need a way to check for null values. The <b id="c5a56db8">isNull</b> and <b id="dba2a2b1">isNotNull</b> operations are our friends here.</p>      <h3 id="isinstanceofcheckandtypecasts">IsInstanceOf check and type casts</h3>   <p id="675a5dc9">Often, we need to check whether a node is an instance of a particular concept. We can't use Java's instanceof operator since it only understands java objects, not our MPS nodes. To perform this type of check, the following syntax should be used:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt;.isInstanceOf(Concept)</div>   <p id="bced7e83">Also, there's the <i id="99e9dd4f">isExactly</i> operation, which checks whether a node's concept is exactly the one specified by a user.</p>   <p id="848fb2a1">Once we've checked a node's type against a concept, we usually want to cast an expression to a concept instance and access some of this concept's features. To do so, the following syntax should be used:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt; : Concept</div>   <p id="e8e3fc17">      <br> Another way to cast node to particular concept instance is by using <b id="0bf9f07a">as</b> cast expression:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt; as Concept</div>   <p id="8c63e080">The difference between the regular cast (using colon) and the <b id="9db72f0c">as</b> cast is in a way it handles the situation when the result of the left-side expression cannot be safely cast to the specified Concept instance: A NullPointer exception will be thrown by the regular cast in this case, while null will be returned by the <b id="2deca32c">as</b> cast.</p>   <p id="84b87baf">Combine this with the <b id="4f799235">null-safe dot operator</b> in the&nbsp;<i id="94785fc0">smodel</i> language and you get a very convenient way to navigate around the model:</p>   <div class="code-block" data-lang="none">node.parent as BinaryOperation.leftExpression as BinaryOperation.leftExpression.isLValue()</div>   <aside class="tip sideblock" data-title="" rel="807ab54f" id="789207d9">      <p id="7921444a">Intention are available to easily migrate from one type of cast expression to the other:</p>               <figure><a class="lightbox" href="/help/img/idea/2019.1/cast1.png"><img alt="cast1" title="cast1" src="/help/img/idea/2019.1/cast1.png" id="a687bb08" width="500" height="124"></a></figure>          <figure><a class="lightbox" href="/help/img/idea/2019.1/cast2.png"><img alt="cast2" title="cast2" src="/help/img/idea/2019.1/cast2.png" id="c305abc0" width="400" height="101"></a></figure>         </aside>   <h3 id="nodecollectioncast">Node collection cast</h3>   <p id="ee1bafad">A collection of nodes can be filtered and cast by the concept of the nodes using the&nbsp;<i id="507809ce">ofConcept</i> construct:</p>   <div class="code-block" data-lang="none">node.statements.ofConcept&lt;LocalVariableDeclaration&gt;</div>   <p id="822d1fb9"><code class="code">seq.ofConcept&lt;MyConcept&gt;</code> is equivalent to <code class="code">seq.ofType&lt;node&lt;MyConcept&gt;&gt;</code></p>   <h3 id="aspectcollectioncast">Aspect collection cast</h3>   <p id="784b9540"><code class="code">seq.ofAspect&lt;structure&gt;</code> filters nodes of a particular aspect</p>   <h3 id="parent">Parent</h3>   <p id="51952897">In order to find a node's parent, the <b id="2fa69a58">parent</b> operation is available on every node.</p>   <h3 id="children">Children</h3>   <p id="70f4bf45">The <b id="c719d87b">children</b> operation can be used to access all direct child nodes of the current node. This operation has an optional parameter <b id="7614c1f6">linkQualifier</b>. With this parameter result of <b id="96b24501">children&lt;linkQualifier&gt;</b> operation is equivalent to <b id="edb44b7a">node.linkQualifier</b> operation call and so will recall only the children belonging to the <b id="07cb91bc">linkQualifier</b> group/role. E.g. <i id="0b6877fd">classDef.children&lt;annotation, member&gt;</i>   </p>      <h3 id="siblingqueries">Sibling queries</h3>   <p id="3424fb05">When you manipulate the AST, you will often want to access a node's siblings (that is, nodes with the same role and parent as the node under consideration). For this task we have the following operations:</p>   <ul class="list _ul"><li class="list__item" id="b6a56e85"><p>next-sibling/prev-sibling - returns next/previous sibling of a node. If there is no such sibling, null is returned.</p></li><li class="list__item" id="a86206fc"><p>next-siblings/prev-siblings - returns nlist of next/previous siblings of a node. These operations have an optional parameter that specifies whether to include the current node.</p></li><li class="list__item" id="0db82dd0"><p>siblings - returns nlist of all siblings of a node. These operations have an optional parameter that specifies whether to include the current node.</p></li></ul>      <h3 id="ancestors">Ancestors</h3>   <p id="d3ab16e0">During model manipulation, it's common to find all ancestors (parent, parent of a parent, parent of a parent of a parent, etc) of a specified node. For such cases we have two operations:</p>   <ul class="list _ul"><li class="list__item" id="6f8d376f"><p>ancestor - return a single ancestor of the node</p></li><li class="list__item" id="e3cba2bb"><p>ancestors - returns all ancestors of the node<br> Both of them have the following parameters to narrow down the list:</p></li><li class="list__item" id="b08c7905"><p>concept type constraint: concept=Concept, concept in [ConceptList]</p></li><li class="list__item" id="bb571e38"><p>a flag indicating whether to include the current node: +</p></li></ul>   <p id="7e7c9c5d">E.g. <i id="4960cbaf">myNode.ancestors&lt;concept = InstanceMethodDeclaration, +&gt;</i>   </p>      <h3 id="descendants">Descendants</h3>   <p id="59b354ab">It's also useful to find all descendants (direct children, children of children etc) of a specified node. We have the <b id="0e71ee54">descendants</b> operation for such purposes. It has the following parameters:</p>   <ul class="list _ul"><li class="list__item" id="183dc09d"><p>concept type constraint: concept=Concept, concept in [ConceptList]</p></li><li class="list__item" id="a43c5d88"><p>a flag indicating whether to include current node: +</p></li></ul>   <p id="145dd058">E.g.&nbsp;<i id="2f75cbe9">myNode.descendants&lt;concept = InstanceMethodDeclaration&gt;</i>   </p>   <h3 id="containingrootandmodel">Containing root and model</h3>   <p id="69c6a45f">To access top-most ancestor node of a specified node you can make use of <b id="7036c2a6">containing root</b> operation. Containing model is available as a result of the <b id="30ea4a18">model</b> operation.</p>   <p id="2985ddd5">For example,</p>   <ul class="list _ul"><li class="list__item" id="527cb77e"><p>node&lt;&gt; containingRoot = myNode.containing root</p></li><li class="list__item" id="34bb416b"><p>model owningModel = myNode.model</p></li></ul>      <h3 id="modelqueries">Model queries</h3>   <p id="ad7c89c3">The&nbsp;<i id="279bfa99">model-ptr/.../</i> expression retrieves a resolvable reference to a model. With a repository it can be resolved into the&nbsp;<i id="da63d0f7">model&lt;&gt;</i> type.</p>   <p id="b62a6e83">Often we want to find all nodes in a model which satisfy a particular condition. We have several operations that are applicable to expressions of the model&lt;&gt; type:</p>   <ul class="list _ul"><li class="list__item" id="52ec8c14"><p>roots(Concept) - returns all roots in a model, which are instances of the specified Concept</p></li><li class="list__item" id="d6c7868b"><p>nodes(Concept) - returns all nodes in a model, which are instances of the specified Concept</p></li></ul>   <p id="4c71edaa">E.g.&nbsp;<i id="38ec7177">model.roots(&lt;all&gt;)</i>&nbsp;or&nbsp;<i id="ba2ad3ba">model.nodes(IfStatement)</i>   </p>      <h3 id="searchscopequeries">Search scope queries</h3>   <p id="45d1de70">In some situations, we want to find out, which references can be set on a specified node. For such cases we have the search scope operation. It can be invoked with the following syntax:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt;.search scope(link, operationContext)</div>      <h3 id="theconceptliteral">The Concept literal</h3>   <p id="4da27396">Often we want to have a reference to a specified concept. For this task we have the <b id="540a8c38">concept</b> literal. It has the following syntax:</p>   <div class="code-block" data-lang="none">concept/ConceptName/</div>   <p id="43c33843">E.g. <i id="15eae336">concept&lt;IfStatement&gt; concept = concept/IfStatement/</i>   </p>      <h3 id="conceptoperation">Concept operation</h3>   <p id="3004052a">If you want to find the concept of a specified node, you can call the <i id="fc344c6a">concept</i> operation on the node.</p>   <p id="c7b77217">E.g.&nbsp;<i id="4d995973">concept&lt;IfStatement&gt; concept = myNode.concept</i>   </p>      <h3 id="migratingawayfromdeprecatedtypes">Migrating away from deprecated types</h3>   <p id="59dbc1e7">The <i id="470332a2">conceptNode&lt;&gt;</i>&nbsp;type as well as the <i id="dea291dd">conceptNode</i>&nbsp;operation have been deprecated. The <i id="0de201aa">asConcept</i>&nbsp;operation will convert a <i id="7ded6fac">conceptNode&lt;&gt;</i>&nbsp;to a <i id="248a9ded">concept&lt;&gt;</i>. The <i id="621e7377">asNode</i>&nbsp;operation, on the other hand, will do the opposite conversion and will return a <i id="06ae5d36">node&lt;AbstractConceptDeclaration&gt;</i> for a <i id="4fa35072">concept&lt;&gt;</i>.</p>   <aside class="tip sideblock" data-title="" rel="59dbc1e7" id="b784becc">      <p id="0971b7a0">The <i id="57a3fe58">conceptNode&lt;&gt;</i>&nbsp;type was called <i id="13c6c80b">concept&lt;&gt;</i>&nbsp;in MPS 3.1. The <i id="267dc391">conceptNode</i>&nbsp;operation was called <i id="7fbfface">concept</i>&nbsp;in MPS 3.1.</p>   </aside>   <h3 id="concepthierarchyqueries">Concept hierarchy queries</h3>   <p id="6367e599">We can query super/sub-concepts of expression with the concept type. The following operations are at your disposal:</p>   <ul class="list _ul"><li class="list__item" id="bd9a98e7"><p>         <b id="c93df202">super-concepts/all</b>&nbsp;- returns all super-concepts of the specified concept. There is an option to include/exclude the current concept - <i id="ed7212fb">super-concepts/all&lt;+&gt;</i>      </p></li><li class="list__item" id="d3a3e49a"><p>         <i id="f72a9b04">super-concepts/direct</i>&nbsp;- returns all direct super-concepts of the specified concept. Again, there is an option to include/exclude the current concept -&nbsp;<i id="a0109a46">super-concepts/direct&lt;+&gt;</i>      </p></li><li class="list__item" id="73ef965a"><p>         <b id="d20875f7">sub-concepts</b> - returns sub-concepts</p></li></ul>   <p id="cc94f267">For example:</p>   <p id="557fec9c">concept&lt;IfStatement&gt; concept = myNode.concept;&nbsp;<br> list&lt;concept&lt;&gt;&gt; superConceptsAll = concept.super-concepts/all;&nbsp;<br> concept.super-concepts/direct&lt;+&gt;;&nbsp;<br> concept.sub-concepts(model);<br>       <i id="53694b19">concept&lt;IfStatement&gt; concept = myNode.concept;&nbsp;</i>      <br>       <i id="e6ced8ac">list&lt;concept&lt;&gt;&gt; superConceptsAll = concept.super-concepts/all;&nbsp;</i>      <br>       <i id="f242ce66">concept.super-concepts/direct&lt;+&gt;;&nbsp;</i>      <br>       <i id="8716f878">concept.sub-concepts(model, myScope);</i>   </p>      <h3 id="thehasroleoperation">The hasRole operation</h3>   <p id="2ab1529c">Sometimes we may want to check whether a node has a particular role. For this we have the following syntax:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt;.hasRole(Concept : child)</div>   <p id="9cebb560">For example,</p>   <p id="080b70a1">      <i id="d78e3c9d">myNode.hasRole(IfStatement: elsifClauses)</i>&nbsp;</p>   <h3 id="linkqueries">Link queries</h3>   <p id="82e42083">The&nbsp;<i id="fa7adb6c">link</i>,&nbsp;<i id="e0d785ef">linkName</i> and&nbsp;<i id="b5b868fa">linkNode</i> operations &nbsp;give you access to the details of a link between nodes.</p>   <p id="7dbf5e68">&nbsp;</p>   <div class="code-block" data-lang="none">node&lt;LinkDeclaration&gt; decl = linkNode/ClassCreator : constructorDeclaration/; 
decl.sourceCardinality; 
decl.metaClass; 
decl.role; 
decl.target; 
decl.unordered;&nbsp;
...
 
string name = linkName/ClassCreator : constructorDeclaration/; 
 
SReferenceLink link = link/ClassCreator : constructorDeclaration/; 
link.isOptional(); 
link.getDeclarationNode(); 
link.getOwner(); 
link.getName(); 
link.getTargetConcept(); 
link.getScope(decl/);
...</div>   <h3 id="containinglinkqueries">Containing link queries</h3>   <p id="96b3bb4f">If one node was added to another one (parent) using the following expression:</p>   <div class="code-block" data-lang="none">parent.childLinkRole.add(node)</div>   <p id="c73e3509">then you can call the following operations to access the containment relationship information:</p>   <ul class="list _ul"><li class="list__item" id="09f0fce8"><p>         <b id="9e6e6e26">containingRole</b> - returns a string representing the child role of the parent node containing this node ("childLinkRole" in above case)</p></li><li class="list__item" id="c4f7d996"><p>         <b id="3fa32dde">containingLink</b> - returns node&lt;LinkDeclaration&gt; representing a link declaration of the parent node containing this node</p></li><li class="list__item" id="b68dd5ec"><p>         <b id="e93415da">index</b> - returns int value representing index of this node in a list of children with corresponding role. Identical to the following query upon the model represented above:</p></li></ul>   <div class="code-block" data-lang="none">parent.childLinkRole.indexOf(node)</div>      <h3 id="downcast">downcast</h3>   <h3 id="downcasttolowersemanticlevel">Downcast to lower semantic level</h3>   <p id="5d29ffbf">SModel language generates code that works with raw MPS classes. These classes are quite low-level for the usual work, but in some exceptional cases we may still need to access them. To access the low-level objects, you should use the <i id="f5674bb0">downcast to lower semantic level</i> construct. It has the following syntax:</p>   <div class="code-block" data-lang="none">&lt;node expression&gt;/</div>   <p id="7d970a02">For example,</p>         <i id="75a9d0b0">myNode/.getConcept().findProperty("name")</i>            <i id="6e355c32"></i>   <div class="last-modified" data-skip-index="skip">Last modified: 5 July 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="smodel-language-types.html">SModel language Types</a><a class="navigation-links__next" href="smodel-language-queries-references.html">SModel language Queries References</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>