<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>SModel语言查询-帮助|帮助MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="SModel+language+Queries.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="smodel-language-queries.xml" data-toc="SModel+language+Queries.html">SModel语言查询</h1>      <h2 id="comparison">比较方式</h2>   <p id="da3ed3a2"><i id="0d972a93">：eq：</i>和<i id="9d4d78c7">：ne：</i>运算符可用于比较节点是否相等。运算符是空安全的，将比较两个比较节点表示的整个子树。</p>   <h2 id="queries">查询</h2>   <h3 id="gettingnodesbyname">按名称获取节点</h3>   <p id="0888ea7b">使用<i id="315d47c2">node-ptr /.../</i>构造使用节点名称获取对节点的引用。</p>   <p id="bf526972">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/ndptr1.png"><img alt="ndptr1" title="ndptr1" src="/help/img/idea/2019.2/ndptr1.png" id="2133d0b6" width="700" height="232"></a></figure>   <p></p>   <p id="9f90e3ff">要检查某个节点是否为特定节点，可以使用“ is”操作。</p>   <div class="code-block"><code class="code-block__wrapper">equals.is(Object->equals);</code></div>   <p id="b8d93f3f">要获得指向节点的<b id="339adf48">指针</b> ，请使用<b id="339adf48">指针</b>构造：</p>   <p id="18422d61">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/ndptr2.png"><img alt="ndptr2" title="ndptr2" src="/help/img/idea/2019.2/ndptr2.png" id="0ea22c11" width="500" height="112"></a></figure>   <p></p>   <h3 id="gettingconceptsbyname">通过名称获取概念</h3>   <p id="423f1700">使用<i id="f223a885">concept /.../</i>构造通过指定名称来获得概念声明：</p>   <div class="code-block" data-lang="none">概念<commandlist>myConcept = concept / CommandList /;</commandlist></div>   <p id="d6bc52ca">根据当前的<i id="6381156b">概念，</i>可以使用<i id="6381156b">概念开关</i>构造来分支逻辑：</p>   <p id="e00d3636">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/ConceptSwitch.png"><img alt="ConceptSwitch" title="ConceptSwitch" src="/help/img/idea/2019.2/ConceptSwitch.png" id="0ff53c8e" width="700" height="340"></a></figure>   <p></p>      <h3 id="featuresaccess">功能访问</h3>   <p id="0d39ac65">SModel语言可用于访问以下功能：</p>   <ul class="list _ul"><li class="list__item" id="54a3da3d"><p>属性</p></li><li class="list__item" id="5f01f86d"><p>孩子们</p></li><li class="list__item" id="9f47aed6"><p>参考资料</p></li></ul>   <p id="2b8b2a02">要访问它们，请使用以下语法：</p>   <div class="code-block" data-lang="none"><node expression="">.featureName。
</node></div>   <p id="c2c5bc1e">如果要素是属性，则整个表达式的类型就是属性的类型。如果特征是参考或0..1或1基数的子代，则此表达式的类型为<b id="2676f29c">node <linktarget></linktarget></b> ，其中<b id="0c1fd4c2">LinkTarget</b>是引用或子声明中的目标概念。如果特征是0..n基数的子代，则此表达式的类型为<b id="51ab6b11">nlist <linktarget></linktarget></b> 。</p>   <p id="22994378">您可以使用所谓的<i id="81777c20">隐式选择</i>来访问子节点的功能。例如，以下查询：</p>   <div class="code-block" data-lang="none">thisNode.children.grandChildren</div>   <p id="20262a6b">MPS会自动将其转换为以下内容：</p>   <div class="code-block" data-lang="none">thisNode.children.selectMany（{〜it => it.grandChildren;}）</div>   <p id="e739957b">导致通过指定的链接声明链可访问的所有非空模型元素的简单集合。</p>      <h3 id="nullchecks">空检查</h3>   <p id="00d0bdd4">由于在MPS中自由对待null，因此我们需要一种方法来检查null值。<b id="46fce6e6">isNull</b>和<b id="62aee878">isNotNull</b>操作是我们的朋友。</p>      <h3 id="isinstanceofcheckandtypecasts">IsInstanceOf检查并强制类型转换</h3>   <p id="08fab75d">通常，我们需要检查节点是否是特定概念的实例。我们不能使用Java的instanceof运算符，因为它只能理解Java对象，而不能理解我们的MPS节点。要执行这种类型的检查，应使用以下语法：</p>   <div class="code-block" data-lang="none"><node expression="">.isInstanceOf（概念）</node></div>   <p id="c155e79d">另外，还有一个<i id="7dd83de3">isExactly</i>操作，该操作检查节点的概念是否与用户指定的概念完全相同。</p>   <p id="ca472b7b">一旦根据概念检查了节点的类型，通常我们希望将表达式转换为概念实例并访问该概念的某些功能。为此，应使用以下语法：</p>   <div class="code-block" data-lang="none"><node expression="">：概念</node></div>   <p id="efedf039">      <br>另一种方式来铸造节点到特定的概念实例是通过使用<b id="89a1012c">如</b>铸造表达：</p>   <div class="code-block" data-lang="none"><node expression="">作为概念</node></div>   <p id="32b39330">常规转换（使用冒号）和<b id="495a3fb1">as转换</b>之间的区别在于，它可以处理无法将左侧表达式的结果安全地转换为指定的Concept实例的情况：常规将抛出NullPointer异常在这种情况下强制转换，而<b id="11bc3db8">as</b>强制返回null。</p>   <p id="ac62f6d3">将其与<i id="c402269e">smodel</i>语言中的<b id="3ce3533d">null安全点运算符</b> <i id="c402269e">结合</i>使用，您将获得一种非常方便的方式来浏览模型：</p>   <div class="code-block" data-lang="none">node.parent作为BinaryOperation.leftExpression作为BinaryOperation.leftExpression.isLValue（）</div>   <aside class="tip sideblock" rel="fd375dee" id="634a8b18" data-title="">      <p id="a3f15113">可以使用意图轻松地从一种类型的转换表达式迁移到另一种类型：</p>      <p id="d1735af8">         </p><figure><a class="lightbox" href="/help/img/idea/2019.2/cast1.png"><img alt="演员表1" title="演员表1" src="/help/img/idea/2019.2/cast1.png" id="78091be9" width="500" height="124"></a></figure>          <figure><a class="lightbox" href="/help/img/idea/2019.2/cast2.png"><img alt="演员表2" title="演员表2" src="/help/img/idea/2019.2/cast2.png" id="3c3a9c38" width="400" height="101"></a></figure>      <p></p>   </aside>   <h3 id="nodecollectioncast">节点集合演员</h3>   <p id="d32c02ae">可以使用<i id="342fc0f7">ofConcept</i>构造根据节点的概念来过滤和转换节点的<i id="342fc0f7">集合</i> ：</p>   <div class="code-block" data-lang="none">节点声明<localvariabledeclaration></localvariabledeclaration></div>   <p id="07521f8e"><code class="code">seq.ofConcept<MyConcept></code>相当于<code class="code">seq.ofType<node<MyConcept>></code></p>   <h3 id="aspectcollectioncast">外观集合演员表</h3>   <p id="799dbc24"><code class="code">seq.ofAspect<structure></code>过滤特定方面的节点</p>   <h3 id="parent">父母</h3>   <p id="4afe81c3">为了找到节点的父节点，在每个节点上都可以使用<b id="fd656af1">父</b>节点操作。</p>   <h3 id="children">小孩儿</h3>   <p id="30f49b12"><b id="a4b3cb86">子</b>操作可用于访问当前节点的所有直接子节点。此操作具有可选参数<b id="d63119f9">linkQualifier</b> 。带有此参数的<b id="ed113473">孩子的</b>结果<b id="ed113473"><linkqualifier></linkqualifier></b>操作等效于<b id="fd30b822">node.linkQualifier</b>操作调用，因此将仅调用属于<b id="e72223b4">linkQualifier</b>组/角色的子级。例如<i id="7a79658f">classDef.children <annotation, member=""></annotation,></i>   </p>      <h3 id="siblingqueries">同级查询</h3>   <p id="6c96988d">当您操作AST时，您通常会希望访问节点的兄弟姐妹（即，与所考虑的节点具有相同角色和父节点的节点）。对于此任务，我们执行以下操作：</p>   <ul class="list _ul"><li class="list__item" id="6071184c"><p>next-sibling / prev-sibling-返回节点的下一个/上一个同级。如果没有这样的同级，则返回null。</p></li><li class="list__item" id="5ff2ce5a"><p>next-siblings / prev-siblings-返回节点的下一个/上一个同级的nlist。这些操作具有一个可选参数，该参数指定是否包括当前节点。</p></li><li class="list__item" id="0f4a6a6b"><p>兄弟姐妹-返回节点所有兄弟姐妹的nlist。这些操作具有一个可选参数，该参数指定是否包括当前节点。</p></li></ul>      <h3 id="ancestors">祖先</h3>   <p id="47361209">在模型操作期间，通常会找到指定节点的所有祖先（父代，父代的父代，父代的父代的父代等）。对于这种情况，我们有两个操作：</p>   <ul class="list _ul"><li class="list__item" id="77af02e9"><p>祖先-返回节点的单个祖先</p></li><li class="list__item" id="539fb02c"><p>祖先-返回节点的所有祖先<br>它们都具有以下参数来缩小列表的范围：</p></li><li class="list__item" id="f61e411e"><p>概念类型约束：concept = Concept，[ConceptList]中的概念</p></li><li class="list__item" id="a53797e7"><p>一个标志，指示是否包括当前节点：+</p></li></ul>   <p id="7a3af493">例如<i id="a189f9b3">myNode.ancestors <concept =="" instancemethoddeclaration,="" +=""></concept></i>   </p>      <h3 id="descendants">后裔</h3>   <p id="1d64ff1f">查找指定节点的所有后代（直系子代，子代子代等）也很有用。为此，我们有<b id="7dec1fa5">后代</b>行动。它具有以下参数：</p>   <ul class="list _ul"><li class="list__item" id="46bd867e"><p>概念类型约束：concept = Concept，[ConceptList]中的概念</p></li><li class="list__item" id="c7464e0a"><p>一个标志，指示是否包括当前节点：+</p></li></ul>   <p id="0666b0b4">例如<i id="6d3ff1fb">myNode.descendants <concept =="" instancemethoddeclaration=""></concept></i>   </p>   <h3 id="containingrootandmodel">包含根和模型</h3>   <p id="0cd15d04">要访问指定节点的最顶层祖先节点，可以利用<b id="121f2cc6">包含根</b>操作。<b id="fafda357">模型</b>操作的结果是可以包含模型。</p>   <p id="936a6ba3">例如，</p>   <ul class="list _ul"><li class="list__item" id="d5dc3f5f"><p>node <> containsRoot = myNode。包含根</p></li><li class="list__item" id="8e22926d"><p>模型owneringModel = myNode.model</p></li></ul>      <h3 id="modelqueries">模型查询</h3>   <p id="a01ed0e8"><i id="947629f7">model-ptr /.../</i>表达式检索对模型的可解析引用。使用存储库，可以将其解析为<i id="03fa5a02">model <></i>类型。</p>   <p id="bd0152f3">通常，我们希望找到模型中满足特定条件的所有节点。我们有几种适用于model <>类型的表达式的操作：</p>   <ul class="list _ul"><li class="list__item" id="505ca9e0"><p>roots（Concept）-返回模型中的所有根，它们是指定Concept的实例</p></li><li class="list__item" id="145f17b2"><p>nodes（Concept）-返回模型中的所有节点，它们是指定Concept的实例</p></li></ul>   <p id="88c1c70d">例如<i id="2333273d">model.roots（</i> <i id="27688699"><all>）</all></i>或<i id="2333273d">model.nodes（IfStatement）</i>   </p>      <h3 id="searchscopequeries">搜索范围查询</h3>   <p id="c60c9bcd">在某些情况下，我们想找出哪些引用可以在指定节点上设置。对于这种情况，我们具有搜索范围操作。可以使用以下语法调用它：</p>   <div class="code-block" data-lang="none"><node expression="">。搜索范围（链接，operationContext）</node></div>      <h3 id="theconceptliteral">概念字面量</h3>   <p id="34f99f8b">通常，我们希望引用特定的概念。对于此任务，我们有<b id="c1964a80">概念</b>字面量。它具有以下语法：</p>   <div class="code-block" data-lang="none">概念/概念名称/</div>   <p id="d7cff8e1">例如， <i id="8b407a47">概念<ifstatement>concept = concept / IfStatement /</ifstatement></i>   </p>      <h3 id="conceptoperation">概念操作</h3>   <p id="0ba74677">如果要查找指定节点的概念，则可以在该节点上调用<i id="7439074d">概念</i>操作。</p>   <p id="a1cc40b7">例如， <i id="8eccb6d2">概念<ifstatement>concept = myNode.concept</ifstatement></i>   </p>      <h3 id="migratingawayfromdeprecatedtypes">从不推荐使用的类型迁移</h3>   <p id="48eb759b">不推荐使用<i id="ad415ea4">conceptNode <></i>类型以及<i id="ccbc3f6b">conceptNode</i>操作。<i id="f817b9e3">asConcept</i>操作会将<i id="6fd98a27">conceptNode <></i>转换为<i id="6a039aca">concept <></i> 。另一方面， <i id="6c72c900">asNode</i>操作将执行相反的转换并返回一个<i id="405e1369">节点<abstractconceptdeclaration></abstractconceptdeclaration></i>对于一个<i id="f9cc761a">概念<></i> 。</p>   <aside class="tip sideblock" rel="48eb759b" id="e58512f5" data-title="">      <p id="eb72a39e">在MPS 3.1中， <i id="b249abfc">conceptNode <></i>类型被称为<i id="1a0d2b4e">concept <></i> 。在MPS 3.1中， <i id="51c13afa">conceptNode</i>操作被称为<i id="775bb190">concept</i> 。</p>   </aside>   <h3 id="concepthierarchyqueries">概念层次查询</h3>   <p id="dd0302b2">我们可以使用概念类型查询表达式的上/下概念。您可以进行以下操作：</p>   <ul class="list _ul"><li class="list__item" id="857cdc59"><p>         <b id="8b29952f">super-concepts / all-</b>返回指定概念的所有超级概念。有一个包含/排除当前概念的选项- <i id="378925ff">超级概念/全部<+></i>      </p></li><li class="list__item" id="dce30a6c"><p>         <i id="54b9ae52">super-concepts / direct-</i>返回指定概念的所有直接超级概念。同样，可以选择包含/排除当前概念<i id="de0cfbc9">-super-concepts / direct <+></i>      </p></li><li class="list__item" id="b3a82ff9"><p>         <b id="f8001b60">子概念</b> -返回子概念</p></li></ul>   <p id="26c3b8d8">例如：</p>   <p id="4494ff8c">概念<ifstatement>concept = myNode.concept;<br>列表<concept><>> superConceptsAll = concept.super-concepts / all;<br>concept.super-concepts / direct <+>;<br>concept.sub-concepts（model）;<br>       <i id="b13640eb">概念<ifstatement>concept = myNode.concept;</ifstatement></i>      <br>       <i id="b0ed284e">列表<concept><>> superConceptsAll = concept.super-concepts / all;</concept><></i>      <br>       <i id="6ea4eb33">concept.super-concepts / direct <+>;</i>      <br>       <i id="0459282d">concept.sub-concepts（model，myScope）;</i>   </concept><></ifstatement></p>      <h3 id="thehasroleoperation">hasRole操作</h3>   <p id="00d90964">有时我们可能想检查节点是否具有特定角色。为此，我们具有以下语法：</p>   <div class="code-block" data-lang="none"><node expression="">.hasRole（概念：孩子）</node></div>   <p id="a3cdd320">例如，</p>   <p id="eb46fbc6">      <i id="3189de1a">myNode.hasRole（IfStatement：elsifClauses）</i> </p>   <h3 id="linkqueries">链接查询</h3>   <p id="d44ae1c1">使用<i id="c5386961">link</i> ， <i id="8274df6f">linkName</i>和<i id="a7aff793">linkNode</i>操作可以访问节点之间的链接的详细信息。</p>   <p id="02426e31"> </p>   <div class="code-block" data-lang="none">节点<linkdeclaration>decl = linkNode / ClassCreator：构造函数声明/； decl.sourceCardinality; decl.metaClass;角色目标目标;无序的; ...字符串名称= linkName / ClassCreator：constructorDeclaration /; SReferenceLink link =链接/ ClassCreator：构造函数声明/； link.isOptional（）; link.getDeclarationNode（）; link.getOwner（）; link.getName（）; link.getTargetConcept（）; link.getScope（decl /）; ...</linkdeclaration></div>   <h3 id="containinglinkqueries">包含链接查询</h3>   <p id="d9942d7e">如果使用以下表达式将一个节点添加到另一节点（父节点）中：</p>   <div class="code-block" data-lang="none">parent.childLinkRole.add（节点）</div>   <p id="21c16f3c">那么您可以调用以下操作来访问包含关系信息：</p>   <ul class="list _ul"><li class="list__item" id="afdc9380"><p>         <b id="33cafea4">containingRole</b> -返回表示包含此节点（“childLinkRole”在上面的情况下）的父节点的子作用的字符串</p></li><li class="list__item" id="8bb2bfcc"><p>         <b id="fc7fa958">containsLink-</b>返回<linkdeclaration>表示包含此节点的父节点的链接声明的节点</linkdeclaration></p></li><li class="list__item" id="231b1e6a"><p>         <b id="9e99cdb7">index-</b>返回int值，该值表示具有相应角色的子级列表中此节点的索引。对以上表示的模型的以下查询相同：</p></li></ul>   <div class="code-block" data-lang="none">parent.childLinkRole.indexOf（node）</div>      <h3 id="downcast">沮丧</h3>   <h3 id="downcasttolowersemanticlevel">贬低到较低的语义水平</h3>   <p id="ccaeec25">SModel语言生成可与原始MPS类一起使用的代码。这些类对于通常的工作来说是非常低级的，但是在某些特殊情况下，我们可能仍需要访问它们。要访问低级对象，您应该使用<i id="a67343b1">向下转换来降低语义级别的</i>构造。它具有以下语法：</p>   <div class="code-block" data-lang="none"><node expression="">/</node></div>   <p id="cd92a686">例如，</p>   <p id="a53fc6b3">      <i id="1231c035">myNode / .getConcept（）。findProperty（“ name”）</i>   </p>   <p id="43344910">      <i id="b7663ce7"></i>   </p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="smodel-language-types.html">SModel语言类型</a> <a class="navigation-links__next" href="smodel-language-queries-references.html">SModel语言查询参考</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>