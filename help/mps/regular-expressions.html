<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>正则表达式-帮助| MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Regular+expressions.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="regular-expressions.xml" data-toc="Regular+expressions.html">常用表达</h1>   <h2 id="regularexpressionslanguageoverview">正则表达式语言概述</h2>   <h3 id="introduction">介绍</h3>   <p id="58c70e63">正则表达式语言-一种大大简化文本操作的语言-是当今使用最广泛的领域特定语言之一。几乎每个开发人员都至少使用过一次。一些语言，例如Perl和Python，已经内置了对它的支持。有些，例如Java，通过库使用它。Java（用于实现MPS的语言）不支持正则表达式的语言级别，因此自然为它们实现DSL，因此我们可以使用DSL代替正则表达式库。该语言是MPS语言的一个很好的例子。阅读完此介绍后，您将能够了解如何在MPS中创建和使用语言。</p>   <h4 id="examples">例子</h4>   <p id="758ad9db">我们假设您已经安装了MPS。<br>本文档使用许多示例。您可以在<i id="bda85d62">jetbrains.mps.regexp.examples</i>解决方案下的正则表达式语言项目（％MPS_HOME％/ platform / regexp）中找到它们：<br>       </p><figure><img alt="worddav54fd8999f157b75ecce5d51ca9bff681" title="worddav54fd8999f157b75ecce5d51ca9bff681" src="/help/img/idea/2019.2/worddav54fd8999f157b75ecce5d51ca9bff681.png" id="71d9eaf8" width="298" height="107"></figure>   <p></p>   <h3 id="languageoverview">语言概述</h3>   <p id="b0b268f2">让我们看一个简单的正则表达式应用程序。假设我们要从电子邮件地址获取用户名和域名。这是通过使用正则表达式分析电子邮件地址来打印出用户名和域名的代码（您可以在<i id="4b6f2b7c">EmailExample</i>类中找到此示例）：<br>       </p><figure><img alt="worddav6357b7cf6d2db641dc49ad95d2b20ce6" title="worddav6357b7cf6d2db641dc49ad95d2b20ce6" src="/help/img/idea/2019.2/worddav6357b7cf6d2db641dc49ad95d2b20ce6.png" id="1f20b251" width="580" height="115"></figure>      <br>在此match regexp语句中使用的正则表达式执行以下操作。首先，它读取一个或多个单词字符（\ w +），并将其保存在“用户”变量中。之后，它将读取“ @”字符。然后，我们读取由句号（“。”字符）分隔的单词列表，并将其保存在域变量（\ w +（。\ w +））中。如果找到匹配项，则程序将用户和域输出到<i id="7c00a7c2">System.out</i> 。<br>这是此示例正则表达式的语法树：<br>       <figure><img alt="worddave83ccb1d63a90d30c3ac013f61241197" title="worddave83ccb1d63a90d30c3ac013f61241197" src="/help/img/idea/2019.2/worddave83ccb1d63a90d30c3ac013f61241197.png" id="b503c79e" width="397" height="261"></figure>   <p></p>   <h3 id="languagestructure">语言结构</h3>   <p id="08da58d6">在MPS中创建语言时，通常首先定义其抽象语法。MPS中的抽象语法称为语言结构。为此，我们使用一种结构语言。结构语言是XML语言的XML Schema对应物，或者是SQL的DDL对应物。让我们看一下正则表达式语言结构。</p>   <h4 id="overview">总览</h4>   <p id="92542a7c">MPS正则表达式语言包含几个部分：</p>   <ul class="list _ul"><li class="list__item" id="184c501a"><p>正则表达式：用于指定正则表达式的概念。它们包括字符串文字，符号类以及“或”和“序列”正则表达式的概念。</p></li><li class="list__item" id="804927fb"><p>BaseLanguage（BaseLanguage（BaseLanguage是一种类似Java的语言，MPS在内部将其用作生成器的目标语言））集成：这部分包括一些概念，这些概念用于将与常规表达式相关的代码嵌入到BaseLanguage中。例如，它包括<i id="ab72c5ea">MatchStatement</i> ， <i id="e1365024">ReplaceStatement</i>和<i id="ac7cad31">SplitStatement</i> 。</p></li><li class="list__item" id="d79f870b"><p>正则表达式库支持。当使用正则表达式时，我们想重用它们，因此我们为此任务创建了特殊的概念。</p></li></ul>   <h4 id="regularexpressions">常用表达</h4>   <p id="33a3296a">我们语言中的所有正则表达式概念都放在其结构模型的“ Regexp”文件夹中：<br>       </p><figure><img alt="worddavc3eea13ac43a8310f50d2743e3c07435" title="worddavc3eea13ac43a8310f50d2743e3c07435" src="/help/img/idea/2019.2/worddavc3eea13ac43a8310f50d2743e3c07435.png" id="7ef7cd14" width="309" height="268"></figure>      <br>让我们详细考虑它们。我们对所有这些都有一个基本概念：Regexp：<br>       <figure><img alt="worddavb1c8d5e9a555626d4a7c6f326b4391ba" title="worddavb1c8d5e9a555626d4a7c6f326b4391ba" src="/help/img/idea/2019.2/worddavb1c8d5e9a555626d4a7c6f326b4391ba.png" id="1e7470f1" width="484" height="360"></figure>      <br>它源自<i id="6760f66d">BaseConcept</i>概念。所有MPS概念均源于此。此概念还具有抽象的概念属性，这意味着它是为了形成概念层次结构而创建的，而不用在语言中定义正则表达式。它类似于Java类中的“抽象”修饰符。<br>让我们考虑由此衍生的概念。您可以在层次结构视图中查看它们。您可以通过在概念声明上按<b id="3f6fdd65">Ctrl + H</b>来查看此视图。对于<i id="17ff9fda">Regexp</i>概念，我们将看到以下内容：<br>       <figure><img alt="worddav641bbd1e055f8a1257d7e09e8545a4b5" title="worddav641bbd1e055f8a1257d7e09e8545a4b5" src="/help/img/idea/2019.2/worddav641bbd1e055f8a1257d7e09e8545a4b5.png" id="e8cc69e4" width="440" height="597"></figure>      <br>       <i id="d4a9d5d2">StringRegexp</i>表示可以与文本匹配的任意字符串（您可以在<i id="06aac4b1">Regexps</i>根节点中找到本节中考虑的所有正则表达式示例）：<br>       <figure><img alt="worddav60b32b2dae9e635eaec0472fce900e33" title="worddav60b32b2dae9e635eaec0472fce900e33" src="/help/img/idea/2019.2/worddav60b32b2dae9e635eaec0472fce900e33.png" id="84be9498" width="156" height="67"></figure>      <br>让我们看一下它的概念声明（当在编辑器中选择一个概念的实例时，您可以通过按<b id="45500b5e">Ctrl + Shift + S</b>来快速导航至概念声明）：<br>       <figure><img alt="字davc394a4e587c8986c177d7a7e08981894" title="字davc394a4e587c8986c177d7a7e08981894" src="/help/img/idea/2019.2/worddavc394a4e587c8986c177d7a7e08981894.png" id="9ffeffc6" width="294" height="301"></figure>      <br>在其声明中，我们看到带有字符串类型的属性文本，该属性文本用于存储将在编辑器中显示的文本。同样，此概念声明概念属性为“别名”。概念属性不同于简单属性。简单属性对应于Java实例字段，概念属性对应于Java静态字段。当我们按<b id="754fb4b0">Ctrl + Space</b>时，概念属性<i id="398ec6ff">别名</i>的值将显示在完成菜单中：<br>       <figure><img alt="字davf9496c8f18b0eb7b37640d05e82a8bf6" title="字davf9496c8f18b0eb7b37640d05e82a8bf6" src="/help/img/idea/2019.2/worddavf9496c8f18b0eb7b37640d05e82a8bf6.png" id="3fcbd16d" width="405" height="154"></figure>      <br>创建二进制正则表达式来表示将两个不同的正则表达式组合为一个的正则表达式。<i id="4c84a3bf">BinaryRegexp</i>概念被声明为抽象的，并具有两个具体的子概念： <i id="bc74a023">OrRegexp</i>和<i id="1bd0ad7a">SeqRegexp</i> 。以下是其实例的示例：<br>       <figure><img alt="字dav293aaafcd17556c2b1f82ba50ef99148" title="字dav293aaafcd17556c2b1f82ba50ef99148" src="/help/img/idea/2019.2/worddav293aaafcd17556c2b1f82ba50ef99148.png" id="856a6089" width="122" height="66"></figure>       <figure><img alt="worddava8acebee034eb28ab80b57e485b5aebd" title="worddava8acebee034eb28ab80b57e485b5aebd" src="/help/img/idea/2019.2/worddava8acebee034eb28ab80b57e485b5aebd.png" id="8f13b601" width="152" height="68"></figure>      <br>这是其概念声明：<br>       <figure><img alt="worddav37de03cf815e63b6dab3fbf5daf43f86" title="worddav37de03cf815e63b6dab3fbf5daf43f86" src="/help/img/idea/2019.2/worddav37de03cf815e63b6dab3fbf5daf43f86.png" id="62e0c0ec" width="488" height="327"></figure>      <br>它定义了两个链接：一个用于存储左侧部分，另一个用于存储右侧部分。“聚合”一词意味着该链接下的正则表达式将成为已声明概念实例的一部分。即，如果我们查看语法树，我们将在父<i id="88c7e85a">BinaryRegexp</i>下看到一个子正则表达式：<br>       <figure><img alt="worddav4ad0a0fbd213cbdb7725a1851aaf03bf" title="worddav4ad0a0fbd213cbdb7725a1851aaf03bf" src="/help/img/idea/2019.2/worddav4ad0a0fbd213cbdb7725a1851aaf03bf.png" id="3349c501" width="279" height="53"></figure>      <br>       <i id="28e8b2be">点正则</i>表达式表示与任何字符匹配的正则表达式。<i id="4eb6a66a">LineEndRegexp</i>仅在行尾匹配。<i id="4fadcb6d">LineStartRegexp</i>仅在行的开头匹配。<i id="b2279038">ParensRegexp</i>用于对其他正则表达式进行分组，以使封闭的正则表达式更具可读性。<br>       <figure><img alt="worddav24e21f44c149abcb3659dfd9d06e62aa" title="worddav24e21f44c149abcb3659dfd9d06e62aa" src="/help/img/idea/2019.2/worddav24e21f44c149abcb3659dfd9d06e62aa.png" id="aeec0d93" width="134" height="68"></figure>       <figure><img alt="worddav642ced80a263561d8c469346025b4836" title="worddav642ced80a263561d8c469346025b4836" src="/help/img/idea/2019.2/worddav642ced80a263561d8c469346025b4836.png" id="4f7525f1" width="143" height="73"></figure>       <figure><img alt="worddav94705c1fc94ecb5145b425d14f42afcf" title="worddav94705c1fc94ecb5145b425d14f42afcf" src="/help/img/idea/2019.2/worddav94705c1fc94ecb5145b425d14f42afcf.png" id="e6df13dd" width="153" height="71"></figure>      <br>有很多常用的符号集，但是输入起来非常冗长。因此，我们有字符类，可以输入[AZ]而不是（A | B | CZ）。我们有两种：消极的和积极的。它们都扩展了抽象<i id="95432dc2">SymbolClassRegexp</i> ：<br>       <figure><img alt="worddav802b499d6a7435f7a89accadba5698b3" title="worddav802b499d6a7435f7a89accadba5698b3" src="/help/img/idea/2019.2/worddav802b499d6a7435f7a89accadba5698b3.png" id="4a82c76a" width="203" height="68"></figure>       <figure><img alt="worddava11126417379b10b2d63b7b458305019" title="worddava11126417379b10b2d63b7b458305019" src="/help/img/idea/2019.2/worddava11126417379b10b2d63b7b458305019.png" id="148f0c91" width="215" height="71"></figure>      <br>这些字符类中有许多在多个地方使用，因此可以使用<i id="190eb698">PredefinedSymbolClassRegexp</i>以更简单的方式引用它们。代替[AZ]，我们可以写“ \ w”：<br>       <figure><img alt="worddav133f90af8072c5fb9dfe57c7158c29a9" title="worddav133f90af8072c5fb9dfe57c7158c29a9" src="/help/img/idea/2019.2/worddav133f90af8072c5fb9dfe57c7158c29a9.png" id="9e9ffd04" width="225" height="66"></figure>      <br>此概念的声明方式如下：<br>       <figure><img alt="worddav622ddc5598027e3c18f2fbd3f4bf8d24" title="worddav622ddc5598027e3c18f2fbd3f4bf8d24" src="/help/img/idea/2019.2/worddav622ddc5598027e3c18f2fbd3f4bf8d24.png" id="a8e587e5" width="543" height="268"></figure>      <br>在这里，我们有<i id="057ab99a">symbolClass</i>链接声明，它具有参考<i id="057ab99a">构造</i>型（上面我们提到的聚合<i id="057ab99a">也是</i>链接<i id="057ab99a">构造</i>型）。引用构造型表示此概念的实例将不包含被引用的节点作为子节点。而是可以将引用的节点存储在模型中的任何位置。<br>同样，我们有很多不同的<i id="cccb915e">UnaryRegexps</i> ，它们是从抽象概念<i id="900cb99f">UnaryRegexp</i>派生而来的。它们包括+，*和其他正则表达式操作：<br>       <figure><img alt="worddav302fe26fe89dcd25ad86915228449271" title="worddav302fe26fe89dcd25ad86915228449271" src="/help/img/idea/2019.2/worddav302fe26fe89dcd25ad86915228449271.png" id="23c53b8a" width="141" height="64"></figure>       <figure><img alt="worddav196774bebcf4832840530e8a598b777a" title="worddav196774bebcf4832840530e8a598b777a" src="/help/img/idea/2019.2/worddav196774bebcf4832840530e8a598b777a.png" id="442d42f0" width="141" height="70"></figure>      <br>当我们处理文本时，记住一些匹配项并在以后引用它通常很有用。为了便于完成此任务，我们有<i id="ff89a092">MatchParensRegexp</i>记住它匹配的字符串，还有<i id="264b3233">MatchVariableReferenceRegexp</i>引用以前匹配的字符串。以下代码将一对相同的xml标记与其中的文本匹配：<br>       <figure><img alt="worddav480b88108c470d3412e1c3ca338bf95d" title="worddav480b88108c470d3412e1c3ca338bf95d" src="/help/img/idea/2019.2/worddav480b88108c470d3412e1c3ca338bf95d.png" id="71d34dc5" width="351" height="69"></figure>   <p></p>   <h4 id="baselanguageintegration">BaseLanguage集成</h4>   <p id="10e68537">如果不能将正则表达式集成到BaseLanguage代码中，则它们将很少使用。因此，在正则表达式语言中，我们有一些特殊的概念，可以在用BaseLanguage编写的程序中编写与正则表达式相关的结构。<br>如果要向BaseLanguage添加新构造，通常可以从BaseLanguage扩展<i id="37e542c7">Expression</i>或<i id="fc07abd7">Statement</i>概念。<i id="fc2bf3a4">表达式</i>概念表示类似“ 1 + 2”，“ a == b”的表达式。<i id="9ca11327">语句</i>概念表示控件结构，例如“ if（）{}”，“ while（）{}”。在正则表达式语言中，我们同时创建新的表达式和语句。<br>首先让我们看一下语句，然后看一下表达式：<br>       当您要检查指定的字符串是否与正则表达式匹配时，可以使用<i id="cce74155">MatchRegexpStatement</i> （可以在<i id="2445f34e">jetbrains.mps.regexp.examples</i>模型的<i id="1862230d">BaseLanguageIntegration</i>类中找到此部分的示例）：<br>       </p><figure><img alt="worddav7ca0d21a461360dc9e35c6d2732b1467" title="worddav7ca0d21a461360dc9e35c6d2732b1467" src="/help/img/idea/2019.2/worddav7ca0d21a461360dc9e35c6d2732b1467.png" id="f8825785" width="420" height="72"></figure>      <br>我们这里有一个有趣的功能：您可以在<i id="bdb5309c">MatchRegexpStatement</i>块中引用命名的匹配<i id="bdb5309c">项</i> 。这些匹配变量在以正则表达式语言定义的其他语句中起作用。<br>       <i id="d9155bed">FindMatchStatement</i>检查指定的字符串是否包含与指定的正则表达式匹配的内容。它类似于<i id="736cdbee">MatchRegexpStatement</i> 。<br>       <figure><img alt="worddav49147cbc3846c222907f8ab55c1ed548" title="worddav49147cbc3846c222907f8ab55c1ed548" src="/help/img/idea/2019.2/worddav49147cbc3846c222907f8ab55c1ed548.png" id="03f6cf32" width="355" height="53"></figure>      <br>       <i id="2523d8a3">ForEachMatchStatement</i>允许您迭代指定字符串中指定正则表达式的所有匹配项：<br>       <figure><img alt="字davb00b56a3a457bcfa3bd5c194d9f07a2a" title="字davb00b56a3a457bcfa3bd5c194d9f07a2a" src="/help/img/idea/2019.2/worddavb00b56a3a457bcfa3bd5c194d9f07a2a.png" id="e5f51312" width="375" height="52"></figure>      <br>当我们使用字符串时，我们通常希望用指定的文本替换正则表达式的所有匹配项。在正则表达式语言中，您可以借助<i id="67e1e90a">ReplaceWithRegexpExpression</i>来执行此操作：<br>       <figure><img alt="worddav0324d85e995d77bce18cb1796cbb79a9" title="worddav0324d85e995d77bce18cb1796cbb79a9" src="/help/img/idea/2019.2/worddav0324d85e995d77bce18cb1796cbb79a9.png" id="fac10443" width="370" height="54"></figure>      <br>用某些正则表达式拆分字符串通常也是实用的。例如，要提取由一个或多个空格符号分隔的字符串部分，我们可以编写以下<i id="7f8341fd">SplitExpression</i> ：<br>       <figure><img alt="worddav8693e20963fbd910cdc6f17e65500d23" title="worddav8693e20963fbd910cdc6f17e65500d23" src="/help/img/idea/2019.2/worddav8693e20963fbd910cdc6f17e65500d23.png" id="8841d31b" width="353" height="96"></figure>      <br>当我们在块中引用匹配项时，将使用<i id="0c8726ac">MatchVariableReference</i>概念。它也源自<i id="01055217">表达式</i>概念。<p></p>   <h4 id="librarysupport">图书馆支持</h4>   <p id="461fbc16">在使用正则表达式时，我们希望在许多地方使用其中一些。为了定义这些可重用的正则表达式，我们有一个特殊的概念– <i id="af73e59e">Regexps</i> 。它包含零个或多个命名的正则表达式：<br>       </p><figure><img alt="字davb1831b4d7d4be636b5f539589a7abd8c" title="字davb1831b4d7d4be636b5f539589a7abd8c" src="/help/img/idea/2019.2/worddavb1831b4d7d4be636b5f539589a7abd8c.png" id="190bfe0f" width="279" height="200"></figure>   <p></p>   <h4 id="accessorymodels">配件型号</h4>   <p id="73c0287f">在许多语言中，我们存在以下问题：我们有很多非常相似的实体，它们可以用这种语言编写的任何模型中使用（例如预定义符号类正则表达式）。我们可以为每个这样的实体创建一个概念。但是MPS有一个更好的解决方案：您可以创建一个称为附件模型的特殊模型，并使用您的语言在其中声明所有这些实体。<br>我们有<i id="667f4d74">PredefinedSymbolClass</i>概念，用于声明符号类。另外，我们有<i id="e88ee5d4">PredefinedSymbolClasses</i>容器概念，其中包含这些符号类。如果查看正则表达式语言的附件模型，您将看到以下内容：<br>       </p><figure><img alt="worddav26add762091c9a627c43395111298b8a" title="worddav26add762091c9a627c43395111298b8a" src="/help/img/idea/2019.2/worddav26add762091c9a627c43395111298b8a.png" id="20e43678" width="414" height="331"></figure>   <p></p>   <h3 id="editor">编辑</h3>   <p id="ebe197ab">定义概念结构后，我们通常会为其创建一个编辑器。为了完成此任务，我们使用编辑器语言。它非常易于使用，因此让我们考虑一下其最常见的构造。<br>所有与编辑器有关的代码都放置在编辑器模型中。您可以在项目树的语言节点下找到它：<br>       </p><figure><img alt="字davc1136b6cec7f424fb0462579c99c0799" title="字davc1136b6cec7f424fb0462579c99c0799" src="/help/img/idea/2019.2/worddavc1136b6cec7f424fb0462579c99c0799.png" id="8117dede" width="342" height="145"></figure>      <br>这是<i id="c29c4a5e">StringLiteralRegexp</i>的编辑器：<br>       <figure><img alt="worddav9af071cf04fc04a21f5fda7ba65302a4" title="worddav9af071cf04fc04a21f5fda7ba65302a4" src="/help/img/idea/2019.2/worddav9af071cf04fc04a21f5fda7ba65302a4.png" id="22c717c0" width="307" height="139"></figure>      <br>它包含一个水平集合，一个您可以用来在其中分组其他构造的容器以及一个{text}（用于包括一个实例属性的编辑器）。<br>这是<i id="46ac2359">MatchVariableReferenceRegexp</i>的编辑器：<br>       <figure><img alt="worddavde451156ae66510919af6563b7264e39" title="worddavde451156ae66510919af6563b7264e39" src="/help/img/idea/2019.2/worddavde451156ae66510919af6563b7264e39.png" id="99edcb9e" width="360" height="137"></figure>      <br>它也包含一个水平集合，但是这次我们里面有一组更丰富的构造。 “（ref”和“）”是常量，始终包含相同的文本。 “％match％-> {name}”用于引用匹配链接目标的属性“ name”。<br>这是<i id="f6ebb48f">Regexps</i>的编辑器：<br>       <figure><img alt="worddav79e6df4b7ef387a833fa176607b56cd2" title="worddav79e6df4b7ef387a833fa176607b56cd2" src="/help/img/idea/2019.2/worddav79e6df4b7ef387a833fa176607b56cd2.png" id="bd2e7ca9" width="403" height="224"></figure>      <br>它包含一个带有嵌套水平集合的垂直集合。而且，它包含一个“（（>％regexp％<）”构造。它用于包含角色“ regexp”中所有节点的编辑器。<p></p>   <h3 id="scopes">范围</h3>   <p id="e7a11771">在结构中声明引用后，我们为它们提供了默认的替代菜单。这些默认菜单包括当前模型及其所有导入模型中参考类型的所有节点。有时它可以工作，但有时我们必须缩小这些菜单的范围（例如，如果在模型的不同部分中有很多名为“ name”的匹配变量，则遵循Java范围规则是一个好主意。这些变量。）为了处理此任务，我们有约束语言的范围。<br>范围放置在语言节点下的约束模型中：<br>       </p><figure><img alt="worddavaeb22e88a30788c4c39df5434c19093d" title="worddavaeb22e88a30788c4c39df5434c19093d" src="/help/img/idea/2019.2/worddavaeb22e88a30788c4c39df5434c19093d.png" id="56dfee2a" width="336" height="143"></figure>      <br>让我们考虑<i id="efc22ecf">MatchVariableReference</i>的范围：<br>       <figure><img alt="worddavc378d6ee860a2581a4e9dbdc23fae9d8" title="worddavc378d6ee860a2581a4e9dbdc23fae9d8" src="/help/img/idea/2019.2/worddavc378d6ee860a2581a4e9dbdc23fae9d8.png" id="a738431d" width="622" height="201"></figure>      <br>范围由引用集处理程序，范围条件（标记为“可以创建”）和范围构造器组成。通常，仅指定作用域构造函数。范围构造函数必须返回一个实现<i id="b562db9e">ISearchScope</i>接口的对象。通常，将返回类<i id="66a53b9f">SimpleSearchScope</i>的实例。它具有一个接受节点列表的构造函数，即，我们返回在指定位置可见的节点列表。<p></p>   <h3 id="actions">动作</h3>   <p id="796adf49">MPS中的默认编辑器不是很容易使用。为了改善这种默认行为，可以使用与动作语言和编辑器语言不同的构造。<br>当我们使用基于文本的语言输入代码时，通常是从左到右执行。我们可能从“ 2”开始，然后输入“ 2+”，最后我们可能会有“ 2 + 2”。还可以借助一种称为“正确变换”的机制，以这种方式在MPS中输入代码。'<br>要定义正确的变换动作，您必须在动作模型中创建一个正确的变换动作根，并向其中添加一些正确的变换动作。让我们考虑一下从正则表达式语言进行的正确转换动作，该动作将一个正则表达式转换为一元正则表达式，即它将“ a”转换为“ a +”，“ a *”等（例如约束，编辑器和结构） ，您可以在项目树的语言节点下找到操作模型）：<br>      </p><figure><img alt="worddavced409801e815e076620cb81669d28df" title="worddavced409801e815e076620cb81669d28df" src="/help/img/idea/2019.2/worddavced409801e815e076620cb81669d28df.png" id="0c79621e" width="586" height="244"></figure>      <br>每个正确的变换都有一个适用的概念-可以应用此操作的概念类型。此外，它还有一个条件和最重要的部分：正确的转换菜单。右变换菜单有不同类型。上图中的菜单为每个非抽象的<i id="1ef5a704">UnaryRegexp</i>子概念添加了一个菜单项。菜单部分的处理程序将表达式转换为一元表达式。<p></p>   <h3 id="typesystem">类型系统</h3>   <p id="de648909">许多语言都有类型系统。它使您可以根据它检查模型，并可以用来改善编辑体验和简化生成器。例如，如果我们知道特定表达式的类型，则可以计算可以将哪些方法应用于该表达式。MPS对于类型系统有一种特殊的语言，称为HELGINS。在结构非常简单的语言中，也可以不使用它，但是当我们使用复杂的语言或要与BaseLanguage集成时，我们必须创建一个类型系统，至少对于BaseLanguage集成概念而言。<br>在HELGINS中，类型表示为MPS节点。因此，如果像BaseLanguage一样具有类型的子语言，则可以将其用于类型检查。<br>让我们考虑一下正则表达式语言中的两个规则。<br>       </p><figure><img alt="字davfbd103e572784a29f920f075b0b64b55" title="字davfbd103e572784a29f920f075b0b64b55" src="/help/img/idea/2019.2/worddavfbd103e572784a29f920f075b0b64b55.png" id="1cd6e6a4" width="396" height="145"></figure>      <br>在这段代码中，我们定义了一个称为<i id="ad0d5e4f">String</i>的类型（ <i id="3fc83009">String</i>是BaseLanguage的<i id="4c4f8340">ClassifierType</i>的实例，用于方法参数类型，局部变量和其他位置）。为此，我们使用GIVETYPE语句。<br>让我们看一个更复杂的规则：<br>       <figure><img alt="worddav1a274d8e26272ef9d52b6c7f7458bfff" title="worddav1a274d8e26272ef9d52b6c7f7458bfff" src="/help/img/idea/2019.2/worddav1a274d8e26272ef9d52b6c7f7458bfff.png" id="7e09bf9f" width="396" height="176"></figure>      <br>在此规则中，我们要求与<i id="1e46e82d">FindMatchStatement</i>中的正则表达式匹配的表达式是<i id="063bf4cc">String</i>类型的子类型。我们通过指定类型方程式来实现。符号“：<=：”表示子类型；表达式TYPEOF表示括号中的表达式类型。<br>在计算类型时，Helgins使用了一种复杂的算法，可以节省大量时间。您不必担心类型的计算顺序。您要做的就是在输入规则中指定类型方程式，然后HELGINS会为您解决它们。<br>当然，我们的语言中的规则非常简单，如果您想了解更多关于HELGINS的信息，则必须了解一下诸如BaseLanguage或模型语言之类的语言中的规则。<p></p>   <h3 id="generator">发电机</h3>   <p id="bc8a3a40">用MPS创建的几乎所有语言都有生成器。MPS中的生成器将高级语言代码转换为低级语言的代码。生成器的关键组件是其映射配置。它告诉我们如何使用一种语言。<br>让我们考虑一下正则表达式语言的映射配置：<br>       </p><figure><img alt="字davf77db0d024ca925203b56a14931eb487" title="字davf77db0d024ca925203b56a14931eb487" src="/help/img/idea/2019.2/worddavf77db0d024ca925203b56a14931eb487.png" id="2763365d" width="622" height="328"></figure>      <br>它包含一个映射规则和几个归约规则。每个规则都有适用的概念；对于此概念的每个实例，将应用该规则。映射规则在每个应用程序上创建一个新的根节点。归约规则用新节点替换要对其应用的节点。每个规则都有一个用于创建输出节点的关联模板。<br>让我们看一下这样一个模板的实例：<br>       <figure><img alt="字davc1fd76f76c7cffb01f1f0e716bd309a7" title="字davc1fd76f76c7cffb01f1f0e716bd309a7" src="/help/img/idea/2019.2/worddavc1fd76f76c7cffb01f1f0e716bd309a7.png" id="90485cb5" width="623" height="384"></figure>      <br>模板包含带有宏和模板片段的MPS代码。<br>模板片段外部的代码在生成过程中不使用，仅用于为模板片段内部的代码创建上下文。例如，如果我们知道代码将被放置在带有名为node的参数的方法内，则可以在模板片段周围创建具有此类参数的方法。在生成过程中，MPS将识别您的意图，并且此变量将自动解决。<br>宏用于指定代码的可变部分。例如，上图的变量匹配器上有一个属性宏。该属性宏为该变量生成一个唯一的名称，因此我们将能够使用嵌套的匹配块。MPS具有不同种类的宏：不同种类的节点宏，属性宏和参考宏。所有这些概念都在<i id="cadcc3ab">jetbrains.mps中声明<i id="cadcc3ab">。TLBase</i>语言。<p></p>   <h3 id="furtherreading">进一步阅读</h3>   <p id="76a0ad70">我们看了正则表达式语言。它使用了许多MPS语言开发功能，但是当然不是全部。学习如何使用MPS的最好方法是查看另一种语言，例如基本语言和引导语言。MPS中有几种工具可用于了解MPS的工作方式。<br>其中之一是<i id="1d614d4d">查找用法</i> 。您可以通过从编辑器弹出菜单中选择“ <b id="11e9ffcc">查找用法</b> ”或在编辑器中的节点上按<b id="6fd0a5d8">Alt + F7</b>来调用它。<br>       </p><figure><img alt="字dav49f451933a7d937ef0e3fc0fdcb6f70f" title="字dav49f451933a7d937ef0e3fc0fdcb6f70f" src="/help/img/idea/2019.2/worddav49f451933a7d937ef0e3fc0fdcb6f70f.png" id="c14d7289" width="405" height="106"></figure>      <br>第二个是<i id="664d919b">查找概念实例</i> 。当您遇到一个概念并且不知道如何使用它时，学习它的最好方法是找到其实例并尝试了解这些实例的作用。<br>       <figure><img alt="字dav8b182bc2907aa0f4261f0c1176d60061" title="字dav8b182bc2907aa0f4261f0c1176d60061" src="/help/img/idea/2019.2/worddav8b182bc2907aa0f4261f0c1176d60061.png" id="0d5c2cfe" width="405" height="121"></figure>      <br>MPS分发还在％MPS_HOME％/ help文件夹中包含一个文档系统。其中有些已经过时，有些还很不完整，但是可以用来学习MPS。<p></p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="custom-persistence-cookbook.html">自定义持久性食谱</a> <a class="navigation-links__next" href="dataflow.html">数据流</a></div></i></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>