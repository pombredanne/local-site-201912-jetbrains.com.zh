<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>迁移-帮助| MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Migrations.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="migrations.xml" data-toc="Migrations.html">移居</h1>   <p id="de9f3059">在发布一种语言并开始使用该语言之后，语言作者必须谨慎对待语言定义的进一步更改。特别是，删除概念或添加和删除属性，子级以及对概念的引用将在上一个和下一个语言版本之间引入不兼容性。如果他们更新到下一个语言版本，则会影响该语言的用户，因为他们可能发现自己的模型不再与语言定义匹配，并从模型中报告了相应的错误。</p>   <p id="b3ad2070">MPS <b id="8300b1fb">跟踪</b>项目中使用<b id="8300b1fb">的语言版本，</b>并提供自动迁移，以将语言的用法升级到最新版本。语言设计者可以创建维护“迁移”代码，以针对用户代码自动运行，从而更改用户代码，使其与对语言定义所做的更改保持一致。这称为<b id="4ba4a96c">语言迁移</b> 。</p>   <p id="375d6f16">完整的语言迁移故事涉及几个方面：</p>   <ul class="list _ul"><li class="list__item" id="06313b5c"><p>语言设计人员可以编写用于迁移用户代码的脚本，并将其与语言捆绑在一起</p></li><li class="list__item" id="9fba28cf"><p>MPS自动跟踪客户端代码中使用的语言版本</p></li><li class="list__item" id="cd47e385"><p>MPS可以控制用户的项目是最新的，并且具有所有语言更改</p></li><li class="list__item" id="bfd80933"><p>MPS在必要时运行必要的迁移</p></li></ul>   <p id="80e2d73e">MPS有两种类型的迁移：</p>   <ul class="list _ul"><li class="list__item" id="581dc567"><p>         <b id="d7edb7cf">语言迁移</b> -升级项目以符合语言定义的下一版本的迁移。每种语言迁移都附加到语言定义的版本。</p></li><li class="list__item" id="380219ad"><p>         <b id="b8302a01">项目迁移</b> -这些<b id="b8302a01">迁移</b>不是由语言使用触发的，而是由它们自己定义应在其下运行的条件。这些迁移始终应用于整个项目。</p></li></ul>   <h2 id="languageversion">语言版本</h2>   <p id="05fb7cd1">语言在其模块定义（.mpl）文件中存储版本号。在语言的“迁移”方面创建新的迁移时，此数字会增加</p>   <p id="cf74ee88">使用语言的模块包含与模块（.msd，.mpl）文件中每个使用的语言参考相关联的版本号。这些代表模块使用的语言版本。当对该模块运行相应的迁移以将其迁移到更高语言版本时，数字将更改。</p>   <p id="f00116ce">可以在“ <b id="a82a9780">属性”</b>对话框中手动查看和修改语言的版本号：</p>   <p id="41a3f275">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migrationx1003.png"><img alt="迁移x1003" title="迁移x1003" src="/help/img/idea/2019.2/Migrationx1003.png" id="e80f995d" width="500" height="335"></a></figure>   <p></p>   <p id="3329825c">请注意，有两个可用数字：</p>   <ul class="list _ul"><li class="list__item" id="2c7a4f1e"><p>语言版本-每次语言结构更改时都会更新</p></li><li class="list__item" id="8407e904"><p>模块版本-每次迁移对模块中节点的引用时更新。如果您在带有源的模块（例如移动节点）上执行迁移，则需要进行迁移，该迁移将在<b id="8f78cf43">引用</b>或相关<b id="d57d408d">模块</b>上运行。<i id="7fb51da2">模块版本</i>对此进行跟踪。</p></li></ul>   <h2 id="migrationassistant">移民助理</h2>   <p id="421c75c8">当MPS检测到当前打开的项目中的模块引用的语言版本早于当前使用的语言版本时，将运行“ <b id="9b3623db">迁移助手”</b> 。它提示用户是否应该运行迁移，以便将项目更新为语言的最新版本。</p>   <p id="0d208987">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migration1003.png"><img alt="迁移1003" title="迁移1003" src="/help/img/idea/2019.2/Migration1003.png" id="11983c6c" width="500" height="442"></a></figure>   <p></p>   <p id="ba4ab966">将向用户显示将要运行的迁移的详细列表：</p>   <p id="32b5aaa8">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migration1.png"><img alt="迁移1" title="迁移1" src="/help/img/idea/2019.2/Migration1.png" id="5e3d18c1" width="500" height="1168"></a></figure>   <p></p>   <p id="46b61a69">如果用户触发了迁移，则项目将完全迁移。如果出现阻止迁移的问题，则会向用户显示问题列表以及未迁移代码的列表。</p>   <h2 id="defininglanguagemigrations">定义语言迁移</h2>   <p id="a59d2a1d">在语言定义的<b id="8ad3066b">迁移方面</b> ，迁移被定义为<b id="5ebdd62c">迁移类</b> 。迁移类是<i id="b161cefc">jetbrains.mps.lang.migration</i>语言中定义的<i id="bebd2036">MigrationScript</i>概念的节点。</p>   <p id="439fdcef">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migration1001.png"><img alt="移民1001" title="移民1001" src="/help/img/idea/2019.2/Migration1001.png" id="d0b347aa" width="500" height="796"></a></figure>   <p></p>   <h3 id="numberingoflanguagesandmigrations">语言编号和迁移</h3>   <ul class="list _ul"><li class="list__item" id="6cc8eb88"><p>每个迁移脚本的名称均包含一个数字</p></li><li class="list__item" id="500df314"><p>每个迁移脚本都定义一个<b id="fa796862">from version</b>属性</p></li></ul>   <p id="b57d548c">创建新的迁移脚本时，将语言版本增加1，并将迁移中的<i id="aa872047">fromVersion</i>字段设置为<b id="7648998f">语言版本的旧值</b> 。现在我们可以说创建的迁移脚本执行了<b id="e4d6bacd">从旧版本到新版本</b>的迁移。</p>   <h4 id="numberingoflanguagesandmigrationstipsandtricks">语言编号和迁移技巧与窍门</h4>   <ul class="list _ul"><li class="list__item" id="0aa3fe1b"><p>不能“错过”任何迁移。如果一种语言包含从X版本和Y版本的迁移，则它还应该包含X和Y之间的每个版本的迁移。如果找不到某个版本的迁移，则意味着没有用户可以从X版本进行迁移。这样的语言的生成最终会出错。</p></li><li class="list__item" id="15fdae91"><p>不必存储语言的所有迁移。如果某种语言已“发布”，并且有必要删除一些较旧的迁移，则可以将其删除。剩余的迁移版本应形成范围A ..B，其中A是任何较旧的版本，B = <current version="">-1</current></p></li><li class="list__item" id="eb6b6e40"><p>如果迁移是错误创建的并且没有发布（意味着没有用户在其项目上运行过），则可以将其自由删除。删除迁移后，从语言的上下文菜单中执行“正确的语言版本”-此操作允许将语言的版本与上次迁移的版本同步。这样做时要<b id="b96c628c">非常小心</b> 。</p></li></ul>   <p id="331c033b">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migration1002.png"><img alt="迁移1002" title="迁移1002" src="/help/img/idea/2019.2/Migration1002.png" id="02b7df1e" width="300" height="1350"></a></figure>   <p></p>   <h3 id="structureofamigration">迁移的结构</h3>   <p id="065c6f3b">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Migrationx1002.png"><img alt="迁移x1002" title="迁移x1002" src="/help/img/idea/2019.2/Migrationx1002.png" id="3304be7d" width="300" height="341"></a></figure>   <p></p>   <p id="cd5ff304">迁移可以提供几个可选元素：</p>   <ul class="list _ul"><li class="list__item" id="a13477bf"><p>         <b id="a6f3d778">之后执行</b> -在迁移脚本之间放置排序约束</p></li><li class="list__item" id="712082e1"><p>         <b id="2218281d">产生注释数据</b> -指定<i id="91a3b641">ConceptDeclaration</i> ，它将用于保存此脚本生成的迁移数据，并可能由以后的迁移脚本使用。</p></li><li class="list__item" id="1e5cdf61"><p>         <b id="b2246428">需要注释数据</b> -指定用于表示较早迁移脚本产生的迁移数据的<i id="2352ece5">ConceptDeclaration</i> 。它还为数据提供了一个逻辑名称，以表示该迁移脚本中的数据。</p></li><li class="list__item" id="e0870ad7"><p>         <span class="text-line-through" id="c1612aa8"><b id="74e3fa04">产生数据（已弃用）</b></span> -迁移数据的传统变体，使用外部文件而不是节点注释。</p></li><li class="list__item" id="b978f395"><p>         <span class="text-line-through" id="2554cd27"><b id="61d3a57c">需要数据（已弃用）</b></span> -迁移迁移数据的旧变体。</p></li><li class="list__item" id="b845ff75"><p>         <b id="eea63d5b">description-</b>脚本的有用文字描述</p></li><li class="list__item" id="e9119308"><p>         <b id="0d99dedb">execute方法</b> -每个迁移都定义一个<i id="c35b38ba">execute（）</i>方法，该方法执行用户模型的实际模型转换。该方法接收用户模块作为参数，并且可以引用<b id="a0203b37">所需注释数据</b>部分中的已定义元素。</p></li></ul>   <p id="a4cd5e9e">      <b id="637a15b2">数据生产和消费</b>   </p>   <p id="37f06d36">在迁移脚本之间传递数据的功能对于<b id="2eebcc8d">划分迁移过程</b>很有用。例如，一个迁移脚本可以将节点从旧概念迁移到新概念，而随后的迁移脚本将所有对原始节点的引用迁移为指向新节点。为此，第一个脚本必须存储旧节点和新节点的<b id="c84eb266">ID</b> ，并将映射发布为其<i id="2f5c0565">产生的数据</i> 。第二个迁移脚本将使用数据作为<i id="3b49b576">必需数据</i> 。每次必须更新对旧节点的引用时，该数据将用于查找新节点的ID。从技术上讲，生成数据只是将包含数据的特殊属性附加到与数据相关位置足够近的任何节点。如果由于与整个模型有关而没有放置注释的特定位置，则数据节点将作为新的根附加到当前模型中。</p>   <p id="5af84c7b">生成带有数据的节点的迁移脚本应声明此类节点的概念，并使用<b id="9fb1492d"><i id="ab817915">putData</i> <i id="8b1ae998">（）</i></b>构造将每个此类注释插入模型：</p>   <p id="f86b8b35">      </p><figure><img alt="生产型" title="生产型" src="/help/img/idea/2019.2/producedata.png" id="1ff367b3" width="530" height="113"></figure>      <br>   <p></p>   <p id="a3137968">包含数据的节点可以通过在另一个模块上运行的某些其他迁移脚本来检索，具体取决于生成数据的模块：<br>   </p>   <p id="8fc2e2ab">      </p><figure><img alt="必需品" title="必需品" src="/help/img/idea/2019.2/requiredata.png" id="51c02bd9" width="700" height="201"></figure>   <p></p>   <h3 id="orderingofmigrationscripts">迁移脚本的顺序</h3>   <p id="95132d07">通过<b id="afa16473">require批注数据</b>和<b id="01ac9ee7">产生批注数据</b>部分表示的迁移脚本之间的隐式依赖性将照顾到迁移脚本的正确顺序。当脚本迁移某个模块时，它可以使用为该模块及其所有依赖项存储的数据，因此使用脚本仅在对模块的所有依赖项运行了所有必需的生成器后，才开始迁移该模块。无需明确表达那些依赖关系。</p>   <p id="34a71bf5">但是，在仅在针对同一模块执行了某些其他脚本之后才需要执行某些脚本的情况下（无需考虑依赖关系），可以通过在<b id="448c3cc7">执行之后</b>部分来表达这种排序约束。例如，如果某个属性从一个概念移到了它的超概念（恰好用另一种语言声明），则可以使用两个迁移脚本来表示迁移。适用于子概念的第一个脚本将属性值从旧的不赞成使用的属性复制到新的。第二个脚本适用于超级概念，它会为超级概念的此类实例（不是子概念的实例）使用一些默认值启动新属性。让我们假设第二个脚本进行了其他一些初始化，具体取决于移动属性的值。因此，第二个脚本应仅在第一个脚本之后执行，并在每个模块上执行。</p>   <h3 id="languagesfordefiningmigrations">定义迁移的语言</h3>   <p id="5a927483"><i id="34c4818a">jetbrains.mps.lang.migration</i>语言定义了特定于迁移脚本的所有概念。定义迁移时，可以将<i id="cfd16d08">BaseLanguage</i>与<i id="f96a30ea">jetbrains.mps.lang.smodel</i>和<i id="d2fa538f"></i> <i id="2e4037ca">.query</i>语言来操纵模型。<i id="257011df">类型的<model></model></i>构造对于获取传入的<i id="6d7d69be">SModule中</i>包含的模型可能特别<i id="6d7d69be">有用：</i>   </p>   <div class="code-block" data-lang="none">序列<smodel>模型= m.getModels（）; models.ofType <model>.selectMany（{〜model => model.nodes（BaseDocComment）;}）。forEach（{〜node => ...}）;</model></smodel></div>   <p id="e7655813"> </p>   <p id="bb5b4e8e">典型的迁移首先从迁移中排除迁移方面模型，然后扫描需要迁移的节点。创建一个新节点，并使用旧节点的值和子节点进行初始化。然后，将旧节点替换为新节点。将新节点的id设置为旧节点的id的值将允许对该节点的引用进行迁移而不会失去其目标：</p>   <div class="code-block" data-lang="none">void execute（SModule m）{序列<model>模型=（（序列<model>）m.getModels（））。where（{〜it =>！it.isAspectModel（migration）; }）; models.selectMany（{〜m => m.nodes（OldComponent）;}）。forEach（{〜oldNode => node <newcomponent>newNode = <new component="" $(="" oldnode.name="" )$="" {="">; *（oldNode.member）*（（SNode）newNode /）。setId（（（（SNode ）oldNode /）。getNodeId（））; oldNode.replace with（newNode）;}）; }</new></newcomponent></model></model></div>   <p id="2bbb3d77">示意图：</p>   <ol class="list _decimal"><li class="list__item" id="ed9e4e2f"><p>转换将应用于某些节点。结果，我们有一个对旧节点的引用（调用No），以及一个新节点的引用（Nn）。</p></li><li class="list__item" id="fc37390e"><p>No的后代的ID会自动保留：如果was-descendant节点是转换后输出节点的后代，则它已经具有相同的ID。</p></li><li class="list__item" id="7f15d56a">ID号：MPS确定No是否是输出节点的后代。<ol class="list _decimal"><li class="list__item" id="5ea95648"><p>如果是，则我们已经有了指向No的引用的目标（这是针对“包装”的情况-由于转换，该节点被“包装”在另一个节点中）</p></li><li class="list__item" id="1e214cc7"><p>如果为否，则Nn的ID为No（在我们更改节点概念的情况下，但旧节点在语义上等效于新节点）</p></li></ol>      </li><li class="list__item" id="0f4ab994"><p>在包含模型中，将No替换为Nn。</p></li></ol>   <aside class="tip sideblock" rel="da032231" id="b5ffe046" data-title="">      <p id="d325713b">有时，将复杂的迁移分解为一系列转换迁移要简单得多，而不必编写数据持久性逻辑并将其传递给生成的/所需的数据。</p>   </aside>   <h2 id="conceptreplacement">概念替换</h2>   <p id="e74d3786">如果语言设计师决定删除某个语言概念并可能用一个新的语言概念替换它，则她不应立即从该语言中删除概念定义。而是应首先弃用该概念，并应提供迁移脚本以将用户代码从不赞成使用的概念迁移出去。</p>   <aside class="tip sideblock" rel="e74d3786" id="b7f5b299" data-title="">      <p id="5314e511">通常，将不赞成使用的概念移到单独的<b id="f480fc33">虚拟文件夹中</b>是一种好策略，以使它们与构成当前使用该语言的方式的概念分开。更改概念的虚拟包不会影响用户模型中引用的使用。</p>   </aside>   <p id="fbf37b98">可以在已弃用的概念之后的版本中完全删除（但不必删除）已弃用的概念。然后，也删除了引用不推荐使用的概念的迁移脚本。</p>   <h2 id="definingprojectmigrations">定义项目迁移</h2>   <p id="ccd3dd7f">语言开发人员通常不使用项目迁移，而是MPS团队使用项目迁移来描述模型文件格式，模块依赖系统和其他项目范围内的事物中的更改。</p>   <p id="66af1fb3">项目迁移是针对整个项目运行的，因此，MPS开发人员应考虑在项目的一部分更改时他的迁移将如何工作。例如，用户可以从VCS更新她的项目，在这种情况下，仅仅知道该项目已被迁移一次可能还不够。更新的模块可能仍然需要迁移。<br>MPS不能保证运行项目迁移的顺序，因此您基本上不能编写相互依赖的项目迁移。</p>   <p id="6f4920b7">但是，用户可以编写自己的项目迁移。项目迁移没有特殊的语言，因此它们基本上是用<i id="96dc5664">Java / BaseLanguage</i>类编写的，并通过plugin.xml贡献。因此，我们进一步假设您已经有一个MPS插件并在其中编写项目迁移。</p>   <p id="016d4119">请注意，如果在解决方案中编写了项目迁移，则此解决方案必须在“ <b id="f9d37227">解决方案属性”对话框</b>的“ <b id="ab6810c2">构</b> <b id="30845e62">面”选项卡</b>中启用<b id="ab6810c2">IdeaPlugin</b> ，并在“ <b id="391d64c7">想法插件”选项卡中</b>设置插件ID。</p>   <h3 id="addinganewprojectmigration">添加新的项目迁移</h3>   <ul class="list _ul"><li class="list__item" id="625ed7fc"><p>为实现<i id="279f8bd7">ProjectMigration</i>接口的迁移创建一个类。在大多数情况下，从<i id="09d94ff8">BaseProjectMigration</i>类继承是很方便的。</p></li><li class="list__item" id="883d42ea"><p>创建一个<i id="e26bc25f">ApplicationComponent</i>来贡献新的迁移。不要忘记在<i id="9c8f56f9">plugin.xml中</i>注册它      </p></li><li class="list__item" id="a6a8a16a"><p>使用<i id="20953eaf">ProjectMigrationsRegistry.addProjectMigration（）</i>方法从创建的<i id="2cb7684b">ApplicationComponent</i>贡献所有项目迁移</p></li></ul>   <h3 id="savingdatafromprojectmigrations.">从项目迁移中保存数据。</h3>   <p id="5b9c75e7">项目迁移可以使用<i id="86b6369a">MigrationProperties</i>项目组件持久化其数据。保留的数据存储在项目的.mps文件夹中，因此可以通过VCS在项目的开发人员之间共享。</p>   <h2 id="multiplebranches">多个分支</h2>   <p id="b0d96023">迁移使用多个分支的项目还有其他一些挑战。请查看<a href="using-migrations-with-branching.html">将迁移与分支一起使用</a>文档，以获取详细信息。</p>   <h2 id="migrationanttask">迁移蚂蚁任务</h2>   <p id="7eafeed9">有一个ant任务可以通过ant脚本运行项目中的所有迁移。此任务可用于自动测试迁移和/或检查项目是否已迁移。</p>   <p id="da7bb053">此任务需要设置MPS主路径</p>   <ol class="list _decimal"><li class="list__item" id="68adfd0e"><p>定义mpshome任务属性<b id="5611e41d">或</b>      </p></li><li class="list__item" id="cb673913"><p>定义<i id="e0d72aee">mps_home</i>环境属性<b id="a03601c6">或</b>      </p></li><li class="list__item" id="a8d78efc"><p>定义<i id="de6efb03">mps.home</i>环境属性-这是首选方法</p></li></ol>   <p id="d88bff83">主路径是包含build.txt文件的文件夹的路径。例如，在Mac OS中，该名称以“ / Contents /”结尾</p>   <p id="8a5eaf2c">存储库内容可以使用<repository>标记</repository>指定<repository>：</repository></p>   <p id="4cc936a1">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Screen-Shot-2017-10-25-at-20-56-56.png"><img alt="屏幕截图2017年10月25日在20 56 56" title="屏幕截图2017年10月25日在20 56 56" src="/help/img/idea/2019.2/Screen-Shot-2017-10-25-at-20-56-56.png" id="04e0d42a" width="600" height="174"></a></figure>   <p></p>   <p id="9ba98af9">如果要迁移项目需要插件，则可以在<migrate>ant任务中指定<migrate>。相应的插件及其依赖项将被启用。</migrate></migrate></p><figure><a class="lightbox" href="/help/img/idea/2019.2/MigratePlugins.png"><img alt="迁移插件" title="迁移插件" src="/help/img/idea/2019.2/MigratePlugins.png" id="cff8f95b" width="1696" height="182"></a></figure>   <p></p>   <h2 id="examples">例子</h2>   <p id="ed3e6351">有关如何定义迁移的具体示例，您可以查看MPS附带的<b id="4ce7a393">迁移示例项目</b> 。您将看到迁移脚本，用于迁移两种简单的相互关联的语言。其中一个使用数据在两个迁移脚本之间传递有关已迁移节点的信息，而另一个使用节点ID操纵。</p>   <h2 id="changesmadebymigrationsinlocalhistoryview">迁移在“本地历史记录”视图中所做的更改</h2>   <p id="00e8fffa">迁移与“ <b id="dff71adb">本地历史记录”</b>功能配合使用。</p>   <p id="06f664c5">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/lh1.png"><img alt="1小时" title="1小时" src="/help/img/idea/2019.2/lh1.png" id="83f3aac0" width="300" height="612"></a></figure>   <p></p>   <p id="a1bd6610">运行迁移后，可以查看每个迁移对项目所做的所有更改。打开项目文件夹，模块或模型的“本地历史记录”视图，选择任意两个更改，然后按<i id="0ac36ed8">Ctrl + D</i>以查看差异。</p>   <p id="07c824e7">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/lh2.png"><img alt="2小时" title="2小时" src="/help/img/idea/2019.2/lh2.png" id="92c5fcea" width="300" height="618"></a></figure>      <figure><a class="lightbox" href="/help/img/idea/2019.2/lh3.png"><img alt="3小时" title="3小时" src="/help/img/idea/2019.2/lh3.png" id="e4235291" width="500" height="746"></a></figure>   <p></p>   <p id="4454cac4">还可以从“本地历史记录”视图以及“差异”对话框中还原一个或一组更改。</p>   <h2 id="migrationassistantinintellijidea">IntelliJ IDEA中的迁移助手</h2>   <p id="cef21a52">IntelliJ IDEA插件也可以运行语言迁移。就像MPS本身一样， <b id="e30e2d5e">迁移助手</b>将更新IDEA项目中的模型以匹配当前安装的所用语言版本。</p>   <p id="4bd16087">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/IDEA-Migration1.png"><img alt="IDEA迁移1" title="IDEA迁移1" src="/help/img/idea/2019.2/IDEA-Migration1.png" id="ccf501e2" width="500" height="2100"></a></figure>   <p></p>   <h2 id="discoveringdeprecatedcode">发现不推荐使用的代码</h2>   <p id="7a2d53fb">建议使用不推荐使用的机制，该机制可以向一种语言的用户指示在该语言的下一版本中将删除一个元素。MPS提供了几个方便的查找器来帮助用户消除不推荐使用的代码。<b id="bdc079d2">查找不</b>推荐使用的<b id="bdc079d2">用法</b>可以查找不推荐使用的元素的所有用法。找到的用法的报告将按预期的代码删除版本对条目进行分组。这使得更容易识别它们的严重性并确定其优先级。</p>   <p id="c9c3a2de">      </p><figure><img alt="米格斯" title="米格斯" src="/help/img/idea/2019.2/Migx.png" id="2301b163" width="900" height="1800"></figure>   <p></p>   <p id="f7cdb1d2"> </p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="textgen.html">TextGen</a> <a class="navigation-links__next" href="using-migrations-with-branching.html">将迁移与分支</a> <a class="navigation-links__prev" href="textgen.html">结合</a> <a class="navigation-links__next" href="using-migrations-with-branching.html">使用</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>