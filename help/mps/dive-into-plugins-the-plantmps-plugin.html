<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>深入了解插件：PlantMPS插件-帮助|帮助MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Dive+into+plugins%3A+the+PlantMPS+plugin.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="dive-into-plugins-the-plantmps-plugin.xml" data-toc="Dive+into+plugins%3A+the+PlantMPS+plugin.html">深入了解插件：PlantMPS插件</h1>   <h2 id="introduction">介绍</h2>   <p id="47d5b4b1">在我看来，由<a href="http://www.mbeddr.com" rel="noopener noreferrer" data-external="true" target="_blank">mbeddr.com</a>项目开发的PlantUML插件非常有趣，我已经知道<a href="http://plantuml.sf.net" rel="noopener noreferrer" data-external="true" target="_blank">PlantUML，</a>所以我决定研究该插件，以了解如何将外部工具插入MPS。<br>作为奖励，我创建了一个名为<a href="https://github.com/mar9000/plantmps" rel="noopener noreferrer" data-external="true" target="_blank">PlantMPS</a>的自包含插件，该插件可让您使用PlantUML而不将整个mbeddr平台导入MPS。</p>   <p id="99310e7c">我还已将<a href="https://github.com/maystar/LanguageVisualization" rel="noopener noreferrer" data-external="true" target="_blank">LanguageVisualization</a>插件移植到PlantMPS，因此无需mbeddr就可以使用它。</p>   <p id="dc3b79b4">本教程描述了我编写插件所遵循的几乎所有步骤，但这不是分步指南。关于插件还有其他可用资源，因此在这里我没有记录通用插件功能，而是更加关注mbeddr家伙用来实现插件的特定技术和API。</p>   <h3 id="howthepluginworks">插件如何工作</h3>   <p id="163269de">首先，该插件使用一种名为的接口定义一种语言<code class="code">IVisualizable</code> ，可以在一种或多种PlantUML图表类型中可视化实现该接口的概念。要实现这一点<code class="code">IVisualizable</code>接口定义了两种方法：</p>   <ul class="list _ul"><li class="list__item" id="17a64c51"><p>第一个返回一个字符串数组，这些字符串是该概念支持的类别，例如<i id="2c23a69e">Class diagram</i>和<i id="f6dc1735">Activity diagram</i> 。</p></li><li class="list__item" id="b735d4f9"><p>UI允许用户选择受支持的类别之一，因此第二种方法接收选择的类别，并用需要显示为该概念选择的类别的PlantUML语句填充该图（也被视为参数）。</p></li></ul>   <p id="01df1e04">这些方法的示例可以是：</p>   <div class="code-block"><code class="code-block__wrapper">public string[] getCategories() {<br> return new string[]{"Class diagram", "Activity diagram"};<br>}</code></div>   <p id="63611f62">和</p>   <div class="code-block"><code class="code-block__wrapper">public void getVisualization(string category, VisGraph graph)<br>  overrides IVisualizable.getVisualization {<br>  if (category.equals("Class Category")) {<br>    graph.add("\nclass " + <a href="http://this.name" data-external="true" target="_blank" rel="noopener noreferrer">this.name</a>);<br>  } else if (category.equals("Activity Category")) {<br> //...<br> }<br>}</code></div>   <p id="ba961636">要使用插件，您的概念应仅实现此接口，其余部分由插件处理，包括：</p>   <ul class="list _ul"><li class="list__item" id="56d26154"><p>处理<i id="c967b173">下一个</i>和<i id="45101d98">上一个</i>图表可视化的历史记录。</p></li><li class="list__item" id="f10a47af"><p>保存生成的SVG图像。</p></li><li class="list__item" id="f38df01d"><p>将PlantUML源复制到剪贴板。</p></li><li class="list__item" id="11ca955b"><p>放大</p></li><li class="list__item" id="a415169e"><p>         用户单击SVG图像时的“ <i id="79d7455e">转至节点”</i>功能。</p></li></ul>   <p id="b77b02a3">PlantMPS与原始mbeddr插件的不同之处还在于：</p>   <ul class="list _ul"><li class="list__item" id="0d00587d"><p>mbeddr启动一个HTTP服务器，该服务器公开一些内部或什至外部进程可以请求的服务。在原始插件中，实现了<i id="bae8a454">转至节点</i>功能，将用户在SVG上的点击转换为HTTP请求。 PlantMPS直接选择请求的节点。如果您对此主题感兴趣，请查看<i id="e6ee56c9">c.mbeddr.mpsutil.httpserver</i>模块中的<i id="e5f36cde">应用程序插件</i>和<i id="df06abae">扩展点</i>概念。</p></li></ul>   <h3 id="credits">学分</h3>   <ul class="list _ul"><li class="list__item" id="51aa68cc"><p>         <a href="http://www.mbeddr.com" rel="noopener noreferrer" data-external="true" target="_blank">mbeddr.com</a>项目。</p></li><li class="list__item" id="ffd6d2d8"><p>         <a href="https://github.com/maystar/LanguageVisualization" rel="noopener noreferrer" data-external="true" target="_blank">LanguageVisualization</a>插件。</p></li></ul>   <h2 id="gettingstarted">入门</h2>   <h3 id="createtheproject">创建项目</h3>   <p id="d8c88add">通常，我将MPS内容放在代码下，因此在项目根目录中，我可以放置与MPS不相关的文档，自述文件等。因此，在我们的案例中，可以从MPS打开的项目在<span class="filepath">code / plantmps下</span> 。用项目创建的语言将保留<code class="code">IVisualisable</code>界面和<code class="code">VisGraph</code>用于保存图源的类。</p>   <p id="070cbf9e">然后，我们需要一个插件解决方案作为插件的容器：</p>   <ul class="list _ul"><li class="list__item" id="eacfd806"><p>右键单击项目节点，然后选择“ <i id="c9b63644">新建->插件解决方案”</i> 。</p></li><li class="list__item" id="8876b4cb"><p>选择的名称是<i id="33f4a873">org.mar9000.plantmps.plugin</i> 。</p></li></ul>   <p id="3798b67f">MPS IDE现在应该看起来像这样：</p>   <p id="cf79bc3d">      </p><figure><img alt="新创建的项目" title="新创建的项目" src="/help/img/idea/2019.2/project-just-created.png" id="5ee774b6" width="415" height="152"></figure>   <p></p>   <h3 id="createthetool">创建工具</h3>   <p id="7ee29063">现在我们有了插件解决方案，我们可以创建一个MPS <i id="5e961fe7">工具</i> ：</p>   <ul class="list _ul"><li class="list__item" id="4fb17e84"><p>右键单击插件模型，然后选择“ <i id="63b207cc">新建”->“ jmlang.plugin”->“工具”</i> 。</p></li><li class="list__item" id="70f6bb42"><p>将名称设置为<i id="60ee8177">SVGViewer</i> ，将标题设置为<i id="79b01d67">Visualization</i> 。</p></li></ul>   <h3 id="addatoolicon">添加工具图标</h3>   <p id="2da39e5f">这是一个有趣的部分。首先，MPS使用的图标大小为13x13，在调查了该Idea项目的源代码之后，我从mbeddr项目复制了该图标，其中<code class="code">AllIcons</code>来自。<span class="filepath">图标</span> dir已放置在解决方案的相同级别，实际上是<span class="filepath">代码/plantmps/solutions/org.mar9000.plantmps.plugin/icons</span> 。</p>   <p id="3e05bde4">其次，指定图标需要<i id="d4b922c2">jmlang.resources</i>语言，因此将其包含为使用的语言，可以从“ <i id="679116c9">模块属性”</i>对话框中进行操作：</p>   <ul class="list _ul"><li class="list__item" id="8c63b94e"><p>将插入符号放在<code class="code">icon:</code>字段并按ctrl + space</p></li><li class="list__item" id="4bb2f9d7"><p>你应该看到<code class="code">IconResource</code>选项。</p></li><li class="list__item" id="118fe82f"><p>选择它，一个按钮应该出现在UI上，使您可以从文件系统中选择图标文件。</p></li><li class="list__item" id="e0f19337"><p>如果查看检查器，应该会看到如何指定相对于模块目录的路径，即<span class="filepath">$ {module} / icons / ...。</span></p></li></ul>   <h3 id="completeadummytool">完成一个虚拟工具</h3>   <p id="f10e5e36">打开我们的第一个工具需要完成的唯一事情就是getComponent（）方法，目前仅返回JLabel（）。为此，您需要导入<span class="emphasis">JDK/javax.swing@java_stub</span> 。导入此模型的最快方法是：</p>   <ul class="list _ul"><li class="list__item" id="fccd86d4"><p>击中<code class="code">ctrl+R</code> 。</p></li><li class="list__item" id="a20604bc"><p>写<code class="code">JLabel</code> 。</p></li><li class="list__item" id="2fda1a63"><p>建议的选项之一应为上述型号，然后选择它。</p></li><li class="list__item" id="15f181d4"><p>现在您可以使用<code class="code">new JLabel()</code>作为java语句。</p></li></ul>   <p id="9161748e">该工具应如下所示：</p>   <div class="code-block"><code class="code-block__wrapper">tool SVGViewer {<br> caption: Visualization<br> number: <no><br> icon: <here you have the added icon><br> position: right<br> [snip]<br> getComponent()->JComponent {<br> new JLabel("Your first Tool.");<br> }<br>}</code></div>   <h3 id="toollifecycle">工具生命周期</h3>   <p id="d8494cc3">请记住，打开工具时或开发过程中进行修改时，工具只会实例化一次，实际上<code class="code">getComponent()</code>方法被调用一次。调用时的操作会更改工具的状态，在本例中，设置要显示的节点，然后调用<code class="code">openTool()</code>可以将工具设置为在屏幕上可见的方法。</p>   <h2 id="addingactions">添加动作</h2>   <p id="d4fb1137">必须执行一个<i id="a09a57aa">操作</i>才能打开我们的工具，并且需要一个<i id="1c894471">操作组</i>才能在MPS菜单之一中的某处显示操作菜单。首先创建动作：</p>   <ul class="list _ul"><li class="list__item" id="1cff0f69"><p>右键单击<i id="10be2719">插件</i>模型，然后选择<i id="fad42338">New-> jmlang.plugin-> Action</i> 。</p></li><li class="list__item" id="b6fe522c"><p>设置名称和其他琐碎的参数。</p></li><li class="list__item" id="f4de15a9"><p>         <code class="code">action context parameters</code>是在运行时传递给操作的参数。它们是从MPS或Idea API的类的字段中指定的。<br>这里我们需要钥匙<code class="code">PROJECT</code>包含在<code class="code">CommonDataKeys</code> ，将其模型包含<i id="2462938f">ctrl + R。</i><br>密钥的另一个重要容器是<code class="code">MPSCommonDataKeys</code> ，我们将在本教程中使用它。</p></li><li class="list__item" id="a6f1248d"><p>现在您应该可以选择<code class="code">PROJECT</code>进入与<i id="203e6bd4">ctlr + space</i>一起出现的下拉菜单。</p></li><li class="list__item" id="16f69187"><p>设置<code class="code">mnemonic:</code>参数设置为“ V”，它不将任何键绑定到我们的菜单，仅显示<i id="82b762a6">Visualize的</i>下划线。</p></li></ul>   <p id="577e1f93">完成<code class="code">execute()</code>如下所示的方法应添加<code class="code">MPS.Platform</code>作为插件解决方案的依赖项。该工具现在应如下所示：</p>   <div class="code-block"><code class="code-block__wrapper">action VisualizeAction {<br> mnemonic: V<br> execute outside command: false<br> also available in: << ... >><br> <br> caption: Visualize<br> description: <no description><br> icon:<our icon><br> <br> construction parameters<br> << ... >><br> <br> action context parameters ( always visible = false )<br> Project project key: PROJECT required<br> <br> <update block><br> <br> execute(event)->void {<br> tool<SVGViewer> svgViewer = this.project.tool<SVGViewer>;<br> svgViewer.openTool(true);<br> }<br>}</code></div>   <p id="cc96f810">打开该工具的最后一件事是将我们的操作添加到MPS菜单中的某处：</p>   <ul class="list _ul"><li class="list__item" id="fe96ab16"><p>右键单击<i id="4106b1dc">插件</i>模型，然后选择<i id="e981a941">New-> jmlang.plugin-> ActionGroup</i> 。</p></li><li class="list__item" id="15474de2"><p>称它为<code class="code">VisualizeActionGroup</code> 。</p></li><li class="list__item" id="3a37aa45"><p>您应该会看到一个小的红色/必填字段，在此处选择<i id="733e4592">元素列表</i> ，应该出现另一个可以选择操作的字段。</p></li><li class="list__item" id="cfa20120"><p>选择我们的<code class="code">VisualizeAction</code> ，应该是第一选择。</p></li></ul>   <p id="fdd065ae">的<code class="code">modifications</code>部分用于指定操作菜单应出现的位置，例如<code class="code">CommonDataKeys</code>我们需要导入一个模型以指定有趣的地方：</p>   <ul class="list _ul"><li class="list__item" id="5ced36ed"><p>         <code class="code">EditorPopup</code>包含在<code class="code">j.m.ide.editor.actions</code>是右键单击编辑器区域时出现的菜单。</p></li><li class="list__item" id="040c23a7"><p>         <code class="code">NodeActions</code>包含在<code class="code">j.m.ide.actions</code>右键单击树形区域中的节点时出现的菜单。</p></li><li class="list__item" id="4d1be261"><p>搜索<code class="code">ActionGroupDeclaration</code>找到更多，另一个是<code class="code">ModelActions</code> 。</p></li></ul>   <p id="5125d872">您的行动小组应为：</p>   <div class="code-block"><code class="code-block__wrapper">group VisualizeActionGroup<br>is popup: false<br>contents<br> VisualizeAction<br>modifications<br> add to EditorPopup at position <default></code></div>   <p id="e12678a4">现在该打开我们的工具了：</p>   <ul class="list _ul"><li class="list__item" id="6dcefad3"><p>重建解决方案<i id="24ca33cb">ctrl + F9</i> 。</p></li><li class="list__item" id="2b4277e1"><p>从左侧树上的节点或从编辑器中，都应该使用菜单<i id="16b87c2e">Visualize</i> 。</p></li></ul>   <h3 id="keysbindingwithkeymap">使用键映射绑定键</h3>   <p id="07b8fe97">如上所述<code class="code">mnemonic:</code>参数没有实现任何绑定，而只是在视觉上强调菜单的字符之一。<br>键绑定是使用的实例声明的<code class="code">KeymapChangesDeclaration</code>从<i id="ee019ae6">jmlang.plugin</i>语言中：</p>   <ul class="list _ul"><li class="list__item" id="483f55ac"><p>创建后添加一个<i id="b264f90f">简单的</i>项目。</p></li><li class="list__item" id="8c5d3b0d"><p>然后选择<code class="code">VisualizeAction</code>进入<i id="40dbcde6">动作</i>字段。</p></li><li class="list__item" id="48abb9e2"><p>表明<code class="code">ctrl+alt+VK_V</code>作为约束力。</p></li></ul>   <p id="ad41d5a8">重建<code class="code">ctrl+F9</code>并且您应该能够使用打开工具<code class="code">ctrl+alt+V</code> 。</p>   <h3 id="usethedefinedactionsprogrammatically">以编程方式使用定义的操作</h3>   <p id="29e22ab0">如我们所见，可以定义显示在MPS菜单中某处的<i id="a5b4ad90">动作</i> 。但是<i id="b171f61f">动作</i>和<i id="e94f595d">动作组</i>也可以通过编程实例化，动作将像按钮一样显示，动作组像工具栏一样显示。<br>请参阅SVGViewer.getComponent（），在其中构建了工具工具栏，请看一下<code class="code">actionGroup<></code>和<code class="code">toolbar<></code>创作者。为此，您需要导入<i id="d039f11a">jmworkbench.action@java_stub</i> 。<i id="124619ca">工具栏</i>包中的所有操作都非常简单，它们从<i id="6d36637c">项目</i>字段中获取工具并调用一个或多个方法来更新其状态。<i id="731797d0">保存</i>操作还具有<code class="code">FRAME</code>上下文参数。</p>   <h3 id="tuneactions">调音动作</h3>   <p id="52b76c36">我们创建的动作始终可用，但是我们只想在节点上显示它<code class="code">IVisualizable</code> 。为此，将<i id="f1f02434">上下文参数</i>添加到VisualizeAction：</p>   <div class="code-block"><code class="code-block__wrapper">action context parameter (always visible = false)<br> Project project key: PROJECT required<br> node<IVisualizable> elementToVisualize key: NODE required</code></div>   <p id="35706931">另请注意<code class="code">event.getPresentation().setText()</code>动态设置显示为菜单的文本。如果克隆并打开PlantMPS插件，则可以验证“ <i id="198d1d2e">可视化”</i>操作仅针对<code class="code">IVisualizable</code>节点，尝试<code class="code">DummyVis1</code>和<code class="code">DummyVis2</code>节点。</p>   <h3 id="dynamicactions">动态动作</h3>   <p id="0ea2c97b">正如我们刚刚看到的<code class="code">DummyVis2</code>节点可以分为几类。这是通过<i id="ba6d3b27">动态动作</i>来实现的。特别是当一个节点只有一个类别时，它将由<code class="code">VisualizeAction</code>行动，看<code class="code">VisualizeAction.isApplicable(event)</code> 。当一个节点属于多个类别时，此操作将被禁用，并且<code class="code">VisualizeActionParametrized</code>被启用。这个阶梯动作几乎等于第一个阶梯动作，但是它有一个<i id="c8fb1c1f">构造参数</i> ，在这种情况下是一个名为<code class="code">cat</code> 。如果我们有类别，我们要显示<code class="code">execute()</code>方法可以通过显示此类别<code class="code">VisGraph</code>而不是像<code class="code">VisualizeAction</code> 。</p>   <p id="99c4eecc">参数化操作是由创建的<code class="code">VisualizeActionGroupDynamic</code>不同于<code class="code">VisualizeActionGroup</code>在几个地方。创建后的第一个选项，您应该选择（ <i id="11347617">禁用后不可见</i> ） <i id="4644bb3a">更新</i>而不是<i id="ed1954b4">元素列表</i> 。的内容<code class="code">update(event)</code>方法很简单，但是请注意：</p>   <ul class="list _ul"><li class="list__item" id="c4a9286d"><p>的<code class="code">add</code>用于添加参数化操作的语句。</p></li><li class="list__item" id="ba1000ca"><p>的<code class="code">disable(boolean)</code>方法。</p></li><li class="list__item" id="c4307203"><p>还有一种方法<code class="code">setPopup(boolean)</code>以动态方式将添加的操作与所有其他菜单内联显示或作为单独的菜单（弹出窗口）可视化。</p></li></ul>   <p id="48f03581">指定时，请记住要打开<i id="d392db43">检查器</i> <code class="code">cat</code>参数，因为您何时输入<code class="code">toString()</code>方法。</p>   <p id="dd12774f">这里的PlantMPS插件不同于原始的mbeddr插件，后者始终启用参数化和非参数化操作。实际上，PlantMPS的当前实现只能通过动态动作来完成，如果动态动作不止一个，则允许弹出，而仅一个动作则禁用弹出。但这将提供一个较小的教程。动态小组要处理的结果的概念是<code class="code">DummyVisualizableMoreCategory</code>及其实例<code class="code">DummyVis2</code> 。</p>   <h3 id="createactionsprogrammatically">以编程方式创建动作</h3>   <p id="1e05b4cf">也可以创建动作并以编程方式使用它们，例如<code class="code">ChangeCategoryAction</code>实现了使用户从同一节点的一个类别切换到另一类别的组合框。在里面<code class="code">AbstractChangeCategoryAction</code>课堂笔记<code class="code">enabled</code>使用特定概念创建属性（ <code class="code">Property</code>来自<i id="bef9a6f1">baseLanguage</i> ）。</p>   <h3 id="history">历史</h3>   <p id="84040b73">班级<code class="code">VisualizationHistory</code>几乎是纯Java，但：</p>   <ul class="list _ul"><li class="list__item" id="d7747d22"><p>要实现历史记录，我必须保存对节点的引用，以便在历史记录的该点可视化以及要显示的类别。但是，如从使用中所见，未将节点直接分配给历史项的字段。 <code class="code">SNodePointer</code>类。这样做是为了防止如<a href="howto-adding-additional-tools-aka-views.html">HowTo-添加其他工具（又称为“视图”）中</a>指出的内存泄漏。</p></li></ul>   <h2 id="addplantumlandsvgsupport">添加PlantUML和SVG支持</h2>   <p id="19010ad0">此时，我们将使用<code class="code">IVisualizable</code>界面来自<i id="23232562">omplantmps</i>语言，因此不作详细描述，因为它确实非常简单，并且与插件无关。只要记住创建字段<code class="code">Project project</code>需要导入<i id="5b75ff65">jmproject @ java_stub</i> 。我指出这一点是因为依赖关系通常是MPS的黑暗面。</p>   <p id="d9988e4c">请注意，PlantMPS插件与mbeddr插件的不同之处在于，它对用户对SVG图像的单击做出响应。如上所述，mbeddr向其HTTP服务器执行HTTP请求，并在编辑器上执行节点选择。而PlantMPS直接执行选择节点的代码，请参见<code class="code">MbeddrUserAgent.openLink()</code> 。</p>   <h3 id="addingjars">添加罐子</h3>   <p id="42c62444">将jar放入目录后，在本例中为<span class="filepath">lib</span> dir。在插件解决方案目录下，从“ <i id="a5789143">模块属性”</i>窗口（alt + enter），您必须：</p>   <ul class="list _ul"><li class="list__item" id="13f791df"><p>         <i id="5a23281f">常用</i>选项卡：单击<i id="44247207">添加模型根，</i>然后选择<i id="80df4b41">javaclasses</i> 。</p></li><li class="list__item" id="ad66d70a"><p>然后在右侧选择您的目录的罐子，然后单击“ <i id="133dde4d">模型”</i>按钮。</p></li><li class="list__item" id="97e05920"><p>在<i id="02c17cf2">Java</i>选项卡中，将jar添加到<i id="8c1036de">Libraries</i>部分。</p></li></ul>   <p id="71498be9">如果一切顺利，您应该在您的语言/解决方案的导航树中看到一个名为<i id="d9d33fa3">stubs</i>的新项目。请记住，如果添加其他jar，则只有在添加第一个jar时才需要<i id="a12c491a">Add Model Root-> javaclasses</i> 。</p>   <h2 id="implentinglanguage,generationplanandjava_stubdiagrams">令人信服的语言，生成计划和java_stub图</h2>   <p id="99f2ef17">未完待续</p>   <p id="425b22a6"> </p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="editor-cookbook.html">编辑手册</a> <a class="navigation-links__next" href="copyrights.html">版权</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>