<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>从生成的代码中删除源-帮助| MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Removing+sources+from+generated+code.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="removing-sources-from-generated-code.xml" data-toc="Removing+sources+from+generated+code.html">从生成的代码中删除源</h1>   <p id="46bfdf96">MPS默认情况下将源与生成的模型捆绑在一起。因此，模型的用户能够导航到他们在代码中使用的概念的定义。例如，只需单击一次SingleControl，即可让他们查看正在调用的方法或正在实例化的类的实现。这对用户来说非常方便，因为他们可以通过偷看实现方面来掌握语言/库作者的许多想法。<br>但是，在生活中可能会希望隐藏实现。特别是封闭源项目需要仔细保护实施中包含的知识产权。他们的用户仍然应该能够调用代码，但是在按下<i id="e9969cae">Control + B之后，</i>他们只能看到类和方法的签名：</p>   <p id="f35f60c5">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obfuscated1.png"><img alt="混淆1" title="混淆1" src="/help/img/idea/2019.2/obfuscated1.png" id="304ba67b" width="900" height="932"></a></figure>   <p></p>   <p id="dbc3436e">将其与混淆的类文件结合在一起，对某人进行逆向工程的辛勤工作成果的机会就很少。请继续阅读以了解如何执行此操作。</p>   <h2 id="removesourcesfrombaselanguagecode">从BaseLanguage代码中删除源</h2>   <p id="224e95a5"><i id="726928f3">BuildLanguage</i>提供了<i id="bcc3824e">剥离实现</i>标志，以指示应删除特定工件的源。</p>   <p id="bfc84575">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf2.png"><img alt="obf2" title="obf2" src="/help/img/idea/2019.2/obf2.png" id="9aa82781" width="900" height="1196"></a></figure>   <p></p>   <p id="12e87010">在构建布局命令之一（ <i id="33f91481">module</i> ， <i id="5da76ce4">source</i> ， <i id="d22b31d0">plugin</i> ）上将此标志设置为<i id="fd84fbcc">true</i>时，将指示构建过程从生成的工件中删除实现的源。此标志将确保将<i id="84407b47">BaseLanguage</i>方法的主体替换为空的<i id="518f0cb9">StatementList，</i>并确保类已删除静态初始化器和实例初始化器。如果您希望隐藏某种<i id="728eecf3">语言的</i>实现，则该标志将确保将行为方法的主体也替换为空的<i id="24cd312a">StatementList</i> 。</p>   <aside class="tip sideblock" rel="12e87010" id="b619186e" data-title="">      <p id="4ee9dbaf">在构建语言并设置<i id="4a3bcf4e">Strip实施</i>标志时，生成器模块必须将“ <i id="61c881f8">Generate Templates”</i>标志设置为打开。否则，剥离的生成器将无法使用您的语言，因为模板将丢失。</p>      <p id="a3752165">         </p><figure><a class="lightbox" href="/help/img/idea/2019.2/CompileTemplates.png"><img alt="编译模板" title="编译模板" src="/help/img/idea/2019.2/CompileTemplates.png" id="fbde6c0a" width="900" height="718"></a></figure>      <p></p>   </aside>   <p id="fa6db3a4">总而言之，MPS支持开箱即用：</p>   <ul class="list _ul"><li class="list__item" id="2cad1c53"><p>隐藏以<i id="193b1e41">BaseLanguage</i>编写的<i id="193b1e41">实现</i>      </p></li><li class="list__item" id="36b82ab6"><p>隐藏语言定义的各个方面</p></li></ul>   <p id="8c575afa">您只需要在构建脚本中为所需的解决方案或语言设置<i id="00ce9cbf">剥离实现</i>标志。</p>   <aside class="tip sideblock" rel="8c575afa" id="b0941ec6" data-title="">      <p id="1e9a70fd">如果从语言定义中剥离实现，则该语言的用户将能够完全使用您的语言。但是，他们将看不到实现，并且将无法扩展您的语言的许多方面。</p>   </aside>   <h3 id="afewhandynotes">一些方便的笔记</h3>   <ol class="list _decimal"><li class="list__item" id="c00a172f"><p>在包含已剥离和未剥离语言版本的项目之间切换时，使MPS中的<i id="bc48bbab">缓存无效</i>的功能可能会派上用场。</p></li><li class="list__item" id="d76a2ac5"><p>有时可能需要手动引入您的语言更改，以便构建脚本反映生成的工件中的更改。</p></li></ol>   <h2 id="customizingimplementationstrippingforyourownlanguage">为您自己的语言定制实现剥离</h2>   <p id="85371b3d">正如<i id="41e8aafc">BaseLanguage</i>代码允许隐藏实现一样，您的语言也可以允许隐藏实现。</p>   <aside class="tip sideblock" rel="85371b3d" id="23cc250d" data-title="">      <p id="755e7b41">请不要将“定制实现剥离”与“隐藏您的语言的实现”混淆。如上所述，后者与隐藏您实现语言并自动工作的方式有关，而本段则与创建一种允许其用法隐藏其实现的语言有关。</p>   </aside>   <p id="20d989fd">MPS为您提供了三个标记器接口，以区分您的语言概念与实现剥离有关的预期行为：</p>   <ul class="list _ul"><li class="list__item" id="4ca99337"><p>InterfacePart-在生成的模型中完全可见的概念。用户将能够导航到他们并在其代码中保留对其的引用。</p></li><li class="list__item" id="4835aed2"><p>ImplementationPart-从生成的模型中删除的概念。用户将无法导航至他们或在其代码中保留对其的引用。</p></li><li class="list__item" id="c8cf6e43"><p>ImplementationWithStubPart-被空存根替换的概念。它的行为类似于<i id="df804245">ImplementationPart，</i>只是存根替换将用于表示代码中的节点。例如，考虑空方法主体的<i id="00df091d">/ *编译代码* /</i>标记。</p></li></ul>   <h3 id="robotkajasample">机器人Kaja示例</h3>   <p id="c6a33e22">例如，如果我们希望使用Robot Kaja示例语言（与MPS捆绑在一起）以允许其用法隐藏其实现，则可以通过几个步骤来实现。让我们假设以下情况：</p>   <ol class="list _decimal"><li class="list__item" id="a42dc939"><p>最终用户正在使用<i id="a640521b">Robot Kaja</i>语言编写脚本，作为<i id="2c73e85b">SampleRobotScripts</i>项目的一部分。他想下载<i id="80954a38">并重</i>用机器人例程的名为<i id="80954a38">RobotRoutines</i> （MPS解决方案）的库。</p></li><li class="list__item" id="c0afae8d"><p><i id="429ea990">RobotRoutines</i>的作者希望隐藏其库的实现。</p></li><li class="list__item" id="095a600d">需要修改<i id="bbb91cf7">Robot Kaja</i>语言以支持<i id="aff2619c">RobotRoutines的</i>隐藏实现。它需要声明，哪些概念构成了用该语言编写的应用程序/库的公共接口（合同），哪些保留了实现。我们选择了一种简单的语言，因此很容易确定只有三个概念确实需要成为界面的一部分。其他的可以在包装过程中去除其来源。<ol class="list _decimal"><li class="list__item" id="b1b6e8d1">               <i id="411ab311">脚本</i>            </li><li class="list__item" id="2493c686">               <i id="c60757de">图书馆</i>            </li><li class="list__item" id="62c2e171">               <i id="17ef1351">例行定义</i>            </li></ol>      </li></ol>   <h3 id="initialsituation">初始情况</h3>   <p id="a9d4e54b">Robot Kaja语言允许创建例程<i id="9cd3c459">库</i> 。<i id="3acfe7e4">库</i>是一个根概念，它包含一个集合或<i id="1ff33926">RoutineDefinitions</i> 。使用<i id="42b818dd">Robot Kaja</i>语言的<i id="2fd24fc6">RobotRoutines</i>库可以创建多个<i id="608ccaf9">Library</i>根节点并在其中实现一些方便的例程。</p>   <p id="93166ffc">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf6.png"><img alt="obf6" title="obf6" src="/help/img/idea/2019.2/obf6.png" id="50f344d1" width="900" height="882"></a></figure>   <p></p>   <p id="71cfd34d">在<i id="40d07576">SampleRobotScripts</i>代码中使用时，开发人员始终可以导航到定义并查看<i id="2f11a204">RobotRoutines</i>库的完整实现。</p>   <p id="35ed5a9b">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf3.png"><img alt="obf3" title="obf3" src="/help/img/idea/2019.2/obf3.png" id="207bd9fe" width="900" height="348"></a></figure>   <p></p>   <p id="1c7b9a72">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf4b.png"><img alt="obf4b" title="obf4b" src="/help/img/idea/2019.2/obf4b.png" id="4a48a9cd" width="900" height="910"></a></figure>   <p></p>   <h3 id="goal">目标</h3>   <p id="cf7d57bd">我们希望为诸如<i id="5a08e7bb">RobotRoutines</i>之类的库的作者提供隐藏实现的功能。一旦正确实施， <i id="b71888f6">SampleRobotScripts</i>的开发人员将只看到例程签名及其空主体：</p>   <p id="2b0657dd">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf4a.png"><img alt="obf4a" title="obf4a" src="/help/img/idea/2019.2/obf4a.png" id="61c7debe" width="900" height="494"></a></figure>   <p></p>   <h3 id="changestotherobotkajalanguage">更改机器人卡哈语言</h3>   <p id="1d8428c9"><i id="5aa9eb03">Robot Kaja</i>语言需要使用<i id="bdb1610e">InterfacePart</i>接口标记其<i id="70e69211">Script</i> ， <i id="686a7891">Library</i>和<i id="32ff7e6a">RoutineDefinition</i>概念，因为用户代码可以引用它们。</p>   <p id="218b58fd">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf7.png"><img alt="obf7" title="obf7" src="/help/img/idea/2019.2/obf7.png" id="ba89f694" width="900" height="766"></a></figure>   <p></p>   <p id="c919d18b">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf8.png"><img alt="obf8" title="obf8" src="/help/img/idea/2019.2/obf8.png" id="92715f3e" width="900" height="896"></a></figure>   <p></p>   <p id="1ec517eb">为了隐藏例程的实现，我们需要隐藏它们的主体。例程主体是<i id="c7243b9e">CommandList</i>概念。要隐藏它，我们必须使用<i id="cde7a573">ImplementationPart</i>接口或<i id="125e2293">ImplementationWithStubPart</i>接口对其进行标记。它们都会导致隐藏实现，但是后者允许您提供替换的“存根”概念，该概念将被插入而不是删除的实现。存根使您有机会在已删除的实现中提供更好的代码外观，并且应始终考虑将最终用户偶尔看到的隐藏实现。</p>   <p id="1b42376d">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf9.png"><img alt="obf9" title="obf9" src="/help/img/idea/2019.2/obf9.png" id="c17daa9b" width="900" height="746"></a></figure>   <p></p>   <h3 id="stubcreation">存根创建</h3>   <p id="f8bf759c"><i id="ba720318">ImplementationWithStubPart相</i>对于<i id="fc1e68e4">ImplementationPart</i>的开销在于创建存根概念。对于我们的<i id="40bde07a">CommandList，</i>我们需要一个<i id="67da9da0">StubCommandList</i>概念，并使用<i id="33e32e48">IDontSubstituteByDefault</i>和<i id="e642c1fc">IStubForAnotherConcept</i>对其进行标记。是需要的，因为<i id="2120d450">IStubForAnotherConcept</i>继承<i id="f2a4623e">StubCommandList</i>从<i id="85373b84">CommandList</i>的<i id="ed3f0ec7">ImplementationWithStubPart</i>接口，从而MPS必须被明确告知<i id="95ab68ce">，StubCommandList</i>是一个存根本身并不需要通过另一个存根存根。</p>   <p id="d87b5dd1">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/stubx2.png"><img alt="存根x2" title="存根x2" src="/help/img/idea/2019.2/stubx2.png" id="e36d8fea" width="900" height="718"></a></figure>   <p></p>   <p id="e4e09058">如果<i id="a1023da1">StubCommandList</i>扩展了<i id="fa87af95">AbstractCommand</i>而不是<i id="fc022772">CommandList</i> ，则不必将其标记为<i id="c8d22ba6">IStubForAnotherConcept，</i>因为<i id="e57c9554">AbstractCommand</i>不是<i id="5a955159">ImplementationWithStubPart</i> 。</p>   <p id="67adb86d">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/stubx3.png"><img alt="存根x3" title="存根x3" src="/help/img/idea/2019.2/stubx3.png" id="e80c64a0" width="900" height="738"></a></figure>   <p></p>   <p id="64d726d2">存根编辑器应使读者礼貌地知道该实现已被删除，因此在此处不可见。</p>   <p id="ddd30c7e">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf11.png"><img alt="obf11" title="obf11" src="/help/img/idea/2019.2/obf11.png" id="0aadfc30" width="900" height="1250"></a></figure>   <p></p>   <p id="60acda41">在重新<i id="c5a4d92c">编译</i>和打包后，该语言即可帮助<i id="c5a4d92c">RobotRoutines</i>的作者隐藏其库的实现。</p>   <h3 id="buildscriptforthelibraryauthors">图书馆作者的构建脚本</h3>   <p id="2e0914f7">一旦<i id="3cf87e4d">Robot Kaja</i>语言支持实现剥离， <i id="8d6d76a9">RobotRoutines</i>库的作者就可以在其构建脚本中设置<i id="ec67dfae">strip实现</i>标志，从而从生成的插件中删除其库的实现源。</p>   <p id="20033c4c">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/obf5.png"><img alt="obf5" title="obf5" src="/help/img/idea/2019.2/obf5.png" id="01e86540" width="900" height="1696"></a></figure>   <p></p>   <h3 id="generalguidelinesandadditionalnotes">一般准则和附加说明</h3>   <ol class="list _decimal"><li class="list__item" id="f6fbee8f"><p>标记器接口以传统方式从超级概念和超级概念接口继承。如果多个标记接口（直接或通过继承）适用于一个概念，则<i id="9e71a7b5">InterfacePart</i>胜过其他，而<i id="786e0e2d">ImplementationWithStubPart</i>胜过<i id="1cc07afc">ImplementationPart</i> 。</p></li><li class="list__item" id="7e2fdcc6">如果未指定任何标记接口，则概念的行为就像在其上设置了<i id="c2dadbf7">InterfacePart</i>一样。用<i id="cbeceb04">InterfacePart</i>标记概念有两个目的：<ul class="list _ul"><li class="list__item" id="f79699ce"><p>记录一个事实，即概念是您语言的必要公共要素</p></li><li class="list__item" id="ee6dc048"><p>例如，防止该概念继承其他标志时，防止将该概念偶然地标记为实现的一部分。</p></li></ul>      </li><li class="list__item" id="4c8d6900"><p>使用<i id="fdf6562c">ImplementationPart</i>接口来标记您的语言概念，这些概念不需要从客户端代码中引用，也不需要通过强制性（基数<i id="90e137ac">1</i>和<i id="3181e7c3">1..n</i> ）链接从<i id="8d578804">InterfacePart</i>概念直接访问。这些概念的来源将在构建期间从解决方案中删除，因此用户将无法查看其定义，例如使用“ <i id="beafcbac">转到概念声明”</i> 。</p></li><li class="list__item" id="d827d927"><p>使用<i id="f14d4ace">ImplementationWithStubPart</i>接口来标记应删除的概念，就像<i id="372fb415">ImplementationPart一样</i> ，但是需要用占位符替换而不是简单地从源代码中删除，因为用户可能会看到它们作为定义的一部分。 <i id="ab9824a7">InterfacePart</i>概念。</p></li><li class="list__item" id="ef6735c9"><p>         表示从<i id="fee95c06">InterfacePart</i>概念指向的基数为<i id="f5b81410">1</i>和<i id="1e793031">1..n的</i>子代或引用目标的概念通常需要<i id="123d2ade">ImplementationWithStubPart</i> ，因为它们的包含链接不能保持为空，并且会报告验证错误。</p></li><li class="list__item" id="9d518445"><p>基数为<i id="4a4f25bf">0..1</i>和<i id="44c63ec5">0..n</i>的引用的<i id="4a4f25bf">子代</i>和目标可以安全地标记为<i id="2908a659">ImplementationPart</i> 。包含的链接将保持为空。</p></li><li class="list__item" id="6f3eb73c"><p>存根应遵循<i id="77fc3a76">被替换概念</i>的命名约定<i id="77fc3a76">Stub +名称，</i>并且必须与被替换的概念位于同一包中。</p></li><li class="list__item" id="3928e39f"><p>存根概念可以实现<i id="02c13788">ISuppressErrors</i>以避免从其子节点报告类型系统错误。</p></li><li class="list__item" id="86ae8f87"><p>存根还应该实现<i id="ef2a4f34">IDontSubstituteByDefault，</i>以便在代码完成菜单中不提供它们。</p></li><li class="list__item" id="a436fae4"><p>如果概念既是<i id="25f72ce5">InterfacePart，</i>又是<i id="457bfafa">Implementation（WithStub）Part，</i>则MPS将报告警告。</p></li><li class="list__item" id="78342a81"><p>如果某个概念声明或继承了<i id="1e18dc7c">ImplementationWithStubPart</i>接口，并且在同一虚拟包中找不到合适的存根概念，则MPS将报告错误。</p></li><li class="list__item" id="b4e3e6d4"><p>继承了<i id="735139fa">ImplementationWithStubPart</i>接口的存根（也许通过扩展存根概念）需要实现<i id="958caad0">IStubForAnotherConcept，</i>以表明它们是存根，因此不需要自己进行存根。使所有存根都实现<i id="1b4f7e67">IStubForAnotherConcept</i>接口是一个很好的策略。</p></li><li class="list__item" id="65c1a274"><p>不能定义存根来替换抽象的超级概念。他们必须始终单独替换所有具体概念，为实现<i id="6595a273">ImplementationWithStubPart的</i>一个具体概念添加一个存根。</p></li><li class="list__item" id="19799e6d"><p>重新定义存根概念的编辑器，以便它们显示一些清晰的消息，也称为“编译代码”，以向读者清楚地指示已删除实现。</p></li><li class="list__item" id="e9cdf253"><p>为避免剥离语言的用户会在存根概念中看到模型验证错误，请考虑“专门化”所有子级和从其超级概念继承到存根概念中的“至少1”基数的引用。</p></li></ol>   <p id="ad445b50">这对于概念（例如下面的概念）是必需的<i id="51e352fd">-modelAccessor</i>子代具有基数1，因此在存根概念中是必需的。<br>       </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Hid1.png"><img alt="隐藏1" title="隐藏1" src="/help/img/idea/2019.2/Hid1.png" id="ec450b8c" width="900" height="652"></a></figure>   <p></p>   <p id="7bdfcd1a">存根概念必须遵循在存根概念名称之前加上<i id="2747a147">Stub</i>的命名约定。可能需要也可能不需要扩展存根概念-这取决于从其余语言中如何引用原始概念。如果存根概念必须扩展存根概念，则还需要以某种方式对待强制子项，以使子引用不会保持空白。</p>   <p id="96ade5d6">建议的方法是<i id="4581eae9">专门</i> <i id="930f6775">化子</i>关系或引用关系，并将目标概念更改为<i id="930f6775">BaseConcept</i> 。</p>   <p id="9d1a0ebe">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Stubx1.png"><img alt="存根x1" title="存根x1" src="/help/img/idea/2019.2/Stubx1.png" id="d54a4353" width="900" height="748"></a></figure>   <p></p>   <p id="fce4c8b9">然后在构造函数的行为方面，我们将引用设置为指向某个虚拟节点，例如<i id="05fc4757">IntegerConstant</i> 。这将确保链接不会保持为空，但我们避免了在存根概念中创建完全满足原始<i id="cc1afb7d">modelAccessor</i>链接的节点的需求。</p>   <p id="1a5bda52">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Hid3.png"><img alt="隐藏3" title="隐藏3" src="/help/img/idea/2019.2/Hid3.png" id="84f37cae" width="900" height="440"></a></figure>   <p></p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="removing-bootstrapping-dependency-problems.html">消除引导依赖性问题</a> <a class="navigation-links__next" href="regexp-language.html">Regexp语言</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>