<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>发电机食谱-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Generator+cookbook.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="generator-cookbook.xml" data-toc="Generator+cookbook.html">发电机食谱</h1>   <p id="5caf7c4b">本文档旨在回答与MPS生成器有关的最常见问题。您也可以参考<a href="mps-generator.html">Generator文档，</a>并查看<a href="generator-demos.html">Generator演示</a> 。</p>   <p id="b0205bcd">      </p><ul data-skip-index="skip"><li class="list__item"><a href="#howdoesthegeneratorprocesstherules?">生成器如何处理规则？</a></li><li class="list__item"><a href="#canihavemoregeneratorsforasinglelanguage?">我可以为一种语言设置更多生成器吗？</a></li><li class="list__item"><a href="#canihavemultiplemappingconfigurationspergenerator?">每个生成器可以有多个映射配置吗？</a></li><li class="list__item"><a href="#howtogeneratemultipletargetsfromsinglesource?">如何从单一来源生成多个目标？</a></li><li class="list__item"><a href="#whatmacrosareavailableinthetemplates?">模板中有哪些宏？</a></li><li class="list__item"><a href="#whereshallipututilityclasses?">我应该在哪里放置实用程序类？</a></li><li class="list__item"><a href="#whereshalliputruntimeclasses?">我应该在哪里放置运行时类？</a></li><li class="list__item"><a href="#howdoigenerateuniquenames?">如何生成唯一名称？</a></li><li class="list__item"><a href="#howtogenerateenumerationdatatypes?">如何生成枚举数据类型？</a></li><li class="list__item"><a href="#howtoichangepackagesofthegeneratedjavaclasses?">如何更改生成的Java类的包？</a></li><li class="list__item"><a href="#whatisthedifferencebetweenrootmappingrulesandreductionrules?">根映射规则和归约规则之间有什么区别？</a></li><li class="list__item"><a href="#whathappenstountransformedroots?">未转化的根会发生什么？</a></li><li class="list__item"><a href="#howtogeneratemultiplenodesforasinglenode?">如何为单个节点生成多个节点？</a></li><li class="list__item"><a href="#whyiseditingthemacrossoweird?">为什么编辑宏这么奇怪？</a></li><li class="list__item"><a href="#howcanigeneraterootnodesfornon-rootnodes?">如何为非根节点生成根节点？</a></li><li class="list__item"><a href="#howtoremoveno-longerneededrootsfromthemodel?">如何从模型中删除不再需要的根？</a></li><li class="list__item"><a href="#howdoigeneratenodesfornodesinaccessorymodels?">如何为附件模型中的节点生成节点？</a></li><li class="list__item"><a href="#howtousemappinglabels?">如何使用映射标签？</a></li><li class="list__item"><a href="#howtohandlereferencesduringgeneration?">在生成过程中如何处理引用？</a></li><li class="list__item"><a href="#canidebugthegenerationprocess?">我可以调试生成过程吗？</a></li><li class="list__item"><a href="#howdoifigureouttheactualgenerationsteps?">如何确定实际的生成步骤？</a></li><li class="list__item"><a href="#canispecifytheorderinwhichgeneratorsshouldberun?">我可以指定发电机的运行顺序吗？</a></li><li class="list__item"><a href="#howtocheckthatthemodelhasnoerrorsbeforestartingthegenerator?">启动发电机之前，如何检查模型没有错误？</a></li><li class="list__item"><a href="#howtoextendanexistinggenerator?">如何扩展现有的发电机？</a></li><li class="list__item"><a href="#howtobuildanextensiblegenerator?">如何构建可扩展的发电机？</a></li><li class="list__item"><a href="#whatshalliusetextgenfor?">我应该将TextGen用于什么？</a></li><li class="list__item"><a href="#howtogeneratemultiplefilesperrootnode?">如何在每个根节点上生成多个文件？</a></li></ul>   <p></p>   <h3 id="howdoesthegeneratorprocesstherules?">生成器如何处理规则？</h3>   <p id="b277791b">生成逐渐将输入模型转换为输出模型，然后可以通过TextGen将其转换为文本，也可以不转换为文本。生成过程本身包括步骤。每个步骤分为三个阶段：</p>   <ol class="list _decimal"><li class="list__item" id="dd08b056"><p>执行预映射脚本</p></li><li class="list__item" id="261b821c"><p>基于模板的模型转换</p></li><li class="list__item" id="ea808905"><p>执行映射后脚本</p></li></ol>   <p id="7e2a5b70">基于模板的模型转换阶段包括一个或多个微步骤。微步是输入模型到瞬态（输出）模型的单遍模型转换。在生成步骤中，生成器将迭代模型，并在此步骤涉及的所有语言的生成器中搜索适用于输入模型中节点的规则。如果找不到适用的规则，则生成步骤停止。下一代步骤（如果有）将接收上一步的输出模型作为输入。</p>   <p id="fa73158f">您可以在生成器文档中查看<a href="mps-generator.html">生成器算法的完整描述</a> 。</p>   <h3 id="canihavemoregeneratorsforasinglelanguage?">我可以为一种语言设置更多生成器吗？</h3>   <p id="bccc2f73">不，MPS目前仅允许一种语言的一种生成器。如果您需要一种语言的多个生成器，则建议创建扩展您的语言的空语言，并使用每种扩展语言来定义所需的备用生成器。</p>   <h3 id="canihavemultiplemappingconfigurationspergenerator?">每个生成器可以有多个映射配置吗？</h3>   <p id="e786a3bb">是的，它们在生成过程中将被视为平等。此外，每个<i id="d4165dd0">映射配置</i>可以单独指定其生成过程<b id="87964277">优先级</b> ，这使您可以更灵活地调整生成。</p>   <h3 id="howtogeneratemultipletargetsfromsinglesource?">如何从单一来源生成多个目标？</h3>   <p id="9df9ed62">您可能希望从同一代码库为多个目标平台生成代码。至少有两种方法可以实现：</p>   <ul class="list _ul"><li class="list__item" id="e431c597"><p>将用于不同平台的所有生成规则放在一个生成器中，也许在逻辑上将其分成虚拟包和多个映射配置，并使用每个规则的<i id="9e9afb98">条件</i>根据当前选定的目标激活该规则。开发人员将通过在代码中设置<b id="6026c5ca">标记</b>来指示目标平台</p></li><li class="list__item" id="e0bdc383"><p>直接使用您的语言没有生成器，并使用单独的<b id="4d4f203f">空</b>语言（用于扩展原始语言）为每个目标平台提供生成器。开发人员将通过导入适当的扩展语言来选择所需的目标平台。</p></li></ul>   <h3 id="whatmacrosareavailableinthetemplates?">模板中有哪些宏？</h3>   <ul class="list _ul"><li class="list__item" id="57e34631"><p>         <b id="827e6f7f">属性宏</b> -计算属性值</p></li><li class="list__item" id="737a3ada"><p>         <b id="b26dd074">参考宏</b> -计算<b id="b26dd074">参考</b>的目标（节点）</p></li><li class="list__item" id="4e5026e2">         <b id="682c235d">节点宏</b> -用于在生成时控制模板填充<ul class="list _ul"><li class="list__item" id="427c7966"><p>$ IF $-有条件发电</p></li><li class="list__item" id="9b55a7f0"><p>$ CALL $-在当前位置插入另一个模板，并处理它在当前节点中的传递</p></li><li class="list__item" id="04d88df9"><p>$ LOOP $-遍历节点集合并为每次迭代设置当前节点</p></li><li class="list__item" id="4b6b37dd"><p>$ COPY_SRC $-复制指定的节点并替换包装的节点。还原规则在此过程中应用于复制的节点及其子节点</p></li><li class="list__item" id="d936ee99"><p>$ COPY_SRCL $-复制指定的节点集合并替换包装的代码。在此过程中，将还原规则应用于复制的节点及其子节点</p></li><li class="list__item" id="04e94074"><p>$ MAP_SRC $-将一个节点设置为包装代码中的当前节点</p></li><li class="list__item" id="8aaa85c0"><p>$ MAP_SRCL $-设置节点的集合，每个节点应依次用作包装代码中的当前节点</p></li><li class="list__item" id="7c866ab6"><p>$ SWITCH $-从多种选择中选择用于生成的模板</p></li><li class="list__item" id="aeb54dc4"><p>$ LABEL $-将包装的节点存储在<i id="d81cc15e">映射标签中，</i>以方便其他宏发现</p></li><li class="list__item" id="b9d2d283"><p>$ VAR $-将值设置为变量，然后可以通过<i id="9c4312a3">genContext.varName</i>在包装的节点中<i id="9c4312a3">访问</i>            </p></li><li class="list__item" id="e3dcfee9"><p>$ TRACE $-存储回溯到被包裹节点的原始节点所需的信息，并将源节点和生成的文本之间的映射存储到<i id="da447414">trace.info</i>文件中-当启用“ <i id="b0518249">保存瞬态模型”</i>时，这将启用“ <b id="415747f0">显示原始节点”</b>瞬态模型中“ <b id="157772dc">调试”</b>弹出菜单项中的“选项”</p></li><li class="list__item" id="fae5a0d4"><p>$ WEAVE $-调用特定的编织规则</p></li><li class="list__item" id="e8f96838"><p>$ INSERT $-在当前位置的输出模型中插入一个节点</p></li></ul>      </li></ul>   <h3 id="whereshallipututilityclasses?">我应该在哪里放置实用程序类？</h3>   <p id="27b120b3">在生成器内部创建一个新模型。确保它没有附带<i id="0ed3755d">生成器</i>原型。该模型通常应依赖于<i id="69a04a48">BaseLanguage，</i>以便您可以在其中创建类。然后，原始<i id="2512e650">生成器</i>模型应导入实用程序模型。</p>   <h3 id="whereshalliputruntimeclasses?">我应该在哪里放置运行时类？</h3>   <p id="0a63cdb3">生成的代码所依赖的类和库应放入单独的<b id="db0e2872">运行时解决方案中</b> ，如<a href="getting-the-dependencies-right.html">正确获取依赖项</a>的“ <a href="getting-the-dependencies-right.html">将外部Java类和jar添加到项目-运行时解决方案</a> ”部分<a href="getting-the-dependencies-right.html">所述</a> 。</p>   <h3 id="howdoigenerateuniquenames?">如何生成唯一名称？</h3>   <p id="a1347373">使用<i id="7a771d6c">genContext</i>参数，该参数使您可以访问生成器上下文对象并调用：</p>   <p id="f5dd15c4">      <i id="d5622f8c">来自的唯一名称<base name="">在上下文中<node></node></i>   </p>   <p id="99985c18">      <i id="34d5c1cc">基本名称</i> -是任意字符串，必须是生成的名称的一部分</p>   <p id="52553b90">      <i id="20f335ab">上下文节点</i> -如果指定，则MPS会尽最大努力在作用域（通常是根节点）中生成“包含”的名称。然后，当重新计算名称时（由于输入模型或生成器模型中的更改），这不会影响范围之外的其他名称。<b id="ec56d333">上下文节点</b>参数是可选的，尽管我们建议指定该参数以确保生成的稳定性。</p>   <p id="9415f5f8">在整个生成过程中，都会确保生成名称的唯一性。<br>与使用该服务未生成的名称相冲突仍然是可能的。</p>   <h3 id="howtogenerateenumerationdatatypes?">如何生成枚举数据类型？</h3>   <p id="bdba23bc">必须将枚举数据类型简化为Java枚举，使用<i id="b292379b">$ SWITCH $</i>宏通常是最佳选择。</p>   <p id="0bba6a47">      </p><figure><img alt="发电机2" title="发电机2" src="/help/img/idea/2019.2/Generator2.png" id="e69053ba" width="721" height="347"></figure>   <p></p>   <p id="c637beb6">注意，使用<i id="8225b61e">is（）</i>方法测试实际枚举数据类型是否相等的方式：</p>   <p id="e57491e9">      </p><figure><img alt="发电机3" title="发电机3" src="/help/img/idea/2019.2/Generator3.png" id="92651848" width="1404" height="1188"></figure>   <p></p>   <h3 id="howtoichangepackagesofthegeneratedjavaclasses?">如何更改生成的Java类的包？</h3>   <p id="1127eb34">生成复杂的Java代码时，经常需要将Java类，接口和枚举组织到包中。默认情况下，MPS生成器在生成的Java代码包的结构中反映MPS模型的结构。每个BaseLanguage模型都转换为具有相同名称的Java包。如果你需要操作生成的Java包的结构，使用的该财产<i id="ee1bec98">的packageName</i> <code class="code">Classifier</code>概念。该属性可用于根分类器：</p>   <p id="cbcab7fe">      </p><figure><img alt="cp iface" title="cp iface" src="/help/img/idea/2019.2/cp_iface.png" id="0ee3fae6" width="400" height="488"></figure>   <p></p>   <h3 id="whatisthedifferencebetweenrootmappingrulesandreductionrules?">根映射规则和归约规则之间有什么区别？</h3>   <p id="d5da9eab">在生成期间，将具有树形式的模型（抽象语法树，请参见<a href="basic-notions.html">基本概念</a> ）转换为生成的模型，这些模型也是树。通常，将根节点生成为根节点（例如，将机器人<i id="0d69ae49">脚本</i>转换为Java类），将非根节点生成为非根节点（例如，将机器人<i id="c634d4d5">Step</i>命令转换为Java <i id="8e339e23">BlockStatement</i> ）。因此，用于根映射规则的模板代表生成的模型的起点，并且不能指定模板上下文，与归约模板不同，归约模板可以保存上下文并使用<b id="7dd713f7">模板片段</b>标记指示实际的生成内容。</p>   <aside class="warning " rel="d5da9eab" id="87ff2740" data-title="">      <p id="a448296b">当将可生根概念的节点置于非根位置时，将对其应用归约规则。根映射规则仅适用于根位置中的节点。</p>   </aside>   <h3 id="whathappenstountransformedroots?">未转化的根会发生什么？</h3>   <p id="444a5133">没有适用转换规则的根，将不更改地移入下一代步骤。</p>   <h3 id="howtogeneratemultiplenodesforasinglenode?">如何为单个节点生成多个节点？</h3>   <p id="1ce7476b">模板中的模板片段指示哪个节点将替换当前输入节点。模板片段只能附加到模板内的单个节点，但是生成器模板可以包含多个模板片段，前提是所有片段都附加到同一父节点下具有相同角色的节点。这样，可以为单个输入节点生成多个节点。</p>   <p id="181ed6bc">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/templateFragments.png"><img alt="templateFragments" title="templateFragments" src="/help/img/idea/2019.2/templateFragments.png" id="517e41d8" width="300" height="176"></a></figure>   <p></p>   <h3 id="whyiseditingthemacrossoweird?">为什么编辑宏这么奇怪？</h3>   <p id="821c032a">确实，生成器宏和模板片段标记起初很难编辑。但是，一旦您了解了它们如何工作的基本原理，便可以有效地使用它们。</p>   <p id="eb001e6f">宏已实现为<b id="69a4082b">节点/属性/引用属性</b> （请参见“ <a href="structure.html">结构”</a>一章的“ <b id="b3789c18">属性”</b>部分）。这样，它们可以以任何语言使用，并且不需要任何前期支持即可以该语言提供。这很重要，因为任何语言都可以用作MPS的生成目标。因此，宏是附加到它们包装的节点上的属性。删除或替换由宏包裹的节点也将删除该宏，并且您必须重新输入宏以将其附加到新节点。建议的方法是先输入模板的代码，然后开始添加宏。如果需要更改由宏包裹的节点，则可以至少将<b id="296073a4">Inspector</b>窗口内容复制粘贴到新节点上的宏中，从而将其保留在旧节点上。</p>   <h3 id="howcanigeneraterootnodesfornon-rootnodes?">如何为非根节点生成根节点？</h3>   <p id="e35cf4ef">只需为该概念创建一个<b id="82670285">根映射规则</b> ，甚至可以通过条件对其进行进一步限制。该规则称为<b id="c8bc4c90">root</b> ，因为它会生成一个根节点，并不一定要以根作为输入。</p>   <p id="c47079ab">或者，您可以使用<b id="ba4fb7b0">条件根规则</b> （基于评估布尔谓词插入根节点），也可以使用<b id="fa188802">预处理脚本</b> （可以检查输入模型并根据需要创建根节点）。</p>   <h3 id="howtoremoveno-longerneededrootsfromthemodel?">如何从模型中删除不再需要的根？</h3>   <p id="b9630ed0">使用根映射规则转换根节点后，将自动删除根节点。对于未直接转换的根，请使用“ <b id="1a98bf59">放弃根”</b>规则以防止其传播到下一代步骤中。</p>   <h3 id="howdoigeneratenodesfornodesinaccessorymodels?">如何为附件模型中的节点生成节点？</h3>   <p id="6c957f15">生成器不以任何方式处理附件模型中的节点。为了基于附件模型中的节点生成节点，您可以利用<b id="ee85925c">条件根规则</b>或<b id="3b58f121">预处理脚本</b> 。</p>   <p id="910bb97d">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/accessoryGeneration.png"><img alt="annexGeneration" title="annexGeneration" src="/help/img/idea/2019.2/accessoryGeneration.png" id="cb9cc006" width="500" height="496"></a></figure>   <p></p>   <p id="f79a9a01">然后可以使用归约规则进一步将“插入的节点”生成为所需的目标语言。</p>   <h3 id="howtousemappinglabels?">如何使用映射标签？</h3>   <p id="95483639">映射标签在映射配置（例如<i id="8c27f577">main</i> ）中定义。然后必须通过用宏包装要存储的节点来填充它们，例如$ LOOP $，$ LABEL $，$ COPY_SRC $等。</p>   <h3 id="howtohandlereferencesduringgeneration?">在生成过程中如何处理引用？</h3>   <p id="002b17cb">参考宏应用于在生成的参考上设置适当的目标节点。通常，您将引用宏与<b id="041a21ff">映射</b> <b id="febb92e9">标签</b>一起使用。</p>   <p id="da950ad9">此处的基本任务是，对于指向节点<b id="1a9e1e73">N</b>的引用<b id="643c246a">R</b> ，我们需要确保从<b id="b721e524">R</b>生成的引用<b id="b5040866">G（R）</b>必须指向从<b id="13f5165f">N</b>生成的节点<b id="07be2d9d">G（N）</b> 。</p>   <p id="b2f01b09">      <i id="560ca0b0">如果R-> N，N生成为G（N），R生成为G（R），</i> <i id="b232acfe">则G（R）-> G（N）</i>   </p>   <p id="fefb7b19">映射标签用作字典，将节点存储为键，并将节点生成的值存储为值-在我们的示例中为<b id="bc04c5c8">N-> G（N）</b> 。必须明确指示生成器将节点及其生成的节点之间的映射存储到映射标签中。模板片段以及节点宏允许用户指定一个映射标签，应将生成的节点保存到其中。</p>   <p id="15f25417">当将<b id="84e2a885">R</b>简化为<b id="a0777163">G（R）时</b> ，在<i id="e44627ee">genContext.get中通过标签和输入</i>调用生成器上下文时， <b id="87164edc">G（R）</b>上的引用宏可以使用<b id="d3ed0f3d">N</b>作为键从映射标签中检索<b id="9bede269">G（N）</b> 。</p>   <p id="8130990c">      <a href="generator-demos.html">生成器教程的</a> <a href="generator-user-guide-demo7.html">第7章</a>更详细地介绍了映射标签。</p>   <h3 id="canidebugthegenerationprocess?">我可以调试生成过程吗？</h3>   <p id="5e112f87">第一个选项是启用保存瞬态模型。MPS在生成过程中创建的中间模型将被保留，您可以在屏幕左侧的“ <i id="2cb8a949">项目视图”</i>面板中访问它们：</p>   <p id="dbd48a3f">      </p><figure><img alt="瞬态1" title="瞬态1" src="/help/img/idea/2019.2/transient1.png" id="5eeec7ba" width="291" height="83"></figure>       <figure><a class="lightbox" href="/help/img/idea/2019.2/transient2.png"><img alt="瞬态2" title="瞬态2" src="/help/img/idea/2019.2/transient2.png" id="e842c1b5" width="500" height="278"></a></figure>   <p></p>   <p id="b7109339">保存的瞬态模型使您可以调查模型在生成过程的各个阶段的外观。</p>   <p id="81eb3889">第二种选择是使用<b id="64280210">Generator Tracer Tool</b> 。对于此工具，“保存瞬态模型”选项也必须设置为<b id="b41178b7">on</b> 。Generator Tracer Tool使您能够详细研究选定节点的生成过程。当您选择原始模型或任何瞬变模型中的节点时，上下文菜单将为您提供用于向前或向后跟踪生成过程的选项。结果，您将获得一个树形报告，该报告使您可以访问所有阶段，特定节点在生成过程中通过这些阶段以及影响其生成的规则。</p>   <p id="e8b233f1">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/tracer1.png"><img alt="示踪剂1" title="示踪剂1" src="/help/img/idea/2019.2/tracer1.png" id="df181df0" width="300" height="988"></a></figure>   <p></p>   <p id="3466cb4f">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/transient2.png"><img alt="瞬态2" title="瞬态2" src="/help/img/idea/2019.2/transient2.png" id="a72771b7" width="300" height="278"></a></figure>   <p></p>   <p id="7ea59255">此外， <i id="a06debcc">$ TRACE $</i>生成器宏为您提供了标记模板的一部分以进行跟踪的选项，这样您就可以使用以下选项中的“ <b id="de1871ba">显示原始节点”</b>选项从<b id="137112e3">瞬态模型中</b>的生成节点导航回其原始节点。 <i id="dfcd28f9">上下文菜单->语言调试</i>菜单：</p>   <p id="34ad5e79">      </p><figure><img alt="轨迹2" title="轨迹2" src="/help/img/idea/2019.2/Trace2.png" id="fd6b60b3" width="1418" height="1094"></figure>   <p></p>   <p id="dca636a1">      </p><figure><img alt="轨迹1" title="轨迹1" src="/help/img/idea/2019.2/Trace1.png" id="d8dabd57" width="1770" height="1078"></figure>   <p></p>   <h3 id="howdoifigureouttheactualgenerationsteps?">如何确定实际的生成步骤？</h3>   <p id="c5993ac0">使用<i id="9851aa61">生成</i>器上下文菜单中的“ <i id="9851aa61">显示生成计划”</i>操作。这将提供一份详细的报告，显示所有计划的生成阶段，并列出在每个阶段中运行的映射配置。</p>   <p id="ad56b150">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/genplan1.png"><img alt="genplan1" title="genplan1" src="/help/img/idea/2019.2/genplan1.png" id="f731053f" width="300" height="197"></a></figure>   <p></p>   <p id="c57c0ab6">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/genplan2.png"><img alt="genplan2" title="genplan2" src="/help/img/idea/2019.2/genplan2.png" id="cabe6238" width="500" height="565"></a></figure>   <p></p>   <h3 id="canispecifytheorderinwhichgeneratorsshouldberun?">我可以指定发电机的运行顺序吗？</h3>   <p id="4bdf6a01"><i id="8578adc5">生成</i>器的“ <i id="a9d3208d">模块属性”对话框</i>中的“生成<i id="8578adc5">器优先级”</i>选项卡使您可以指定两个不同<i id="509f7e59">映射配置</i>之间的排序规则。</p>   <p id="1b831335">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/Priorities2.png"><img alt="优先事项2" title="优先事项2" src="/help/img/idea/2019.2/Priorities2.png" id="2b512c35" width="300" height="550"></a></figure>   <p></p>   <p id="1930fd36">对于更复杂的方案，“ <a href="generation-plan.html">生成计划”</a>的新功能使您可以完全控制生成器过程。</p>   <h3 id="howtocheckthatthemodelhasnoerrorsbeforestartingthegenerator?">启动发电机之前，如何检查模型没有错误？</h3>   <p id="a4ed2569">在模型/语言/解决方案上运行“ <i id="b3816b62">检查模型（语言/解决方案）”</i>上下文菜单操作以进行检查。</p>   <p id="71c578a7">      </p><figure><img alt="发电机101" title="发电机101" src="/help/img/idea/2019.2/Generator101.png" id="51db5fa7" width="526" height="289"></figure>   <p></p>   <p id="3a33daa3"><i id="496e195b">首选项->构建，执行，部署->生成器->在生成</i>配置标志<i id="496e195b">之前检查模型是否存在错误，</i>该标志指定是否应在每次触发生成器时自动运行模型检查器。</p>   <h3 id="howtoextendanexistinggenerator?">如何扩展现有的发电机？</h3>   <p id="c50c02f3">遵循一条规则-确保扩展的生成器在扩展的生成器之前运行-在生成器顺序优先级对话框中为其赋予更高的优先级。</p>   <h3 id="howtobuildanextensiblegenerator?">如何构建可扩展的发电机？</h3>   <p id="423c1ac7">通过扩展生成器，扩展可以更改原始语言的语义。MPS生成器可以通过设计进行扩展–它可以解析所有生成器规则和来自所有涉及语言的映射配置，并构建全局生成计划。项目附带的任何语言都将包含其规则。该计划根据生成器规则在映射配置中表示的相互相对优先级来指定其执行顺序。这使语言扩展可以将其自己所需的生成规则注入最合适的生成阶段。由于优先级表示为映射配置之间相对顺序的集合，因此语言扩展不需要知道生成中涉及的所有其他生成器即可工作。检测到潜在的（罕见的）冲突，并留给开发人员解决。创建完成后，将使用生成计划来迭代调用生成器，从而有可能利用底层硬件的并行性来实现相互独立的规则。</p>   <p id="1aa23994">提供其他归约规则是扩展语言的一种方法。使用发电机开关是另一种选择。如果父语言使用生成器开关选择正确的归约规则，则语言扩展可以使用附加的逻辑扩展该生成器开关，以选择归约规则-通常包括扩展语言贡献的新规则。</p>   <h3 id="whatshalliusetextgenfor?">我应该将TextGen用于什么？</h3>   <p id="c9c34e7d">在生成器执行模型到模型的转换时，TextGen会映射到文本。这通常是生成的最后一步，由生成器完全管理。生成器选择根并将其转换为文件。TextGen故意为语言设计者提供了很少的灵活性。它是生成器，主要应配置和处理生成过程。如果您需要解决TextGen的局限性，则很可能会以错误的方式尝试操作。Generator是您最灵活的地方。</p>   <h3 id="howtogeneratemultiplefilesperrootnode?">如何在每个根节点上生成多个文件？</h3>   <p id="f5334e6b">TextGen每个根节点仅允许一个文件。另外，每个概念只能有一个TextGen组件。应该将灵活性编码到生成器中。您可以让生成器创建该节点的多个副本，也许将每个副本都包装在具有不同概念的新节点中。然后，这些新节点将其TextDef定义为执行所需的模型到文件的转换。</p>   <p id="72b32485"> </p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="howto-integration-with-the-data-flow-engine.html">如何-与数据流引擎</a> <a class="navigation-links__next" href="editor-cookbook.html">编辑器食谱</a> <a class="navigation-links__prev" href="howto-integration-with-the-data-flow-engine.html">集成</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>