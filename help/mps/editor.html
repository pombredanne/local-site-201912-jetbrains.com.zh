<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>编辑器-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Editor.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="editor.xml" data-toc="Editor.html">编辑</h1>   <p id="5636f37d">      <br>定义好语言的结构后，您可能会去创建使开发人员可以方便地用它构建AST的方法。直接操纵AST既不是很直观，也不会有生产力。隐藏AST并为用户提供舒适，直观的交互是语言编辑者的任务。</p>   <aside class="tip sideblock" rel="5636f37d" id="d7048e79" data-title="">      <p id="2afa6999">有时在某些情况下需要直接操作AST。例如，当可用的编辑器定义不授予您访问节点的所有属性时的权限。<b id="6cc521d9">反射式编辑</b>器使您可以停止选定节点的编辑器，而直接访问AST。按<b id="6676c548">F5</b>键以恢复为默认编辑器。</p>      <p id="3214b2b7">         </p><figure><a class="lightbox" href="/help/img/idea/2019.2/ReflectiveEditorFix1.png"><img alt="ReflectiveEditorFix1" title="ReflectiveEditorFix1" src="/help/img/idea/2019.2/ReflectiveEditorFix1.png" id="ddfdfbc3" width="300" height="1930"></a></figure>      <p></p>   </aside>   <h2 id="editoroverview">编辑器概述</h2>   <p id="60f79bf0">节点的编辑器既充当其视图又充当其控制器。编辑器将显示该节点，并允许用户对其进行修改，替换，删除等。不同概念的节点具有不同的编辑器。语言设计师应使用他/她的语言为每个概念创建一个编辑器。</p>   <p id="36cb006d">在MPS中，编辑器由单元格组成，单元格本身包含其他单元格，某些文本或UI组件。每个编辑器都有其指定的概念。一个概念最多只能有一个编辑器声明（也可以没有一个）。如果概念没有编辑器声明，则将使用具有编辑器声明的该概念的最接近祖先的编辑器来编辑其实例。</p>   <p id="0a255a11">为了描述某个概念的编辑器（即，对于该概念的节点，哪些单元格必须出现在编辑器中），语言设计人员将使用专用语言，简称为<i id="a0d9222b">编辑器语言</i> 。您会看到，MPS将<i id="284c9ff8">面向语言的编程</i>原理应用于自身。</p>   <p id="529204c5">编辑器的描述包含它所保存的单元格的描述。我们称这种描述为“细胞模型”。例如，如果您希望编辑器由具有不可修改文本的唯一单元格组成，则可以在编辑器描述中创建一个恒定单元格模型并指定该文本。如果您希望编辑器由多个单元格组成，则可以创建一个集合单元格模型，然后在其中为其元素指定单元格模型。等等。</p>   <aside class="tip sideblock" rel="529204c5" id="a5679bac" data-title="">      <p id="d4c94493">有关MPS编辑器的快速操作文档，请查看<a href="editor-cookbook.html">编辑器食谱</a> 。</p>   </aside>      <h2 id="typesofcellmodels">细胞模型的类型</h2>   <div class="table-wrapper"><table width="100%" id="d8cb0a4f"><thead><tr id="704778ee" class="ijRowHead"><th id="1272cbe1">            <h4 id="constant cell">恒定细胞</h4>         </th><th id="d005a388">            <p id="947e5dca">               <img alt="常数池" title="常数池" src="/help/img/idea/2019.2/ConstantCell.png" id="7d61f3c6" width="79" height="18" class="inline-icon-79">此模型描述了一个始终包含相同文本的单元格。常数单元通常以基于文本的编程语言反映“关键字”。</p>         </th></tr></thead><tbody><tr id="81ae6191" class="ijRowOdd"><td id="97e5e6cc">            <h4 id="collectioncell">收集池</h4>         </td><td id="45edf214">            <p id="59c1567b">包含其他单元格的单元格。可以水平<img alt="HorizontalCollection" title="HorizontalCollection" src="/help/img/idea/2019.2/HorizontalCollection.png" id="9c037ae7" width="106" height="18" class="inline-icon-106"> （集合中的单元格排成一行），垂直</p><figure><img alt="垂直收藏" title="垂直收藏" src="/help/img/idea/2019.2/VerticalCollection.png" id="636c30f1" width="86" height="48"></figure>（单元格彼此位于顶部）或具有所谓的“缩进布局” <img alt="缩进集合" title="缩进集合" src="/help/img/idea/2019.2/IndentCollection.png" id="496fef60" width="112" height="18" class="inline-icon-112"> （单元格是水平排列的，但如果一行太长，则将其像文本一样包裹到下一行，并在每行下缩进）。<br>在Inspector中，您可以指定结果单元格集合是否将使用折叠，以及是否将使用括号。折叠允许您的单元格列表收缩为单个单元格（折叠），并在必要时从其扩展（展开）。这对于程序员在编辑大型词根时用您的语言编写很有用：他/她能够折叠一些单元格并隐藏当前任务不需要的所有信息。例如，当编辑一个大类时，可以折叠除他/她当前正在编辑的方法之外的所有方法主体。<br><b id="5b68d509">默认情况下</b> ， <b id="5b68d509">折叠</b>属性设置为true时，将确保该集合在首次显示时显示为折叠状态，除非用户手动将其展开。<p></p>            <p id="d37291a7">收集单元还可以指定<b id="9abffc6c">Context助手</b> ，该<b id="9abffc6c">助手</b>将为用户提供直观的视觉动作。有关详细信息，请查看<a href="context-assistant.html">Context Assistant文档</a> 。</p>         </td></tr><tr id="10a0084d" class="ijRowEven"><td id="69178f7c">            <h4 id="propertycell">属性单元</h4>         </td><td id="2ba29012">            <p id="9709a28e">               <img alt="PropertyCell" title="PropertyCell" src="/help/img/idea/2019.2/PropertyCell.png" id="8a062457" width="91" height="18" class="inline-icon-91">该单元模型描述了一个单元，该单元将显示节点某个属性的值。可以在属性单元格中编辑属性的值，因此，属性单元不仅用作视图，还用作控制器。在检查器中，您可以指定属性单元格是只读的还是允许其属性值被编辑。</p>         </td></tr><tr id="df3f9827" class="ijRowOdd"><td id="0a234e73">            <h4 id="childcell">子细胞</h4>         </td><td id="b72c127b">            <p id="d9363d06">               <img alt="子细胞" title="子细胞" src="/help/img/idea/2019.2/ChildCell.png" id="8ecfd4c3" width="70" height="18" class="inline-icon-70">该单元模型包含对节点概念中某个链接声明的引用。结果单元格将包含链接目标的编辑器（几乎总是针对子对象，而不是针对对象）。例如，如果您有一个二进制操作，例如说“ +”，并带有两个子对象“ leftOperand”和“ rightOperand”，则该操作的编辑器模型如下：缩进收集单元格，其中包含左操作数的引用节点单元格，带有“ +”的常量单元格以及右操作数的引用节点单元格。它将被呈现为右操作数的编辑器，然后是带有“ +”的单元格，然后是左操作数的编辑器（按行排列）。正如我们所看到的，以及其名称所代表的含义，这种类型的单元格模型通常用于显示子级编辑器。</p>         </td></tr><tr id="6a0843db" class="ijRowEven"><td id="048f159b">            <h4 id="referentcell">参照单元格</h4>         </td><td id="aaff258c">            <p id="20918e95">               <img alt="参考单元" title="参考单元" src="/help/img/idea/2019.2/ReferenceCell.png" id="3ceefb92" width="204" height="18" class="inline-icon-204">主要用于显示参考目标。引用单元格和子单元格之间的主要区别在于，我们不需要或不希望显示参考目标的整个编辑器。例如，当某个节点（例如类类型）引用了Java类时，我们不想显示该类的整个编辑器及其方法，字段等。我们只想显示它的名字。因此，子单元不能用于此目的。一个应该使用参照单元格。<br>使用“参照”单元格，您可以显示参照目标的其他内联编辑器，而不是使用目标自身的编辑器。在大多数情况下，这非常简单：引用目标的单元格通常仅包含具有目标名称的属性单元格。</p>         </td></tr><tr id="8c3170a1" class="ijRowOdd"><td id="5a35b910">            <h4 id="childlistcell">子清单储存格</h4>         </td><td id="c6ae9c6b">            <p id="75833941">               <img alt="ChildListCell" title="ChildListCell" src="/help/img/idea/2019.2/ChildListCell.png" id="26690f8f" width="269" height="18" class="inline-icon-269">该单元是一个集合，其中包含节点角色相同的子代的多个子代单元。例如，方法调用的编辑器将包含一个子列表单元格，用于呈现其实际参数。子列表可以缩排（类似文本），水平或垂直。<br>从此单元模型生成的单元支持插入和删除给定角色的子级，因此既充当视图又充当控制器。插入的默认键是“插入”和“ Enter”（分别在选定的一个之前或之后插入一个子级），删除的默认键是“删除”。您还可以为列表指定分隔符。<br>分隔符是一个字符，将在儿童单元格之间的恒定单元格中显示。当您在单元格列表中并按具有此字符的键时，将在所选子项之后插入一个新子项。例如，表示方法调用中实际参数的列表的分隔符是逗号。<br>在Inspector中，您可以指定结果单元格列表是否将使用折叠以及是否使用花括号。折叠允许您的单元格列表收缩为单个单元格（折叠），并在必要时从其扩展（展开）。这对于程序员在编辑大型词根时用您的语言编写很有用：他/她能够折叠一些单元格并在编辑器中隐藏当前当前任务不需要的所有信息。例如，当编辑一个大类时，可以折叠除他/她当前正在编辑的方法之外的所有方法主体。</p>         </td></tr><tr id="fdc2398f" class="ijRowEven"><td id="633c0daf">            <h4 id="indentcell">缩进单元</h4>         </td><td id="23400c8b">            <p id="ca3adb77">               <img alt="缩进单元" title="缩进单元" src="/help/img/idea/2019.2/IndentCell.png" id="f53e6403" width="31" height="18" class="inline-icon-31">缩进单元格模型将生成为包含空白的不可选择的常数单元格。从缩进单元格生成的单元格与从包含空格作为文本的恒定单元格模型生成的单元格之间的主要区别在于，缩进单元格的宽度将根据用户定义的全局编辑器设置而变化。例如，如果用户将缩进定义为4个空格长，则每个缩进单元将占用4个字符的空格；如果长度为2个空格，则每个缩进单元将为2个字符。</p>         </td></tr><tr id="b26709d1" class="ijRowOdd"><td id="c1ad7f77">            <h4 id="uicomponentcell">UI组件单元</h4>         </td><td id="1cae70e9">            <p id="1e057a59">               <img alt="ComponentCell" title="ComponentCell" src="/help/img/idea/2019.2/ComponentCell.png" id="585ae9b0" width="140" height="18" class="inline-icon-140">该单元模型允许语言设计人员在节点的编辑器内插入任意UI组件。语言设计人员应编写一个返回JComponent的函数，并将该组件插入生成的单元格中。请注意，每次重建编辑器时都会重新创建这样的组件，因此请勿尝试在组件内部保留任何状态。每个状态都应取自模型（即节点，其属性和引用）并写入模型-而不是视图（您的组件）。<br>这种单元模型的一个好用例是在属性中保留某个文件的路径，而您的组件是一个激活模式文件选择器的按钮。从上述属性中读取文件选择器中的默认选定路径，并将用户选择的文件路径写入该属性。</p>         </td></tr><tr id="31dfa5ae" class="ijRowEven"><td id="c55bc7d1">            <h4 id="modelaccess">模型访问</h4>         </td><td id="ca53dcd8">            <p id="12c47472">               <img alt="型号Acces" title="型号Acces" src="/help/img/idea/2019.2/ModelAcces.png" id="0c6f0ae7" width="119" height="18" class="inline-icon-119">模型访问单元模型是属性单元的概括，因此更加灵活。虽然属性单元格仅显示属性值并允许用户更改值，但是模型访问单元格可以根据节点的状态显示任意文本，并根据用户所做的更改以任意方式修改节点到单元格的文本。<br>使属性单元格工作仅需要指定通过该单元格访问的属性，而使模型访问单元格工作则需要语言设计人员编写三种方法：“获取”，“设置”和“验证”。后两个是可选的。<br>“ get”方法使用一个节点，并应返回一个String，它将显示为单元格的文本。“设置”方法采用String（单元格的文本），并在必要时根据此String修改节点。“验证”方法获取单元格的文本并返回它是否有效。如果更改用户后单元格中的文本无效，则该文本将标记为红色，并且不会传递给“ set”方法。<br>如果未指定“验证”方法，则单元格将始终有效。如果未指定“设置”方法，则单元格文本中的任何更改都不会影响其节点本身。</p>         </td></tr><tr id="a7024178" class="ijRowOdd"><td id="82282b49">            <h4 id="nextapplicableeditor">下一个适用的编辑器</h4>         </td><td id="d63ea9e3">            <p id="155321a8">更加具体的编辑器可以通过新的<b id="33efbdb3">下一个适用的编辑</b>器<b id="33efbdb3">编辑</b>器单元重用同一概念的不太具体的<b id="33efbdb3">编辑</b>器。<b id="fbebf046">下一个适用的编辑器</b>单元用作占位符，它将重新应用查找不太具体的编辑器的逻辑，并将找到的编辑器插入其位置。例如，特定于特定<b id="ca64f0a1">上下文提示</b>的编辑器可以<b id="21872135">在下一个适用的编辑器</b>单元周围提供一些视觉仪式。通过删除<b id="48ec4d52">下</b> <b id="c070bf3d">一个适用的编辑器</b>单元上的<b id="48ec4d52">上下文提示</b> ，MPS将重新评估编辑器发现逻辑，并将找到的编辑器提供给<b id="32c78a86">下一个适用的编辑器</b>单元。</p>            <p id="fa02367a">               </p><figure><a class="lightbox" href="/help/img/idea/2019.2/next1.png"><img alt="下一个" title="下一个" src="/help/img/idea/2019.2/next1.png" id="9eff4ac8" width="100" height="576"></a></figure>               <br>特别是，在定制通用<b id="538a87f9">注释</b>功能时，经常使用此机制为“注释”节点实现编辑器。<p></p>         </td></tr><tr id="bcae6fb2" class="ijRowEven"><td id="20a6b90a">            <h4 id="customcell">自定义单元</h4>         </td><td id="9ee05b08">            <p id="7f3f0bdc">               <img alt="CustomCell" title="CustomCell" src="/help/img/idea/2019.2/CustomCell.png" id="13cbd1c7" width="112" height="18" class="inline-icon-112">如果其他单元格模型不足以使语言设计师创建他/她想要的编辑器，那么他/她还有一个选择：创建一个单元格提供程序，该提供程序将返回任意自定义单元格。唯一的限制是它应该实现“ EditorCell”接口。</p>         </td></tr></tbody></table></div>      <h3 id="editorcomponentsandeditorcomponentcells">编辑器组件和编辑器组件单元</h3>   <p id="98515917">有时，针对不同概念的两个或多个编辑器声明具有一个公共部分，在每个这些编辑器中都有相同的部分。为了避免冗余，有一种称为编辑器组件的机制。您可以指定要为其创建编辑器组件的概念，并创建一个单元模型，就像在概念编辑器声明中一样。编写时，该组件可随后在编辑器声明中用于任何指定概念的后代。要在编辑器声明中使用编辑器组件，将创建一个特定的单元模型：编辑器组件单元模型，并将您的编辑器组件声明设置为该单元模型引用的目标。</p>      <h2 id="celllayouts">单元格布局</h2>   <p id="41ad475d">每个收集单元都有“单元布局”属性，该属性描述子节点的放置方式。有几种布局：</p>   <ul class="list _ul"><li class="list__item" id="023e4fc0"><p>缩进版式-放置像文本一样的单元格。</p></li><li class="list__item" id="e8eb1dfc"><p>水平布局-将单元格水平放置在行中。</p></li><li class="list__item" id="3327c587"><p>垂直布局-垂直放置单元格。</p></li></ul>   <p id="e539f780"><b id="024b3250">缩进布局</b>单元格提供了一些属性以自定义布局，某些属性适用于布局单元格本身，某些属性适用于布局单元格内的单元格：</p>   <ul class="list _ul"><li class="list__item" id="7fe5ec03"><p>indent-layout-indent-如果此单元格显示为第一行，则该单元格将带有<i id="632c0940">缩进</i></p></li><li class="list__item" id="6abfa31a"><p>indent-layout-new-line-此单元格将是一行中的最后一个</p></li><li class="list__item" id="23ec3e72"><p>indent-layout-on-new-line-此单元格将在下一行第一</p></li><li class="list__item" id="c20ba920"><p>indent-layout-new-line-children-此收集单元格的所有子单元格将显示在单独的行上</p></li><li class="list__item" id="c625b9ef"><p>indent-layout-wrap-anchor-当此收集单元的子单元超出屏幕宽度时，它们将被包裹以与该收集垂直对齐</p></li><li class="list__item" id="4ef100b2"><p>indent-layout-indent-anchor-所有后续缩进将相对于当前收集单元的缩进进行计算</p></li><li class="list__item" id="9dd3f802"><p>indent-layout-no-wrap-绝对不能包装单元，这样它才能以新行开头</p></li></ul>      <h2 id="styles">款式</h2>   <p id="b690b10f">编辑器单元的样式为语言设计人员提供了一种非常强大的方法来提高代码的可读性。以不同的颜色或字体显示关键字，常量，调用，定义，表达式，注释和其他语言元素有助于开发人员更轻松地掌握语法。您还可以使用样式将编辑器的区域屏蔽为只读，以使开发人员无法对其进行编辑。</p>   <p id="6913983b">每个单元模型都有一些外观设置，这些设置决定了单元的显示方式。例如，它们是<i id="5e24388e">字体颜色</i> ， <i id="e5db965f">字体样式</i> ，是否<i id="4defda9e">可选择</i>单元格等。这些设置组合成一个称为<i id="6ba9b471">样式表</i>的实体。<b id="3aff304f">样式表</b>可以是<b id="a5148f8f">内联的</b> ，即与特定的单元模型一起描述，也可以单独<b id="e2405736">声明</b>并在许多单元模型中使用。在<i id="d15496bd">Inspector视图中</i>为每个单元格都指定了<b id="8f211489">内联样式表</b>和<b id="ffc694de">样式引用</b> 。</p>   <p id="2eb52706">      </p><figure><img alt="样式2" title="样式2" src="/help/img/idea/2019.2/style2.png" id="84d9cef6" width="404" height="287"></figure>   <p></p>   <p id="1048a1a0">      </p><figure><img alt="样式1" title="样式1" src="/help/img/idea/2019.2/style1.png" id="f1354487" width="394" height="250"></figure>   <p></p>   <p id="08ed6f9b">这些设置不必由单个值指定。<b id="e27b3d21">查询</b>选项也可用于所有设置，在这种情况下，开发人员需要实现概念功能，并返回所需的值：</p>   <p id="5fcc8d17">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/image2017-10-19-18-2-53.png"><img alt="image2017 10 19 18 2 53" title="image2017 10 19 18 2 53" src="/help/img/idea/2019.2/image2017-10-19-18-2-53.png" id="12a4f7fd" width="500" height="260"></a></figure>   <p></p>   <p id="0465f085">声明一些样式表用于不同目的是一种好习惯。另一个好的做法是，在开发适用于您的语言的编辑器以及开发适用于您的语言的扩展时，请牢记样式指南。例如，在<i id="02d46798">BaseLanguage中，</i>有关键字（适用于<i id="f09fb77e">BaseLanguage</i>编辑器中的那些常数单元格，与Java中的关键字相对应），静态字段（适用于静态字段声明和静态字段引用），实例字段，数字文字，字符串的样式文字等等。开发<i id="577e9b46">BaseLanguage</i>的扩展时，应将关键字样式应用于新关键字，将字段样式应用于新类型的字段，等等。</p>   <p id="2c34938c"><b id="9bbe95bd">样式表</b>与CSS样式表非常相似；它由样式类列表组成，其中指定了一些样式属性的值。MPS还提供了一种扩展样式以及覆盖属性值的机制。</p>      <h2 id="styleproperties">样式属性</h2>      <h3 id="booleanstyleproperties">布尔样式属性</h3>   <ul class="list _ul"><li class="list__item" id="3d9b44f4"><p>         <i id="e9f4b086">可选</i> -是否可以选择单元格。默认为True。</p></li><li class="list__item" id="c0504aff"><p>         <i id="f802d707">只读</i> -是否可以修改单元格和嵌套单元格。默认为<i id="0ecdbf81">False</i> 。设计用于冻结细胞树的片段。</p></li><li class="list__item" id="ed19e668"><p>         <i id="781a2c40">可编辑</i> -是否可以修改单元格中的文本。对于恒定像元模型，默认情况下为<i id="0521242f">false</i> ，对于其他像元模型，则为true。</p></li><li class="list__item" id="5f44bee8"><p>         <i id="31c03b87">绘制边框</i> -是否在单元格周围绘制边框</p></li><li class="list__item" id="0101a31a"><p>         <i id="becb8b76">绘制括号</i> -是否在单元格周围绘制括号</p></li><li class="list__item" id="9ff9ce5d"><p>         <i id="4d0cab7d">第一位置允许</i> / <i id="5938f57e">最后位置允许</i> -对于包含文本的单元格，指定是否允许插入符号位于第一/最后位置（即单元格整个文本之前/之后）</p></li></ul>   <p id="acde7a1c">您可以从完成菜单中选择属性值，也可以指定查询（即返回布尔值的函数）。</p>   <p id="292070ff">      </p><figure><img alt="样式3" title="样式3" src="/help/img/idea/2019.2/Style3.png" id="5348a60b" width="624" height="167"></figure>   <p></p>      <h3 id="paddingproperties.">填充属性。</h3>   <ul class="list _ul"><li class="list__item" id="5d5d8050"><p>         <i id="ce4a81e4">padding-left / right / top / bottom-</i>一个浮点数，它指定文本单元格的填充，即，单元格的文本与单元格的左侧和右侧之间分别有多少空间。</p></li></ul>      <h3 id="punctuationproperties.">标点属性。</h3>   <p id="3f3bdf70">默认情况下，集合中的所有单元格都用一个空格分隔。有时我们需要将细胞放置在一起。</p>   <ul class="list _ul"><li class="list__item" id="4bc23e7b"><p>         <i id="0e00144c">标点左侧</i> -如果此属性为true，则删除单元格左侧的空间，并且不允许在单元格中的第一个位置。</p></li><li class="list__item" id="f3b906ff"><p>         <i id="8c77ba35">标点右对齐</i> -如果此属性为true，则删除单元格右侧的空格，并且不允许在单元格中的最后一个位置。</p></li><li class="list__item" id="01cb421e"><p>         <i id="252621f3">水平间隙</i> -指定集合中单元格之间的间隙大小。默认值为1个空格。</p></li></ul>   <p id="353ff532">例如在代码中</p>   <div class="code-block" data-lang="none">（1 +1）</div>   <p id="15652b6f">我们不希望在“（”和“ 1”之间以及“ 1”和“）”之间存在空格。因此，我们应在单元格“（”和“ property”中添加属性标点符号<br>标点符号-左移至单元格“）”。</p>      <h3 id="colorstyleproperties">颜色样式属性</h3>   <ul class="list _ul"><li class="list__item" id="53e90712"><p>文本前景色-单元格文本的颜色（仅影响文本单元格）</p></li><li class="list__item" id="4cc519ce"><p>文本背景颜色-单元格文本的背景色（仅影响文本单元格）</p></li><li class="list__item" id="c73b95e9"><p>背景色-单元格的背景色。影响任何细胞。如果文本单元格具有非零填充和某些文本背景色，则该单元格的背景色将为其边距的颜色。<br>您可以从完成菜单中选择一种颜色，也可以指定一个查询，即返回颜色的函数。</p></li></ul>      <h3 id="indentlayoutproperties">缩进布局属性</h3>   <ul class="list _ul"><li class="list__item" id="6c2a04f4"><p>         <i id="e48d4184">indent-layout-indent-</i>所有行均以<i id="e48d4184">缩进</i>方式放置。此属性可用于缩进代码块。</p></li></ul>   <p id="ee0a912b">      </p><figure><img alt="BlockStatementEditor" title="BlockStatementEditor" src="/help/img/idea/2019.2/BlockStatementEditor.PNG" id="03fbedea" width="630" height="358"></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="8429b8a3"><p>         <i id="963522ee">indent-layout-new-line-</i>此单元格后将有一个新行标记。</p></li></ul>   <p id="a9b55821">      </p><figure><img alt="SwitchCaseEditor" title="SwitchCaseEditor" src="/help/img/idea/2019.2/SwitchCaseEditor.PNG" id="1c95640d" width="337" height="326"></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="aaf75cbc"><p>         <i id="046c9288">在新行上缩进布局</i> -此单元格将放置在新行上</p></li></ul>   <ul class="list _ul"><li class="list__item" id="477f71b4"><p>         <i id="a906b535">indent-layout-new-line-children-</i>集合的所有子代都将放在新行上</p></li></ul>   <p id="3974eccc">      </p><figure><img alt="StatementListEditor" title="StatementListEditor" src="/help/img/idea/2019.2/StatementListEditor.PNG" id="76cc8bb5" width="706" height="324"></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="23950577"><p>         <i id="220cf387">indent-layout-no-wrap-</i>在此单元格之前不会<i id="220cf387">换</i>行</p></li></ul>      <h3 id="otherstyleproperties">其他样式属性</h3>   <ul class="list _ul"><li class="list__item" id="e0fbc701">         <i id="0289752a">字体系列</i>      </li><li class="list__item" id="58243302">         <i id="05338391">字体大小</i>      </li><li class="list__item" id="f7aa789d"><p>         <i id="fc7f8f7c">字体样式</i> -可以是普通，粗体，斜体或粗斜体。</p></li><li class="list__item" id="b7f9b455">         <i id="e7aa346a">布局约束</i> -<ul class="list _ul"><li class="list__item" id="5275de34">用于流布局<ul class="list _ul"><li class="list__item" id="54b7b1b2"><p>无-默认行为</p></li><li class="list__item" id="9bb9c117"><p>标点-表示流布局中的上一个项目应始终与该约束分配到的项目位于同一行。</p></li><li class="list__item" id="03ebfec7"><p>noflow-从流布局中排除单元格。当前行已完成，项目已放置在其下方。此项之后，将开始新的一行并应用常规流布局。此样式可用于将图片嵌入文本中。</p></li></ul>            </li></ul>      </li><li class="list__item" id="68707ac3"><p>         <i id="f1a56c6f">带下划线的</i> -可以带下划线，不带下划线或按原样显示（“按原样”表示它取决于封闭细胞集合的属性）。</p></li></ul>      <h3 id="stylepropertiespropagation">样式属性传播</h3>   <p id="0a018fe5">虽然某些样式属性仅影响应用它们的单元格，但其他属性的值将向下推到单元子树（嵌套单元格）并应用到它们，直到某些子单元格为其属性指定其自己的值。向下推到单元层次结构的此类可继承属性包括<i id="90296b89">text-foreground-color</i> ， <i id="8f23d3df">text-background-color</i> ， <i id="ee3e39e2">background-color</i> ， <i id="c1e04cfe">font-style</i> ， <i id="e2283483">font-size</i>等。</p>   <h3 id="customstyles">自定义样式</h3>   <p id="186ad649">语言设计人员可以在样式表中定义自己的样式属性，然后在编辑器中使用它们。这增加了语言编辑器定义的灵活性。这些属性可以保存不同类型的值，并且可以选择提供默认值。</p>   <p id="6c26485a">      </p><figure><img alt="风格500" title="风格500" src="/help/img/idea/2019.2/styles500.png" id="ea7c55bc" width="292" height="123"></figure>   <p></p>   <p id="91a856a6">有两种类型的自定义样式属性：</p>   <ul class="list _ul"><li class="list__item" id="5aa50e46"><p>简单-仅应用于单个编辑器单元</p></li><li class="list__item" id="00ed9f1d"><p>继承-递归应用于单元格及其所有后代单元格</p></li></ul>   <p id="3e0d26c5">为了在编辑器定义中使用style属性，您的语言必须导入定义属性的语言，而<i id="ef303dcc">编辑器</i>方面必须在使用的语言中列出定义语言。<br>要从<i id="f676a135">BaseLanguage</i>代码中引用自定义属性，您需要导入<i id="50293bef">jetbrains.mps.lang.editor</i>以访问<i id="813020f4">StyleAttributeReferenceExpression</i>概念。</p>   <div class="code-block" data-lang="none">EditorCell单元格= ...cell.getStyle（）。get（styleAttribute / myValue /）;</div>   <h3 id="styleinheritance">样式继承</h3>   <p id="151702a6">为了真正可用，样式类需要一种扩展机制，以便描述特定的样式类继承所有样式属性的值，而这些属性不会被显式覆盖。我们可以使用特殊的样式属性<i id="ac05d070">将</i>父样式类中指定的所有属性的值复制到样式类中。使用<i id="77c7d54f">apply</i>属性在语义上等效于从父样式类复制粘贴所有属性。<i id="a1893f6a">apply-if</i>变体也可用于有条件地应用样式属性值。与传统的样式扩展不同，apply机制允许从多个类继承。</p>   <p id="d144e034"><i id="486b7454">unapply</i>属性允许样式类停止选定继承属性的影响。例如，注释掉的代码的样式类将压低使代码元素看起来全部为灰色的样式。但是，可能需要以通常的颜色来显示链接，以便用户可以发现它们并可能单击它们。</p>   <p id="fcdc30a9">在父样式中指定的属性和/或在继承单元格中显式定义的属性之间的潜在冲突将按顺序解决。最后指定的值将覆盖同一style属性的所有先前值。</p>   <p id="6d1c4745">例如， <i id="a461210b">ConsoleRoot</i>概念提供了一个只读编辑器，其中只有一个点（ <i id="21ae5907">commandHolder</i>单元格），允许进行编辑。首先在编辑器上设置<i id="35215dd4">readOnly</i>样式类：</p>   <p id="4b83bd5b">      </p><figure><img alt="样式4" title="样式4" src="/help/img/idea/2019.2/style4.png" id="65d7ea36" width="506" height="297"></figure>   <p></p>   <p id="9b92ee0f">然后将<i id="108aff1c">readOnly</i>样式类<i id="a7ed8412">不适</i>用于<i id="a7ed8412">commandHolder</i>单元：</p>   <p id="a65901d7">      </p><figure><img alt="样式5" title="样式5" src="/help/img/idea/2019.2/style5.png" id="2df21545" width="507" height="297"></figure>   <p></p>   <p id="35df4f5e"><i id="fd733fc1">readOnly</i>样式类的定义如下：</p>   <p id="491034b6">      </p><figure><img alt="风格30" title="风格30" src="/help/img/idea/2019.2/style30.png" id="7d721e2b" width="339" height="105"></figure>   <p></p>   <h3 id="stylepriorities">风格优先</h3>   <p id="4416dfc7">可以声明一个样式类优先于某些其他样式类或多个类。</p>   <ol class="list _decimal"><li class="list__item" id="34354b1d"><p>如果样式类不支配一切，则为<b id="70ca5500">低层样式类</b> 。</p></li><li class="list__item" id="53c357ca"><p>如果某个样式类声明为主导，但未指定其<i id="abf18d79">主导</i>的样式类（未指定任何样式类，但单词<i id="78255a39">在</i>当前<i id="78255a39">之上主导</i> ），则该样式类被视为主导所有低级样式类。</p></li><li class="list__item" id="fa3ba68a"><p><i id="2ec00c4e">支配关系</i>是可<b id="fedcd347">传递的</b> ，不允许<b id="70897b75">循环</b> 。</p></li></ol>   <p id="2a596138">统治关系仅对具有可继承属性的样式有意义。当某个样式属性的一个值从父项下推，并且在应用于当前单元格的样式类中指定了同一属性的另一个值时，所得行为取决于两个样式类之间的关系：</p>   <ol class="list _decimal"><li class="list__item" id="29723bba"><p>如果两个样式类都是<b id="1e4fce33">低级的</b> ，则将从parent推入的值将被忽略，并替换为当前单元格的样式类中的值。</p></li><li class="list__item" id="32978591"><p>如果一个样式类优于另一个样式类，则两个值都将保留并向下推，但是占主导地位的样式类中的值将隐藏另一个样式类中的值。</p></li><li class="list__item" id="222be9cf"><p>但是，如果在某个子单元格中未应用主导样式的类（特殊样式属性为<i id="9f26a887">unapply</i> ），则其他样式类的值将成为该属性的结果值。</p></li></ol>   <p id="de9dbbf1">例如，包含单词TODO的注释的样式应比普通注释更突出。因此，表示注释的语言概念需要应用TODO感知样式（ <i id="3d1db72d">TODO_Style</i> ），该样式声明其在普通<i id="1975408a">Comment_Style上的</i>优势。但是，仅当注释确实包含TODO文本（isToDo（））时，才应用实际的样式属性，否则将使用普通的<i id="5e9390a8">Comment_Style</i>属性。</p>   <p id="d34c488b">      </p><figure><img alt="风格7" title="风格7" src="/help/img/idea/2019.2/style7.png" id="f48465e9" width="893" height="83"></figure>   <p></p>   <p id="33bc3d40">使用<i id="12242a27">“添加优势”</i>意图将domins <i id="1885c3b9">over</i>子句附加到样式：</p>   <p id="84d48716">      </p><figure><img alt="风格31" title="风格31" src="/help/img/idea/2019.2/style31.png" id="bed6c5a0" width="244" height="103"></figure>   <p></p>   <h2 id="cellactions">细胞动作</h2>   <p id="bc078d33">每个单元模型可能都有一些与之关联的动作。此类操作旨在提高编辑的可用性。您可以在任何单元模型的检查器中指定它们。</p>      <h3 id="keymaps">按键图</h3>   <p id="804cfaa7">您可以为单元模型指定对键映射的引用。按键图是一个根概念-一组按键图项目，每个项目都包含一个击键和一个要执行的动作。从单元格模型生成并参考某个键映射的单元格将在击键时执行适当的操作。</p>   <p id="f40ca505">在键映射中，必须指定一个适用于键映射的概念。例如，如果要对表达式执行某些操作，则必须将Expression指定为适用的概念；那么您可以仅为包含在Expression后代的编辑器声明中的那些单元格模型指定这样的键映射，否则为类型错误。</p>   <p id="0370381d">如果键映射属性“ everyModel”为“ true”，则此键映射的行为就像为编辑器中的每个单元格指定的一样。当您有某个概念的许多后代，而这些后代又有许多不同的编辑器，并且您的键映射适用于它们的祖先时，这将很有用。如果将其标记为“每个模型”键映射，则无需在每个编辑器中都指定这样的键映射。</p>   <p id="740c1d88">按键映射项包含以下功能：</p>   <ul class="list _ul"><li class="list__item" id="04aecb7d"><p>触发键映射项时执行的功能（不返回任何内容）</p></li><li class="list__item" id="a44f9afc"><p>一组触发此按键映射项的按键</p></li><li class="list__item" id="3958e9b5"><p>一个布尔函数，用于确定键映射项在此处是否适用（如果未指定，则始终适用）。如果按键映射项在被触发时不适用，则它将不会执行任何操作。</p></li><li class="list__item" id="a9ecbeb3"><p>您可以为关键映射项目指定插入符号策略。插入符号策略表示应在单元格中的何处放置此关键映射项以启用。插入符号策略可以是第一个位置，最后一个位置，中间位置或任何位置。默认情况下，插入符号策略是“任何位置”。如果单元中的插入符在被触发时与键映射项的插入符策略不匹配，则此键映射项将不执行操作。</p></li></ul>      <h3 id="actionmaps">动作图</h3>   <p id="ddf28c87">单元模型可以包含对动作图的引用。动作图会覆盖某个概念的某些默认单元动作。一个动作图由几个动作图项组成。在操作图中，必须指定适用于该操作图的概念。</p>   <p id="1d534153">动作图项包含：</p>   <ul class="list _ul"><li class="list__item" id="ffb95d8d"><p>一个动作描述，它是一个字符串，</p></li><li class="list__item" id="b0e7aef6"><p>和执行动作的功能（不返回任何内容）。</p></li></ul>   <p id="d07f9139">动作映射项可能会覆盖默认动作之一（请参阅动作）。例如，当您在其编辑器中有一个没有任何操作映射的return语句，并在带有关键字“ return”的单元格上按Delete时，整个语句将被删除。但是，您可以指定一个包含删除动作映射项的动作映射，它不仅仅是删除return语句，而是将其替换为一个表达式语句，该表达式语句包含与删除的return语句相同的表达式。</p>动作DELETE描述： <no description="">执行：（节点，editorContext）-> void {节点<ExpressionStatement> expressionStatement =节点。用new（ExpressionStatement）替换； expressionStatement。表达。设置（node。expression）; }<p id="c23d1fa1">SELECT_ALL操作可以选择编辑器的全部内容，并由<i id="d2dd7034">Control / Cmd + A</i>触发，也可以通过<b id="012613e3">操作映射</b>进行自定义。的<code class="code">jetbrains.mps.nodeEditor.selection.SelectUpUtil</code>上课<code class="code">executeWhile</code>可以利用此方法指定此操作的选择上限。</p>   <p id="5dddbab2">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/mps-selectall.png"><img alt="mps全选" title="mps全选" src="/help/img/idea/2019.2/mps-selectall.png" id="d070e29b" width="500" height="518"></a></figure>   <p></p>   <p id="9b83595e">现有动作图的动作图项可以通过<b id="b3960c49">导入</b>在新动作图中重用。用户有两个选择：</p>   <ul class="list _ul"><li class="list__item" id="284af3ec"><p>从动作图导入所有项目</p></li><li class="list__item" id="0a69be3b"><p>仅导入具有给定操作ID的项目</p></li></ul>   <p id="5655d833">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/image2018-9-14-13-23-37.png"><img alt="image2018 9 14 13 23 37" title="image2018 9 14 13 23 37" src="/help/img/idea/2019.2/image2018-9-14-13-23-37.png" id="57c1b518" width="500" height="700"></a></figure>   <p></p>   <p id="944ad025">导入操作遵循以下规则：</p>   <ul class="list _ul"><li class="list__item" id="4f47b352"><p>暂时导入工作。</p></li><li class="list__item" id="90315bad"><p>在当前单元格动作图中定义的动作优先于在任何导入的单元格动作图中定义的动作。</p></li><li class="list__item" id="ffaa73c9"><p>如果多个导入的地图定义了相同类型的操作，则最新导入的优先。</p></li><li class="list__item" id="01c70ba4"><p>不允许循环导入。</p></li><li class="list__item" id="74f11ce3"><p>任何导入的单元格动作图的适用概念都必须是该图的适用概念相同的概念或超概念。</p></li><li class="list__item" id="e97b35e3"><p>动作图导入跨语言工作：一种语言的编辑器方面的动作图可以从另一种语言的编辑器方面导入动作图。</p></li></ul>   <p id="337fe26b">DELETE和BACKSPACE操作处理程序具有特定的语义。如果操作映射<b id="9604e80c">定义或导入</b>了DELETE处理程序，而<b id="476995bb">没有定义或导入</b> BACKSPACE处理程序，则将自动注册一个与DELETE相同的默认BACKSPACE处理程序。</p>   <p id="678db2dc">导入的动作处理程序的解析是动态的（在运行时发生。当动作图A从动作图B导入项目时，将在动作图A的生成时未解析将要注册的确切动作处理程序。而是生成了将在运行时注册动作图B提供的处理程序的代码。结果，当动作图B改变时，不必重新生成动作图A。</p>      <h2 id="cellmenus">单元菜单</h2>   <p id="854ebe0a">可以为某个单元格指定自定义完成菜单。打开用于单元格声明的检查器，找到一个名为Common的表，找到一个名为menu的行，创建一个新的单元格菜单描述符。单元菜单描述符由菜单部分组成，这些菜单部分具有不同的种类，下面将进行讨论。</p>      <h3 id="propertyvaluesmenupart">属性值菜单部分</h3>   <p id="6d3afb72">此菜单部分在属性单元格上可用，它指定属性的属性值列表，该列表将在完成时显示。应该编写一个返回list类型值的函数<string>。</string></p>      <h3 id="propertypostfixhintsmenupart">属性后缀提示菜单部分</h3>   <p id="4c892881">该菜单部分在属性单元格上可用，它指定了一个字符串列表，这些字符串用作属性值的“良好”后缀。在这样的菜单部分中，应该编写一个函数，该函数返回list类型的值<string>。如果您希望MPS“猜测”某个属性的良好价值，则此菜单很有用。例如，可能会决定它将是一个好的变量名，该变量名是变量类型名，但首字母小写，或者以其类型名结尾：对于类型为“ Foo”的变量，好名将是“ foo”。 “，” aFoo“，” firstFoo“，” goodFoo“等。因此，应该在变量单元格的属性单元菜单中的变量声明编辑器中编写变量名称，例如菜单部分：</string></p>属性后缀提示后缀：（作用域，操作上下文，节点）->列表<string>{列表<字符串>结果； node <类型> nodeType =节点。类型;如果（nodeType！= null）{结果= MyUtil.splitByCamels（nodeType。getPresentation（））; } else {结果=新列表<字符串> {空};返回结果； }<p id="e2c09b12">其中splitByCamels（）将是一个函数，该函数返回以大写字母开头的字符串的后缀列表（例如MyFooBar-> MyFooBar，FooBar，Bar）。</p>      <h3 id="primaryreplacechildmenu">主替换子菜单</h3>   <p id="7020c1a2">这是一个单元菜单部分，它返回子级的主要操作（默认情况下，好像没有单元菜单一样）。</p>      <h3 id="primarychoosereferentmenu">主要选择参照菜单</h3>   <p id="12f04161">这是一个单元菜单部分，它返回引用对象的主要操作（默认情况下，就像没有单元菜单一样）。</p>      <h3 id="replacenodemenu(customnode'sconcept)">替换节点菜单（自定义节点的概念）</h3>   <p id="53b6b56b">这种单元菜单部分允许用某个指定概念及其子概念的实例替换已编辑的节点（即，在其上调用完成菜单的节点）。例如，当您希望节点编辑器的特定单元格负责替换整个节点时，这样的单元格菜单部分将很有用。例如，考虑使用二进制操作的编辑器。对于所有二进制运算都有一个通用的编辑器，该编辑器由一个用于左操作数的单元格，一个用于操作符号的单元格，一个用于概念属性“别名”的单元格和一个用于右操作数的单元格组成。</p>[>％leftExpression％^ {{别名}}％rightExpression％<]<p id="22b258c6">为带有操作符号的单元格创建一个单元格菜单是很自然的，这将允许将操作符号替换为另一个（当然，通过替换整个节点）。为此，将在操作单元格中写入替换节点菜单部分：</p>替换节点（自定义节点概念）替换为：BinaryOperation<p id="e6dbaa1f">根据用于BinaryOperation概念的<a href="editor-actions.html#node_factories">节点工厂</a> ，将以前的左孩子和右孩子添加到新创建的BinaryOperation中。</p>      <h3 id="replacechildmenu(customchild'sconcept)">替换子菜单（自定义子菜单的概念）</h3>   <p id="4ad4debe">这样的单元格菜单部分适用于某个孩子的单元格，并指定了一个特定的概念，其具体概念和子概念将显示在完成菜单中（并在选定时实例化，并将实例设置为孩子）。为了说明这一概念，应该编写一个返回类型节点值的函数<conceptdeclaration>。</conceptdeclaration></p>      <h3 id="replacechildmenu(customaction).">替换子菜单（自定义操作）。</h3>   <p id="c3d9d156">这种单元格菜单部分适用于某个孩子的单元格，不仅可以自定义子概念，还可以自定义整个替换子动作：匹配文本（将在完成菜单中显示的文本），描述文本（描述动作（如完成菜单的右侧所示），以及从完成菜单中选择动作时创建子节点的功能。因此，要编写这样的菜单，应该指定匹配的文本，描述文本并编写返回节点的函数（该节点应该是在相应子链接中指定的目标概念的实例）。</p>      <h3 id="genericmenuitem">通用菜单项</h3>   <p id="0854e835">当在完成菜单中选择相应的菜单项时，这种单元菜单部分可使MPS执行任意操作。应该为菜单项指定匹配的文本，并编写一个可以完成所需功能的函数。例如，如果不存在任何类字段，则可能不想显示该类字段的子级列表单元格。因此，不能使用其默认操作来创建新字段。取而代之的是，您可以在类编辑器的某处创建一个通用菜单项，该菜单项具有匹配的文本“创建字段”，从而为类创建一个新字段。</p>通用项目匹配文本：添加字段处理程序：（节点，模型，范围，operationContext）-> void {节点。领域。添加新的（ <default>）; }<h3 id="actiongroups">行动小组</h3>   <p id="12412beb">操作组是单元菜单部分，它返回一组自定义操作。在运行时，在菜单构建期间，将收集或创建某些特定类型的对象（称为参数对象）。为此，指定了操作组函数的参数对象类型，这些函数将返回其匹配文本和描述文本。还指定了选择带有参数对象的菜单项时触发的功能。</p>   <p id="85310854">因此，动作组描述包括：</p>   <ul class="list _ul"><li class="list__item" id="c6e4c04f"><p>参数对象类型；</p></li><li class="list__item" id="261491cd"><p>返回指定类型的参数对象列表的函数（采用已编辑的节点，作用域和操作上下文）；</p></li><li class="list__item" id="92ba74e3"><p>一个函数，该函数接受指定类型的参数对象并返回匹配的文本（将在完成菜单中显示的文本）；</p></li><li class="list__item" id="f537d3aa"><p>该函数采用指定类型的参数对象并返回该参数对象的描述文本；</p></li><li class="list__item" id="1625bfb6"><p>在完成菜单中选择参数对象时执行动作的功能。</p></li></ul>   <p id="b9f7507b">执行动作的功能可能是不同的，因此单元格动作组菜单部分分为三种：</p>   <ul class="list _ul"><li class="list__item" id="31776874"><p>通用行动小组。给定参数对象的动作函数执行任意动作。除了参数对象外，该函数还提供了编辑后的节点，其模型，范围和操作上下文。</p></li><li class="list__item" id="b0307882"><p>替换子组。它适用于子单元格，并且其动作函数（给定参数对象）返回一个新的子代，该子代必须具有在相应子代链接声明中指定的类型。除了参数对象之外，该函数还提供了已编辑的节点，其模型，当前子代（即要替换的子代），作用域和操作上下文。</p></li><li class="list__item" id="a51e013a"><p>替换节点组。给定参数对象的动作函数将返回一个节点。通常，它是已编辑节点（即在其上调用完成菜单的节点）的参考对象。除了参数对象外，该函数还提供了编辑后的节点，其模型，范围和操作上下文。</p></li></ul>      <h3 id="cellmenucomponents">单元菜单组件</h3>   <p id="bcb6ad08">当不同单元格中的某些菜单部分相等时，可能需要将它们提取到单独且唯一的实体中，以避免重复。为此目的，意味着单元菜单组件。单元菜单组件由单元菜单描述符（单元菜单部分的容器）和适用功能的规范组成。适用功能的规范包含对菜单适用的功能的引用（即子链接声明，引用链接声明或属性声明）。例如，如果您的菜单组件将用于替换某些子组件，则应在此处指定其子链接声明；等等</p>   <p id="e12557aa">创建单元格菜单组件时，可以通过单元格菜单组件菜单部分在单元格菜单中使用它，该单元格菜单部分包含对特定菜单组件的引用。<a href="smodel-language.html">SModel语言</a>   </p>   <h2 id="customizingreferencepresentation">定制参考展示</h2>   <p id="81018991">可以在编辑器方面直接指定匹配文本和供参考的编辑器内文本表示。</p>   <p id="fed3e9e2"><i id="f6d86c06">参考。演示</i>单元可以自定义显示的文本：</p>   <p id="4433e224">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/RefCust1.png"><img alt="RefCust1" title="RefCust1" src="/help/img/idea/2019.2/RefCust1.png" id="d6e29734" width="500" height="722"></a></figure>   <p></p>   <p id="9cbbdd91"><i id="bfad15ef">单元菜单</i>可以自定义完成菜单中显示的文本：</p>   <p id="82702bf6">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/RefCust2.png"><img alt="RefCust2" title="RefCust2" src="/help/img/idea/2019.2/RefCust2.png" id="5afe4cb9" width="500" height="730"></a></figure>   <p></p>   <p id="c4a0a9b5">此功能以前是通过<i id="fb859c95">Constraints</i>实现的。</p>   <h2 id="migrationofpresentationqueryinreferenceconstraints">表示查询在参考约束中的迁移</h2>   <p id="e8a472d3">约束方面的参考表示部分的设计已经显示了它的使用期限，因此已被上述新功能替换。大多数代码将自动迁移。迁移产生的某些代码可以简化，因此请考虑对其进行复审。</p>   <p id="592d1691">在某些情况下，无法迁移表示查询：假设您有一个带有参考链接的概念的编辑器，然后在其子概念之一中具有定义了表示部分的参考约束，以供其参考。如果在子概念中未覆盖编辑器组件，则MPS不知道应在此演示文稿部分的内联位置。在这种情况下，您应该手动迁移演示文稿零件的用法，以防止用户代码中未经纠正的参考演示文稿。有几种替代方法：</p>   <ul class="list _ul"><li class="list__item" id="bad3a9b7"><p>只需在子概念中覆盖编辑器。将代码从演示文稿部分移到正确的参考单元格。</p></li><li class="list__item" id="ac473bc3"><p>将参考单元格提取到一个单独的组件中，并为子概念覆盖该组件。</p></li><li class="list__item" id="bbfd1d04"><p>创建新的行为方法，以供参考。使引用单元格委托创建的方法。在子概念中重写此方法。</p></li></ul>   <p id="a1af2f28">如果您希望其他人可以在其他项目中扩展您的语言，请<b id="b424e573">不要</b>删除不推荐使用的演示文稿部分。否则，扩展语言可能会被不正确地迁移。</p>   <h2 id="two-stepdeletion">两步删除</h2>   <p id="10f54e25">在投影编辑器中，有时很难预测当按<i id="ac941412">Delete</i>或<i id="472917a4">Backspace键</i>时将删除代码的哪一部分。例如，当插入标记位于baseLanguage语句的分号上并按<i id="e9da5892">Backspace时</i> ，整个语句将被删除。通过<b id="36a0fc72">两步删除</b> ，您现在可以看到将删除代码的哪一部分。<br>这是它的工作方式：按下<i id="f3ae0c9a">Delete</i>或<i id="81c00d27">Backspace键</i> ，将要删除的部分代码将突出显示。如果适合，请再次按<i id="5ff49fe2">Delete</i>或<i id="5bba2069">Backspace键</i> ，代码将被删除。如果突出显示之后您意识到不想删除这段代码，则可以按<i id="b09e1558">Escape</i>键或仅移动插入符号，突出显示将消失。</p>   <p id="fb0a9ec3">让我们来看一个例子：<br>将插入符号置于分号语句中。</p>   <p id="2a6ead4d">      </p><figure><img alt="分号" title="分号" src="/help/img/idea/2019.2/Semicolon.png" id="349f15dc" width="706" height="124"></figure>   <p></p>   <p id="f45fd741">按<i id="e31d99e6">Backspace键</i> 。整个语句突出显示。这意味着如果再次按<i id="5e29c062">Backspace键</i> ，该语句将被删除。</p>   <p id="17217d07">      </p><figure><img alt="分号突出显示" title="分号突出显示" src="/help/img/idea/2019.2/Semicolon-highlighted.png" id="a578f9dc" width="720" height="120"></figure>   <p></p>   <p id="155172fe">再次按<i id="8e201c95">Backspace键</i> 。该语句已删除。</p>   <p id="3948d8ca">      </p><figure><img alt="已删除" title="已删除" src="/help/img/idea/2019.2/Deleted.png" id="a3a476a5" width="702" height="116"></figure>   <p></p>   <p id="04b1bd9f">默认情况下，其他节点也是如此。</p>   <aside class="warning " rel="04b1bd9f" id="74e49d34" data-title="">      <p id="0f05cc3a">请注意，如果选择了该节点，将立即将其删除而不突出显示。同样，如果插入符号在可编辑的文本单元格上，则文本部分也将立即删除。</p>   </aside>   <p id="5fa36b40">要打开两步删除，请在“ <b id="1966a5fb">偏好设置”>“编辑器”>“常规</b> ”中选中“两步删除”复选框。</p>   <h3 id="invokingtwo-stepdeletionfromcode">从代码中调用两步删除</h3>   <p id="06fa5745">语言设计者可以在其自定义删除操作中包括两步删除方案。<b id="35310351">为此</b> ，引入了<b id="35310351">jetbrains.mps.lang.editor</b>中的<i id="2ce56f4d">ApproveDelete_Operation</i> 。此操作应用于节点：</p>   <p id="5be6bc66">      </p><figure><img alt="Appr del" title="Appr del" src="/help/img/idea/2019.2/appr-del.png" id="2d53f334" width="616" height="34" class="inline-icon-616"></figure>   <p></p>   <p id="3e0d0a01">如果该操作成功并且之前尚未批准删除该节点，则此操作返回true。更正式地，必须满足以下所有条件：</p>   <p id="93b839a6">1）选中两步删除首选项。</p>   <p id="17d3ead2">2）尚未完全选择该节点。</p>   <p id="be498dfd">3）该节点尚未被批准删除。</p>   <p id="08d4192b">当满足所有这些条件时，将批准删除的节点突出显示，并且自定义删除操作可能会在此时停止。</p>   <p id="adbce6bc">如果在批准删除后立即调用相同的自定义删除操作，则<i id="14525364">approveDelete</i>操作将返回false（因为该节点已被批准），并且该操作将继续进行删除。</p>   <p id="bef36f2a">让我们从baseLanguage看典型的场景：</p>   <p id="9f7d0f89">      </p><figure><img alt="宠爱" title="宠爱" src="/help/img/idea/2019.2/dotE.png" id="e75759b8" width="1100" height="74"></figure>   <p></p>   <p id="13caf0e0">这是<b id="b2c7b68d">Dot_Expression</b>操作的删除动作的一部分。该操作首先尝试批准删除操作，如果操作成功，操作将停止。如果ir不成功，则意味着该节点的操作已被批准（=突出显示），或者该节点已由用户选择，或者“两步删除”首选项选项已关闭。在这种情况下，我们删除操作并将其替换为抽象概念的节点。</p>   <h3 id="morecomplexcases">更复杂的情况</h3>   <p id="abfa7e9b">有时，自定义删除操作需要比仅删除当前节点更为复杂。</p>   <p id="819b298f">让我们看一个示例场景：我们在<b id="1fa50f90">IncompleteMemberDeclaration</b>的“ final”关键字上按Delete键。有一个自定义操作，它将<i id="0903701d">final</i>属性设置为false。 <b id="657fac50"> </b>在编辑器中，有一个单元格，仅当节点的<i id="1c50f114">最终</i>属性为true时才显示该单元格，因此在操作之后，将不会显示该单元格。</p>   <p id="2a99599f">如果我们想在隐藏最终关键字之前突出显示最终关键字（通过将<i id="6fc678a8">final</i>属性设置为false），则可以通过以下方式批准将其删除：</p>   <p id="d6143489">      </p><figure><img alt="最后" title="最后" src="/help/img/idea/2019.2/final.png" id="7608821b" width="1256" height="76"></figure>   <p></p>   <h2 id="2bb22ce4">自定义样式和完成项目的优先级（EXPERIMENTAL）</h2>   <figure><img alt="CompletionStylingConceptFunc" title="CompletionStylingConceptFunc" src="/help/img/idea/2019.2/CompletionStylingConceptFunc.png" id="d2030427" width="2590" height="226"></figure>   <p id="c8ec8330">语言设计者可以在完成菜单中设置项目的样式和优先级。为此，语言设计人员应在语言的编辑器方面创建<i id="4e9dd9cb">完成样式</i>根。为了指定完成菜单项的样式，语言设计者应首先指定该项。<br>当前，我们提供两种可能的完成项目选择器：</p>      <ul class="list _ul"><li class="list__item" id="58115e72"><p>修改特定概念实例的项目。当用户将插入符号放在概念的节点（或其属性，引用或子元素）上并按<i id="7a8ab891">Control + Space</i>时，此选择器选择出现在完成菜单中的项目         </p></li><li class="list__item" id="0fd7ce63"><p>创建特定概念实例的项目。这些主要是替代行动。例如，当用户选择<i id="24db1f8c">StatementList中</i>的<i id="9972e4ab">ReturnStatement</i>并按<i id="a5665dc3">Control + Space时</i> ，完成菜单中的项目将创建<i id="b3f71a80">Statement</i>的实例，并将<i id="25a61731">ReturnStatement</i>替换为这些实例。因此，用于创建<i id="77a0daa0">Statement</i>实例的操作的选择器将选择那些项目。</p></li></ul>   <p id="e6d63202">重要的是可以由多个选择器选择一项。例如，在上述情况下，多个选择器将匹配一个完成项：</p>      <ul class="list _ul"><li class="list__item" id="ace6cf60"><p>用于创建<i id="491a77d1">Statement</i>实例的操作（因为该项目将用另一个<i id="1cc653e6">Statement</i>替换当前节点）</p></li><li class="list__item" id="bd47d4ea"><p>用于修改<i id="c24bb379">Statement</i>实例的操作（因为当前节点是<i id="60b33fb8">ReturnStatement</i> ，它也是<i id="b422cfc5">Statement</i> ）</p></li><li class="list__item" id="15a989ad"><p>用于修改<i id="023e5d0c">StatementList：statement</i>实例的操作（因为菜单项会将新节点粘贴到父<i id="f88e397c">StatementList</i>的statement角色中）</p></li></ul>   <p id="9e39537f">因此，您应该选择最具体的选择器。例如，选择器或修改<i id="352ec346">BaseConcept</i>实例的<i id="352ec346">操作</i>是最不明确的选择器，它将影响所有完成菜单项</p>   <figure><img alt="完成造型罢工" title="完成造型罢工" src="/help/img/idea/2019.2/CompletionStylingStrike.png" id="318318af" width="1882" height="206"></figure>   <p id="c9d2d7f5">选择器与菜单项匹配后，语言设计人员便可以自定义其样式。<i id="09203448">样式对象</i>用于此目的。<br>目前可以：</p>      <ul class="list _ul"><li class="list__item" id="7f6b2aec"><p>使项目的字体变为粗体</p></li><li class="list__item" id="23a4d292"><p>将项目的字体设为斜体</p></li><li class="list__item" id="263ecb50"><p>删除项目的文本（对于弃用概念很有用）</p></li><li class="list__item" id="22ea0302"><p>设置项目的背景和文本颜色</p></li><li class="list__item" id="917003ed"><p>隐藏一个项目</p></li><li class="list__item" id="d73c50b3"><p>设置项目的优先级</p></li></ul>   <p id="89384ccb">请注意，所有样式都会累积：</p>      <ul class="list _ul"><li class="list__item" id="00f5391d"><p>如果至少一个样式器设置了任何粗体/斜体/隐藏样式，则该项将为粗体/斜体/隐藏。</p></li><li class="list__item" id="ccfe1fa4"><p>如果背景或文本颜色发生冲突，将使用第一个指定的颜色。</p></li><li class="list__item" id="c167f19c"><p>优先级用于对项目进行排序。使用由样式师设置为项目优先级的最大值。</p></li><li class="list__item" id="373f2365"><p>项目首先按优先级排序，然后按与用户文本匹配的级别排序。当前无法覆盖此级别。</p></li></ul>   <p id="0af32d0c">语言设计人员可以使用几个参数。它们存储在项目中。</p>      <h3 id="cf35d6f2">信息参数：</h3>      <ul class="list _ul"><li class="list__item" id="97e33174"><p>            <b id="e238f5b8">matchingText-</b>出现在项目左侧的文本。当用户在完成菜单中键入文本时，该文本用于过滤项目。</p></li><li class="list__item" id="6c636704"><p>            <b id="a7747e69">descriptionText-</b>出现在项目右侧的文本。</p></li><li class="list__item" id="7f065e0e"><p><b id="ccea8ed5">parameterObject-</b>某些项目可以使用对象进行参数化。例如，更改节点引用的项目将使用执行时将设置的引用目标进行参数化。</p></li><li class="list__item" id="ef477b2b"><p>            <b id="b8d94bdf">outputConcept-</b>一些动作，例如替代动作创建新节点，输出概念是新节点的概念。</p></li></ul>      <h3 id="a06a41f0">baseLanguage中样式器的一些著名示例：</h3>      <ul class="list _ul"><li class="list__item" id="d97c615e"><p>            <i id="d48d351f">ReturnStatementStyling</i> ，使返回项变为粗体，并将其优先级设置为非零（如果它位于当前语句列表的最后）。</p><figure><img alt="完成样式返回" title="完成样式返回" src="/help/img/idea/2019.2/CompletionStylingReturn.png" id="9e316526" width="2286" height="330"></figure>         <p></p></li><li class="list__item" id="944e0a54"><p>            <i id="38fc81be">VariableReferencePriority</i> ，如果项目引用变量声明，则将项目优先级设置为非零。</p><figure><img alt="完成样式VarRef" title="完成样式VarRef" src="/help/img/idea/2019.2/CompletionStylingVarRef.png" id="70bab816" width="2578" height="350"></figure>         <p></p></li></ul>      <h3 id="ac8e3c37">重要的提示：</h3>   <p id="98de7781">此功能是实验性的，其设计可能会在将来进行很多更改。关于此功能的反馈将不胜感激，并将帮助我们进行改进。可以关闭此功能：设置->编辑器->常规->使用完成样式</p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="structure.html">结构</a> <a class="navigation-links__next" href="editor-actions.html">编辑器动作</a></div></default></string></no></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>