<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>发电机用户指南Demo3-帮助| MPS</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Generator+User+Guide+Demo3.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="generator-user-guide-demo3.xml" data-toc="Generator+User+Guide+Demo3.html">发电机用户指南Demo3</h1>   <h2 id="generatoruserguidedemo3">发电机用户指南演示3</h2>   <p id="66eea4da">在演示2中，我们生成了如下的Java语句：</p>   <div class="code-block" data-lang="none">container.add（new JButton（））;</div>   <p id="4fa0960f">创建一个Swing组件并将其添加到应用程序的内容窗格中。</p>   <p id="47773613">在演示3中，我们将添加对组件属性的支持，这将需要生成更复杂的初始化代码-而不仅仅是构造函数调用。此外，对于不同类型的组件，生成的属性初始化代码将有所不同。<br>因此，我们将选择一种能够满足此类要求的生成策略。</p>   <h2 id="newlanguage">新语言</h2>   <p id="54124966">同样，我们需要设置一种新语言并将一些Demo 2生成器构件复制到其中。</p>   <ul class="list _ul"><li class="list__item" id="5fa4fdf2"><p>创建一种新语言：“ generator_demo.demoLang3”</p></li><li class="list__item" id="0fd6841c"><p>在语言属性对话框中，添加对'jetbrains.mps.sampleXML'和'jetbrains.mps.baseLanguage'的<b id="385a364f">扩展依赖</b></p></li><li class="list__item" id="88ae874f"><p>为此语言创建一个新的生成器（如果不存在）（有关详细信息，请参见《 <a href="generator-user-guide-demo1.html">生成器用户指南Demo1</a> 》）</p></li><li class="list__item" id="1739751c"><p>从<i id="ac03f64e">demoLang3</i>生成器中删除映射配置“ main”（如在Demo 2中一样，我们将从<i id="13851740">demoLang2</i>生成器中复制所有需要的部分到<i id="71dfa2cc">demoLang3</i>生成器中）</p></li><li class="list__item" id="74cce474">将映射配置“ main”从<i id="4e212dd8">demoLang2</i>生成器复制粘贴到<i id="b1a20f60">demoLang3</i>生成器<aside class="note " rel="b1a20f60" id="6c256af5" data-title="">            <p id="cd72bf97">有关详细信息，请参见《 <a href="generator-user-guide-demo2.html#new_language">生成器用户指南Demo2</a> 》。</p>         </aside>      </li><li class="list__item" id="d4f2d976"><p>将'DemoApp'模板从<i id="90365726">demoLang2</i>生成器复制粘贴到<i id="5e8302b9">demoLang3</i>生成器</p></li></ul>   <h2 id="addcontent(container)">addContent（容器）</h2>   <p id="d199a917">该生成器在许多方面都将类似于我们在演示2中创建的生成器。因此，我们将使用<i id="bfb560b7">条件根规则</i>将<i id="dfab4338">DemoApp</i>类插入输出模型。最初，我们需要对<i id="57197169">DemoApp</i>类进行一些调整。</p>   <ul class="list _ul"><li class="list__item" id="6765ac89"><p>打开“ DemoApp”模板</p></li><li class="list__item" id="04dea00f"><p>添加静态void方法'addContent（Container）'</p></li><li class="list__item" id="bbe07bc6"><p>在“ main（）”方法中找到以下语句：</p><div class="code-block" data-lang="none">$ LOOP $ [container.add（$ SWITCH $ [null]）;</div>      <p></p></li><li class="list__item" id="1215a9e2"><p>用下面的语句替换上面的语句：</p><div class="code-block" data-lang="none">addContent（container）;</div>      <p></p></li></ul>   <p id="29b094b8">      </p><figure><img alt="gdc1" title="gdc1" src="/help/img/idea/2019.2/gdc1.png" id="0eb319a7" width="842" height="387"></figure>   <p></p>   <p id="02b99d7c">现在，应该使用<i id="ad843174">addContent（）</i>方法将所有组件添加到<i id="3fdc803d">JFrame中</i> 。因此它将调用<i id="ac447946">container.add（）</i>并依次传递初始化的可视化组件-每个输入XML <i id="2a42037d">Document</i>都传递一个。因此，我们将添加一个可以在代码中使用的虚拟方法，并使生成器将其替换为实际的组件初始化代码。</p>   <p id="347d9bdf">       </p><figure><img alt="gdc3" title="gdc3" src="/help/img/idea/2019.2/gdc3.png" id="844c6b7f" width="582" height="331"></figure>   <p></p>   <h2 id="generatingcomponents">生成组件</h2>   <p id="bfbd7bc1">为了使每个输入<i id="8eca9778">Element都</i>生成一个组件初始化方法，我们将用<i id="f9084d8e">LOOP</i>宏包装<i id="afbcd7d7">component（）</i>方法声明。<i id="593f121a">LOOP</i>宏将遍历输入模型中的所有<i id="650ef362">元素</i> ，并为每个<i id="650ef362">元素</i>生成一个方法。</p>   <p id="2cfd184a">      </p><figure><img alt="gdc4" title="gdc4" src="/help/img/idea/2019.2/gdc4.png" id="39e17684" width="735" height="303"></figure>   <p></p>   <p id="8bac85ff">类似地，我们需要为每个输入<i id="0ea85983">Element</i>调用这些生成的方法，并将返回的组件添加到容器中，因此我们需要在对<i id="910a71df">容器</i>的调用周围使用另一个<i id="750dcbe2">LOOP</i>宏<i id="910a71df">。</i> <i id="38658a8b">addContent（）</i>方法内部的方法。</p>   <p id="11475864">      </p><figure><img alt="gdc5" title="gdc5" src="/help/img/idea/2019.2/gdc5.png" id="c2418331" width="733" height="307"></figure>   <p></p>   <p id="7bb8a88a">最后但并非最不重要的一点，我们必须用对<b id="0a84d28f">对应于相同</b>输入<i id="4446cb8a">Element</i>的实际生成的方法的调用替换对dummy <i id="d6b93b8b">component（）</i>方法的调用。因此，选择<i id="853fa994">组件</i> （不带括号），然后按<i id="4f62be24">Control + Shift + M</i>插入<i id="1095a0c0">参考宏</i> 。</p>   <p id="e520b0f1">      </p><figure><img alt="gdc6" title="gdc6" src="/help/img/idea/2019.2/gdc6.png" id="6713d30d" width="841" height="310"></figure>   <p></p>   <p id="e97214f9">这是我们暂时无法前进的地方。我们不知道如何解析与当前节点相对应的方法声明，以便可以从引用宏中引用它。在此阶段，我们将使用<i id="b58b388c">映射标签</i> 。它们将用作方法声明的注册表，可通过为其创建的<i id="d49d1c77">Element</i>访问。因此，我们的<i id="b6beb201">参考宏</i>将能够从那里检索相应的方法声明。</p>   <p id="8a877e6b">要定义映射标签，请返回“主”映射配置：</p>   <p id="6cc9dc6b">      </p><figure><img alt="gdc7" title="gdc7" src="/help/img/idea/2019.2/gdc7.png" id="247dc1a6" width="564" height="282"></figure>   <p></p>   <aside class="tip sideblock" rel="6cc9dc6b" id="579392db" data-title="">      <p id="830198dd">映射标签的<b id="75086c71">输入概念</b>和<b id="95bcbb24">输出概念</b>是可选参数，用于在使用映射标签查找输出节点的表达式中提供静态类型检查。<br>在我们的例子中，我们将映射标签附加到规则，这些规则将生成<i id="7aecf8f6">StaticMethodDeclaration</i> 。这就是为什么我们选择<i id="b3dc4c49">StaticMethodDeclaration</i>作为标签的输出概念的原因。<br>表达式（我们将很快使用它）：</p>      <div class="code-block" data-lang="none">genContext.get输出“方法”</div>      <p id="6731e002">然后将具有类型：'node <staticmethoddeclarationt>'。<br>在这种特殊情况下，“获取输出”表达式具有类型这一事实并没有为我们带来任何好处，但总的来说，这是一个非常有用的功能。</staticmethoddeclarationt></p>   </aside>   <p id="dcda3b5e">现在，回到<i id="989b0980">DempApp</i> ，我们可以完成参考宏：</p>   <p id="eefedea8">      </p><figure><img alt="gdc9" title="gdc9" src="/help/img/idea/2019.2/gdc9.png" id="d0660edc" width="867" height="370"></figure>   <p></p>   <p id="bc5a4058">      </p><figure><img alt="gdc10" title="gdc10" src="/help/img/idea/2019.2/gdc10.png" id="a6bec507" width="780" height="161"></figure>   <p></p>   <p id="e59d3895">显然，现在我们需要完成方法声明的生成并将其正确存储在<i id="f66ccf60">方法</i>映射标签中。</p>   <h2 id="insertingcomponents">插入组件</h2>   <p id="8b2f0133">就像在演示2中一样，当为它们生成方法时，我们将使用<i id="2b66c98a">SWITCH</i>宏来适应不同类型的<i id="1e3c296b">Elements</i> 。因此，右键单击生成器模型，然后选择<i id="6097b755">New-> template switch</i> 。根据<i id="943d86ba">Element</i>的<i id="5591c9cc">名称</i> ，我们可以为按钮或标签生成代码。</p>   <p id="acd7f628">      </p><figure><img alt="gdc11" title="gdc11" src="/help/img/idea/2019.2/gdc11.png" id="59a94438" width="1150" height="405"></figure>   <p></p>   <p id="84dd1545">这次，由于生成的代码更加复杂，因此内联模板不足以捕获逻辑，因此我们需要用于生成按钮和标签的独立模板-分别命名为<i id="b131ddb9">insert_Button</i>和<i id="99178e13">insert_Label</i> 。通过右键单击生成器模型并选择<i id="3a101e3c">New-> template Declaration</i>来创建它们。</p>   <p id="40067c30">模板是要生成的代码片段，并根据从输入模型计算出的值进行参数化。在我们的例子中，我们需要生成一个新的静态方法，该方法将被添加到<i id="880e23d0">DemoApp</i>类中，并且具有与<i id="386863a7">DemoApp</i>类模板中声明的<i id="6afdc6ce">component（）</i>方法兼容的签名。因此，我们现在要为按钮执行的操作是创建一个带有静态方法的虚拟类。该静态方法将成为<i id="41313ee5">模板片段</i> ，以便仅将方法而不是整个类插入目标模型。</p>   <p id="c05d3825">首先，选择<i id="ba3c34ef">ClassConcept</i>作为内容节点：</p>   <p id="74a4e6b5">       </p><figure><img alt="gdc12" title="gdc12" src="/help/img/idea/2019.2/gdc12.png" id="9c69e050" width="549" height="249"></figure>      <br>在下面输入代码，声明带有所需签名的静态方法。<br>      <figure><img alt="gdc13" title="gdc13" src="/help/img/idea/2019.2/gdc13.png" id="cc9a56ac" width="477" height="239"></figure>      <br>现在选择整个方法声明，单击<i id="ce4cb76b">Alt + Enter，</i>然后从菜单中选择“ <i id="0ecdd5df">创建模板片段</i> ”。这表明应该仅将我们的方法声明用作模板。周围的类仅用作方法的上下文。<br>      <figure><img alt="gdc14" title="gdc14" src="/help/img/idea/2019.2/gdc14.png" id="19d667f3" width="566" height="452"></figure>      <br>这是我们将用此模板生成的所有方法注册到<i id="5d5a7f98">方法</i>映射标签中的时间，以便稍后在生成对这些方法的调用时可以检索这些方法。只需在“ <i id="ae9936a7">检查器”</i>窗口中为<i id="e1e8b84d">模板片段</i>输入所需的<i id="742087bf">映射标签</i> （ <tf visual="" element).<br="">      <figure><img alt="gdc15" title="gdc15" src="/help/img/idea/2019.2/gdc15.png" id="596259a7" width="631" height="358"></figure>      <br>目前，我们正在为所有具有相同名称的输入<i id="0d83fc9b">Element</i>生成方法<i id="45987ca5">-createComponent</i> ，如果输入模型中有多个<i id="2eabc35a">Element</i> ，则会导致Java编译时的麻烦。我们需要给每个生成的方法一个唯一的名称，然后通过<i id="961316c1">属性宏来实现</i> 。<p></p>   <p id="a830d535">      </p><figure><img alt="gdc16" title="gdc16" src="/help/img/idea/2019.2/gdc16.png" id="98f594a1" width="785" height="283"></figure>   <p></p>   <p id="0a157c27">我们正在使用<i id="2adca677">genContext</i>功能生成唯一标识符。<b id="a05653e7"><i id="d6196181">templateValue</i></b>参数将为“ createComponent”（即，在模板中编写的方法名称）。</p>   <p id="07f596c8">现在，请创建用于创建<i id="4d01b0f2">JLabel的</i> <i id="2ba8fe8d">模板声明</i> 。</p>   <p id="940a2226">完成后，我们应该能够完成<i id="7230f8ea">SWITCH模板</i>声明。<br>      </p><figure><img alt="gdc18" title="gdc18" src="/help/img/idea/2019.2/gdc18.png" id="03a99084" width="861" height="403"></figure>   <p></p>   <p id="701dcf8d">在<i id="199144b5">DempApp</i>类模板中修复了<i id="6cd3f9bd">SWITCH宏</i>并制作了语言之后，我们应该可以尝试使用我们的新生成器。<br>      </p><figure><img alt="gdc19" title="gdc19" src="/help/img/idea/2019.2/gdc19.png" id="c1bcdf73" width="607" height="516"></figure>   <p></p>   <h2 id="newtestmodel">新的测试模型</h2>   <p id="5dc34c6f">让我们创建一个新的输入测试模型：</p>   <ul class="list _ul"><li class="list__item" id="7e138015"><p>转到“ test_models”解决方案</p></li><li class="list__item" id="9ecc9f74"><p>将模型“ test2”克隆到模型“ test3”</p></li><li class="list__item" id="6bf1d1b9"><p>在模型属性对话框中，替换“参与生成”语言demoLang2-> demoLang3（有关详细信息，请参见<a href="generator-user-guide-demo2.html#first_test">Generator用户指南Demo2</a> ）</p></li><li class="list__item" id="ad7b6ea8"><p>在编辑器中打开“按钮”文档（来自模型“ test3”）</p></li><li class="list__item" id="f81c59f9"><p>将属性'text =“ Hello”'添加到'button'元素</p></li><li class="list__item" id="3aadf3af"><p>将属性'enabled =“ false”'添加到'button'元素</p></li></ul>   <p id="fec5bb9c">      </p><figure><img alt="gdcb" title="gdcb" src="/help/img/idea/2019.2/gdcb.png" id="68cc411f" width="487" height="95"></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="8141ee03"><p>添加一个属性'text =“ world！“”到“标签”文档中的“标签”元素</p></li><li class="list__item" id="cf2c3acd"><p>向“标签”文档中的“标签”元素添加属性“ background =“ orange””</p></li></ul>   <p id="7ddbe83c">      </p><figure><img alt="gdcl" title="gdcl" src="/help/img/idea/2019.2/gdcl.png" id="1eedb031" width="525" height="98"></figure>      <br>当您点击<i id="eaafe457">预览生成的代码时</i> ，您应该获得一个有效的Java应用程序。<p></p>   <p id="80a60613">d</p><figure><img alt="gdc20" title="gdc20" src="/help/img/idea/2019.2/gdc20.png" id="2e165720" width="409" height="610"></figure>      <br>注意<i id="c40b6fd5">createComponent（）</i>方法的唯一性。<p></p>   <p id="e7cf29cb">现在，让我们为额外的XML属性定义语义。</p>   <h2 id="addingan$if$macro">添加$ IF $宏</h2>   <p id="34ca70fc">让我们专注于<i id="1d17daeb">insert_Button</i>和<i id="830771dc">insert_Label</i>模板。它们定义了基于输入XML <i id="9c2bb330">元素中</i>指定的值初始化Swing组件的代码。到目前为止，我们忽略了输入模型中的所有属性，但是现在这将改变。现在，重点关注<i id="95a6917f">insert_Label</i> ，如果输入<i id="fc4b58d5">元素</i>具有名为“文本”的属性，我们将生成一条语句：</p>   <div class="code-block" data-lang="none">component.setText（_text_）</div>   <p id="43bf226f">其中<i id="9014dd41">text</i>是在输入<i id="dc4c04f1">Element</i>的'text'属性中指定的字符串。</p>   <ul class="list _ul"><li class="list__item" id="009ff610"><p>在顶部，将<i id="4764f4d5">Element</i>指定为模板的<b id="6901754c">输入</b> ，以便MPS可以对涉及模板当前<i id="9400d25a">节点的</i>代码进行类型检查      </p></li><li class="list__item" id="2fc68615"><p>在“ createComponent（）”方法的主体中输入以下代码</p></li><li class="list__item" id="ab7d15bb"><p>围绕'component.setText（“ text”）;'创建IF宏语句（选择整个语句，按<i id="9194b9be">Ctrl-Shift + M</i> ）</p></li><li class="list__item" id="7df050b6"><p>将代码输入到IF宏的<b id="ad02fabf">条件</b>函数中，该函数将检查'text'属性的存在</p></li></ul>   <p id="e859c907">      </p><figure><img alt="gdc21" title="gdc21" src="/help/img/idea/2019.2/gdc21.png" id="cee49376" width="925" height="461"></figure>      <br>      <a name="property_macro_in_if_macro"></a>      <br>   <p></p>   <ul class="list _ul"><li class="list__item" id="1794f6f7"><p>在字符串文字“ text”中创建property-macro，因为我们需要使用输入模型中的实际属性值对值进行参数化</p></li><li class="list__item" id="d4c5558f"><p>在属性宏的<b id="02fb51bb">值</b>函数中，输入代码以返回输入<i id="fc5a6e89">元素</i>的'text'属性的值      </p></li></ul>   <p id="82fef9f9">      </p><figure><img alt="gdc22" title="gdc22" src="/help/img/idea/2019.2/gdc22.png" id="4800c4ca" width="771" height="269"></figure>   <p></p>   <p id="6e276677">现在应该对<i id="4c2eac38">insert_Button</i>模板重复相同的步骤。</p>   <h2 id="reusabletemplate">可重复使用的模板</h2>   <p id="7fcf943a">我们可以继续以相同的方式添加对越来越多的组件属性的支持，但是这样一来，我们最终将在模板中产生大量重复的代码。</p>   <p id="6ca55f79">一个更好的主意是创建一个包含一些通用代码的模板，然后在每个组件的模板中重新使用它。例如，让我们添加对属性“ enabled”的支持。我们将创建一个“共享”模板，并使用<b id="2e904e79">CALL宏</b>在其他模板中重用它：</p>   <ul class="list _ul"><li class="list__item" id="0cba705b"><p>转到demoLang3生成器中的“ main @ generator”模型（在项目树中选择）</p></li><li class="list__item" id="1e5d8585"><p>使用模型弹出菜单中的“ <i id="1599c8a3">创建</i>根节点”来<i id="1599c8a3">创建</i>新的<b id="dcb295bf">模板声明</b>节点</p></li><li class="list__item" id="3665bb5c"><p>将其命名为“ include_ComponentProperties”</p></li><li class="list__item" id="c4871e21"><p>选择<b id="dfa3ac62">输入</b> - <i id="062244d6">元素</i>      </p></li><li class="list__item" id="a6d2f3bc"><p>选择StatementList作为模板的<b id="05cba98d">内容节点</b> ：</p></li><li class="list__item" id="3607404b">         <figure><img alt="gdc23" title="gdc23" src="/help/img/idea/2019.2/gdc23.png" id="84000f6e" width="694" height="255"></figure>      </li><li class="list__item" id="a48fad88">在语句列表中创建一个变量声明：<div class="code-block" data-lang="none">JComponent component = null;</div>         <br>         <aside class="note " rel="a48fad88" id="3af570ad" data-title="">            <p id="8550d86a">变量的名称很重要-生成器将使用该名称解析引用。</p>         </aside>         <br>      </li><li class="list__item" id="a6549e2f"><p>添加一个语句块（按<i id="ee944078"><enter></enter></i>在变量声明之后，键入“ {”，然后按<i id="d820662a">Ctrl + <space></space></i>自动完成）</p></li><li class="list__item" id="d46ca456"><p>创建一条语句：</p><div class="code-block" data-lang="none">component.setEnabled（false）;</div>内在陈述<p></p></li><li class="list__item" id="263a6f8f"><p>将块语句（即，不包括<i id="1ef7d2cf">组件</i>变量的声明）标记为<b id="638c71f8">模板片段</b> ：</p></li><li class="list__item" id="18103e89">         <figure><img alt="gdc24" title="gdc24" src="/help/img/idea/2019.2/gdc24.png" id="9d5eec7c" width="419" height="203"></figure>         <aside class="tip sideblock" rel="9d5eec7c" id="7e83dca9" data-title="">            <p id="a9ad6d64">我们实际上并不一定要使用block语句，但选择这样做将使我们日后轻松向此模板片段添加更多语句。</p>         </aside>      </li></ul>   <h2 id="map_src-macro">MAP_SRC-宏</h2>   <p id="256b15bc">作为“文本”属性的“ <a href="#property_macro_in_if_macro">生成器用户指南Demo3</a> ”，“ setEnabled（）”方法调用的生成应是有条件的-仅当输入元素具有“已启用”属性时，才应生成此语句。</p>   <p id="327b93e5">这次，为了实现条件生成，我们将使用<b id="2b31c5a6">MAP_SRC-macro</b>代替IF <b id="2b31c5a6">-macro</b> 。正如我们将看到的，在这种情况下，MAP_SRC-宏比IF-宏具有多个优势。</p>   <ul class="list _ul"><li class="list__item" id="406c2fb4"><p>创建一个MAP_SRC宏（它应该包装整个语句）</p></li><li class="list__item" id="7e07a0b7"><p>在宏的<b id="85775cb9">映射节点</b>函数中输入代码，如下所示：</p></li></ul>   <p id="a2792ae5">      </p><figure><img alt="gdc25" title="gdc25" src="/help/img/idea/2019.2/gdc25.png" id="a76ee6cf" width="845" height="299"></figure>   <p></p>   <p id="cbafb7dc">如果存在，则<b id="6fe268ad">映射的节点</b>函数将返回“已启用”属性的节点，否则返回<i id="28f0ffe3">null</i> 。如果MAP_SRC-macro中的<b id="1030f6ca">映射节点</b>函数返回<i id="907f71d9">null</i> ，则生成器将忽略此宏包装的节点（就像<i id="2e61bc7a">If宏</i>一样）。<br>但是，如果映射的节点不为<i id="24ba0028">null</i> ，则它在处理包装的模板代码时将成为当前<b id="37d829ee">输入节点</b> 。与使用IF宏相比，这有助于我们掌握属性，从而使属性宏的创建更加容易-我们不必再次查找“ enabled”属性，该属性已经是我们的<b id="c2f0afcc">输入节点</b> 。</p>   <p id="3159c2c1">现在，为模板设置正确的值：</p>   <ul class="list _ul"><li class="list__item" id="c4a19938"><p>将属性宏附加到布尔常量'false'</p></li><li class="list__item" id="0dfd6fa4"><p>将代码输入其<b id="e55f7e01">value</b>函数中（请注意，这次<b id="6d8d6a20">value</b>函数需要一个布尔返回值）：</p></li></ul>   <p id="386a6748">      </p><figure><img alt="gdc26" title="gdc26" src="/help/img/idea/2019.2/gdc26.png" id="dee963f5" width="728" height="262"></figure>   <p></p>   <h2 id="include-macro">呼叫宏</h2>   <p id="32d92754">我们将使用CALL宏指定代码中要插入“ component.setEnabled（..）;”的位置。生成过程中的声明。</p>   <ul class="list _ul"><li class="list__item" id="604280f3"><p>在编辑器中打开“ insert_Button”模板</p></li><li class="list__item" id="6c6b71d0"><p>在语句之后插入新的空行</p><div class="code-block" data-lang="none">component.setText（“ text”）;</div>         <br>      <p></p></li><li class="list__item" id="4326f776"><p>在空行上插入CALL节点宏（ <i id="da97f5f5">Control + Shift + M</i> ）</p></li><li class="list__item" id="9e2f04af"><p>在宏的检查器中引用“ include_ComponentProperties”模板：</p></li><li class="list__item" id="406fc55e">         <figure><img alt="gdc27" title="gdc27" src="/help/img/idea/2019.2/gdc27.png" id="413fedac" width="1382" height="1064"></figure>      </li><li class="list__item" id="e4693af6"><p>在“ insert_Label”模板中创建类似的宏</p></li><li class="list__item" id="23efc420"><p>重新生成发电机模型（ <i id="e2b144c1">Shift + F9</i> ）<br> </p></li></ul>   <h2 id="testingwhatwehave">测试我们拥有的</h2>   <p id="839a3c05">为“ test3”模型生成代码将呈现有效的Java应用程序：</p>   <p id="978014ae">       </p><figure><img alt="gdc28" title="gdc28" src="/help/img/idea/2019.2/gdc28.png" id="8e340634" width="422" height="661"></figure>      <br>我们正确地获得了仅为按钮而不是为标签生成的<i id="8f4c9e86">setEnabled（）</i>方法。<p></p>   <h2 id="reference-macro(resolvingbyname)">参考宏（按名称解析）</h2>   <aside class="tip sideblock" rel="reference-macro(resolvingbyname)" id="df727129" data-title="">      <p id="69da95a2">方法调用节点或变量使用节点包含对方法或变量声明的引用。</p>   </aside>   <p id="3cea755e">在许多情况下，引用无法自动解析，这是<b id="90389c76">引用宏</b>非常有用的地方。</p>   <p id="0d32e083">例如，让我们在生成器中添加对“ background”属性的支持：</p>   <ul class="list _ul"><li class="list__item" id="8ab3bc68"><p>打开“ include_ComponentProperties”模板</p></li><li class="list__item" id="1a514d65"><p>在“ component.setEnabled（false）;”之后添加一个语句块声明</p></li><li class="list__item" id="35aee733"><p>在该语句中输入以下代码：</p><div class="code-block" data-lang="none">component.setOpaque（true）; component.setBackground（Color.black）;</div>         <br>      <p></p></li><li class="list__item" id="769891a4"><p>将块语句包装在MAP_SRC宏中</p></li><li class="list__item" id="fbc35587"><p>将代码输入到宏的<b id="f9727ac7">映射节点</b>函数中，如下所示：</p></li></ul>   <p id="74970c02">      </p><figure><img alt="gdc29" title="gdc29" src="/help/img/idea/2019.2/gdc29.png" id="5cb36a02" width="871" height="489"></figure>   <p></p>   <ul class="list _ul"><li class="list__item" id="cb0a2eae"><p>将<b id="741c555f">引用宏</b>附加到静态字段引用'black'（在'Color.black'表达式中），因为我们需要根据输入XML <i id="d1048447">Element</i>的'background'属性的实际值对颜色进行参数化。</p></li><li class="list__item" id="68c140ed"><p>在<b id="dccd0e02">referent</b>函数中输入以下代码：</p></li></ul>   <p id="242899eb">      </p><figure><img alt="gdc30" title="gdc30" src="/help/img/idea/2019.2/gdc30.png" id="9b855dae" width="1077" height="310"></figure>   <p></p>   <p id="d5ab580e">在此示例中， <b id="4b9f1813">referent</b>函数具有组合的返回类型：</p>   <div class="code-block" data-lang="none">JOIN（节点<staticfielddeclaration>|字符串）</staticfielddeclaration></div>   <p id="0b67a0b0">具有eithor-or语义。这意味着对于从函数返回的内容，我们有两种选择：</p>   <ol class="list _decimal"><li class="list__item" id="7973e666"><p>我们可以在“颜色”类中找到合适的静态字段声明，然后返回该节点</p></li><li class="list__item" id="260eb8db"><p>或者我们可以返回<b id="fa7b1685">参考信息</b>字符串-静态字段声明的名称（颜色的名称），然后让MPS为其查找静态字段</p></li></ol>   <p id="c74a3ace">当然，第二种选择更具吸引力。因此，我们将返回“背景”属性的值-所需颜色的名称。</p>   <h2 id="thefinaltest">最终测试</h2>   <p id="ac0160e2">现在，在重新构建语言之后，将在Java应用程序中生成“ test3”模型，该模型现在考虑了所有输入元素的属性。</p>   <p id="e47991d4">       </p><figure><img alt="gdc31" title="gdc31" src="/help/img/idea/2019.2/gdc31.png" id="a077bf04" width="416" height="709"></figure>   <p></p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="generator-user-guide-demo2.html">发电机用户指南Demo2</a> <a class="navigation-links__next" href="generator-user-guide-demo4.html">发电机用户指南Demo4</a></div></tf></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>