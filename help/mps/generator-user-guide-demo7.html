<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>生成器用户指南Demo7-帮助|帮助MPS</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Generator+User+Guide+Demo7.html"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索MPS帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>MPS 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="primary_default" data-group="primary" selected>默认</option><option value="primary_default_for_gnome" data-group="primary">GNOME的默认设置</option><option value="primary_default_for_kde" data-group="primary">KDE的默认值</option><option value="primary_default_for_xwin" data-group="primary">XWin的默认设置</option><option value="primary_eclipse" data-group="primary">日食</option><option value="primary_eclipse_mac_os_x" data-group="primary">Eclipse（Mac OS X）</option><option value="primary_emacs" data-group="primary">埃马克斯</option><option value="primary_jbuilder" data-group="primary">JBuilder的</option><option value="primary_mac_os_x" data-group="primary">Mac OS X</option><option value="primary_mac_os_x_10.5_" data-group="primary">Mac OS X 10.5以上</option><option value="primary_netbeans" data-group="primary">NetBeans</option><option value="primary_visual_studio" data-group="primary">视觉工作室</option><option value="secondary_default" data-group="secondary">默认</option><option value="secondary_default_for_gnome" data-group="secondary">GNOME的默认设置</option><option value="secondary_default_for_kde" data-group="secondary">KDE的默认值</option><option value="secondary_default_for_xwin" data-group="secondary">XWin的默认设置</option><option value="secondary_eclipse" data-group="secondary">日食</option><option value="secondary_eclipse_mac_os_x" data-group="secondary">Eclipse（Mac OS X）</option><option value="secondary_emacs" data-group="secondary">埃马克斯</option><option value="secondary_jbuilder" data-group="secondary">JBuilder的</option><option value="secondary_mac_os_x" data-group="secondary">Mac OS X</option><option value="secondary_mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5以上</option><option value="secondary_netbeans" data-group="secondary">NetBeans</option><option value="secondary_visual_studio" data-group="secondary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="generator-user-guide-demo7.xml" data-toc="Generator+User+Guide+Demo7.html">发电机用户指南Demo7</h1>   <h2 id="generatoruserguidedemo7">发电机用户指南演示7</h2>   <p id="46828e0c">在最后的演示中，我们将返回到演示3，并以略有不同的方式实现所需的功能，以便我们探索MPS生成器的另一个领域-编织规则和根映射规则。</p>   <p id="a3e70701">在我们将在此处构建的演示2中，我们生成了如下Java语句：</p>   <div class="code-block" data-lang="none">container.add（new JButton（））;</div>   <p id="d5b977bc">创建一个Swing组件并将其添加到应用程序的内容窗格中。</p>   <p id="e3af14bc">在演示7中，就像在演示3中一样，我们将添加对组件属性的支持，这将需要生成更复杂的初始化代码-而不仅仅是构造函数调用。此外，对于不同类型的组件，生成的属性初始化代码将有所不同。<br>因此，我们将选择一种能够满足此类要求的生成策略-而不是使用<i id="00d7265f">SWITCH</i>宏，而是使用<b id="87e1f143">Weaving Rules</b> ，它将“注入”组件的初始化代码到<i id="76cff307">DemoApp</i>类中。</p>   <h2 id="newlanguage">新语言</h2>   <p id="9df53d61">同样，我们需要设置一种新语言并将一些Demo 2生成器构件复制到其中。</p>   <ul class="list _ul"><li class="list__item" id="229c5324"><p>创建一种新语言：“ generator_demo.demoLang7”</p></li><li class="list__item" id="d0c7b780"><p>在语言属性对话框中，添加对'jetbrains.mps.sampleXML'和'jetbrains.mps.baseLanguage'的<b id="82e42845">扩展依赖</b></p></li><li class="list__item" id="1a507613"><p>如果该语言不存在，请为其创建一个新的生成器（有关详细信息，请参见<a href="generator-user-guide-demo1.html">演示1</a> ）</p></li><li class="list__item" id="23297aae"><p>从<i id="1349e2b2">demoLang7</i>生成器中删除（空）映射配置“ main”（如在Demo 2中一样，我们将从<i id="1c3da35f">demoLang2</i>生成器中复制所有需要的部分到<i id="ef25b761">demoLang7</i>生成器中）</p></li><li class="list__item" id="15495437">         <p id="bac825b3">将映射配置“ main”从<i id="0a05c256">demoLang2</i>生成器复制粘贴到<i id="69cf342e">demoLang7</i>生成器</p>         <aside class="note " rel="bac825b3" id="5ff0608e" data-title="">            <p id="7e452e6d">有关详细信息，请参见<a href="generator-user-guide-demo2.html#new_language">演示2</a> 。</p>         </aside>      </li><li class="list__item" id="c581e8f2"><p>将'DemoApp'模板从<i id="3b511ab4">demoLang2</i>生成器复制粘贴到<i id="e5292763">demoLang7</i>生成器</p></li></ul>   <h2 id="enhancethelanguage">增强语言</h2>   <p id="6b8609e7">这次，我们不是将所有输入XML <i id="03801425">元素都</i>表示为输入模型中的独立根，而是将它们包装到一个单独的根概念（称为<i id="ba7e89f0">XMLDocument）中</i> 。<i id="330d211c">demoLang7</i>语言将介绍此新概念及其编辑器：</p>   <p id="eefdf744">      </p><figure><img alt="gdg14" title="gdg14" src="/help/img/idea/2019.2/gdg14.png" id="9b1c81ac" width="873" height="379"></figure>      <br>该概念可能包含XML <i id="ff7ebe9e">元素</i>的集合，并且会将它们作为垂直集合显示在屏幕上。<p></p>   <p id="4f71d094">      </p><figure><img alt="屏幕截图2017年7月26日上午1 26 17" title="屏幕截图2017年7月26日上午1 26 17" src="/help/img/idea/2019.2/Screen-Shot-2017-07-26-at-1-26-17-AM.png" id="cb69c48f" width="798" height="348"></figure>   <p></p>   <h2 id="addcontent(container)">addContent（容器）</h2>   <ul class="list _ul"><li class="list__item" id="c0daeb4f"><p>打开<i id="6a98955d">DemoApp</i>模板</p></li><li class="list__item" id="924b6710"><p>添加静态void方法'addContent（Container）'</p></li><li class="list__item" id="e76a88b7">         <p id="be1ce3bf">在“ main（）”方法中找到以下语句：</p>         <div class="code-block" data-lang="none">$ LOOP $ [container.add（$ SWITCH $ [null]）;</div>      </li><li class="list__item" id="014e2939">         <p id="0ab712e9">用下面的语句替换上面的语句：</p>         <div class="code-block" data-lang="none">addContent（container）;</div>      </li></ul>   <p id="3d3e6f1d">      </p><figure><img alt="gdc1" title="gdc1" src="/help/img/idea/2019.2/gdc1.png" id="a0934c38" width="842" height="387"></figure>   <p></p>   <h2 id="newtestmodel">新的测试模型</h2>   <p id="fcd49e32">在继续使用生成器之前，让我们创建一个新的输入测试模型：</p>   <ul class="list _ul"><li class="list__item" id="3849494c"><p>转到“ test_models”解决方案</p></li><li class="list__item" id="6e3e15f3"><p>创建一个新模型“ test7”</p></li><li class="list__item" id="aa27dd0f"><p>在“ <b id="40ae9d45">使用的语言”</b>选项卡中添加“ jetbrains.mps.sampleXML”和“ jetbrains.mps.samples.generator_demo.demoLang7”</p></li><li class="list__item" id="cf9662fd"><p>添加一个新的<i id="f38c59e7">XMLDocument</i>根节点并键入代码：</p></li></ul>   <p id="17a90ddf">      </p><figure><img alt="gdg15" title="gdg15" src="/help/img/idea/2019.2/gdg15.png" id="95403215" width="810" height="187"></figure>   <p></p>   <p id="2393ace1">现在，让我们为这些文档定义语义。</p>   <h2 id="rootmappingrules">根映射规则</h2>   <p id="f1f1bc53">在以前的演示中，我们曾经利用<i id="c2be635b">条件根规则</i>来实例化<i id="3eef69f4">DemoApp</i>类模板。在演示7中，我们将使用不同的机制- <i id="327990b4">根映射规则</i> 。在“主要”映射配置中，删除<b id="95864cff">条件根规则</b>部分中的条目以及“ <b id="8637b0ed">放弃根”</b>部分中的条目，然后添加<i id="4d63d73f">根映射规则</i> ：<br>       </p><figure><img alt="gdg16" title="gdg16" src="/help/img/idea/2019.2/gdg16.png" id="45ea9d1a" width="851" height="220"></figure>   <p></p>   <p id="df023038">此规则将取代与我们所期望<i id="239081af">DemoApp</i>类模板一个<i id="8a66d0bc">XMLDocument。</i></p>   <h2 id="weavingrules">编织规则</h2>   <p id="5ef8b168">编织规则是一种可以在输出模型中添加额外节点的工具。在我们的案例中，我们将利用它们来插入代码，以向其容器中添加摆动组件。</p>   <ul class="list _ul"><li class="list__item" id="8268095a"><p>返回<i id="ebff25b2">demoLang7</i>生成器并在编辑器中打开映射配置“ main”</p></li><li class="list__item" id="2cde35df"><p>创建一个新的编织规则（当光标在<b id="3adfed85">编织规则</b>部分中时，按<i id="05b45d7d">Insert</i>或_Enter）</p></li><li class="list__item" id="dfc76ae5"><p>选择规则适用的概念-'元素'</p></li><li class="list__item" id="8026778c"><p>输入规则条件，如下所示：</p></li></ul>   <p id="4fa5229d">      </p><figure><img alt="gdg9" title="gdg9" src="/help/img/idea/2019.2/gdg9.png" id="dda95b2b" width="683" height="198"></figure>   <p></p>   <h2 id="weavingcontext">编织背景</h2>   <p id="34133f4e">编织规则将其他生成的代码注入其他生成的代码。编织上下文是编织规则将代码注入到的确切位置。 （注入的节点将是<i id="960d709f">上下文</i>节点的子节点）。</p>   <p id="d9eb6eff">在我们的例子中，我们将组件的设置代码注入到<i id="d23df9dd">DemoApp</i>类中。因此，我们必须在输出模型中找到生成的<i id="0eba7e1e">DemoApp</i>类，并将该类作为其编织上下文传递给我们的编织规则。</p>   <h2 id="mappinglabel">映射标签</h2>   <p id="30a3f98d">我们将使用<b id="19c0d7da">映射标签</b>在输出模型中找到生成的“ DemoApp”节点。如演示3中已讨论的那样，它们充当生成的节点的注册表，以便稍后可以由生成器的其他部分检索。这松开了独立发电机部件之间的耦合。</p>   <h4 id="declaringmappinglabel">声明映射标签</h4>   <p id="e04b377b">在使用映射标签之前，必须在映射配置中声明它：</p>   <ul class="list _ul"><li class="list__item" id="83fd63d2"><p>转到<i id="d0a571f7">主</i>映射配置的“ <b id="32bff88a">映射标签”</b>部分</p></li><li class="list__item" id="ac5a1d88"><p>添加新的映射标签（按<i id="8557ddb4">Insert</i>或<i id="acaa9742">Enter</i> ）</p></li><li class="list__item" id="380fc978"><p>给它起个名字：'main_class'</p></li><li class="list__item" id="6b396ba7"><p>选择“ ClassConcept”作为标签的输出概念，因为我们将<i id="466894a4">ClassConcepts</i>存储在映射标签中</p></li></ul>   <p id="a4e84f5d">      </p><figure><img alt="gdg18" title="gdg18" src="/help/img/idea/2019.2/gdg18.png" id="d96c0ad2" width="500" height="150"></figure>   <p></p>   <aside class="tip sideblock" rel="a4e84f5d" id="7aecc12f" data-title="">      <p id="e116e26e">在我们的案例中，我们将映射标签附加到规则，该规则将生成“ Demo App”类（Root映射规则）。<br>这就是为什么我们选择“ ClassConcept”作为标签的输出概念的原因。<br>表达式（我们将很快使用它）：</p>      <div class="code-block" data-lang="none">genContext.get输出“ main_class”</div>      <p id="6ec1c0f6">然后将具有类型：'node <classconcept>'。<br>在这种特殊情况下，“获取输出”表达式具有类型这一事实并没有为我们带来任何好处，但总的来说，它是一个非常有用的功能。</classconcept></p>   </aside>   <h4 id="attachingthelabeltoarule">将标签附加到规则</h4>   <p id="c088102b">使用规则的检查器将映射标签“ main_class”附加到“ <i id="9841e790">根”映射规则</i> ：</p>   <p id="aa7999ef">      </p><figure><img alt="gdg17" title="gdg17" src="/help/img/idea/2019.2/gdg17.png" id="ba41d935" width="607" height="256"></figure>   <p></p>   <h4 id="usingthemappinglabelforfindingthedesiredoutputnode">使用映射标签查找所需的输出节点</h4>   <p id="a77932f8">现在，返回到“编织规则”，并将以下代码输入到<b id="9144e753">上下文</b>函数中：</p>   <p id="d4c08551">      </p><figure><img alt="gdg19" title="gdg19" src="/help/img/idea/2019.2/gdg19.png" id="484f396a" width="978" height="187"></figure>      <br>现在，这将正确解析与已处理的<i id="d2c822d6">XMLDocument</i>相对应的<i id="c4bf36b5">DemoApp</i>类，并将其传递到编织规则中，以便它可以向其添加新方法。请注意<i id="20fa0a66">jetjetins.mps.smodel</i>查询<i id="40d9f034">node.ancestor</i>的使用，该查询将检索AST中指定概念的最近节点的祖先。<p></p>   <h2 id="externaltemplate">外部模板</h2>   <p id="da7fcf76">现在，我们为该编织规则创建一个模板，该模板将用于生成要添加到<i id="b41fe548">DempApp</i>类的代码：</p>   <ul class="list _ul"><li class="list__item" id="84a8f3b3"><p>在红色的“选择结果”单元格中键入“ weave_Button”</p></li><li class="list__item" id="674e5556"><p>按<i id="6ffd6a2a">Alt-Enter</i>并选择“新模板”（应用意图）</p></li><li class="list__item" id="2d33cc68"><p>在编辑器中打开模板（使用<i id="116425cf">Ctrl- <left-click></left-click></i>或参考单元格上的<i id="d9cda8d1">Ctrl + B组合键</i> ）</p></li></ul>   <p id="c4379ee0">模板应该已经设置了一个Class作为模板的内容节点，因为这是存储在<i id="0cdff0ce">main_class</i>映射标签中的元素的类型。如果不是，请选择“ ClassConcept”作为模板的内容节点。</p>   <ul class="list _ul"><li class="list__item" id="211889dd">         <p id="f6f2be3d">给班级起个名字</p>         <aside class="tip sideblock" rel="f6f2be3d" id="d4ca8e99" data-title="">            <p id="8b576dcb">您实际上不必给班级起一个名字。此类不会生成。<br>该类将用作上下文或位置，我们可以在其中放置新生成的代码<br>我们将使用<b id="76e5ae65">模板片段</b>标签标记此“真实代码”。</p>         </aside>      </li></ul>   <ul class="list _ul"><li class="list__item" id="c165c811"><p>添加一个静态方法'createComponent（）'</p></li><li class="list__item" id="61fc1233"><p>创建<b id="a09f8317">模板片段</b> ：选择整个方法声明，然后按<i id="3e7f0e73">Ctrl + Shift + F组合键</i> ：</p></li></ul>   <p id="67ba99e3">      </p><figure><img alt="gdg6" title="gdg6" src="/help/img/idea/2019.2/gdg6.png" id="57af03a6" width="600" height="257"></figure>   <p></p>   <aside class="tip sideblock" rel="67ba99e3" id="41e6cf0e" data-title="">      <p id="b23f7427">标记为<b id="c9c2412b">模板片段的</b>代码（在这种情况下为方法声明）在生成过程中插入到编织上下文节点（ <i id="a3547a43">DemoApp</i>类）中。</p>   </aside>      <h2 id="if-macro">IF宏</h2>   <p id="2da56341">以下步骤与示例3中的操作非常相似，因为我们仅使用另一种技术（编织规则而不是归约规则）有效地生成了相同的代码。</p>   <p id="9464e8aa">在'createComponent（）'方法内部，我们将创建和初始化JButton组件。<br>可选地，如果输入元素具有属性“文本”，那么我们将生成一条语句：</p>   <div class="code-block" data-lang="none">component.setText（_text_）</div>   <p id="4988657a">其中<i id="0086660e">text</i>是在输入元素的'text'属性中指定的字符串。</p>   <ul class="list _ul"><li class="list__item" id="191209b5"><p>在“ createComponent（）”方法的主体中输入以下代码</p></li><li class="list__item" id="1086733d"><p>围绕'component.setText（“ text”）;'创建一个IF宏语句（选择整个语句，按<i id="487bd448">Ctrl-Shift + M</i> ）</p></li><li class="list__item" id="4cebbb04"><p>输入IF宏的<b id="1789b26f">条件</b>函数的代码，该代码将检查'text'属性的存在</p></li></ul>   <p id="51f86500">      </p><figure><img alt="gdg7" title="gdg7" src="/help/img/idea/2019.2/gdg7.png" id="0608dc02" width="872" height="374"></figure>      <br>    <p></p>   <ul class="list _ul"><li class="list__item" id="627e32ca"><p>在字符串文字“ text”内创建一个属性宏</p></li><li class="list__item" id="80e7a7ed"><p>在属性宏的<b id="211aaa3c">值</b>函数中，输入代码以返回输入<i id="33310b67">元素</i>的'text'属性的值      </p></li></ul>   <p id="950a5087">      </p><figure><img alt="gdg8" title="gdg8" src="/help/img/idea/2019.2/gdg8.png" id="53ead038" width="783" height="280"></figure>   <p></p>   <h2 id="completethegenerator">完成发电机</h2>   <p id="73239cd7">为了完成此步骤，我们必须创建另一个编织规则，该规则将适用于“标签”元素。</p>   <ul class="list _ul"><li class="list__item" id="80145831"><p>打开“主”映射配置编辑器</p></li><li class="list__item" id="b9a2cdff"><p>选择刚才为“按钮”创建的编织规则（选择整个节点：将光标放在规则内，使用<i id="6a853c83">Ctrl + W</i>展开选择）</p></li><li class="list__item" id="c14d31d1"><p>按<i id="e5b71f4f">Ctrl + D</i> （重复）以在原始规则旁边创建相同的规则</p></li><li class="list__item" id="4d388d12">         <p id="dca44e2b">在<b id="b37edae2">条件</b>函数中，在语句中</p>         <div class="code-block" data-lang="none">node.name.equals（“ button”）;</div>         <p id="8cff4957">将“按钮”替换为“标签”</p>      </li><li class="list__item" id="8bc6289e"><p>在项目树中，选择模板节点“ weave_Button”</p></li><li class="list__item" id="5cac2dc0"><p>使用弹出菜单中的<i id="00ff2ddb">Clone Root</i>命令复制此模板节点</p></li><li class="list__item" id="d562749a"><p>在编辑器中，将此新模板重命名为“ weave_Label”</p></li><li class="list__item" id="5e874b45">         <p id="ce5cec61">在模板代码中替换语句</p>         <div class="code-block" data-lang="none">JButton组件=新的JButton（）;</div>      </li><li class="list__item" id="cd3bedd8">         <p id="061687aa">与</p>         <div class="code-block" data-lang="none">JLabel组件= new JLabel（）;</div>         <p id="4c075ad7">            <br>            </p><figure><img alt="gdg12" title="gdg12" src="/help/img/idea/2019.2/gdg12.png" id="33fbf0b6" width="578" height="268"></figure>         <p></p>      </li><li class="list__item" id="9f443a0a">         <p id="9d4abe15">如果未自动解决方法调用，请在语句中重新自动完成“ setText”</p>         <div class="code-block" data-lang="none">$ IF $ [component.setText（“ $ [text]”）;]</div>      </li><li class="list__item" id="18e3eb9c">         <p id="73d08e1e">将“ weave_Label”模板附加到“主”映射配置中的第二条编织规则<br>            <br>            </p><figure><img alt="gdg11" title="gdg11" src="/help/img/idea/2019.2/gdg11.png" id="04253c5f" width="674" height="365"></figure>         <p></p>      </li><li class="list__item" id="2ee1c62d"><p>重新生成发电机模型</p></li></ul>   <h2 id="firsttest(error)">首次测试（错误）</h2>   <p id="54905e47">尝试重建语言并从模型“ test7”生成文件。<br>生成应该没有问题，但编译将失败并显示以下错误：</p>   <div class="code-block" data-lang="none">generator_demo \ test7 \ DemoApp.java：类型为DemoApp的重复方法createComponent（）（行：37）</div>   <p id="e1b8b46b">单击错误消息以查看生成的代码中的错误：</p>   <div class="code-block" data-lang="none">公共静态组件createComponent（）{// <-error JButton component = new JButton（）; component.setText（“ Hello”）;返回组件； } public static Component createComponent（）{// <-error JLabel component = new JLabel（）; component.setText（“世界！“）;返回组件；}</div>   <p id="2807aa57">问题在于我们的编织规则总是注入同名的方法声明：'createComponent（）'</p>      <h2 id="generatinguniquenames">生成唯一名称</h2>   <p id="ba37eb1a">为了使每个生成的“ createComponent（）”方法的名称唯一，我们将创建另一个属性宏：</p>   <ul class="list _ul"><li class="list__item" id="d72a9866"><p>在编辑器中打开“ weave_Button”模板</p></li><li class="list__item" id="b61d6213"><p>将属性宏添加到“ createComponent（）”方法的名称中</p></li><li class="list__item" id="915e55f1"><p>在其<b id="eb156b5d">value</b>函数中输入代码，如下所示</p></li></ul>   <p id="b060a133">      </p><figure><img alt="gdg22" title="gdg22" src="/help/img/idea/2019.2/gdg22.png" id="ad58c508" width="784" height="294"></figure>   <p></p>   <p id="51d929bd"><b id="1de45627"><i id="ccc9a9e2">templateValue</i></b>将是“ createComponent”（即，在模板中编写的方法名称）。</p>   <ul class="list _ul"><li class="list__item" id="b8bf29ad"><p>在“ weave_Label”模板中进行类似的更改</p></li><li class="list__item" id="1de89f46"><p>重新生成发电机模型</p></li></ul>   <h2 id="secondtest">第二次测试</h2>   <p id="0659c944">从“ test7”模型生成文件-这次我们应该没有错误。</p>   <p id="87755cbe">预览为“ test7”生成的文本：</p>   <div class="code-block" data-lang="none">公共类DemoApp {公共静态void main（String [] args）{JFrame frame = new JFrame（“ Demo”）; frame.setDefaultCloseOperation（JFrame。EXIT_ON_CLOSE）;容器容器= frame.getContentPane（）; container.setLayout（new FlowLayout（））; addContent（container）; frame.pack（）; frame.setLocationRelativeTo（null）; frame.setVisible（true）; } public static void addContent（Container container）{} public static Component createComponent0（）{JButton component = new JButton（）; component.setText（“ Hello”）;返回组件； }公共静态组件createComponent1（）{JLabel component = new JLabel（）; component.setText（“世界！“）;返回组件；}}</div>   <p id="b56b7379">该代码没有编译问题，但是仍然无法正常工作，因为'addContent（）'方法的主体为空。我们不是在调用刚刚创建的创建方法。让我们通过编织以下代码来解决此问题：</p>   <div class="code-block" data-lang="none">container.add（createComponent0（））; container.add（createComponent1（））;</div>   <p id="11a67894">放入“ addContent（）”方法的主体中。</p>   <h2 id="secondtemplatefragment">第二个模板片段</h2>   <p id="8117d6db">为了生成“ createComponent（）”方法的方法调用，我们将添加另一个编织规则和一个模板。必须将对所有生成的“ createComponent（）”方法的调用编织到主要生成的类的“ addContent（）”方法中，因此，我们首先必须将“ addContent（）”方法存储在<b id="49ad5cad">映射标签</b>中，以便引用从编织规则。</p>   <p id="a38c7a5a">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f1.png"><img alt="g7f1" title="g7f1" src="/help/img/idea/2019.2/g7f1.png" id="404545d6" width="700" height="532"></a></figure>   <p></p>   <p id="73144813">我们可以使用<b id="cdb0dcac">LABEL</b>节点宏将生成的方法存储在<b id="ef4c9b7b">映射标签中</b> ：</p>   <p id="6af91eca">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f3.png"><img alt="g7f3" title="g7f3" src="/help/img/idea/2019.2/g7f3.png" id="c19df6af" width="900" height="712"></a></figure>   <p></p>   <p id="bcfa9f03">现在，一个新<b id="e06f0de8">的编织规则</b>需要被添加到<i id="127a5640">主要</i>的<i id="f8e46438">织造规则</i>部分<b id="672965b5"></b>映射配置，该配置会将对单个“ createComponent（）”方法的调用插入到“ addContent（）”方法中：</p>   <p id="56c32e06">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f4.png"><img alt="g7f4" title="g7f4" src="/help/img/idea/2019.2/g7f4.png" id="d55ce483" width="900" height="290"></a></figure>   <p></p>   <p id="d2012ad5">注意， <b id="96e3e06f">上下文</b>从<b id="3605cb22">映射标签</b> <b id="96e3e06f">中</b>检索“ addContent（）”方法，并将该方法的<i id="2f75fbb6">主体</i>作为将编织模板片段的节点返回。</p>   <p id="1caf83e9"><i id="b30ec2c3">weave_ElementInitialization</i>模板会将对单个“ createComponent（）”方法的调用插入其上下文节点（方法主体，即<i id="987e765d">StatementList</i> ）中：</p>   <p id="c5502035">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f5.png"><img alt="g7f5" title="g7f5" src="/help/img/idea/2019.2/g7f5.png" id="829567b2" width="500" height="608"></a></figure>   <p></p>   <aside class="warning " rel="c5502035" id="11cc457f" data-title="">      <p id="60ccf370">确保将整个语句标记为模板片段，包括结尾的分号。</p>   </aside>   <p id="a12a149a"> </p>   <p id="f7e228b8">向方法声明中添加参数“容器容器”（此参数必须与“ DemoApp”模板中实际“ addContent（）”方法中的参数名称相同）。</p>   <p id="7a56ab36"> </p>   <aside class="tip sideblock" rel="7a56ab36" id="c21f3640" data-title="">      <p id="0eaa5ebe">如果决定以不同的方式命名<i id="ffc99e42">Container</i>参数，以使模板片段中的“容器”与生成的“ DemoApp.addContent（）”方法中的容器参数之间不再存在名称匹配，则需要解析实际的参数“ DemoApp.addContent（）”以及参考宏：</p>      <p id="3f9a1603">         </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f8.png"><img alt="g7f8" title="g7f8" src="/help/img/idea/2019.2/g7f8.png" id="189d1041" width="900" height="994"></a></figure>      <p></p>   </aside>   <p id="09feb444">实际的'createComponent（）'方法必须从某个地方获取- <b id="c16103ca">映射标签</b>会很好地工作，因此我们需要首先创建一个新的<b id="f263b90a">映射标签</b>以容纳这些方法，然后将这些方法插入到<b id="98ca7c64">映射标签中</b> ：</p>   <p id="30002803">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f6.png"><img alt="g7f6" title="g7f6" src="/help/img/idea/2019.2/g7f6.png" id="cc2a45bb" width="700" height="464"></a></figure>   <p></p>   <p id="35c477b9"><b id="2fae9798">LABEL</b>节点宏将帮助我们在其各自的编织规则/模板中将<b id="ba470112">Button</b>和<b id="2b892146">Labels</b>的'createComponent（）'方法存储在<i id="111604b4">createComponentMethods</i> <b id="9cfd97da">映射标签</b>中：</p>   <p id="df8d1a17">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f2.png"><img alt="g7f2" title="g7f2" src="/help/img/idea/2019.2/g7f2.png" id="a6c494ca" width="900" height="590"></a></figure>   <p></p>   <p id="754c0497">对于<b id="7d6b33c4">weave_Button</b>和<b id="209a659c">weave_Label</b>都应该这样做。</p>   <p id="6c5af87d">现在，我们可以返回到<i id="4309d9c4">weave_ElementInitialization</i>模板，并在对“ createComponent（）”的调用上指定一个引用宏，以从<i id="9008105b">createComponentMethods</i> <b id="b6ee0ac3">映射标签</b>获取适当的“ createComponent（）”方法：</p>   <p id="ad818513">      </p><figure><a class="lightbox" href="/help/img/idea/2019.2/g7f7.png"><img alt="g7f7" title="g7f7" src="/help/img/idea/2019.2/g7f7.png" id="f095e319" width="700" height="994"></a></figure>   <p></p>   <h2 id="thirdtest">第三次测试</h2>   <p id="03144425">现在，您可以将生成器模型设为从“ test_models”解决方案中的“ test7”模型生成文件。</p>   <p id="07d591e4">      </p><figure><img alt="gdg21" title="gdg21" src="/help/img/idea/2019.2/gdg21.png" id="7b3ea330" width="462" height="613"></figure>   <p></p>   <p id="baf2f661">现在，您将获得我们简单应用程序的正确且完整的代码。</p><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月30日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="generator-user-guide-demo6.html">发电机用户指南Demo6</a> <a class="navigation-links__next" href="textgen.html">TextGen</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>