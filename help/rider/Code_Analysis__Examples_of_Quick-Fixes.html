<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>快速修复的示例-帮助|帮助JetBrains骑士</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Code_Analysis__Examples_of_Quick-Fixes" data-breadcrumbs="Code_Analysis__Index.xml|Code Analysis/Code_Analysis__Quick-Fixes.xml|Quick-Fixes for Code Issues/Code_Analysis__Examples_of_Quick-Fixes.xml|Examples of Quick-Fixes" data-main-title="Examples of Quick-Fixes" data-article-props="
                {
                
            " seeals=":[=" titl=":=" procedure=",=" link=":=" ur=":" coding_assistance__importing_namespaces.htm="," tex=":" import="" missing="" namespace="}=" coding_assistance__context_actions.htm="," context="" action="}=" web="" resource=",=" http:="" ="" www.jetbrains.net="" devnet="" community="" idea="" k="," developer="" communit="}=" data-disqus-id="Code_Analysis__Examples_of_Quick-Fixes_rdr"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索JetBrains Rider帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>JetBrains Rider 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="visual_studio" data-group="primary">视觉工作室</option><option value="resharper" data-group="primary">锐化器</option><option value="_default" data-group="primary">默认（IntelliJ IDEA）</option><option value="visual_studio_osx" data-group="secondary">Visual Studio（macOS）</option><option value="resharper_osx" data-group="secondary">ReSharper（macOS）</option><option value="mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5+（IntelliJ IDEA）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="active"><h1 id="Code_Analysis__Examples_of_Quick-Fixes.xml" data-toc="Code_Analysis__Examples_of_Quick-Fixes">快速修复的示例</h1>    <p id="44edc799">快速修复程序在各种情况下都可用，它太大而无法列出。JetBrains Rider以所有受支持的语言提供了总共1200多个快速修复。这里我们将展示如何在少数情况下使用它们：</p>    <div class="chapter"><h2 id="typeMismatch" data-toc="Code_Analysis__Examples_of_Quick-Fixes#typeMismatch">类型不匹配</h2>        <p id="1e88d76f">每当无法将表达式的类型隐式转换为适用于表达式上下文的类型时，JetBrains Rider都会检测到此错误并在编辑器中突出显示该错误。将插入符号定位在突出显示的错误并按<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd> ，您可以从以下列表中选择一种快速修复：</p>        <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch.gif" id="a4e991e0" width="285" height="182"></figure>        <p id="92133268">下表列出了应用建议的快速修复方法的效果。</p>        <div class="table-wrapper"><table width="100%" id="17bffcaf"><thead><tr id="3c3c692e" class="ijRowHead"><th id="e1cb7320" width="35%"><p>快速解决</p></th><th id="00718df0" width="65%"><p>影响</p></th></tr></thead><tbody><tr id="d3215028" class="ijRowOdd"><td id="1988e125"><p>投放到<code class="code">string</code>                </p></td><td id="37e4381b">                    <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch1.gif" id="436329a8" width="186" height="40"></figure>                </td></tr><tr id="33db04d2" class="ijRowEven"><td id="d8bd67ca"><p>安全地投射到<code class="code">string</code>                </p></td><td id="ee85ee9e">                    <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch2.gif" id="11a570c0" width="191" height="39" class="inline-icon-191"></figure>                </td></tr><tr id="e6e93f07" class="ijRowOdd"><td id="c0d2e1d1"><p>变更类型<code class="code">o</code>至<code class="code">string</code>                </p></td><td id="93fb14f9">                    <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch5.png" id="37c7814b" width="141" height="39" class="inline-icon-141"></figure>                </td></tr><tr id="ec0da3d5" class="ijRowEven"><td id="1bee2397"><p>变更类型<code class="code">s</code>至<code class="code">object</code>                </p></td><td id="6d60db11">                    <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch3.gif" id="d9535023" width="191" height="39" class="inline-icon-191"></figure>                </td></tr><tr id="347c874c" class="ijRowOdd"><td id="1293dbc2"><p>呼叫<code class="code">ToString()</code>                </p></td><td id="c06af848">                    <figure><img alt="JetBrains Rider：类型不匹配快速修复" title="JetBrains Rider：类型不匹配快速修复" src="/help/img/dotnet/2019.2/typeMismatch4.gif" id="51bfada9" width="194" height="42"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="undefinedVariable" data-toc="Code_Analysis__Examples_of_Quick-Fixes#undefinedVariable">未定义的变量</h2>        <p id="611b96a6">每当JetBrains Rider在您的代码中检测到未定义的变量时，都会突出显示该错误。将插入符号定位在突出显示的错误并按<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd>您将看到以下快速修复列表：</p>        <figure><img alt="JetBrains Rider：未定义的变量快速修复" title="JetBrains Rider：未定义的变量快速修复" src="/help/img/dotnet/2019.2/undefinedVariable.gif" id="04791870" width="279" height="152"></figure>        <p id="dd05924a">下表列出了应用建议的快速修复方法的效果。</p>        <div class="table-wrapper"><table width="100%" id="660ac072"><thead><tr id="59e23ae5" class="ijRowHead"><th id="ade53a80" width="35%"><p>快速解决</p></th><th id="354706d4" width="65%"><p>影响</p></th></tr></thead><tbody><tr id="d89134b3" class="ijRowOdd"><td id="98dfc82c"><p>创建局部变量<code class="code">s</code>                </p></td><td id="1875706e"><p>一个新的局部变量<code class="code">s</code>创建，建议您选择所需的类型。</p></td></tr><tr id="ee566adf" class="ijRowEven"><td id="52c0ac02"><p>创建参数<code class="code">s</code>在包含方法中</p></td><td id="022defbd">                    <p id="2103916f">将新参数添加到方法签名：</p>                    <figure><img alt="JetBrains Rider：未定义的变量快速修复" title="JetBrains Rider：未定义的变量快速修复" src="/help/img/dotnet/2019.2/undefinedVariable3.gif" id="3ac39cee" width="324" height="51"></figure>                </td></tr><tr id="a7d7d229" class="ijRowOdd"><td id="e6d5a275"><p>建立其他</p></td><td id="4b7a1d26">                    <p id="6095f491">打开一个子菜单，您可以在其中选择在相应的类中创建字段或属性。例如，如果您选择创建一个字段，则创建一个新的私有字段<code class="code">s</code>在当前类中创建。出现以下建议，以帮助您选择新字段的正确类型：</p>                    <figure><img alt="JetBrains Rider：未定义的变量快速修复" title="JetBrains Rider：未定义的变量快速修复" src="/help/img/dotnet/2019.2/undefinedVariable2.gif" id="57b1cf36" width="234" height="127"></figure>                </td></tr><tr id="6930f8ea" class="ijRowEven"><td id="aef2a969"><p>全部更改<code class="code">s</code>                </p></td><td id="0944db07">                    <p id="2f0ad677">如果选择<span class="control">全部更改</span> ，则会显示以下建议：</p>                    <figure><img alt="JetBrains Rider：未定义的变量快速修复" title="JetBrains Rider：未定义的变量快速修复" src="/help/img/dotnet/2019.2/syncEdit.png" id="d68dd404" width="112" height="51"></figure>                    <p id="b1f5ad12">只需输入一次新名称； JetBrains Rider会更改所有其他未定义变量的出现：</p>                    <figure><img alt="JetBrains Rider：未定义的变量快速修复" title="JetBrains Rider：未定义的变量快速修复" src="/help/img/dotnet/2019.2/undefinedVariable1.gif" id="f0558f28" width="267" height="39" class="inline-icon-267"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="undefinedMethod" data-toc="Code_Analysis__Examples_of_Quick-Fixes#undefinedMethod">未定义的方法调用</h2>        <p id="08e51eec">每当JetBrains Rider在您的代码中检测到对未定义方法的调用时，都会突出显示该错误。将插入符号定位在突出显示的错误并按<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd> ，JetBrains Rider显示以下快速修复列表：<br>            </p><figure><img alt="JetBrains Rider：未定义的方法调用快速修复" title="JetBrains Rider：未定义的方法调用快速修复" src="/help/img/rider/2019.2/Code_Analysis__Examples_of_Quick-Fixes__undefined_method__quick-fixes.png" id="6d5f9aa7" width="501" height="198"></figure>        <p></p>        <p id="42ed6c39">应用快速修复后，代码将被修改，如下表所示：</p>        <div class="table-wrapper"><table width="100%" id="d53ae9f3"><thead><tr id="ea11218b" class="ijRowHead"><th id="e405c579" width="35%"><p>快速解决</p></th><th id="3faa72f9" width="65%"><p>影响</p></th></tr></thead><tbody><tr id="ebf200b2" class="ijRowOdd"><td id="1b963d6b"><p>创建方法<code class="code">ResolveManagedReference</code>                </p></td><td id="d246ee08">                    <p id="31f582e8">此快速修复程序声明了一个具有从方法调用派生的签名的新方法，从而使喜欢自顶向下编程的开发人员受益。在我们的示例中，JetBrains Rider创建以下声明，正确猜测返回类型：</p>                    <figure><img alt="JetBrains Rider：未定义的方法调用快速修复" title="JetBrains Rider：未定义的方法调用快速修复" src="/help/img/rider/2019.2/Code_Analysis__Examples_of_Quick-Fixes__undefined_method__return_type.png" id="fdf5bcfb" width="321" height="70"></figure>                    <p id="4dd48dce">JetBrains Rider还建议新方法的适用类型和参数名称：</p>                    <figure><img alt="JetBrains Rider：未定义的方法调用快速修复" title="JetBrains Rider：未定义的方法调用快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__undefined_method__parameter.png" id="8b98dab1" width="798" height="133"></figure>                    <a name="tip_generation_settings"></a>        <aside class="prompt" rel="00d4d54e" id="554fa4b1" data-type="tip" data-title="">            <p id="422f1b36">                <a name="generated_settings_raw"></a>根据您的设置，可以用不同的方式生成新成员的存根。例如，他们可以抛出新的<code class="code">NotImplementedException()</code> ，返回默认值或包含将无法编译的代码。您可以在以下位置配置这些首选项和其他首选项<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">编辑器|的会员生成</span>页面<a name="product_settings"></a> JetBrains骑士设置<kbd data-visual_studio="Ctrl+Alt+S" data-resharper="Ctrl+Alt+S" data-_default="Ctrl+Alt+S" data-visual_studio_osx="⌘ ," data-resharper_osx="⌘ ," data-mac_os_x_10.5_="⌘ ,">Ctrl+Alt+S</kbd> 。</p>        </aside>                    </td></tr><tr id="d22b5163" class="ijRowEven"><td id="759a7a1c"><p>建立其他</p></td><td id="12f1a386">                    <p id="d9ebf76a">该子菜单包括其他涉及创建辅助代码的快速修复。例如：</p>                    <ul class="list _ul"><li class="list__item" id="3021f793"><p>创建参数<code class="code">ResolveManagedReference</code>在包含方法和更新层次结构中。<br>此快速修复程序会通过未解析的符号在当前方法中创建一个新参数，并将此参数引入该方法可能具有的任何基本成员和继承者中。</p></li><li class="list__item" id="88d56ef2"><p>创建参数<code class="code">ResolveManagedReference</code>在包含方法中<br>此快速修复程序会通过未解析的符号在当前方法中创建一个新参数，但不会更新其基本方法或继承者。</p></li></ul>                </td></tr><tr id="dabc3732" class="ijRowOdd"><td id="b143da35"><p>全部更改<code class="code">ResolveManagedReference</code>                </p></td><td id="3c2c3177"><p>与<a href="#undefinedVariable">未定义变量</a>的相应快速修复类似，该快速修复使您可以快速替换所有出现的符号<code class="code">someMethod</code> 。</p></td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="forgottenReturn" data-toc="Code_Analysis__Examples_of_Quick-Fixes#forgottenReturn">被遗忘的方法返回</h2>        <p id="8bb35a1f">如果期望某个方法返回一个值，但是您忘记提供一个<code class="code">return</code>声明中，JetBrains Rider通过突出显示该麻烦方法的右括号来警告您。将插入符号定位在突出显示的错误并按<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd>您将获得以下快速修复：</p>        <figure><img alt="JetBrains骑士：被遗忘的方法返回快速修复" title="JetBrains骑士：被遗忘的方法返回快速修复" src="/help/img/dotnet/2019.2/forgottenReturn.gif" id="8c8a6053" width="225" height="124"></figure>        <div class="table-wrapper"><table width="100%" id="259d9a72"><thead><tr id="8ad36e99" class="ijRowHead"><th id="13ae1d3e" width="35%"><p>快速解决</p></th><th id="9d6c7b22" width="65%"><p>影响</p></th></tr></thead><tbody><tr id="5d34bd84" class="ijRowOdd"><td id="e1924329"><p>添加退货声明</p></td><td id="a968427c"><p>应用快速修复后，JetBrains Rider将添加一个<code class="code">return</code>声明返回<code class="code">null</code> 。</p></td></tr><tr id="876d63ea" class="ijRowEven"><td id="af95e819"><p>使方法返回空</p></td><td id="43c20b70"><p>应用快速修复后，JetBrains Rider将方法的初始返回类型替换为<code class="code">void</code> 。</p></td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="missingUsing" data-toc="Code_Analysis__Examples_of_Quick-Fixes#missingUsing">缺少使用指令</h2>        <p id="74fa5092">每当您在代码中有一个无法解析的类型名称，因为您忘记在文件中编写相应的using指令时，都会弹出一个小窗口，提示您导入该类型：</p>        <figure><img alt="JetBrains Rider：命名空间导入快速修复" title="JetBrains Rider：命名空间导入快速修复" src="/help/img/rider/2019.2/namespace_style_01.png" id="d7a5aa39" width="565" height="90"></figure>        <p id="22b3f2d5">按<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd> ，并将插入适当的using指令。如果存在多个具有匹配名称的类型，则将要求您选择要使用的类型（有关详细信息，请参阅<a href="Coding_Assistance__Importing_Namespaces.html">导入名称空间</a> ）。</p>        <p id="importing_via_alt_enter">如果由于某种原因您选择在显示弹出窗口时不导入所需的名称空间，或者<span class="control">在“</span> <span class="menupath" data-skip-index="skip">代码检查” |</span> “ <span class="menupath" data-skip-index="skip">代码” |“检查</span> <span class="control">”中</span>清除了<span class="control">“使用弹出窗口显示“导入名称空间”操作</span>复选框，通过JetBrains Rider选项的<span class="menupath" data-skip-index="skip">“设置”</span>页面，您可以随时通过将插入符号置于非导入类型并按来导入类型<kbd data-visual_studio="Alt+Enter" data-resharper="Alt+Enter" data-_default="Alt+Enter" data-visual_studio_osx="⌥ Enter" data-resharper_osx="⌥ Enter" data-mac_os_x_10.5_="⌥ Enter">Alt+Enter</kbd>并选择相应的快速修复。</p><figure><img alt="JetBrains Rider：缺少名称空间导入的快速修复" title="JetBrains Rider：缺少名称空间导入的快速修复" src="/help/img/rider/2019.2/namespace_import_fixes.png" id="d3e9c437" width="418" height="151"></figure>    <p></p>        <p id="excluding_items_from_suggestions">您可能希望不建议使用某些符号，例如，如果解决方案中的内容与系统类型相似，请说<code class="code">MyFramework.MyCollections.List</code> ，但实际上并没有使用它。要将此类符号从建议中<span class="control">排除</span> ，请将其添加到“ <span class="control">从导入和完成</span>中<span class="control">排除”</span>列表中<a name="the_options_page"></a> <span class="menupath" data-skip-index="skip">编辑器|一般|的自动导入</span>页面<a name="product_settings"></a> JetBrains骑士设置<kbd data-visual_studio="Ctrl+Alt+S" data-resharper="Ctrl+Alt+S" data-_default="Ctrl+Alt+S" data-visual_studio_osx="⌘ ," data-resharper_osx="⌘ ," data-mac_os_x_10.5_="⌘ ,">Ctrl+Alt+S</kbd> 。 <a name="exclude_format_of_the_entries"></a>                    条目的格式为<code class="code">Fully.Qualified.Name</code> ， <code class="code">Fully.Qualified.Name.Prefix*</code> ， 要么<code class="code">*Fully.Qualified.Name.Suffix</code> 。通用类型指定为<code class="code">List`1</code> 。</p>    </div>    <div class="chapter"><h2 id="async" data-toc="Code_Analysis__Examples_of_Quick-Fixes#async">缺少异步修饰符</h2>        <p id="72c4bfc2">如果您的方法包含<code class="code">await</code>运算符，但未定义为异步运算符，JetBrains Rider会检测到这种不匹配，并提供使用相应的快速修复程序解决此问题的方法。</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="9a74dfea"><tbody><tr id="58648d1b" class="ijRowOdd"><td id="6ca5ca24" width="200"><p>之前：</p></td><td id="a83e4dfa">                    <figure><img alt="JetBrains骑士：缺少异步修改器快速修复" title="JetBrains骑士：缺少异步修改器快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_async_01.png" id="45370e81" width="586" height="72"></figure>                </td></tr><tr id="082a5a3b" class="ijRowEven"><td id="fdf28f2b"><p>应用快速修复：</p></td><td id="cfa4f6e7">                    <figure><img alt="JetBrains骑士：缺少异步修改器快速修复" title="JetBrains骑士：缺少异步修改器快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_async_02.png" id="48ff2929" width="635" height="108"></figure>                </td></tr><tr id="082cef67" class="ijRowOdd"><td id="fee9f380"><p>后：</p></td><td id="3260744d">                    <figure><img alt="JetBrains骑士：缺少异步修改器快速修复" title="JetBrains骑士：缺少异步修改器快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_async_03.png" id="2719156b" width="587" height="73"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="loop_to_LINQ" data-toc="Code_Analysis__Examples_of_Quick-Fixes#loop_to_LINQ">将循环转换为LINQ表达式</h2>        <p id="2713622b">使用C＃3.0和LINQ，开发人员可以通过直接向编译器描述其意图来更轻松地编写数据密集型代码。JetBrains Rider检测到可以使用LINQ语法重写的代码，并提供自动执行转换的功能：</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="4dcba2f8"><tbody><tr id="7a731057" class="ijRowOdd"><td id="a5b21dbe" width="200"><p>之前：</p></td><td id="da7fea63">                    <figure><img alt="JetBrains Rider：将循环转换为LINQ表达式快速修复" title="JetBrains Rider：将循环转换为LINQ表达式快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__loops_to_LINQ_01.png" id="a4584ccb" width="584" height="89"></figure>                </td></tr><tr id="f4c43799" class="ijRowEven"><td id="cd931985"><p>应用快速修复：</p></td><td id="0b1ecb16">                    <figure><img alt="JetBrains Rider：将循环转换为LINQ表达式快速修复" title="JetBrains Rider：将循环转换为LINQ表达式快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__loops_to_LINQ_02.png" id="b9b2ad73" width="482" height="127"></figure>                </td></tr><tr id="c1b627ac" class="ijRowOdd"><td id="b3003570"><p>后：</p></td><td id="bee404ef">                    <figure><img alt="JetBrains Rider：将循环转换为LINQ表达式快速修复" title="JetBrains Rider：将循环转换为LINQ表达式快速修复" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__loops_to_LINQ_03.png" id="e01cc080" width="627" height="58"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="use_ienumerable" data-toc="Code_Analysis__Examples_of_Quick-Fixes#use_ienumerable">迁移到方法参数中的IEnumerable并返回</h2>        <p id="50ceaa7e">JetBrains Rider扫描您的代码库以检测可以安全返回并接受的方法<code class="code">IEnumerable</code>而不是更具体的类型，例如<code class="code">Array</code> ， <code class="code">List</code> ， 要么<code class="code">ArrayList</code> ：</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="857f2035"><tbody><tr id="704b1cc3" class="ijRowOdd"><td id="c121d3bb" width="200"><p>之前：</p></td><td id="d31e240e">                    <figure><img alt="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" title="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__use_ienumerable_01.png" id="8bac0158" width="308" height="98"></figure>                </td></tr><tr id="3c48710f" class="ijRowEven"><td id="9c6fd8f7"><p>应用快速修复：</p></td><td id="bfe26187">                    <figure><img alt="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" title="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__use_ienumerable_02.png" id="da21a161" width="423" height="133"></figure>                </td></tr><tr id="d3c446f7" class="ijRowOdd"><td id="f536d394"><p>后：</p></td><td id="4aef416b">                    <figure><img alt="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" title="JetBrains Rider：在方法参数中迁移到IEnumerable并返回" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__use_ienumerable_03.png" id="4c45f802" width="340" height="93"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="object_initializers" data-toc="Code_Analysis__Examples_of_Quick-Fixes#object_initializers">将赋值语句转换为对象初始化程序</h2>        <p id="34614e85">JetBrains Rider提供了上下文操作和快速修复程序，可将赋值语句转换为对象初始化程序。上下文操作使您可以将字段分配一对一地添加到初始化程序，而快速修复可以一次性添加所有字段。快速修复的工作方式如下：</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="e9e8e3e9"><tbody><tr id="fc596543" class="ijRowOdd"><td id="fa296f02" width="200"><p>之前：</p></td><td id="1d6d2258">                    <figure><img alt="JetBrains Rider：将赋值语句转换为对象初始化程序" title="JetBrains Rider：将赋值语句转换为对象初始化程序" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__object_initializers__01.png" id="83fd1641" width="186" height="63"></figure>                </td></tr><tr id="cfd50ddc" class="ijRowEven"><td id="2c7ba7a0"><p>应用快速修复：</p></td><td id="53a6ca74">                    <figure><img alt="JetBrains Rider：将赋值语句转换为对象初始化程序" title="JetBrains Rider：将赋值语句转换为对象初始化程序" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__object_initializers__02.png" id="de8a9657" width="459" height="86"></figure>                </td></tr><tr id="2386f172" class="ijRowOdd"><td id="ae7369c2"><p>后：</p></td><td id="8644d531">                    <img alt="JetBrains Rider：将赋值语句转换为对象初始化程序" title="JetBrains Rider：将赋值语句转换为对象初始化程序" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__object_initializers__03.png" id="7e9c5431" width="423" height="28" class="inline-icon-423">                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="static_to_extension" data-toc="Code_Analysis__Examples_of_Quick-Fixes#static_to_extension">将静态方法调用转换为扩展方法调用</h2>        <p id="c7d94191">当您将扩展方法作为传统的C＃静态方法调用时，JetBrains Rider可帮助您快速遵守标准扩展方法调用惯例：</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="fd86932a"><tbody><tr id="60bb5a33" class="ijRowOdd"><td id="4386f234" width="200"><p>之前：</p></td><td id="67cedb1c">                    <figure><img alt="JetBrains Rider：将静态方法调用转换为扩展方法调用" title="JetBrains Rider：将静态方法调用转换为扩展方法调用" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__invoke_as_extension_method__01.png" id="c71b7034" width="263" height="43"></figure>                </td></tr><tr id="1ed63cb5" class="ijRowEven"><td id="e3dd34c1"><p>应用快速修复：</p></td><td id="e6a82a22">                    <figure><img alt="JetBrains Rider：将静态方法调用转换为扩展方法调用" title="JetBrains Rider：将静态方法调用转换为扩展方法调用" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__invoke_as_extension_method__02.png" id="c3f3c34d" width="511" height="92"></figure>                </td></tr><tr id="0c7dcdec" class="ijRowOdd"><td id="ade566fd"><p>后：</p></td><td id="fbd62f1f">                    <figure><img alt="JetBrains Rider：将静态方法调用转换为扩展方法调用" title="JetBrains Rider：将静态方法调用转换为扩展方法调用" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__invoke_as_extension_method__03.png" id="a7b4949c" width="260" height="45"></figure>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="lambdas" data-toc="Code_Analysis__Examples_of_Quick-Fixes#lambdas">将匿名方法转换为Lambda表达式</h2>        <p id="e7fd4309">JetBrains Rider建议将匿名方法转换为lambda表达式。提供反向功能作为上下文动作。</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="0c6ff0bb"><tbody><tr id="a41c0b9a" class="ijRowOdd"><td id="713b0d60" width="200"><p>之前：</p></td><td id="d1d2b5cb">                    <img alt="JetBrains Rider：将匿名方法转换为lambda表达式" title="JetBrains Rider：将匿名方法转换为lambda表达式" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__to_lambda__01.png" id="b2a3446b" width="414" height="32" class="inline-icon-414">                </td></tr><tr id="51933e6d" class="ijRowEven"><td id="0ba42da6"><p>应用快速修复：</p></td><td id="a8fba8df">                    <figure><img alt="JetBrains Rider：将匿名方法转换为lambda表达式" title="JetBrains Rider：将匿名方法转换为lambda表达式" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__to_lambda__02.png" id="679f50f1" width="453" height="87"></figure>                </td></tr><tr id="4483486a" class="ijRowOdd"><td id="5691670e"><p>后：</p></td><td id="0bc23f7d">                    <img alt="JetBrains Rider：将匿名方法转换为lambda表达式" title="JetBrains Rider：将匿名方法转换为lambda表达式" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__to_lambda__03.png" id="41b62f46" width="255" height="25" class="inline-icon-255">                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="to_auto_property" data-toc="Code_Analysis__Examples_of_Quick-Fixes#to_auto_property">转换为自动属性</h2>        <p id="9c5eb70a">使用JetBrains Rider，可以快速将传统的基于私有字段的属性转换为在C＃3.0中实现的自动属性。有关更多信息，请参见<a href="Using_Auto_Properties.html">使用自动属性</a> 。</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="a6ab0c64"><tbody><tr id="344addb8" class="ijRowOdd"><td id="b5b84314" width="200"><p>之前：</p></td><td id="37e85da2">                    <figure><img alt="JetBrains Rider：转换为自动属性" title="JetBrains Rider：转换为自动属性" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__convert_to_auto_property__01.png" id="8e7336d6" width="210" height="109"></figure>                </td></tr><tr id="eec9d50e" class="ijRowEven"><td id="0f14baa0"><p>应用快速修复：</p></td><td id="6b86193b">                    <figure><img alt="JetBrains Rider：转换为自动属性" title="JetBrains Rider：转换为自动属性" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__convert_to_auto_property__02.png" id="5d5c770f" width="382" height="120"></figure>                </td></tr><tr id="7bcf3c7b" class="ijRowOdd"><td id="20a871c9"><p>后：</p></td><td id="87484012">                    <img alt="JetBrains Rider：转换为自动属性" title="JetBrains Rider：转换为自动属性" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__convert_to_auto_property__03.png" id="11b1671a" width="221" height="28" class="inline-icon-221">                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="make_invariant" data-toc="Code_Analysis__Examples_of_Quick-Fixes#make_invariant">使类型参数不变</h2>        <p id="97e1cede">当类型参数的用法违反其方差时，JetBrains Rider建议使参数不变：</p>        <div class="table-wrapper"><table class=" no_header" width="100%" id="578f0fb1"><tbody><tr id="f688a38a" class="ijRowOdd"><td id="25390461" width="200"><p>之前：</p></td><td id="e576384b">                    <figure><img alt="JetBrains Rider：使类型参数不变" title="JetBrains Rider：使类型参数不变" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_invariant__01.png" id="ad305851" width="392" height="75"></figure>                </td></tr><tr id="631272ae" class="ijRowEven"><td id="a832cd86"><p>应用快速修复：</p></td><td id="10409e68">                    <figure><img alt="JetBrains Rider：使类型参数不变" title="JetBrains Rider：使类型参数不变" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_invariant__02.png" id="57207cb0" width="416" height="83"></figure>                </td></tr><tr id="3cebf59f" class="ijRowOdd"><td id="77d5e30b"><p>后：</p></td><td id="20e89d39">                    <figure><img alt="JetBrains Rider：使类型参数不变" title="JetBrains Rider：使类型参数不变" src="/help/img/dotnet/2019.2/Code_Analysis__Examples_of_Quick-Fixes__make_invariant__03.png" id="878a98fc" width="376" height="76"></figure>                </td></tr></tbody></table></div>    </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月29日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Code_Analysis__Quick-Fixes.html">代码问题的快速修复</a> <a class="navigation-links__next" href="Coding_Assistance__Importing_Namespaces.html">导入缺少的命名空间</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>