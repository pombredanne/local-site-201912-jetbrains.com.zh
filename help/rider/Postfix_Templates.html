<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Postfix模板-帮助| JetBrains骑士</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Postfix_Templates" data-breadcrumbs="Creating_and_Editing_Code.xml|Create and Edit Code/Templates_Rider.xml|Using Templates to Create Code/Templates__Index.xml|.NET-Specific Templates/Postfix_Templates.xml|Postfix Templates" data-main-title="Postfix Templates" data-disqus-id="Postfix_Templates_rdr"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索JetBrains Rider帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>JetBrains Rider 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="visual_studio" data-group="primary">视觉工作室</option><option value="resharper" data-group="primary">锐化器</option><option value="_default" data-group="primary">默认（IntelliJ IDEA）</option><option value="visual_studio_osx" data-group="secondary">Visual Studio（macOS）</option><option value="resharper_osx" data-group="secondary">ReSharper（macOS）</option><option value="mac_os_x_10.5_" data-group="secondary">Mac OS X 10.5+（IntelliJ IDEA）</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Postfix_Templates.xml" data-toc="Postfix_Templates">后缀模板</h1>    <a name="note_net_templates"></a>        <aside class="prompt" rel="Postfix_Templates.xml" id="486faa15" data-type="note" data-title="">            <p id="a56c64f9">本页介绍.NET语言的模板。Web特定模板中描述了可在HTML，JavaScript，TypeScript等中使用的<a href="Templates_Web.html">Web特定模板</a> 。</p>        </aside>        <p id="intro">Postfix模板可帮助您转换已经键入的表达式而不会向后跳-只需在表达式后键入点，然后从完成列表中选择一个模板即可。</p>    <aside class="prompt" rel="intro" id="e3bb75e8" data-type="tip" data-title="">        <p id="7a8234b4">您可以使用自定义<a href="Source_Templates.html">源模板</a>扩展默认的Postfix模板集。</p>    </aside>    <div class="chapter"><h2 id="applying" data-toc="Postfix_Templates#applying">应用后缀模板</h2>        <p id="4c0f782a">后缀模板的最简单示例之一是取反布尔表达式。假设您刚刚键入了一个布尔表达式，然后意识到比较逻辑应该反转。通常，您必须移回插入符号并进行更改<code class="code">==</code>至<code class="code">!=</code>反之亦然，然后返回您所在的位置。使用JetBrains Rider，您可以继续输入<code class="code">.not</code>然后按<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Enter</span></kbd> 。</p>        <p id="d8f21d62">您可以使用<a href="#list">更多的postfix模板</a>来加快编码速度。例如，您可以使用<code class="code">if</code> ， <code class="code">while</code> ， <code class="code">lock</code> ， <code class="code">using</code> ，添加<code class="code">return</code> ， <code class="code">yield return</code> ， <code class="code">await</code>在当前表达式的前面，遍历一个集合，生成一个switch语句，将该表达式转换为特定类型，甚至为该表达式引入一个字段或属性。</p>        <p id="195ae570">Postfix模板甚至可以更改您的键入例程。考虑一下<code class="code">CheckInput</code>下面的方法，想象一下如何键入null-checking子句。</p>        <div class="code-block" data-lang="csharp">私有无效CheckInput（字符串输入）{如果（输入==空）{抛出新ArgumentNullException（“输入为空”）; } //使用“输入”做某事}</div>    <p id="26343900">现在，让我们看看如何使用后缀模板。</p>    <p id="741d4128">将插入符号插入方法主体后，即可开始输入<code class="code">input</code>立即开始，因为这就是您要检查的内容。当。。。的时候<code class="code">input</code>在那儿，继续输入<code class="code">.null</code> -用于检查表达式的后缀模板<code class="code">null</code> ：</p>    <figure><img alt="应用后缀模板进行空检查" title="应用后缀模板进行空检查" src="/help/img/rider/2019.2/postfix_templates_1.png" id="973d197f" width="528" height="145"></figure>    <p id="7e954849">这将比较<code class="code">input</code>与<code class="code">null</code>并将比较结果包装在<code class="code">if</code>语句，然后将插入符号设置为可以继续输入的位置：</p>    <figure><img alt="应用后缀模板进行空检查" title="应用后缀模板进行空检查" src="/help/img/dotnet/2019.2/postfix_templates_2.png" id="98d0781b" width="275" height="119"></figure>    <p id="d3028023">现在，不用输入<code class="code">throw</code> ，您可以继续输入异常类名称，然后调用<code class="code">.throw</code>之后的模板：</p>    <figure><img alt="应用后缀模板进行空检查" title="应用后缀模板进行空检查" src="/help/img/rider/2019.2/postfix_templates_3.png" id="fba1a6c6" width="515" height="120"></figure>    <p id="22b667cf">应用此模板后，您将拥有完整的<code class="code">throw</code>语句，然后在插入符处输入参数：</p>    <figure><img alt="应用后缀模板进行空检查" title="应用后缀模板进行空检查" src="/help/img/dotnet/2019.2/postfix_templates_4.png" id="478248d0" width="283" height="116"></figure>    <p id="51811054">您可能会看到，与其手动输入常用的语言结构，不如直接键入模板快捷方式的几个初始字符，然后将所有内容正确放置，正确格式化且没有错别字。</p>    <section class="procedure-steps"><h3 id="94fe506e">应用后缀模板</h3><ol class="list _decimal"><li class="list__item" id="e409fba5"><p>在当前表达式之后键入一个点，并检查所需模板的完成列表。</p></li><li class="list__item" id="dd3b1230"><p>如果您知道要应用的模板的快捷方式，请开始输入它-这样会缩小建议列表。</p></li><li class="list__item" id="92dcf040"><p>在建议列表中选择所需模板后，请按<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Enter</span></kbd> 。</p></li><li class="list__item" id="6eba5138">如果模板具有<a href="Templates__Template_Basics__Template_Variables.html#editable">可编辑的参数</a> （即，需要用户输入），JetBrains Rider将在编辑器中部署一个<a href="Reference__Hot_Spot_Session.html">热点会话</a> ，并将输入位置设置为第一个参数。然后，您可以执行以下操作： <a name="hot_spot_list"></a>        <ul class="list _ul"><li class="list__item" id="bfae2e9c"><p>如果JetBrains Rider建议使用当前参数的一些值，请使用<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Up</span></kbd>和<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Down</span></kbd>箭头键浏览建议值列表，或仅键入所需值。</p></li><li class="list__item" id="05a9bc5f"><p>按<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Tab</span></kbd>要么<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Enter</span></kbd>接受该值并移至下一个参数的输入位置。如果这是最后一个参数，则热点会话完成，并且脱字符号移动到为该会话定义的结束位置。</p></li><li class="list__item" id="47eec3ce"><p>按<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Shift+Tab</span></kbd>将输入焦点移至上一个参数的输入位置。</p></li><li class="list__item" id="824ef68e"><p>按<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Esc</span></kbd>退出热点会话。在这种情况下，所有会话参数都将使用默认值初始化。</p></li></ul>            </li></ol></section>    </div>        <div class="chapter"><h2 id="list" data-toc="Postfix_Templates#list">后缀模板列表</h2>        <div class="tabs" id="f3a29bd2"><div class="tabs__content" id="f0a0ab57" data-title="C#">                <a name="postfix_table_CSHARP"></a>    <div class="table-wrapper"><table class=" wide" width="100%" id="db21bf1c"><thead><tr id="f6d7191e" class="ijRowHead"><th id="aa10633d"><p>捷径</p></th><th id="f573fac0"><p>描述</p></th><th id="718f5300"><p>例</p></th></tr></thead><tbody><tr id="05a21b52" class="ijRowOdd"><td id="CSHARP_arg">          <b id="5ea72684" origin="dotnet">.arg</b>        </td><td id="dbab0b1a"><p>用调用将表达式括起来</p></td><td id="cb6f6a7e">          <code class="code">Method(expr)</code>        </td></tr><tr id="c008d60b" class="ijRowEven"><td id="CSHARP_await">          <b id="3f141544" origin="dotnet">。等待</b>        </td><td id="41f41a91"><p>等待“任务”类型的表达式</p></td><td id="b783910b">          <code class="code">await expr</code>        </td></tr><tr id="34deb0fd" class="ijRowOdd"><td id="CSHARP_cast">          <b id="d3bfd0cb" origin="dotnet">。投</b>        </td><td id="9b9276e7"><p>用演员包围表达</p></td><td id="a8e9f8ac">          <code class="code">((SomeType) expr)</code>        </td></tr><tr id="1c727f32" class="ijRowEven"><td id="CSHARP_else">          <b id="d12fb3eb" origin="dotnet">。其他</b>        </td><td id="3019f327"><p>检查布尔表达式为'false'</p></td><td id="a0d68d42">          <code class="code">if (!expr)</code>        </td></tr><tr id="460f9503" class="ijRowOdd"><td id="CSHARP_field">          <b id="f7541a83" origin="dotnet">。领域</b>        </td><td id="2d4bb741"><p>引入表达领域</p></td><td id="a002ae50">          <code class="code">_field = expr;</code>        </td></tr><tr id="0f3026c0" class="ijRowEven"><td id="CSHARP_for">          <b id="efec9c65" origin="dotnet">。对于</b>        </td><td id="b6be3283"><p>用索引遍历集合</p></td><td id="66cfd33c">          <code class="code">for (var i = 0; i < xs.Length; i++)</code>        </td></tr><tr id="3334b22e" class="ijRowOdd"><td id="CSHARP_foreach">          <b id="290231c2" origin="dotnet">.foreach</b>        </td><td id="ae145329"><p>遍历可枚举的集合</p></td><td id="32e05db1">          <code class="code">foreach (var x in expr)</code>        </td></tr><tr id="5d0979aa" class="ijRowEven"><td id="CSHARP_forr">          <b id="f7ef6898" origin="dotnet">.forr</b>        </td><td id="9c14146e"><p>用索引反向遍历集合</p></td><td id="66f7b017">          <code class="code">for (var i = xs.Length-1; i >= 0; i--)</code>        </td></tr><tr id="1c8257d8" class="ijRowOdd"><td id="CSHARP_if">          <b id="35814cab" origin="dotnet">。如果</b>        </td><td id="f5065195"><p>检查布尔表达式为'true'</p></td><td id="b50522b1">          <code class="code">if (expr)</code>        </td></tr><tr id="2ce032cf" class="ijRowEven"><td id="CSHARP_lock">          <b id="8c9b91e7" origin="dotnet">。锁</b>        </td><td id="339b6476"><p>用锁定块包围表达式</p></td><td id="945fe96f">          <code class="code">lock (expr)</code>        </td></tr><tr id="54d7c967" class="ijRowOdd"><td id="CSHARP_new">          <b id="d28022f7" origin="dotnet">。新</b>        </td><td id="53ea6187"><p>产生类型的实例化表达式</p></td><td id="a17f0179">          <code class="code">new SomeType()</code>        </td></tr><tr id="a6d0274b" class="ijRowEven"><td id="CSHARP_not">          <b id="2e716ee9" origin="dotnet">。不</b>        </td><td id="f4c0d88b"><p>取反布尔表达式</p></td><td id="ea0657b2">          <code class="code">!expr</code>        </td></tr><tr id="093dbc10" class="ijRowOdd"><td id="CSHARP_notnull">          <b id="0ad54c17" origin="dotnet">.notnull</b>        </td><td id="01e64f66"><p>检查表达式不为空</p></td><td id="bc77328f">          <code class="code">if (expr != null)</code>        </td></tr><tr id="8fe116d5" class="ijRowEven"><td id="CSHARP_null">          <b id="a8087de9" origin="dotnet">。空值</b>        </td><td id="75770774"><p>检查表达式为空</p></td><td id="d4ebab53">          <code class="code">if (expr == null)</code>        </td></tr><tr id="8e08e49a" class="ijRowOdd"><td id="CSHARP_par">          <b id="97f3357d" origin="dotnet">.par</b>        </td><td id="afea8afd"><p>用括号括住当前表达式</p></td><td id="833b1a98">          <code class="code">(expr)</code>        </td></tr><tr id="b82346d4" class="ijRowEven"><td id="CSHARP_parse">          <b id="963a4145" origin="dotnet">.parse</b>        </td><td id="b1c9ee00"><p>将字符串解析为某种类型的值</p></td><td id="f578c6f7">          <code class="code">int.Parse(expr)</code>        </td></tr><tr id="8e9916a7" class="ijRowOdd"><td id="CSHARP_prop">          <b id="04218349" origin="dotnet">。支柱</b>        </td><td id="02ab64e2"><p>引入表达属性</p></td><td id="7442b41e">          <code class="code">Property = expr;</code>        </td></tr><tr id="e9473eb5" class="ijRowEven"><td id="CSHARP_return">          <b id="8d99b518" origin="dotnet">。返回</b>        </td><td id="506db478"><p>从当前函数返回表达式</p></td><td id="8afb8766">          <code class="code">return expr;</code>        </td></tr><tr id="3252befe" class="ijRowOdd"><td id="CSHARP_sel">          <b id="dcf644a7" origin="dotnet">.sel</b>        </td><td id="eea78dcc"><p>在编辑器中选择表达式</p></td><td id="cf1db408">          <code class="code">|selected + expression|</code>        </td></tr><tr id="7d4208d6" class="ijRowEven"><td id="CSHARP_switch">          <b id="7904a9c3" origin="dotnet">。开关</b>        </td><td id="1d52afb8"><p>产生switch语句</p></td><td id="6c2ee04a">          <code class="code">switch (expr)</code>        </td></tr><tr id="13b3ffa1" class="ijRowOdd"><td id="CSHARP_throw">          <b id="e455fb49" origin="dotnet">。扔</b>        </td><td id="314eb5e7"><p>抛出“ Exception”类型的表达式</p></td><td id="62545c3b">          <code class="code">throw expr;</code>        </td></tr><tr id="56e9efba" class="ijRowEven"><td id="CSHARP_to">          <b id="b51009f4" origin="dotnet">。至</b>        </td><td id="ffc06580"><p>将当前表达式分配给某个变量</p></td><td id="8ff19943">          <code class="code">lvalue = expr;</code>        </td></tr><tr id="3356372a" class="ijRowOdd"><td id="CSHARP_tryparse">          <b id="5e3389fc" origin="dotnet">.tryparse</b>        </td><td id="fec63951"><p>将字符串解析为某种类型的值</p></td><td id="9c6b2582">          <code class="code">int.TryParse(expr, out value)</code>        </td></tr><tr id="207c8fe5" class="ijRowEven"><td id="CSHARP_typeof">          <b id="3872c2a0" origin="dotnet">。类型</b>        </td><td id="26a31245"><p>使用typeof（）表达式包装类型用法</p></td><td id="ab7fe2e0">          <code class="code">typeof(TExpr)</code>        </td></tr><tr id="bdb60cec" class="ijRowOdd"><td id="CSHARP_using">          <b id="3bdbf5c5" origin="dotnet">。使用</b>        </td><td id="719cc170"><p>用using语句包装资源</p></td><td id="9e64908b">          <code class="code">using (expr)</code>        </td></tr><tr id="d40ce464" class="ijRowEven"><td id="CSHARP_var">          <b id="d399c5ac" origin="dotnet">.var</b>        </td><td id="7d764306"><p>引入表达变量</p></td><td id="60758462">          <code class="code">var x = expr;</code>        </td></tr><tr id="69505cec" class="ijRowOdd"><td id="CSHARP_while">          <b id="0b1ee751" origin="dotnet">。而</b>        </td><td id="56733d5d"><p>在布尔语句为“ true”时进行迭代</p></td><td id="b7e3399c">          <code class="code">while (expr)</code>        </td></tr><tr id="1f188465" class="ijRowEven"><td id="CSHARP_yield">          <b id="9392ca88" origin="dotnet">。让</b>        </td><td id="529fd7d5"><p>迭代器方法的收益值</p></td><td id="0638ecf5">          <code class="code">yield return expr;</code>        </td></tr></tbody></table></div>              </div></div>    </div>                <div class="last-modified" data-skip-index="skip">上次修改时间：2019年11月29日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Templates__Creating_and_Editing_Templates__Declaring_Variables.html">声明模板变量</a> <a class="navigation-links__next" href="Source_Templates.html">源模板</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>