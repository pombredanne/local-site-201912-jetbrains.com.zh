<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotMemory how to, dotMemory tutorials, .NET memory tutorials, .NET memory management
    " data-skip-index="skip"><meta charset="UTF-8"><title>优化内存流量-帮助|帮助点内存</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="How_to_Optimize_Memory_Traffic" data-disqus-id="How_to_Optimize_Memory_Traffic_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected>视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="How_to_Optimize_Memory_Traffic.xml" data-toc="How_to_Optimize_Memory_Traffic">优化内存流量</h1>            <div class="table-wrapper"><table width="50%" id="snapshots"><thead><tr valign="top" id="16011168" class="ijRowHead"><th id="a1770f83" width="50%"></th><th id="a4d972bb"></th></tr></thead><tbody><tr id="5cf7d200" class="ijRowOdd"><td id="5f40fc7c">                <b id="fecaad54">样品申请</b>            </td><td id="f176e05f">                <ul class="list _ul"><li class="list__item" id="883d8560">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3.git" rel="noopener noreferrer" data-external="true" target="_blank">生活游戏</a>                    </li></ul>            </td></tr><tr id="d9e4599c" class="ijRowEven"><td id="5d53365e">                <b id="55e4be17">快照</b>            </td><td id="0a03a0c5">                <ul class="list _ul"><li class="list__item" id="eb2bfb65">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_Before_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Optimize_Traffic_Before_Fix.dmw</a>                    </li><li class="list__item" id="1f1b90f0">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_After_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Optimize_Traffic_After_Fix.dmw</a>                    </li></ul>            </td></tr><tr id="d25cbec9" class="ijRowOdd"><td id="a6432c11"></td><td id="e9f7c1fb"></td></tr></tbody></table></div>    <p id="42c3d53a">在本教程中，我们将看到如何使用dotMemory优化应用程序的内存使用率。</p>    <p id="220958e8">“优化内存使用率”是什么意思？像操作系统中的任何进程一样，垃圾收集器（GC）消耗系统资源。逻辑很简单：GC必须进行的收集越多，CPU开销就越大，应用程序性能就越差。通常，当您的应用程序分配在有限的一段时间内需要的大量对象时，就会发生这种情况。</p>    <p id="a1aaf2da">为了识别和分析此类问题，您应该检查所谓的<i id="139d9165">内存流量</i> 。交通信息显示您在特定时间间隔内分配和释放了多少个对象（和内存）。让我们看看如何确定应用程序中过多的分配并使用dotMemory消除它们。</p>    <div class="chapter"><h2 id="ab81db3e" data-toc="How_to_Optimize_Memory_Traffic#ab81db3e">样品申请</h2>        <p id="0b63eab9">传统上，我们将在本教程中使用的示例应用程序是Conway的《人生游戏》。在开始之前，请从<a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3" rel="noopener noreferrer" data-external="true" target="_blank">github</a>下载该应用程序。</p><figure><img alt="t3 gol应用" title="t3 gol应用" src="/help/img/dotnet/2019.2/t3_gol_app.png" id="31e09ee1" width="600" height="392"></figure>由于此应用程序可处理大量对象（单元），因此有趣的是查看这些对象的分配和收集方式的动态情况。<p></p>    </div>    <div class="chapter"><h2 id="t3_step1" data-toc="How_to_Optimize_Memory_Traffic#t3_step1">步骤1。运行dotMemory</h2>        <ol class="list _decimal"><li class="list__item" id="399a9378"><p>在Visual Studio中打开“人生游戏”解决方案。</p></li><li class="list__item" id="74c35aef"><p>使用菜单<span class="menupath" data-skip-index="skip">ReSharper |</span>运行dotMemory <span class="menupath" data-skip-index="skip">。简介|运行启动项目内存分析...。</span></p><figure><img alt="t2 reshaper菜单更新dM" title="t2 reshaper菜单更新dM" src="/help/img/dotnet/2019.2/t2_resharper_menu_upd_dM.png" id="7a79e61f" width="576" height="372"></figure>            <p></p></li><li class="list__item" id="22901904"><p>在打开的<span class="control">Profiler配置</span>窗口中，选择<span class="control">从开始收集内存分配和流量数据</span> 。这将告诉dotMemory在应用启动后立即开始收集分析信息。指定选项后，窗口应如下所示：</p><figure><img alt="tutorial1运行dotMemory 3" title="tutorial1运行dotMemory 3" src="/help/img/dotnet/2019.2/tutorial1_running_dotMemory_3.png" id="9c41b7fc" width="347" height="298"></figure>            <p></p></li><li class="list__item" id="b64ec035"><p>单击<span class="control">运行</span>以启动分析会话。这将启动我们的应用程序，并在dotMemory中打开<span class="control">Analysis＃1</span>主页面：</p><figure><img alt="tutorial1会话1" title="tutorial1会话1" src="/help/img/dotnet/2019.2/tutorial1_session_1.png" id="cc0b8af8" width="700" height="488"></figure>            <p></p></li><li class="list__item" id="e57ab8e6">切换到dotMemory的主窗口以查看时间线。时间轴可实时显示应用程序的内存使用情况。更具体地说，它提供了有关非托管内存*，Gen0，Gen1，Gen2堆和大对象堆的当前大小的详细信息。直到“生命游戏”开始之前，内存消耗仍保持不变。<aside class="note " rel="e57ab8e6" id="f62003b3" data-title="">                    <p id="ce33df54">*为了方便起见，可以通过取消选中“ <span class="control">显示非托管内存”</span>复选框来隐藏内存的非托管部分。</p>                </aside>                <figure><img alt="t3时间轴" title="t3时间轴" src="/help/img/dotnet/2019.2/t3_timeline.png" id="171a8ebd" width="762" height="287"></figure>            </li></ol>    </div>    <div class="chapter"><h2 id="t3_step2" data-toc="How_to_Optimize_Memory_Traffic#t3_step2">第2步。获取快照</h2>        <aside class="tip sideblock" rel="t3_step2" id="38f2ec59" data-title="">            <p id="7083802c">如果要跳过“获取快照”步骤，则可以<a href="#snapshots">下载</a>本教程使用<a href="#snapshots">的快照</a> 。</p>        </aside>        <p id="0ed2c09f">启动应用程序后，我们可以开始获取内存快照。当我们要研究应用程序行为的动态变化时，我们需要至少拍摄两个快照。获取快照之间的时间间隔将成为进一步的内存流量分析的主题。</p>        <p id="6bd575d7">自然，当大多数分配发生时，两个快照都必须在“人生游戏”操作的那部分期间进行。让我们在“人生游戏”的第30代中拍摄一张快照，在第100代时拍摄第二张快照。</p>        <ol class="list _decimal"><li class="list__item" id="4fc7781e"><p>使用应用程序中的<span class="control">开始</span>按钮开始游戏。</p></li><li class="list__item" id="40d419bc">当“世代”计数器（在我们应用的右上角）达到<span class="control">30</span> *时，单击dotMemory中的“ <span class="control">获取快照”</span>按钮。<aside class="note " rel="0dffa5bf" id="d394780a" data-title="">                    <p id="da3502c1">*您应该在大约那个时候拍摄快照。在这个例子中，我们只想了解正在发生的事情。不需要非常精确。但是，当需要在代码的确切位置拍摄快照时，可以使用<a href="Profiling_Guidelines__Advanced_Profiling_Using_dotTrace_API.html">dotMemory API</a> 。</p>                </aside>                <figure><img alt="t3获取快照1" title="t3获取快照1" src="/help/img/dotnet/2019.2/t3_get_snapshot1.png" id="8cd80a99" width="800" height="548"></figure>如果现在查看时间线，您将看到应用程序如何实时消耗内存。当应用程序分配新对象时，内存消耗增加（ <span class="control">Gen0</span>图增加）。进行垃圾收集时，内存消耗会减少。结果，时间线遵循锯齿状模式。</li><li class="list__item" id="360d5825"><p>当“世代”计数器达到100时，再次使用dotMemory中的“ <span class="control">获取快照”</span>按钮再获取一个快照。</p></li><li class="list__item" id="0d8e3cde"><p>通过关闭“生活游戏”应用程序结束分析会话。现在，主页包含两个快照：</p><figure><img alt="t3获取快照2" title="t3获取快照2" src="/help/img/dotnet/2019.2/t3_get_snapshot2.png" id="8c33caa9" width="800" height="548"></figure>            <p></p></li></ol>    </div>    <div class="chapter"><h2 id="t3_step3" data-toc="How_to_Optimize_Memory_Traffic#t3_step3">第三步分析内存流量</h2>        <aside class="tip sideblock" rel="t3_step3" id="b6af4c4f" data-title="">            <p id="733aff7d">如果您跳过了<a href="#t3_step2">步骤2。获取快照</a> ，可以将以下快照用于此步骤： <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_Before_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Optimize_Traffic_Before_Fix.dmw</a> ， <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_After_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Optimize_Traffic_After_Fix.dmw</a> 。</p>        </aside>        <p id="32111f5d">现在，我们来看看获取快照之间的时间间隔内的内存流量。</p>        <ol class="list _decimal"><li class="list__item" id="eee1ee6b"><p>确保将两个快照都添加到比较区域（两个都选择了“ <span class="control">添加到比较”</span> ）：</p><figure><img alt="t3快照比较" title="t3快照比较" src="/help/img/dotnet/2019.2/t3_snapshots_comparison.png" id="135e725a" width="771" height="378"></figure>            <p></p></li><li class="list__item" id="ec9073b9"><p>单击比较区域中的<span class="control">查看内存流量</span> 。这将打开<span class="control">内存流量</span>视图。该视图显示在快照1和快照2之间创建了多少种特定类型的对象。</p><figure><img alt="t3流量视图" title="t3流量视图" src="/help/img/dotnet/2019.2/t3_traffic_view.png" id="ceeecccb" width="800" height="558"></figure>            <p></p></li><li class="list__item" id="1aa0f340">看一下清单。由于分配了超过27 MB的内存，约占总内存流量的50％ <code class="code">GameOfLife.Cell</code> *对象。同时，还收集了大多数这些26+ MB的单元。这很奇怪，因为细胞应该在生命游戏的整个过程中都存在。毫无疑问，这些集合正在损害我们应用程序的性能。让我们检查一下这些<code class="code">Cell</code>对象来自。<aside class="note " rel="0870faf1" id="f989e788" data-title="">                    <p id="a960afa8">*在分析内存流量时，不仅要查看分配了某种类型的对象的数量，而且还查看了收集了该类型的对象的数量。这些参数几乎具有相同的值，这可能意味着内存使用不足。您可能会改进代码并避免这些分配。</p>                </aside>            </li><li class="list__item" id="1fb3bc96"><p>点击带有<code class="code">GameOfLife.Cell</code>类。该屏幕底部的列表向我们显示了创建对象的功能（回溯）。显然，这是<code class="code">CalculateNextGeneration()</code>的方法<code class="code">Grid</code>类。让我们在代码中找到它。</p><figure><img alt="t3流量查看功能" title="t3流量查看功能" src="/help/img/dotnet/2019.2/t3_traffic_view_function.png" id="c5ea93d3" width="738" height="515"></figure>            <p></p></li><li class="list__item" id="980c0dcb"><p>在Visual Studio中打开GameOfLife解决方案。</p></li><li class="list__item" id="c4f2e569"><p>打开<span class="filepath">Grid.cs</span>文件，其中包含<code class="code">Grid</code>类：</p><figure><img alt="T3解决方案资源管理器" title="T3解决方案资源管理器" src="/help/img/dotnet/2019.2/t3_solution_explorer.png" id="803b11d2" width="271" height="268"></figure>            <p></p></li><li class="list__item" id="5b60764e"><p>找到<code class="code">CalculateNextGeneration(int row, int column)</code>方法：</p><div class="code-block" data-lang="csharp">public Cell CalculateNextGeneration（int row，int column）{bool alive;整数计数，年龄；存活= _cells [行，列]。活着;年龄= _cells [行，列]。年龄; count = CountNeighbors（行，列）; if（alive && count <2）返回新的Cell（row，column，0，false）; if（alive &&（count == 2 || count == 3））{_cells [row，column]。年龄++;返回新的单元格（行，列，_cells [行，列]。年龄，真实）；如果（alive && count> 3）返回新的Cell（row，column，0，false）;如果（！alive && count == 3）返回新的Cell（row，column，0，true）;返回新的Cell（row，column，0，false）; }</div>看来此方法会计算并返回<code class="code">Cell</code>每个下一代“生命游戏”的对象。但这不能解释高内存流量。让我们回到dotMemory，找出什么函数调用了<code class="code">CalculateNextGeneration</code>方法。<p></p></li><li class="list__item" id="6b38c7f9"><p>在dotMemory中，展开<code class="code">CalculateNextGeneration</code>方法，以查看堆栈中的下一个函数。它是<code class="code">Update</code>的方法<code class="code">Grid</code>类：</p><figure><img alt="t3流量查看功能2" title="t3流量查看功能2" src="/help/img/dotnet/2019.2/t3_traffic_view_function2.png" id="e4fbf0a6" width="739" height="217"></figure>            <p></p></li><li class="list__item" id="270b5ba4"><p>在代码中找到此方法：</p><div class="code-block" data-lang="csharp">public void Update（）{for（int i = 0; i <SizeX; i ++）{for（int j = 0; j <SizeY; j ++）{_nextGenerationCells [i，j] = CalculateNextGeneration（i，j）; }} UpdateToNextGeneration（）; }</div>最终，我们可以了解导致内存流量过高的原因。有<code class="code">nextGenerationCells</code>的数组<code class="code">Cell</code>类型，用于存储下一代“生命游戏”的单元。在每个世代更新中，此阵列中的单元将被新单元替换。不再需要上一代留下的细胞，并在一段时间后由GC收集。显然，无需填写<code class="code">_nextGenerationCells</code>在应用程序的整个生命周期中，每次在数组中都存在新的单元格。为了摆脱高内存流量，我们只需要用新值更新现有单元的属性，而不用创建新的单元。让我们在代码中做到这一点。<p></p></li><li class="list__item" id="3a63aae3"><p>实际上，由于我们的应用程序是一个学习示例，因此它已经包含了所需的<code class="code">CalculateNextGeneration</code>方法。此方法更新单元格的<code class="code">IsAlive</code>和<code class="code">Age</code>通过引用发送的字段：</p><div class="code-block" data-lang="csharp">public void CalculateNextGeneration（int row，int column，ref bool isAlive，ref int age）{...}</div>要解决此问题，只需取消注释中的行<code class="code">Update()</code>更新<code class="code">_nextGenerationCells</code>使用此方法的数组。最后， <code class="code">Update()</code>方法应如下所示：<div class="code-block" data-lang="none">公共无效Update（）{bool alive = false;整数年龄= 0; for（int i = 0; i <SizeX; i ++）{for（int j = 0; j <SizeY; j ++）{CalculateNextGeneration（i，j，引用存活，引用年龄）; _nextGenerationCells [i，j]。IsAlive =活着； _nextGenerationCells [i，j]。年龄=年龄； }} UpdateToNextGeneration（）; }</div>现在，让我们应用这些更改，并检查它们如何影响内存流量。<p></p></li><li class="list__item" id="4bc6a707"><p>再次构建应用程序。重复<a href="#t3_step1">步骤1中所述的</a><a href="#t3_step1">步骤。运行dotMemory</a>并执行<a href="#t3_step2">步骤2。获取快照</a>以获取两个新快照。</p></li><li class="list__item" id="c1eb9b08"><p>打开“ <span class="control">内存流量”</span>视图以查看收集的快照之间的内存流量（如<a href="#t3_step3">步骤3中的子步骤1和2所述） </a><a href="#t3_step3">。分析内存流量</a> ）：</p><figure><img alt="T3流量视图已修复" title="T3流量视图已修复" src="/help/img/dotnet/2019.2/t3_traffic_view_fixed.png" id="f938e2c8" width="738" height="379"></figure>的<code class="code">GameOfLife.Cell</code>班级已不在列表中！这导致总体流量下降了40％（降至33 MB），这是非常好的优化。<p></p></li></ol>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="How_to_Find_a_Memory_Leak.html">查找内存泄漏</a> <a class="navigation-links__next" href="Profile_Standalone_Application.html">配置文件独立应用程序</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>