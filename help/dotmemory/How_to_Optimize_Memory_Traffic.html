<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        dotMemory how to, dotMemory tutorials, .NET memory tutorials, .NET memory management&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Optimize Memory Traffic - Help | dotMemory</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="How_to_Optimize_Memory_Traffic" data-disqus-id="How_to_Optimize_Memory_Traffic_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="How_to_Optimize_Memory_Traffic" id="How_to_Optimize_Memory_Traffic.xml">Optimize Memory Traffic</h1>            <div class="table-wrapper"><table width="50%" id="snapshots"><thead><tr valign="top" id="16011168" class="ijRowHead"><th id="a1770f83" width="50%"></th><th id="a4d972bb"></th></tr></thead><tbody><tr id="5cf7d200" class="ijRowOdd"><td id="5f40fc7c">                <b id="fecaad54">Sample application</b>            </td><td id="f176e05f">                <ul class="list _ul"><li class="list__item" id="883d8560">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3.git" data-external="true" target="_blank" rel="noopener noreferrer">Game of Life</a>                    </li></ul>            </td></tr><tr id="d9e4599c" class="ijRowEven"><td id="5d53365e">                <b id="55e4be17">Snapshots</b>            </td><td id="0a03a0c5">                <ul class="list _ul"><li class="list__item" id="eb2bfb65">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_Before_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Optimize_Traffic_Before_Fix.dmw</a>                    </li><li class="list__item" id="1f1b90f0">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_After_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Optimize_Traffic_After_Fix.dmw</a>                    </li></ul>            </td></tr><tr id="d25cbec9" class="ijRowOdd"><td id="a6432c11"></td><td id="e9f7c1fb"></td></tr></tbody></table></div>    <p id="42c3d53a">        In this tutorial, we will see how you can use dotMemory to optimize your application's memory usage.    </p>    <p id="220958e8">        What do we mean by "optimizing memory usage"? Like any process in the operating system, Garbage Collector (GC)        consumes system resources. The logic is simple: the more collections GC has to make, the larger the CPU overhead        and the poorer application performance. Typically, this happens when your application allocates a large        number of objects that are required for some limited period of time.    </p>    <p id="a1aaf2da">        To identify and analyze such issues, you should examine the so-called        <i id="139d9165">memory traffic</i>. Traffic information shows        you how many objects (and memory) were allocated and released during a particular time interval.        Let's see how you can determine excessive allocations in your application and get rid of them using dotMemory.    </p>    <div class="chapter"><h2 id="ab81db3e" data-toc="How_to_Optimize_Memory_Traffic#ab81db3e">Sample application</h2>        <p id="0b63eab9">            Traditionally, the sample application we'll use for this tutorial is Conway's Game of Life. Before you            begin,            please download the application from <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3" data-external="true" target="_blank" rel="noopener noreferrer">github</a>.            <figure><img alt="t3 gol app" title="t3 gol app" src="/help/img/dotnet/2019.2/t3_gol_app.png" id="31e09ee1" width="600" height="392"></figure>            As this application works with a large number of objects (cells), it would be interesting to look at the            dynamics of how            these objects are allocated and collected.        </p>    </div>    <div class="chapter"><h2 id="t3_step1" data-toc="How_to_Optimize_Memory_Traffic#t3_step1">Step 1. Run dotMemory</h2>        <ol class="list _decimal"><li class="list__item" id="399a9378"><p>                Open the Game of Life solution in Visual Studio.            </p></li><li class="list__item" id="74c35aef"><p>                Run dotMemory using the menu                <span data-skip-index="skip" class="menupath">ReSharper | Profile | Run Startup Project Memory Profiling...</span>.                <figure><img alt="t2 resharper menu upd dM" title="t2 resharper menu upd dM" src="/help/img/dotnet/2019.2/t2_resharper_menu_upd_dM.png" id="7a79e61f" width="576" height="372"></figure>            </p></li><li class="list__item" id="22901904"><p>                In the opened                <span class="control">Profiler Configuration</span>                window, select <span class="control">Collect memory allocation and traffic data from start</span>.                This will tell dotMemory to start collecting profiling info right after the app is launched.                This is how the window should look like after you specify the options:                <figure><img alt="tutorial1 running dotMemory 3" title="tutorial1 running dotMemory 3" src="/help/img/dotnet/2019.2/tutorial1_running_dotMemory_3.png" id="9c41b7fc" width="347" height="298"></figure>            </p></li><li class="list__item" id="b64ec035"><p>                Click                <span class="control">Run</span>                to start the profiling session. This will launch our application and open the main                <span class="control">Analysis #1</span>                page in dotMemory:                <figure><img alt="tutorial1 session 1" title="tutorial1 session 1" src="/help/img/dotnet/2019.2/tutorial1_session_1.png" id="cc0b8af8" width="700" height="488"></figure>            </p></li><li class="list__item" id="e57ab8e6">                Switch to the dotMemory's main window to see the timeline. The timeline shows you the memory usage of                your                application in real time. More specifically, it provides details on the current size of                unmanaged memory*, Gen0, Gen1, Gen2 heaps and Large Object Heap.                Up until Game of Life starts, memory consumption stands still.                <aside class="note " data-title="" rel="e57ab8e6" id="f62003b3">                    <p id="ce33df54">* For convenience, you can hide the unmanaged part of memory by deselecting the                        <span class="control">Show unmanaged memory</span>                        check box.                    </p>                </aside>                <figure><img alt="t3 timeline" title="t3 timeline" src="/help/img/dotnet/2019.2/t3_timeline.png" id="171a8ebd" width="762" height="287"></figure>            </li></ol>    </div>    <div class="chapter"><h2 id="t3_step2" data-toc="How_to_Optimize_Memory_Traffic#t3_step2">Step 2. Get snapshots</h2>        <aside class="tip sideblock" data-title="" rel="t3_step2" id="38f2ec59">            <p id="7083802c">                If you want to skip the "get snapshots" step, you can                <a href="#snapshots">                    download the snapshots                </a>                that were used for this tutorial.            </p>        </aside>        <p id="0ed2c09f">            After the application is launched, we can start getting memory snapshots.            As we want to investigate the dynamics of how our application behaves, we need to take at least two            snapshots.            The time interval between getting the snapshots will be the subject of further memory traffic analysis.        </p>        <p id="6bd575d7">            Naturally, both snapshots must be taken during that part of Game of Life's operation when the majority of            allocations occur. Let's take one snapshot at the 30th generation of the Game of Life, and the second one at            the            100th generation.        </p>        <ol class="list _decimal"><li class="list__item" id="4fc7781e"><p>                Start the game using the <span class="control">Start</span> button in the application.            </p></li><li class="list__item" id="40d419bc">                When the Generations counter (in the top right-hand corner of our app) reaches                <span class="control">30</span>*, click the <span class="control">Get Snapshot</span> button in dotMemory.                <aside class="note " data-title="" rel="0dffa5bf" id="d394780a">                    <p id="da3502c1">* You should take the snapshot at approximately that time. In this example, we just want to get a                        "big picture" of what is going on; there's no need to be very precise.                        Nevertheless, when it is required to take snapshots at exact places of your code, you can use                        <a href="Profiling_Guidelines__Advanced_Profiling_Using_dotTrace_API.html">dotMemory API</a>.                    </p>                </aside>                <figure><img alt="t3 get snapshot1" title="t3 get snapshot1" src="/help/img/dotnet/2019.2/t3_get_snapshot1.png" id="8cd80a99" width="800" height="548"></figure>                If you now look at the timeline, you'll see how the application consumes memory in real time.                When the application allocates new objects, memory consumption increases (<span class="control">Gen0</span> diagram                grows). When garbage collection takes place, memory consumption                decreases. As a result, the timeline follows a saw-like pattern.            </li><li class="list__item" id="360d5825"><p>When the Generations counter reaches 100, get one more snapshot, again by using the                <span class="control">Get Snapshot</span>                button in dotMemory.            </p></li><li class="list__item" id="0d8e3cde"><p>                End the profiling session by closing the Game of Life app.                The main page now contains two snapshots:                <figure><img alt="t3 get snapshot2" title="t3 get snapshot2" src="/help/img/dotnet/2019.2/t3_get_snapshot2.png" id="8c33caa9" width="800" height="548"></figure>            </p></li></ol>    </div>    <div class="chapter"><h2 id="t3_step3" data-toc="How_to_Optimize_Memory_Traffic#t3_step3">Step 3. Analyze memory traffic</h2>        <aside class="tip sideblock" data-title="" rel="t3_step3" id="b6af4c4f">            <p id="733aff7d">                If you skipped <a href="#t3_step2">Step 2. Get snapshots</a>, you can use the following snapshots for this step:                <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_Before_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Optimize_Traffic_Before_Fix.dmw</a>, <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial3/raw/master/Snapshots/Optimize_Traffic_After_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Optimize_Traffic_After_Fix.dmw</a>.            </p>        </aside>        <p id="32111f5d">Now, we'll take a look at the memory traffic in the time interval between getting the snapshots.</p>        <ol class="list _decimal"><li class="list__item" id="eee1ee6b"><p>Make sure both snapshot are added to the comparison area (<span class="control">Add to comparison</span> is                selected for both of them):                <figure><img alt="t3 snapshots comparison" title="t3 snapshots comparison" src="/help/img/dotnet/2019.2/t3_snapshots_comparison.png" id="135e725a" width="771" height="378"></figure>            </p></li><li class="list__item" id="ec9073b9"><p>                Click <span class="control">View memory traffic</span> in the comparison area                This will open the                <span class="control">Memory Traffic</span>                view. The view shows how many objects of a certain type were created                between Snapshot #1 and Snapshot #2.                <figure><img alt="t3 traffic view" title="t3 traffic view" src="/help/img/dotnet/2019.2/t3_traffic_view.png" id="ceeecccb" width="800" height="558"></figure>            </p></li><li class="list__item" id="1aa0f340">                Take a look at the list. 27+ MB, or about 50% of the overall memory traffic, takes place due to the allocation                of <code class="code">GameOfLife.Cell</code>* objects.                At the same time, most of these cells, 26+ MB, were collected as well. That's quite                strange, since cells should exist for the whole duration of Game of Life. There is no doubt that these                collections are hurting our application's performance.                Let's check where these <code class="code">Cell</code> objects come from.                <aside class="note " data-title="" rel="0870faf1" id="f989e788">                    <p id="a960afa8">                        * When analyzing memory traffic, look not only at how many objects of a certain type were                        allocated,                        but also how many objects of this type were collected. The fact these parameters have almost                        identical values may imply                        sub-optimal memory usage. Chances are that you can improve your code and avoid these                        allocations.                    </p>                </aside>            </li><li class="list__item" id="1fb3bc96"><p>                Click the row with the <code class="code">GameOfLife.Cell</code> class.                The list at the bottom of this screen shows us the function (back trace) that created the objects.                Apparently, this is the                <code class="code">CalculateNextGeneration()</code>                method of the <code class="code">Grid</code> class. Let's find it in the code.                <figure><img alt="t3 traffic view function" title="t3 traffic view function" src="/help/img/dotnet/2019.2/t3_traffic_view_function.png" id="c5ea93d3" width="738" height="515"></figure>            </p></li><li class="list__item" id="980c0dcb"><p>Open the GameOfLife solution in Visual Studio.</p></li><li class="list__item" id="c4f2e569"><p>Open the                <span class="filepath">Grid.cs</span>                file which contains the implementation of the                <code class="code">Grid</code>                class:                <figure><img alt="t3 solution explorer" title="t3 solution explorer" src="/help/img/dotnet/2019.2/t3_solution_explorer.png" id="803b11d2" width="271" height="268"></figure>            </p></li><li class="list__item" id="5b60764e"><p>                Locate the                <code class="code">CalculateNextGeneration(int row, int column)</code>                method:                <div class="code-block" data-lang="csharp">
public Cell CalculateNextGeneration(int row, int column)
{
    bool alive;
    int count, age;
    alive = _cells[row, column].IsAlive;
    age = _cells[row, column].Age;
    count = CountNeighbors(row, column);

    if (alive &amp;&amp; count &lt; 2)
        return new Cell(row, column, 0, false);

    if (alive &amp;&amp; (count == 2 || count == 3))
    {
        _cells[row, column].Age++;
        return new Cell(row, column, _cells[row, column].Age, true);
    }

    if (alive &amp;&amp; count &gt; 3)
        return new Cell(row, column, 0, false);

    if (!alive &amp;&amp; count == 3)
        return new Cell(row, column, 0, true);

    return new Cell(row, column, 0, false);
}
                </div>                It appears that this method calculates and returns the                <code class="code">Cell</code>                objects for each next generation of Game of Life.                But this doesn't explain high memory traffic. Let's return to dotMemory and find out what function calls                the                <code class="code">CalculateNextGeneration</code>                method.            </p></li><li class="list__item" id="6b38c7f9"><p>                In dotMemory, expand the                <code class="code">CalculateNextGeneration</code>                method to see the next function in the stack.                It is the <code class="code">Update</code> method of the                <code class="code">Grid</code>                class:                <figure><img alt="t3 traffic view function2" title="t3 traffic view function2" src="/help/img/dotnet/2019.2/t3_traffic_view_function2.png" id="e4fbf0a6" width="739" height="217"></figure>            </p></li><li class="list__item" id="270b5ba4"><p>                Find this method in the code:                <div class="code-block" data-lang="csharp">
public void Update()
{
    for (int i = 0; i &lt; SizeX; i++)
    {
        for (int j = 0; j &lt; SizeY; j++)
        {
            _nextGenerationCells[i, j] = CalculateNextGeneration(i,j);
        }
    }
    UpdateToNextGeneration();
}
                </div>                This finally sheds light on the causes of our high memory traffic. There is the                <code class="code">nextGenerationCells</code>                array of the                <code class="code">Cell</code>                type which stores cells for the next generation of Game of Life.                On each generation update, cells in this array                are replaced with new ones. Cells left from previous generation are no longer needed and get collected                by GC                after some time.                Obviously, there's no need to fill the                <code class="code">_nextGenerationCells</code>                array with new cells each time as the array                exists during the entire lifetime of the application.                To get rid of high memory traffic, we simply need to update the properties of                existing cells with new values instead of creating new cells. Let's do this in the code.            </p></li><li class="list__item" id="3a63aae3"><p>                Actually, as our application is a learning example, it already contains the required implementation of                the                <code class="code">CalculateNextGeneration</code>                method. This method updates a cell's                <code class="code">IsAlive</code>                and <code class="code">Age</code> fields sent by reference:                <div class="code-block" data-lang="csharp">
public void CalculateNextGeneration(int row, int column, ref bool isAlive, ref int age)
{
    ...
}
                </div>                To fix the issue, simply uncomment the lines in                <code class="code">Update()</code>                that update the                <code class="code">_nextGenerationCells</code>                array using this method. Finally, the                <code class="code">Update()</code>                method should look as follows:                <div class="code-block" data-lang="none">
public void Update()
{
    bool alive = false;
    int age = 0;

    for (int i = 0; i &lt; SizeX; i++)
    {
        for (int j = 0; j &lt; SizeY; j++)
        {
            CalculateNextGeneration(i, j, ref alive, ref age);
            _nextGenerationCells[i, j].IsAlive = alive;
            _nextGenerationCells[i, j].Age = age;
        }
    }
    UpdateToNextGeneration();
}
    </div>                Now, let's apply these changes and check how they affect the memory traffic.            </p></li><li class="list__item" id="4bc6a707"><p>                Build the application one more time. Repeat the steps described in                <a href="#t3_step1">Step 1. Run dotMemory</a>                and                <a href="#t3_step2">Step 2. Get snapshots</a>                to get two new snapshots.            </p></li><li class="list__item" id="c1eb9b08"><p>                Open the                <span class="control">Memory Traffic</span>                view to see the memory traffic between the collected snapshots (as described in Sub-steps 1 and                2 in <a href="#t3_step3">Step 3. Analyze memory traffic</a>):                <figure><img alt="t3 traffic view fixed" title="t3 traffic view fixed" src="/help/img/dotnet/2019.2/t3_traffic_view_fixed.png" id="f938e2c8" width="738" height="379"></figure>                The                <code class="code">GameOfLife.Cell</code>                class is no longer on the list! This resulted in a 40% drop in the overall traffic (down                to 33 MB), which is a very good optimization.            </p></li></ol>    </div><div class="last-modified" data-skip-index="skip">Last modified: 8 August 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="How_to_Find_a_Memory_Leak.html">Find a Memory Leak</a><a class="navigation-links__next" href="Profile_Standalone_Application.html">Profile Standalone Application</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>