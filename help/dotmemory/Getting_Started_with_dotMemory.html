<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotMemory tutorial, .NET C# memory profiling tutorial, .NET memory management tutorial,
        .NET memory profiler
    " data-skip-index="skip"><meta charset="UTF-8"><title>dotMemory入门-帮助|点内存</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Getting_Started_with_dotMemory" data-disqus-id="Getting_Started_with_dotMemory_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected>视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Getting_Started_with_dotMemory.xml" data-toc="Getting_Started_with_dotMemory">dotMemory入门</h1>            <div class="table-wrapper"><table width="50%" id="d154496b"><thead><tr valign="top" id="c55165ad" class="ijRowHead"><th id="513db0f5" width="50%"></th><th id="c45a4166"></th></tr></thead><tbody><tr id="71189414" class="ijRowOdd"><td id="7815ae60">                <b id="b77732e6">样品申请</b>            </td><td id="6b6c26bd">                <ul class="list _ul"><li class="list__item" id="45cb7239">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1" rel="noopener noreferrer" data-external="true" target="_blank">生活游戏</a>                    </li></ul>            </td></tr><tr id="8c36e8e9" class="ijRowEven"><td id="d4d73c86">                <b id="7b27bb1e">快照</b>            </td><td id="af037b29">                <ul class="list _ul"><li class="list__item" id="38b05873">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1/raw/master/Snapshots/Get_Started_Snapshot.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Get_Started_Snapshot.dmw</a>                    </li></ul>            </td></tr><tr id="0b49f1f9" class="ijRowOdd"><td id="f52f11c4"></td><td id="adb1feee"></td></tr></tbody></table></div>    <p id="bc2d56fd">在本教程中，我们将学习如何运行dotMemory并获取内存快照。此外，我们将简要介绍dotMemory的用户界面和基本配置文件概念。将本教程视为dotMemory的起点。</p>    <div class="chapter"><h3 id="e5efee0f" data-toc="Getting_Started_with_dotMemory#e5efee0f">基本条款</h3>        <p id="3292ed5a">您可能会问：“什么是内存快照？为什么要获取它们？“这是一个就使用dotMemory时遇到的一些内存分析术语达成共识的好时机。</p>        <p id="a61ec210">从内存的角度来看，应用程序的工作包括为新对象连续分配内存，并释放不再由应用程序使用的对象留下的内存。对象在所谓的托管堆中一个接一个地分配。基于此，我们需要执行两个基本操作，内存分析器必须能够执行此操作：</p>        <ul class="list _bullet"><li class="list__item" id="6b4f25ca"><p>获取<span class="emphasis">内存快照</span> 。快照是托管堆的即时映像。每个快照都包含有关您单击<span class="control">获取快照</span>按钮时应用程序已在内存中分配的所有对象的信息。</p></li><li class="list__item" id="c646496b"><p>收集<span class="emphasis">内存流量</span>信息。内存流量显示您已分配和释放了多少内存，例如在两个内存快照之间。该信息也是非常有价值的，因为它使您能够了解应用程序性能的动态变化。</p></li></ul>        <p id="4be43213">收集流量并获取快照（或换句话说，对应用程序进行<span class="emphasis">概要分析</span> ）的时间间隔称为<span class="emphasis">分析会话</span> 。</p>        <p id="905c6736">当然，在学习本教程时，您还将熟悉一些其他术语。但是到目前为止，这足以了解接下来的几个步骤中发生的情况。让我们开始吧！</p>    </div>    <div class="chapter"><h2 id="2333ab88" data-toc="Getting_Started_with_dotMemory#2333ab88">样品申请</h2>        <p id="d22e0b5c">首先，我们需要一个用于分析的应用程序。在整个dotMemory教程系列中，我们将使用相同的C＃应用程序。它模仿了大多数人可能都知道的经典Conway的《人生游戏》。如果没有，请检查<a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" rel="noopener noreferrer" data-external="true" target="_blank">Wikipedia</a> 。这不会花费很多时间，但是会使对教程的理解更加容易。因此，在我们开始之前，请从<a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1" rel="noopener noreferrer" data-external="true" target="_blank">github</a>下载该应用程序。</p><figure><img alt="tutorial1生活游戏" title="tutorial1生活游戏" src="/help/img/dotnet/2019.2/tutorial1_game_of_life.png" id="29665e85" width="540" height="352"></figure>        <p></p>    </div>    <div class="chapter"><h2 id="step-1-run-dotmemory" data-toc="Getting_Started_with_dotMemory#step-1-run-dotmemory">步骤1。运行dotMemory</h2>        <ol class="list _decimal"><li class="list__item" id="e454f92c"><p>使用Windows的“开始”菜单运行dotMemory。</p><figure><img alt="tutorial1运行dotMemory 1" title="tutorial1运行dotMemory 1" src="/help/img/dotnet/2019.2/tutorial1_running_dotMemory_1.png" id="6b5b6a51" width="250" height="64"></figure>这将打开主dotMemory窗口。<figure><img alt="tutorial1运行dotMemory 2" title="tutorial1运行dotMemory 2" src="/help/img/dotnet/2019.2/tutorial1_running_dotMemory_2.png" id="dea546ff" width="700" height="471"></figure>现在让我们开始一个性能分析会话（一个时间段，在此期间dotMemory将收集内存使用情况数据）。<p></p></li><li class="list__item" id="bafe53d5"><p>在左侧面板上选择<span class="control">本地</span> ，然后在<span class="control">配置文件应用程序中</span> ，选择<span class="control">独立应用程序</span> 。</p></li><li class="list__item" id="d71fc3ad">现在，我们应该配置性能分析会话选项。在右侧面板中：<ul class="list _ul"><li class="list__item" id="096142d2"><p>在“ <span class="control">应用程序”中</span> ，指定我们的“生命游戏”可执行文件的路径。建议您分析应用程序的<i id="3318e1f4">发行版</i> *。</p></li><li class="list__item" id="2d023269">选择<span class="control">从开始收集内存分配和流量数据</span>选项。这将告诉dotMemory在应用启动后立即开始收集分配调用堆栈数据。<p id="8b696151">指定所有选项后，窗口应如下所示：</p><figure><img alt="tutorial1运行dotMemory 3" title="tutorial1运行dotMemory 3" src="/help/img/dotnet/2019.2/tutorial1_running_dotMemory_3.png" id="da0ca999" width="347" height="298"></figure>                        <p></p>                        <aside class="note " rel="8b696151" id="1730ce0a" data-title=""><p>*调试版本包含可能影响分析结果的编译器指令。</p></aside>                    </li></ul>            </li><li class="list__item" id="54ccfbc6"><p>单击<span class="control">运行</span>以启动分析会话。这将运行我们的应用程序，并在dotMemory中打开一个新的<span class="control">Analysis</span>标签。</p></li></ol>    </div>    <div class="chapter"><h2 id="2f9c4858" data-toc="Getting_Started_with_dotMemory#2f9c4858">第2步。取得快照</h2>        <aside class="tip sideblock" rel="2f9c4858" id="0f7e1204" data-title="">            <p id="bbdc6b9e">如果要跳过“获取快照”步骤，则可以<a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1/raw/master/Snapshots/Get_Started_Snapshot.dmw" rel="noopener noreferrer" data-external="true" target="_blank">下载</a>本教程使用<a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1/raw/master/Snapshots/Get_Started_Snapshot.dmw" rel="noopener noreferrer" data-external="true" target="_blank">的快照</a> ，然后继续下一步。</p>        </aside>        <p id="48b1c6ff">应用程序运行后，我们可以获得内存快照。此操作中最重要的是为其选择合适的时刻。您还记得，快照是应用程序托管堆的即时映像。因此，在拍摄快照之前，您应该做的第一件事就是将应用程序置于您感兴趣的状态。例如，如果我们要看一看在“生命游戏”启动后立即创建的对象，则必须在应用中执行任何操作之前获取快照。相反，如果我们需要知道动态创建了哪些对象，则在应用程序中单击“ <span class="control">启动”</span>之后，必须拍摄快照。</p>        <ol class="list _decimal"><li class="list__item" id="a583ee55"><p>假设我们需要获取有关“生命游戏”运行时分配的对象的信息。因此，在应用程序中单击“ <span class="control">开始”</span>按钮，然后让游戏运行一段时间。</p></li><li class="list__item" id="12a4c857"><p>单击dotMemory中的“ <span class="control">获取快照”</span>按钮。</p><figure><img alt="tutorial1会话1" title="tutorial1会话1" src="/help/img/dotnet/2019.2/tutorial1_session_1.png" id="9f040f3d" width="700" height="488"></figure>这将捕获数据并将快照添加到快照区域。获取快照不会中断配置过程，因此允许我们获取另一个快照（目前不需要）。<p></p></li><li class="list__item" id="c200ec06"><p>通过关闭“生命游戏”窗口来结束分析会话。</p></li><li class="list__item" id="07536a15">查看dotMemory。现在，主页包含具有基本信息的单个快照。<figure><img alt="tutorial1快照" title="tutorial1快照" src="/help/img/dotnet/2019.2/tutorial1_snapshot.png" id="430dfafc" width="395" height="276"></figure>                <span class="control">总共114.47 MB</span>意味着应用程序<span class="control">总共</span>消耗了114.47 MB的内存。该大小等于Windows Task Manager的<i id="7dd089fe">Commit大小</i> ：进程请求的内存量。总价值包括：<ul class="list _bullet"><li class="list__item" id="7971cb59"><p>非托管内存：分配给托管堆之外且不受垃圾收集器管理的内存。通常，这是.NET CLR，动态库，图形缓冲区（对于密集使用图形的WPF应用程序来说尤其如此）所需的内存。无法在事件探查器中分析这部分内存。</p></li><li class="list__item" id="dc8c6248"><p>                        <span class="control">.NET，总计</span> ：托管堆中的内存总量，包括可用内存（请求但未由应用程序使用）。</p></li><li class="list__item" id="42ebcca7"><p>                        <span class="control">.NET，已使用</span> ：应用程序在托管堆中<span class="control">使用</span>的内存量。这是.NET允许您使用的唯一内存部分。因此，它也是您可以在探查器中分析的唯一部分。</p></li></ul>            </li></ol>        <p id="b5622524">让我们更详细地看一下快照。为此，请单击“ <span class="control">Snapshot＃1”</span>链接。</p>    </div>    <div class="chapter"><h2 id="47cf304f" data-toc="Getting_Started_with_dotMemory#47cf304f">第三步熟悉快照概述</h2>        <p id="e97fc61a">打开快照后，您看到的第一件事是“ <span class="control">检查”</span>视图。此页面显示主要快照热点。</p>        <figure><img alt="tutorial1快照概述" title="tutorial1快照概述" src="/help/img/dotnet/2019.2/tutorial1_snapshot_overview.png" id="80cb4734" width="800" height="594"></figure>        <p id="a5f3ed2d">您在这里看到的是：</p>        <ul class="list _ul"><li class="list__item" id="c844b058"><p>                <span class="control">最大大小</span> ：该图显示了消耗内存主要部分的对象类型。</p></li><li class="list__item" id="7fde49ee"><p>                <span class="control">最大保留大小</span> ：该图显示了关键对象，这些关键对象将应用程序中的所有其他对象保存在内存中（本教程后面的详细信息）。</p></li><li class="list__item" id="dc96f8f0"><p>                <span class="control">字符串重复项</span> ， <span class="control">稀疏数组</span> ， <span class="control">事件处理程序泄漏</span>等：为了简化您的工作，dotMemory会自动检查快照中是否存在最常见的内存问题。如果您不知道从哪里开始，那么这些自动检查的结果就是很好的切入点。</p></li><li class="list__item" id="365c28da"><p>                <span class="control">堆碎片</span> ：该图示出了托管堆段的碎片<span class="control">：1代</span> <span class="control">，2</span>和<span class="control">大对象堆</span> 。</p></li></ul>        <p id="6d4d57c9">让我们继续检查快照并查看其中包含的对象：</p>        <ol class="list _decimal"><li class="list__item" id="59653d42"><p>单击<span class="control">类型</span>按钮。这将按快照类型将所有对象<span class="control">分组，</span>并显示“ <span class="control">按类型分组”</span>视图。</p><figure><img alt="tutorial1所有对象" title="tutorial1所有对象" src="/help/img/dotnet/2019.2/tutorial1_all_objects.png" id="722b937b" width="800" height="560"></figure>            <p></p></li></ol>        <p id="19677d90">现在，是了解dotMemory用户界面和整个内存分析“材料”的最佳时间。</p>    </div>    <div class="chapter"><h2 id="3d338176" data-toc="Getting_Started_with_dotMemory#3d338176">第四步。内存分析入门</h2>        <p id="9e9c6fba">在继续之前，让我们先走一下弯路，讨论一下对象如何存储在内存中。这是为了更好地了解dotMemory实际向您显示的内容。</p>        <div class="chapter"><h3 id="bc6ed37c">内存中的对象</h3>            <p id="6166fad4">应用程序消耗的大部分内存都分配给了应用程序的对象。对象存储数据并引用其他对象。一个对象及其引用构成一个<i id="2e479040">对象图</i> 。例如， <code class="code">Photo</code>类将存储<code class="code">id</code>的领域<code class="code">long</code>值类型本身，并引用其他字段（引用类型的对象）。</p>            <div class="code-block" data-lang="csharp">类照片{long _id;字符串_title;用户_user;列出<photocomment>评论}</photocomment></div>            <figure><img alt="底漆照相课" title="底漆照相课" src="/help/img/dotnet/2019.2/primer_photo_class.png" id="2a718d11" width="461" height="339"></figure>        </div>        <div class="chapter"><h3 id="app-roots">应用根</h3>            <aside class="note " rel="app-roots" id="3f1bd65e" data-title=""><p>*应用程序根目录由运行时处理。</p></aside>            <p id="0d0ee145">当您的应用程序需要内存时，.NET的垃圾收集器（GC）确定并删除不再需要的对象。为此，GC将从<i id="1028efcf">根</i> *开始的每个对象的图形向下传递，即，静态字段，局部变量和外部句柄。如果从任何根目录都无法访问该对象，则认为不再需要该对象，并将其从内存中删除。在以下示例中，由于无法从应用程序的根目录访问对象D和F，因此它们将从内存中删除。</p>            <figure><img alt="底漆gc" title="底漆gc" src="/help/img/dotnet/2019.2/primer_gc.png" id="3a8bb907" width="364" height="296"></figure>        </div>        <div class="chapter"><h3 id="91a0be73">保留</h3>            <p id="3abfeb6f">在这里，我们谈到<i id="f2e295da">保留</i>的关键概念。</p>            <p id="89549be1">从根到对象的路径可能会穿过许多其他对象。如果到对象B的所有路径都经过对象A，则A是B的<i id="40c2be96">主导者</i> 。换句话说，B仅由A保留在内存中。如果A被垃圾回收，B也将被垃圾回收。这就是每个对象最重要的参数是其保留的对象大小的原因。在dotMemory中，此参数称为<span class="control">保留字节</span> 。例如，下面示例中的对象C保留632个字节。对象B并非由C独占；因此，它不包括在计算中。</p>            <figure><img alt="引物保留" title="引物保留" src="/help/img/dotnet/2019.2/primer_retention.png" id="7eb753e8" width="281" height="295"></figure>            <p id="aaea5d35">让我们回到dotMemory，看看打开的<span class="control">Group by Types</span>视图。该视图当前向您显示堆中的所有对象，并按它们<i id="f28f5d91">专有</i>保留的内存量排序。如您所见，主要部分保留在<code class="code">System.Windows.Shapes.Ellipse</code>类（显然，这些是我们用来可视化生命游戏细胞的椭圆形状）。该类型的对象保留11,864,580字节的内存，而自身消耗3,862,600字节。</p>            <figure><img alt="tutorial1普通列表" title="tutorial1普通列表" src="/help/img/dotnet/2019.2/tutorial1_plain_list.png" id="0da7fc19" width="735" height="314"></figure>            <p id="5268f8ba">熟悉主要的分析术语后，让我们看看如何使用dotMemory。</p>        </div>    </div>    <div class="chapter"><h2 id="4b1ad08e" data-toc="Getting_Started_with_dotMemory#4b1ad08e">第五步熟悉用户界面</h2>    <p id="15bbe2d7">我们希望您将您在dotMemory中的工作视为某种犯罪调查（以dotMemory进行<i id="3f0e719a">内存分析</i> ）。这里的主要思想是收集数据（一个或多个内存快照）并选择许多可疑<i id="fdc5696d">对象</i> （可能引起此问题的<i id="fdc5696d">分析对象</i> ）。因此，您先从一些可疑列表开始，然后逐步缩小范围。一个犯罪嫌疑人可能将您引向另一犯罪嫌疑人，依此类推，直到您确定有罪为止。</p>    <ol class="list _decimal"><li class="list__item" id="51260e80">请查看dotMemory窗口的左侧。在“ <span class="control">分析路径”</span>中显示所有调查步骤。<figure><img alt="tutorial1分析路径" title="tutorial1分析路径" src="/help/img/dotnet/2019.2/tutorial1_analysis_path.png" id="9e89af2a" width="252" height="190"></figure><span class="control">分析路径</span>中的每个项目都是您要分析的主题。如您所见，首先从<span class="control">Profiling GameOfLife.exe</span> （步骤＃1）开始，然后打开<span class="control">Snapshot＃1</span> （步骤＃2），并要求dotMemory向您显示堆中的<span class="control">所有对象</span> （对象集<span class="control">All objects</span> ）。即使是一个很小的应用程序也会创建许多对象，因此尝试分别分析每个对象并不是很有效。这就是为什么在dotMemory中分析的主要主题是所谓的<span class="emphasis">对象集</span> 。<figure><img alt="基本概念4" title="基本概念4" src="/help/img/dotnet/2019.2/basic_concepts_4.png" id="80cbd4d9" width="773" height="398"></figure>            <span class="emphasis">对象集</span>是根据特定条件选择的许多对象。为了便于理解，请将对象集视为某些查询*（非常类似于SQL查询）的结果。例如，您可以告诉dotMemory类似“ <i id="0e10844a">选择由SomeCall（）创建并升级到Gen 2的</i> <i id="4f987c61">所有对象</i> ”或“ <i id="4f987c61">选择实例A保留在内存中的所有对象</i> ”之类的内容。<aside class="note " rel="4f987c61" id="7d9c5f9d" data-title=""><p>*当然，您实际上没有键入任何查询。您与dotMemory的所有通信都是通过GUI执行的。</p></aside>        </li><li class="list__item" id="fa2aaa9d"><p>可以从称为<span class="emphasis">view的</span>不同角度检查每个对象集。看屏幕。您看到的视图称为“ <span class="control">按类型分组”</span> ，它向您显示了对象集中按类型分组的简单列表。其他视图可以显示有关所选集的其他信息。例如，“ <span class="control">按主宰者分组”</span>视图将显示谁将所选对象保留在内存中。 <span class="control">调用树</span>将向您显示什么调用创建了对象；等等。您可以使用屏幕顶部的按钮轻松更改视图：</p><figure><img alt="tutorial1浏览" title="tutorial1浏览" src="/help/img/dotnet/2019.2/tutorial1_views.png" id="3072cac6" width="667" height="62"></figure>如上所述，您分析的每个主题都可能将您引向另一个主题。例如，我们看到<code class="code">System.Windows.Shapes.Ellipse</code>类保留了大部分内存，我们想知道是什么方法创建了所有这些省略号。让我们找出来。<p></p></li><li class="list__item" id="556f5023"><p>双击<span class="control">系统。视窗。形状。椭圆化</span>或打开（右键单击）这些对象的上下文菜单，然后选择“ <span class="control">打开此对象集”</span> 。</p></li><li class="list__item" id="8bc19b6d"><p>选择<span class="control">返回轨迹</span>视图。</p><figure><img alt="tutorial1调用树" title="tutorial1调用树" src="/help/img/dotnet/2019.2/tutorial1_call_tree.png" id="c4fb7333" width="800" height="533"></figure>该视图表明，我们的椭圆来自于<code class="code">Grid.InitCellsVisuals()</code>方法。请注意，“分析路径”现在还包含一个步骤： <span class="control">按系统类型分组。视窗。形状。椭圆形</span> 。<p></p></li><li class="list__item" id="97b591d0"><p>尝试一点dotMemory。例如，确定<span class="control">系统对象保留的<span class="control">内容。视窗。形状。椭圆</span>课。</span></p></li></ol></div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Examples.html">如何</a> <a class="navigation-links__next" href="How_to_Find_a_Memory_Leak.html">找到内存泄漏</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>