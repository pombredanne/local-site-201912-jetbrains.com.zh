<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/help/app/v2/analytics.js"></script><meta content="&#xA;        dotMemory tutorial, .NET C# memory profiling tutorial, .NET memory management tutorial,&#xA;        .NET memory profiler&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Get Started with dotMemory - Help | dotMemory</title><link rel="stylesheet" href="/help/app/v2/app.css"></head><body data-id="Getting_Started_with_dotMemory" data-disqus-id="Getting_Started_with_dotMemory_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2018.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="false"><h1 data-toc="Getting_Started_with_dotMemory" id="Getting_Started_with_dotMemory.xml">Get Started with dotMemory</h1>            <div class="table-wrapper"><table class="                 " width="50%" id="54c80d12"><thead><tr valign="top" id="a5169490" class="ijRowHead"><th id="a8395178" width="50%"></th><th id="01847f6e"></th></tr></thead><tbody><tr id="54e21dbf" class="ijRowOdd"><td id="94660a6a"><p>                <b id="d4da7105">Sample application</b>            </p></td><td id="bf9c79be">                <ul class="list _ul"><li class="list__item" id="49233d37"><p>                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1" data-external="true" target="_blank" rel="noopener noreferrer"><span>Game of Life</span></a>                    </p></li></ul>            </td></tr><tr id="6d1e8b01" class="ijRowEven"><td id="a504fb91"><p>                <b id="ef5156e4">Snapshots</b>            </p></td><td id="c8ee9aba">                <ul class="list _ul"><li class="list__item" id="e2c7c252"><p>                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1/raw/master/Snapshots/Get_Started_Snapshot.dmw" data-external="true" target="_blank" rel="noopener noreferrer"><span>Get_Started_Snapshot.dmw</span></a>                    </p></li></ul>            </td></tr><tr id="d2d334fb" class="ijRowOdd"><td id="11941504"></td><td id="eba8ad63"></td></tr></tbody></table></div>    <p id="0ca2f2ad">        In this tutorial, we will learn how to run dotMemory and get memory snapshots. In addition, we will take a brief        look at dotMemory's user interface and basic profiling concepts. Consider this tutorial as your starting point        to dotMemory.    </p>    <div class="chapter"><h2 id="59d4ea8e" data-toc="Getting_Started_with_dotMemory#59d4ea8e">Basic terms</h2>        <p id="37dac2a7">            You might ask: "What are memory snapshots and why should I get them?" This is a good time to agree on some            memory            profiling terms you'll come across while using dotMemory.        </p>        <p id="09120ad0">            From memory perspective, the work of your application consists of continuous allocation of memory for new            objects and            releasing the memory left from the objects that are no longer used by the app. Objects are allocated one            after            another in the so-called managed heap. Based on this, we have two basic operations a memory profiler must be            able to do:        </p>        <ul class="list _bullet"><li class="list__item" id="c39aaddc"><p>                Get a <span class="emphasis">memory snapshot</span>. Snapshot is an instant image of the managed heap. Each snapshot contains                the info                about all the objects that your app has allocated in memory at the moment you click the                <span class="control">Get Snapshot</span>                button.            </p></li><li class="list__item" id="cdae0e48"><p>                Collect <span class="emphasis">memory traffic</span> information. Memory traffic shows you how much memory was allocated and                released,                e.g., between two memory snapshots. This info is also very valuable as it allows you to understand the                dynamics of how your application performs.            </p></li></ul>        <p id="30ebb527">            The time interval during which you collect traffic and get snapshots (or, in other words, profile your            application) is called <span class="emphasis">profiling session</span>.        </p>        <p id="6f3de8d2">            Of course, there are some other terms that you'll get acquainted with while following the tutorial. But for            now            this is enough to understand what's going on in the next couple of steps. Let's get started!        </p>    </div>    <div class="chapter"><h2 id="03775e31" data-toc="Getting_Started_with_dotMemory#03775e31">Sample application</h2>        <p id="2d135c5e">            First of all, we need an application for profiling. Through the whole series of dotMemory tutorials, we will            use            the same C# application. It emulates the classic Conway's Game of Life that most of you probably know. If            not,            please            check <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" data-external="true" target="_blank" rel="noopener noreferrer"><span>Wikipedia</span></a>. This won't take a lot of            time            but will            make the understanding of tutorials much easier. So, before we start, please download the application from            <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1" data-external="true" target="_blank" rel="noopener noreferrer"><span>github</span></a>.            <figure><img alt="tutorial1 game of life" title="tutorial1 game of life" src="/help/img/dotnet/2018.3/tutorial1_game_of_life.png" id="657c6b58" width="540" height="352"></figure>        </p>    </div>    <div class="chapter"><h2 id="step-1-run-dotmemory" data-toc="Getting_Started_with_dotMemory#step-1-run-dotmemory">Step 1. Run dotMemory</h2>        <ol class="list _decimal"><li class="list__item" id="69c14c96"><p>                Run dotMemory by using Windows Start menu.                <figure><img alt="tutorial1 running dotMemory 1" title="tutorial1 running dotMemory 1" src="/help/img/dotnet/2018.3/tutorial1_running_dotMemory_1.png" id="a0f2c0cd" width="250" height="64"></figure>                This will open the main dotMemory window.                <figure><img alt="tutorial1 running dotMemory 2" title="tutorial1 running dotMemory 2" src="/help/img/dotnet/2018.3/tutorial1_running_dotMemory_2.png" id="d0e16c61" width="700" height="471"></figure>                Now let's start a profiling session (a timeframe during which dotMemory will collect memory usage data).            </p></li><li class="list__item" id="a36a324d"><p>                Select <span class="control">Local</span> on the left panel and in                <span class="control">Profile Application</span>, choose <span class="control">Standalone application</span>.            </p></li><li class="list__item" id="7d32a7df">                Now we should configure profiling session options. In the right panel:                <ul class="list _ul"><li class="list__item" id="d7bd5615"><p>                        In <span class="control">Application</span>, specify the path to our Game of Life executable.                        It is recommended that you profile application's <i id="21f77702">Release builds</i>*.                    </p></li><li class="list__item" id="daa31e71">                        Select the                        <span class="control">Collect memory allocation and traffic data from start</span>                        option. This will tell dotMemory to start collecting allocation call stack                        data right after the app is launched.                        <p id="c58aa2f2">                            Here is what the window should look like after you specify all the options:                            <figure><img alt="tutorial1 running dotMemory 3" title="tutorial1 running dotMemory 3" src="/help/img/dotnet/2018.3/tutorial1_running_dotMemory_3.png" id="1d15ae72" width="347" height="298"></figure>                        </p>                        <aside class="note " data-title="" rel="c58aa2f2" id="59443e0d"><p>* Debug builds contain compiler instructions that may affect profiling results.</p></aside>                    </li></ul>            </li><li class="list__item" id="5c265f91"><p>                Click <span class="control">Run</span> to start the profiling session. This will run our app and open a new                <span class="control">Analysis</span> tab in dotMemory.            </p></li></ol>    </div>    <div class="chapter"><h2 id="0fe4cf6e" data-toc="Getting_Started_with_dotMemory#0fe4cf6e">Step 2. Get a snapshot</h2>        <aside class="tip sideblock" data-title="" rel="0fe4cf6e" id="2ec48097">            <p id="8e73d612">                If you want to skip the "get a snapshot" step, you can                <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial1/raw/master/Snapshots/Get_Started_Snapshot.dmw" data-external="true" target="_blank" rel="noopener noreferrer"><span>download the snapshot</span></a>                that was used for this tutorial                and proceed to the next step.            </p>        </aside>        <p id="3fd4459f">Once the app is running, we can get memory snapshots. The most important thing in this operation is choosing            the right moment for it. As you remember, a snapshot is the instant image of the application's managed heap.            Thus,            the first            thing you should do before taking a snapshot is bring your application to the state you're interested in.            For            example, if we want to take a look at the objects created right after Game of Life is launched, we must            get a snapshot before taking any actions in the app. Conversely, if we need to know what objects are created            dynamically, we must take a snapshot after we click <span class="control">Start</span> in the application.        </p>        <ol class="list _decimal"><li class="list__item" id="5d2c6cbc"><p>Let's assume we need to get info about objects allocated when Game of Life runs. Therefore, click the                <span class="control">Start</span>                button in the application and let the game run for a while.            </p></li><li class="list__item" id="8ed9a56c"><p>                Click the <span class="control">Get Snapshot</span> button in dotMemory.                <figure><img alt="tutorial1 session 1" title="tutorial1 session 1" src="/help/img/dotnet/2018.3/tutorial1_session_1.png" id="2b06b0bb" width="700" height="488"></figure>                This will capture the data and add the snapshot to the snapshot area. Getting a snapshot doesn't                interrupt                the profiling process, thus allowing us to get another snapshot (not needed for now).            </p></li><li class="list__item" id="3430b5a8"><p>End the profiling session by closing the Game of Life window.</p></li><li class="list__item" id="dca0733d">                Look at dotMemory. The main page now contains the single taken snapshot with basic information.                <figure><img alt="tutorial1 snapshot" title="tutorial1 snapshot" src="/help/img/dotnet/2018.3/tutorial1_snapshot.png" id="7a0a1c8a" width="395" height="276"></figure>                <span class="control">114.47 MB total</span>                means that the application consumes 114.47 MB of memory in total.                This size is equal to Windows Task Manager's                <i id="582e60a8">Commit size</i>: the amount of memory requested by a process. The total value consists of:                <ul class="list _bullet"><li class="list__item" id="429b8372"><p>                        Unmanaged memory: memory allocated outside of the managed heap and not managed by Garbage                        Collector. Generally, this is the memory required by .NET CLR, dynamic libraries, graphics                        buffer                        (especially large for WPF apps that intensively use graphics), and so on.                        This part of memory cannot be analyzed in the profiler.                    </p></li><li class="list__item" id="8b47d623"><p>                        <span class="control">.NET, total</span>: total amount of memory in the managed heap including                        free memory (requested but not used by the application).                    </p></li><li class="list__item" id="de1663df"><p>                        <span class="control">.NET, used</span>: amount of memory in the managed heap                        that is used by the application. This is the only part of memory .NET allows you to work with.                        For this reason, it's also the only part which you're able to analyze in the profiler.                    </p></li></ul>            </li></ol>        <p id="036cddea">            Let's take a look at the snapshot in more details. To do this, click the            <span class="control">Snapshot #1</span>            link.        </p>    </div>    <div class="chapter"><h2 id="86843eea" data-toc="Getting_Started_with_dotMemory#86843eea">Step 3. Get acquainted with Snapshot Overview</h2>        <p id="f210b85f">            The first thing you see after opening the snapshot is the <span class="control">Inspections</span> view.            This page shows you main snapshot hot spots.        </p>        <figure><img alt="tutorial1 snapshot overview" title="tutorial1 snapshot overview" src="/help/img/dotnet/2018.3/tutorial1_snapshot_overview.png" id="b2cb99f7" width="800" height="594"></figure>        <p id="ad34fac8">            What you see here:        </p>        <ul class="list _ul"><li class="list__item" id="8d5f911f"><p>                <span class="control">Largest Size</span>: the diagram shows types of objects that consume the major part of                memory.            </p></li><li class="list__item" id="5f1273f5"><p>                <span class="control">Largest Retained Size</span>: the diagram shows you the key objects, the ones that hold                in memory all other objects in the application (more info about them later in this tutorial).            </p></li><li class="list__item" id="d72ba075"><p>                <span class="control">String duplicates</span>, <span class="control">Sparse arrays</span>, <span class="control">Event handlers leak</span>, etc.:                to ease your life,                dotMemory automatically checks the snapshot for most common types of memory issues. If you don't know                where to start, the results of these automatic inspections is a good entry point.            </p></li><li class="list__item" id="7e269f4d"><p>                <span class="control">Heap Fragmentation</span>: the diagram shows the fragmentation of the managed heap segments:                <span class="control">Generation 1</span>, <span class="control">2</span>, and                <span class="control">Large Object Heap</span>.            </p></li></ul>        <p id="6e800d1e">Let's continue with examining the snapshot and view the objects it contains:</p>        <ol class="list _decimal"><li class="list__item" id="85bdda72"><p>                Click the <span class="control">Types</span> button. This will group all objects in the snapshot by their type                and show you the <span class="control">Group by Types</span> view.                <figure><img alt="tutorial1 all objects" title="tutorial1 all objects" src="/help/img/dotnet/2018.3/tutorial1_all_objects.png" id="ea4e2143" width="800" height="560"></figure>            </p></li></ol>        <p id="37128050">            Now, it's the best time to acquaint with the dotMemory user interface and the entire memory analysis            "stuff".        </p>    </div>    <div class="chapter"><h2 id="71c1d109" data-toc="Getting_Started_with_dotMemory#71c1d109">Step 4. Memory analysis primer</h2>        <p id="e3d04abd">            Before we go any further, let's take a little detour and talk about how objects are stored in memory. This            is            needed for better understanding of what dotMemory actually shows you.        </p>        <div class="chapter"><h3 id="770c7add">Objects in memory</h3>            <p id="12222fdc">                The major part of the memory consumed by your application is allocated for the application's                objects. Objects store data and reference other objects. An object and its references make up an                <i id="4b085ea8">object graph</i>. For example, an object of the                <code class="code" data-lang="Java">Photo</code>                class will store the <code class="code" data-lang="Java">id</code> field of the <code class="code" data-lang="Java">long</code> value type                by itself and reference other fields (objects of reference types).            </p>            <div class="code-block" data-lang="C#"><code class="code-block__wrapper"><span class="k">class</span> <span class="nc">Photo</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">_id</span><span class="p">;</span>
    <span class="n">String</span> <span class="n">_title</span><span class="p">;</span>
    <span class="n">User</span> <span class="n">_user</span><span class="p">;</span>
    <span class="n">List</span><span class="p">&lt;</span><span class="n">PhotoComment</span><span class="p">&gt;</span> <span class="n">_comments</span><span class="p">;</span>
<span class="p">}</span></code></div>            <figure><img alt="primer photo class" title="primer photo class" src="/help/img/dotnet/2018.3/primer_photo_class.png" id="1f47910a" width="461" height="339"></figure>        </div>        <div class="chapter"><h3 id="app-roots">App roots</h3>            <aside class="note " data-title="" rel="app-roots" id="9c552bb3"><p>                * The table of app roots is handled by the runtime.            </p></aside>            <p id="74bc0c0a">                When your application needs memory, .NET's Garbage Collector (GC) determines and removes the objects                that are no longer                needed. To do this, GC passes down the graph of each object starting with                <i id="7cc8ecbb">roots</i>*, i.e. static fields, local variables and external handles. If the object is unreachable                from any                root, it's considered as no longer needed and is                removed from memory. In the example below, objects D and F will be removed from memory as they cannot be                accessed from the application's roots.            </p>            <figure><img alt="primer gc" title="primer gc" src="/help/img/dotnet/2018.3/primer_gc.png" id="f1bcf41d" width="364" height="296"></figure>        </div>        <div class="chapter"><h3 id="c30dd366">Retention</h3>            <p id="545b6198">                Here we come to the crucial concept of <i id="46d9352c">retention</i>.            </p>            <p id="d2810fcb">                A path from roots to an object may lead through a number of other objects. If all paths to the object B                pass                through                the object A, then A is a <i id="f8c6ccca">dominator</i> for B. In other words, B is retained in memory exclusively by                A.                If A is                garbage-collected, B will also be garbage-collected. That is why the most important parameter of each                object is                the size of the objects it retains. In dotMemory, this parameter is called                <span class="control">Retained bytes</span>. For instance, object C in the example below retains 632 bytes.                Object B is not exclusively retained by C; therefore, it is not                included in the calculation.            </p>            <figure><img alt="primer retention" title="primer retention" src="/help/img/dotnet/2018.3/primer_retention.png" id="0c074b82" width="281" height="295"></figure>            <p id="33d44d79">                Let's return to dotMemory and take a look at the opened                <span class="control">Group by Types</span>                view. This view currently shows you all                objects in the heap, sorted by the amount of memory they                <i id="f3c1a3c8">exclusively</i>                retain. As you can see, the major part is                retained by the                <code class="code" data-lang="Java">System.Windows.Shapes.Ellipse</code>                class (apparently, these are ellipse shapes we use to visualize                Game of Life cells). Objects of that type retain 11,864,580 bytes of memory, while consuming 3,862,600                bytes by themselves.            </p>            <figure><img alt="tutorial1 plain list" title="tutorial1 plain list" src="/help/img/dotnet/2018.3/tutorial1_plain_list.png" id="9d5384f8" width="735" height="314"></figure>            <p id="1b9ae556">                Once you're familiar with the main profiling terms, let's look at how we can work with dotMemory.            </p>        </div>    </div>    <div class="chapter"><h2 id="420298af" data-toc="Getting_Started_with_dotMemory#420298af">Step 5. Get acquainted with the user interface</h2>    <p id="fcd3173a">        We want you to think of your work in dotMemory as of some sort of crime investigation (<i id="802d3a9d">memory analysis</i>        in terms of dotMemory). The main idea here is to collect data (one or more memory snapshots) and choose a number        of suspects (<i id="c3832c7c">analysis subjects</i> that are potentially causing the issue).        So, you start with some list of suspects and gradually narrow this list down.        One suspect may lead you to another and so on, until you determine the guilty one.    </p>    <ol class="list _decimal"><li class="list__item" id="61cac29c">            Please look at the left part of the dotMemory window. It is            <span class="control">Analysis Path</span>            where all your investigation steps are shown.            <figure><img alt="tutorial1 analysis path" title="tutorial1 analysis path" src="/help/img/dotnet/2018.3/tutorial1_analysis_path.png" id="470259e8" width="252" height="190"></figure>            Each item in <span class="control">Analysis Path</span> is the subject you analyze. As you can see, you started with            <span class="control">Profiling GameOfLife.exe</span>            (step #1), then you opened            <span class="control">Snapshot #1</span>            (step #2) and asked            dotMemory to show you all objects in the heap (object set <span class="control">All objects</span>).            As even a tiny app creates numerous objects, the attempt to analyze each object separately will not be very            effective. That is why the main subject of your analysis in dotMemory is the so-called            <span class="emphasis">object set</span>.            <figure><img alt="basic concepts 4" title="basic concepts 4" src="/help/img/dotnet/2018.3/basic_concepts_4.png" id="20d84285" width="773" height="398"></figure>            <span class="emphasis">Object set</span>            is a number of objects selected by a specific condition. For ease of understanding, think of an            object set as of a result of some query* (very similar to an SQL query). For example, you can tell dotMemory            something like "<i id="c57ab428">Select all objects created by SomeCall() and promoted to Gen 2</i>",            or "<i id="a0bf3d9d">Select all objects retained in memory by the instance A</i>", and so on.            <aside class="note " data-title="" rel="a0bf3d9d" id="f7b90f24"><p>* Of course, you do not actually type any queries. All your communication with dotMemory is performed                through the GUI.            </p></aside>        </li><li class="list__item" id="34999c1d"><p>            Each object set can be inspected from different perspectives called <span class="emphasis">views</span>. Look at the screen.            The view you see is called <span class="control">Group by Types</span> and it shows you a plain list of objects in the set            grouped by their type.            Other views can reveal other info about the selected set. For example, the            <span class="control">Group by Dominators</span>            view will            show you who retains the selected objects in memory; <span class="control">Call Tree</span>            will show you what calls created the objects; and so on. You can easily change the view using the buttons            at the top of the screen:            <figure><img alt="tutorial1 views" title="tutorial1 views" src="/help/img/dotnet/2018.3/tutorial1_views.png" id="f26b6e21" width="667" height="62"></figure>            As mentioned above, each subject you analysis may lead you to another subject. For example, we see that the            <code class="code" data-lang="Java">System.Windows.Shapes.Ellipse</code>            class retains most of the memory, and we want to know what method created all these ellipses.            Let's find this out.        </p></li><li class="list__item" id="f1ed1a22"><p>            Double-click <span class="control">System.Windows.Shapes.Ellipse</span> or open the context menu            (with the right click) for these objects and select            <span class="control">Open this object set</span>.        </p></li><li class="list__item" id="7b06388a"><p>            Select <span class="control">Back Traces</span> view.            <figure><img alt="tutorial1 call tree" title="tutorial1 call tree" src="/help/img/dotnet/2018.3/tutorial1_call_tree.png" id="99a04739" width="800" height="533"></figure>            The view shows that our ellipses originate from the <code class="code" data-lang="Java">Grid.InitCellsVisuals()</code> method.            Note that the Analysis Path now contains one more step: <span class="control">Group by type System.Windows.Shapes.Ellipse</span>.        </p></li><li class="list__item" id="cc49642d"><p>            Experiment with dotMemory a little bit. For example, determine what is retained by the objects of the            <span class="control">System.Windows.Shapes.Ellipse</span> class.        </p></li></ol></div><div class="last-modified" data-skip-index="skip">Last modified: 15 March 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Examples.html">How To</a><a class="navigation-links__next" href="How_to_Find_a_Memory_Leak.html">Find a Memory Leak</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/help/app/v2/app.js"></script></body></html>