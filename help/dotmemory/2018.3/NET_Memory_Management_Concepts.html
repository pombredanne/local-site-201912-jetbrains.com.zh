<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/help/app/v2/analytics.js"></script><meta content="&#xA;        .NET memory management, CLR memory management concepts, C# .NET garbage collection,&#xA;        garbage collector, .NET managed heap, .NET unmanaged heap, unmanaged memory,&#xA;        heap generations&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>.NET Memory Management Concepts - Help | dotMemory</title><link rel="stylesheet" href="/help/app/v2/app.css"></head><body data-id="NET_Memory_Management_Concepts" data-disqus-id="NET_Memory_Management_Concepts_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2018.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="false"><h1 data-toc="NET_Memory_Management_Concepts" id="NET_Memory_Management_Concepts.xml">.NET Memory Management Concepts</h1>        <p id="aea2030c">To work with dotMemory effectively, you must have a general understanding about how .NET manages memory.        The following lists summarize .NET memory concepts. For additional information, you may refer to MSDN or other        materials in the Web.    </p>    <div class="chapter"><h2 id="1f43fa3b" data-toc="NET_Memory_Management_Concepts#1f43fa3b">Memory allocation</h2>        <ul class="list _ul"><li class="list__item" id="dbfe5da4"><p>Garbage Collector (GC) is the part of the .NET framework that allocates and releases memory for your                .NET                applications.            </p></li><li class="list__item" id="43d8a739"><p>When a new process is started, the runtime reserves a region of address space for the process called the                managed heap.            </p></li><li class="list__item" id="ee6c3434"><p>Objects are allocated in the heap contiguously one after another.</p></li><li class="list__item" id="0a6d65c7"><p>Memory allocation is a very fast process as it is just the adding of a value to a pointer.</p></li><li class="list__item" id="b49ee9b4"><p>In addition to the managed heap, an app always consumes some amount of so-called unmanaged* memory which                is not managed by GC.                <br>                *Generally, it is required by .NET Common Language Runtime itself, dynamic libraries employed by the                app, graphics buffer, and so on.            </p></li></ul>    </div>    <div class="chapter"><h2 id="6a61062b" data-toc="NET_Memory_Management_Concepts#6a61062b">Memory release</h2>        <ul class="list _ul"><li class="list__item" id="daa74d36"><p>The process of releasing memory is called garbage collection.</p></li><li class="list__item" id="8eeb2caa"><p>When GC performs a collection, it releases only objects that are no longer in use by the application                (for example, a local variable in a method can be accessed only during the method execution and after                this,                the variable is no longer needed).            </p></li><li class="list__item" id="fd0f6af4"><p>To determine whether the object is used or not, GC examines applicationâ€™s roots - strong references that                are                global to the application.                Typically, these are global and static object pointers, local variables, and CPU registers. Learn more                about                possible GC roots in <a href="Analyzing_GC_Roots.html"><span>Analyzing GC Roots</span></a>.            </p></li><li class="list__item" id="b864c317"><p>For each active root, GC builds a graph that contains all the objects that are reachable from these                roots.            </p></li><li class="list__item" id="33b01db3"><p>If an object is unreachable, GC considers it no longer in use and removes the object from the heap                (releases                the memory occupied by the object).            </p></li><li class="list__item" id="e55dd97b"><p>After the object is removed, GC compacts reachable objects in memory.                <figure><img alt="basic concepts 1" title="basic concepts 1" src="/help/img/dotnet/2018.3/basic_concepts_1.png" id="583d2d04" width="530" height="467"></figure>            </p></li></ul>    </div>    <div class="chapter"><h2 id="6ced189e" data-toc="NET_Memory_Management_Concepts#6ced189e">Generations</h2>        <ul class="list _ul"><li class="list__item" id="3d845f21"><p>For better performance of memory release, the managed heap is divided into segments called generations:                0,                1, and 2.            </p></li><li class="list__item" id="d57a357e"><p>When objects are just created, they are placed to the Generation 0 (Gen 0).</p></li><li class="list__item" id="a4c5a76b"><p>When Gen 0 is full (the size of the heap and generations is defined by GC), GC performs a garbage                collection.                During the collection, GC removes all unreachable objects from the heap. All reachable objects are                promoted                to the Generation 1 (Gen 1).            </p></li><li class="list__item" id="0d12786b"><p>The Gen 0 collection is a rather quick operation.</p></li><li class="list__item" id="0d1fcd9e"><p>When Gen 1 is full, the Gen 1 garbage collection is performed. All objects that survive the collection                are                promoted to Gen 2.                The Gen 0 collection also takes place here.            </p></li><li class="list__item" id="1501686c"><p>When Gen 2 is full, GC performs full garbage collection. First, Gen 2 collection is performed, after                this,                the Gen 1 and Gen 0 collections take place. If there is still not enough memory for new allocations, GC                raises the OutOfMemory exception.            </p></li><li class="list__item" id="f5b5106b"><p>During full garbage collection, GC has to pass through all objects in the heap, so, this process might                have                a great impact on system resources.                <figure><img alt="basic concepts 2" title="basic concepts 2" src="/help/img/dotnet/2018.3/basic_concepts_2.png" id="5264c6a9" width="338" height="528"></figure>            </p></li></ul>    </div>    <div class="chapter"><h2 id="2815b356" data-toc="NET_Memory_Management_Concepts#2815b356">Large Object Heap</h2>        <ul class="list _ul"><li class="list__item" id="c860b6ee"><p>Due to performance reasons, large objects (&gt;85KB) are stored in a separate segment of the managed                heap                called Large Object Heap (LOH).            </p></li><li class="list__item" id="af5ba5fa"><p>Survived objects in LOH are not compacted*. This means that LOH becomes fragmented over time.                <figure><img alt="basic concepts 3" title="basic concepts 3" src="/help/img/dotnet/2018.3/basic_concepts_3.png" id="b159578c" width="521" height="191"></figure>            </p></li></ul>        <p id="522f4374">*Starting from .NET Framework 4.5.1, you can force GC to compact LOH during the full garbage collection.</p>        <br>    </div>    <div class="last-modified" data-skip-index="skip">Last modified: 15 March 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Basic_Concepts.html">Basic Concepts</a><a class="navigation-links__next" href="Typical_Profiling_Workflow.html">Typical Profiling Workflow</a></div><section class="seealso" data-skip-index="skip"><div class="seealso__header"><h2>See Also</h2></div><div class="seealso__content"><div class="seealso__col" data-skip-index="skip"><h3>Concepts:</h3><ul class="list"><li class="list__item"><a href="Typical_Profiling_Workflow.html"><span>Typical Profiling Workflow</span></a></li><li class="list__item"><a href="First_Look_at_the_dotMemory_s_User_Interface.html"><span>First Look at the User Interface</span></a></li></ul></div></div></section></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/help/app/v2/app.js"></script></body></html>