<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        .NET memory management, .NET garbage collection, CLR application roots
    " data-skip-index="skip"><meta charset="UTF-8"><title>分析GC根目录-帮助|帮助点内存</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Analyzing_GC_Roots" data-disqus-id="Analyzing_GC_Roots_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected>视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Analyzing_GC_Roots.xml" data-toc="Analyzing_GC_Roots">分析GC根</h1>        <p id="50b4335c">对象的保留路径始终以GC根开头。从垃圾收集器的角度来看，root是对必须且不会收集的对象的引用。这使根成为构建保留图的唯一可能的起点。在“谁保留对象？”期间，了解根类型非常重要。”分析。有时检查保留路径并不能为您提供对象仍在内存中的答案。在这种情况下，查看GC根目录是有意义的。例如，一个<i id="afc8b259">RefCounted</i>句柄为您提供了一些非托管COM库保留该对象的线索。</p>    <p id="e0f655d6">.NET Framework中有四种可能的根类型：</p>    <ul class="list _ul"><li class="list__item" id="ab945b29"><p>            <span class="emphasis">堆栈引用</span> ：对本地对象的引用。这样的根存在于方法执行期间。</p></li><li class="list__item" id="e7e52b0e"><p>            <span class="emphasis">静态引用</span> ：对静态对象的引用。这些根源贯穿整个应用程序域的生命周期。</p></li><li class="list__item" id="5bb84b13"><p>            <span class="emphasis">句柄</span> ：通常，这些是用于托管和非托管代码之间通信的引用。这样的根必须至少存在，直到非托管代码需要“托管”对象为止。</p></li><li class="list__item" id="240218ff"><p>            <span class="emphasis">终结器引用</span> ：对等待终结的对象的引用。这些根将一直存在，直到运行终结器为止。</p></li></ul>    <p id="a5c5e005">要分析保留路径的根，请使用任何显示对象保留路径的dotMemory视图： <a href="Similar_Retention.html">按相似保留</a> <a href="Shortest_Path.html">分组，按最短路径分组</a> ， <a href="Key_Retention_Paths.html">键保留路径</a>和<a href="Shortest_Paths_to_Roots.html">最短根目录</a> 。请注意，由dotMemory区分的所有根类型都属于上述列表中提到的类别之一。</p>    <div class="chapter"><h2 id="regular-local-variable" data-toc="Analyzing_GC_Roots#regular-local-variable">正则局部变量</h2>    <p id="076a4c6a">这是在方法中声明的局部变量（堆栈上的变量）。在方法生存期内，对该变量的引用将成为根。例如：</p>    <div class="code-block" data-lang="csharp">静态void Main（）{...var collection = new Collection <int>（）; ...}</int></div>    <figure><img alt="常规局部变量根" title="常规局部变量根" src="/help/img/dotnet/2019.2/regular_local_variable.png" id="f74ffed1" width="150" height="65"></figure>    <p id="6d2e489b">请注意，在发行版中，root的生命周期可能会更短-JIT可以在不再需要该变量后立即将其丢弃。</p>    </div>    <div class="chapter"><h2 id="static-reference" data-toc="Analyzing_GC_Roots#static-reference">静态参考</h2>    <p id="f8df69f8">当CLR遇到静态对象（类成员，变量或事件）时，它将创建此对象的全局实例。在整个应用程序生命周期中都可以访问该对象，因此几乎不会收集静态对象。因此，对静态对象的引用是主要的根类型之一。</p>    <div class="code-block" data-lang="csharp">class StaticClass {public static Collection <string>StCollection; }</string></div>    <p id="6f430f73">初始化集合之后，CLR将创建集合的静态实例。对实例的引用将在应用程序域生存期内存在。</p>    <figure><img alt="静态参考根" title="静态参考根" src="/help/img/dotnet/2019.2/static_reference_1.png" id="fb8b8539" width="144" height="64"></figure>    <p id="cd8a34c4">当通过字段引用静态对象时，dotMemory会显示您的字段名称。</p>    <p id="60a09f67">当然，“未命名”静态引用也可以发生。此类根的最明显示例是对方法中声明的字符串的引用。</p>    <div class="code-block" data-lang="csharp">静态void Main（）{...string A =“这是一个字符串”； ...}</div>    <figure><img alt="静态参考根" title="静态参考根" src="/help/img/dotnet/2019.2/static_reference_2.png" id="9cb001f4" width="118" height="64"></figure>    <p id="20a10953">请注意，在上面的示例中，CLR也创建了<span class="control">常规局部变量</span>引用。但是，为了简化进一步的分析，dotMemory不会向您显示此根目录。</p>    </div>    <div class="chapter"><h2 id="f-reachable-queue" data-toc="Analyzing_GC_Roots#f-reachable-queue">F可达队列/完成队列</h2>        <p id="991a32a8">CLR提供了一种释放非托管资源的有用机制：终结模式。的<code class="code">System.Object</code>类型声明一个虚拟方法<code class="code">Finalize</code> （也称为终结器），垃圾回收器在回收对象的内存之前调用它。通常，您重写此方法以释放非托管资源。任何具有终结器的对象都将放入终结队列（在dotMemory中，这些对象具有终结<span class="control">队列</span>根）。进行垃圾收集时，GC在终结队列中找到了此类对象，但没有直接运行其终结器。相反，GC将对象放入F可达队列（dotMemory中的<span class="control">F-Reachable Queue</span>根），并在单独的Finalization线程中运行终结器（所有这些操作都是为了提高性能，因为终结器可以潜在地运行任何代码量）。在下一个GC上，F可达队列中的对象被垃圾收集。所描述的模式有缺陷，这就是为什么dotMemory提供特殊的Finalizable <a href="Inspections.html#finalized_objects">对象</a>检查的原因。</p>        <p id="0fadb5cc">请注意，由于内存配置文件的性质，dotMemory始终在拍摄快照之前运行完整的GC。这就是为什么您无法在通过dotMemory拍摄的快照中找到带有Finalization <span class="control">Queue</span>根的对象的原因。此根类型仅在原始内存转储中可用。</p>        <figure><img alt="F队列根" title="F队列根" src="/help/img/dotnet/2019.2/roots_fqueue.png" id="297fad50" width="144" height="72"></figure>    </div>    <div class="chapter"><h2 id="pinning-handle" data-toc="Analyzing_GC_Roots#pinning-handle">固定手柄</h2>        <aside class="note " rel="pinning-handle" id="e9ad6830" data-title="">            <p id="73814f63">您也可以使用<code class="code">fixed</code>块。</p>        </aside>    <p id="fa653d99">托管代码和非托管代码的交互是垃圾收集器的另一个问题。例如，您需要将对象从托管堆传递到外部API库。由于在收集过程中压缩了小的对象堆，因此可以移动对象。如果非托管代码依赖于确切的对象位置，则这是一个问题。解决方案之一是修复堆中的对象。在这种情况下，GC将获得该对象的固定手柄，这意味着该对象无法移动。因此，如果看到“ <span class="control">固定”手柄</span>根，则该对象可能是由一些非托管代码保留的。例如， <code class="code">App</code>对象始终具有固定的引用。</p>    <figure><img alt="固定柄根" title="固定柄根" src="/help/img/dotnet/2019.2/pinning_handle.png" id="06d7a200" width="116" height="126"></figure>        <p id="c8f8b3e8">还有一种情况是，您可以在快照中看到“ <span class="control">固定”手柄</span> 。有时，无法正确识别<a href="#static-reference">静态引用</a> ：您可能会看到对象数组，而不是<span class="control">静态引用</span>根<code class="code">Object[]</code>由<span class="control">固定手柄</span>根部保留。这是静态引用如何工作的真实表示。</p>        <figure><img alt="固定句柄根而不是静态参考根" title="固定句柄根而不是静态参考根" src="/help/img/dotnet/2019.2/pinning_handle_static_reference.png" id="397b13d3" width="133" height="68"></figure>    </div>    <div class="chapter"><h2 id="interior-local-variable" data-toc="Analyzing_GC_Roots#interior-local-variable">内部局部变量</h2>        <p id="5633634a">由于可以在垃圾回收期间移动托管对象（请参见<a href="#pinning-handle">固定手柄</a> ），因此无法使用本机指针来跟踪其在堆上的位置。在这种情况下，可以使用<a href="https://docs.microsoft.com/en-us/cpp/extensions/interior-ptr-cpp-cli?view=vs-2019" rel="noopener noreferrer" data-external="true" target="_blank">内部指针</a> 。内部指针声明一个指向引用类型内部的指针，但不声明该对象本身。如果看到<span class="control">内部局部变量</span>根包含一个对象，则可能存在一个内部指针指向该对象内部。有关示例，请参考<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types" rel="noopener noreferrer" data-external="true" target="_blank">MSDN</a> 。</p>        <figure><img alt="内部局部变量" title="内部局部变量" src="/help/img/dotnet/2019.2/interior_local_variable_root.png" id="a7fd13e9" width="227" height="83"></figure>    </div>    <div class="chapter"><h2 id="refcounted-handle" data-toc="Analyzing_GC_Roots#refcounted-handle">提手</h2>    <p id="b6a1795d">如果对象的引用计数是某个值，则根防止垃圾回收。如果使用COM Interop将对象传递给COM库，则CLR将为此对象创建RefCounted句柄。由于COM无法执行垃圾收集，因此需要此根目录。相反，它使用引用计数。如果不再需要该对象，COM会将计数设置为0。这意味着RefCounted句柄不再是根，可以收集对象。</p>    <p id="f87fcef9">因此，如果看到<span class="control">RefCounted handle</span> ，则该对象可能作为参数传递给非托管代码。</p>    <figure><img alt="RefCounted句柄根" title="RefCounted句柄根" src="/help/img/dotnet/2019.2/refcounted_handle.png" id="c33ff3a7" width="145" height="65"></figure>    </div>    <div class="chapter"><h2 id="weak-handle" data-toc="Analyzing_GC_Roots#weak-handle">手柄弱</h2>    <p id="3c14dd42">与其他根相反，弱句柄不会阻止引用的对象进行垃圾回收。因此，可以随时收集对象，但仍可以由应用程序访问。通过对象的中间对象执行对此类对象的访问<code class="code">WeakReference</code>类型。当使用缓存等临时数据结构时，这种方法可能非常有效。由于弱引用无法在完整的垃圾回收中幸存，因此弱引用句柄只能与其他句柄结合使用。例如， <span class="control">Weak，RefCounted handle</span> 。</p>    <figure><img alt="根柄弱" title="根柄弱" src="/help/img/dotnet/2019.2/weak_handle.png" id="dd234eb0" width="175" height="108"></figure>    </div>    <div class="chapter"><h2 id="regular-handle" data-toc="Analyzing_GC_Roots#regular-handle">常规手柄</h2>    <p id="629de1e7">当句柄类型未定义时，dotMemory将其标记为<span class="control">Regular handle</span> 。通常，这些是对整个应用程序生命周期中所需的系统对象的引用。例如， <code class="code">OutOfMemoryException</code>宾语。为了防止其收集，环境通过常规句柄引用该对象。</p>    <figure><img alt="常规手柄根" title="常规手柄根" src="/help/img/dotnet/2019.2/regular_handle.png" id="5a8a6a19" width="174" height="65"></figure></div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Navigating_to_Type_Declaration.html">导航到</a> <a class="navigation-links__next" href="Analyzing_Traffic.html">分析内存流量的</a> <a class="navigation-links__prev" href="Navigating_to_Type_Declaration.html">类型声明</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>