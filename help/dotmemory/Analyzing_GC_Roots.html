<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        .NET memory management, .NET garbage collection, CLR application roots&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Analyzing GC Roots - Help | dotMemory</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Analyzing_GC_Roots" data-disqus-id="Analyzing_GC_Roots_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Analyzing_GC_Roots" id="Analyzing_GC_Roots.xml">Analyzing GC Roots</h1>        <p id="50b4335c">        Retention path of an object always starts with a GC root. From the point of Garbage Collector, root is a        reference to        an object that must not and will not be collected. This makes roots the only possible starting point for        building        retention graphs. Understanding root types can be extremely important during the "Who retains the object?" analysis.        Sometimes examining retention paths does not give you an answer why the object is still in memory.        In this case, it makes sense to look at GC roots. For example, a        <i id="afc8b259">RefCounted</i> handle gives you a clue that the object is retained by some unmanaged COM library.    </p>    <p id="e0f655d6">        There are four possible root types in .NET Framework:    </p>    <ul class="list _ul"><li class="list__item" id="ab945b29"><p>            <span class="emphasis">Stack references</span>: references to local objects. Such roots live during a method execution.</p></li><li class="list__item" id="e7e52b0e"><p>            <span class="emphasis">Static references</span>: references to static objects. These roots live the entire app domain life time.</p></li><li class="list__item" id="5bb84b13"><p>            <span class="emphasis">Handles</span>: typically, these are references used for communication between managed and unmanaged code. Such roots must            live            at least until the unmanaged code needs "managed" objects.        </p></li><li class="list__item" id="240218ff"><p>            <span class="emphasis">Finalizer references</span>: references to objects waiting to be finalized. These roots live until the finalizer is run.</p></li></ul>    <p id="a5c5e005">        To analyze a root of a retention path, use any dotMemory view that shows object retention paths: <a href="Similar_Retention.html">Group by Similar Retention</a>,        <a href="Shortest_Path.html">Group by Shortest Paths</a>, <a href="Key_Retention_Paths.html">Key Retention Paths</a>, and <a href="Shortest_Paths_to_Roots.html">Shortest Paths to Roots</a>.        Note that all root types distinguished by dotMemory        fall into one of the categories mentioned int the list above.    </p>    <div class="chapter"><h2 id="regular-local-variable" data-toc="Analyzing_GC_Roots#regular-local-variable">Regular local variable</h2>    <p id="076a4c6a">        This is a local variable declared in a method (variable on the stack). Reference to this variable becomes a root        during the method life time.        For example:    </p>    <div class="code-block" data-lang="csharp">
static void Main()
{
   ...
   var collection = new Collection &lt;int&gt;();
   ...
}
    </div>    <figure><img alt="Regular local variable root" title="Regular local variable root" src="/help/img/dotnet/2019.2/regular_local_variable.png" id="f74ffed1" width="150" height="65"></figure>    <p id="6d2e489b">        Note that in release builds, root's life time may be shorter - JIT can discard the variable right after it is no        longer needed.    </p>    </div>    <div class="chapter"><h2 id="static-reference" data-toc="Analyzing_GC_Roots#static-reference">Static reference</h2>    <p id="f8df69f8">When CLR meets static object (class member, variable, or event), it creates a global instance of this object. The        object can be accessed during the entire app life time, so static objects are almost never collected. Thus,        references to static objects is one of the main root types.    </p>    <div class="code-block" data-lang="csharp">
class StaticClass
{
   public static Collection&lt;string&gt; StCollection;
}
    </div>    <p id="6f430f73">After the collection is initialized, CLR will create a static instance of the collection. The reference to the        instance will exist during the application domain life time.    </p>    <figure><img alt="Static reference root" title="Static reference root" src="/help/img/dotnet/2019.2/static_reference_1.png" id="fb8b8539" width="144" height="64"></figure>    <p id="cd8a34c4">        When the static object is referenced through a field, dotMemory shows you field's name.    </p>    <p id="60a09f67">Of course, "unnamed" static references can also take place. The most obvious example of such a root is a        reference to a string declared in a method.    </p>    <div class="code-block" data-lang="csharp">
static void Main()
{
   ...
   string A = "This is a string";
   ...
}
    </div>    <figure><img alt="Static reference root" title="Static reference root" src="/help/img/dotnet/2019.2/static_reference_2.png" id="9cb001f4" width="118" height="64"></figure>    <p id="20a10953">Note that in the example above, the <span class="control">Regular local variable</span>        reference is also created by CLR. But, to simplify        further analysis, dotMemory doesn't show you this root.    </p>    </div>    <div class="chapter"><h2 id="f-reachable-queue" data-toc="Analyzing_GC_Roots#f-reachable-queue">F-reachable queue / Finalization queue</h2>        <p id="991a32a8">            CLR provides a helpful mechanism for releasing unmanaged resources: the finalization pattern. The            <code class="code">System.Object</code> type declares a virtual method <code class="code">Finalize</code>            (also called the finalizer) that is called by the Garbage Collector before the object's memory is reclaimed. Typically,            you override this method in order to release unmanaged resources. Any object that has a finalizer is put            to the Finalization queue (in dotMemory these objects have <span class="control">Finalization Queue</span> root).            When a garbage collection takes place, the GC finds such object in the            Finalization queue but doesn't run its finalizer directly. Instead, the GC puts the object            to the F-reachable queue (the <span class="control">F-Reachable Queue</span> root in dotMemory)            and runs the finalizer in a separate Finalization thread (all of these is done            for the sake of performance as the finalizer can potentially run any amount of code). On the next GC,            the object in the F-reachable queue is garbage collected.            The described pattern has drawbacks, and that's why dotMemory offers a special            <a href="Inspections.html#finalized_objects">Finalizable objects</a> inspection.        </p>        <p id="0fadb5cc">            Note that due to the nature of memory profiling, dotMemory always runs a full GC before a snapshot is taken.            That's why you won't find objects with the <span class="control">Finalization Queue</span> root in snapshots taken            via dotMemory. This root type is possible only in raw memory dumps.        </p>        <figure><img alt="F-Queue root" title="F-Queue root" src="/help/img/dotnet/2019.2/roots_fqueue.png" id="297fad50" width="144" height="72"></figure>    </div>    <div class="chapter"><h2 id="pinning-handle" data-toc="Analyzing_GC_Roots#pinning-handle">Pinning handle</h2>        <aside class="note " data-title="" rel="pinning-handle" id="e9ad6830">            <p id="73814f63">                You can also pin objects intentionally using the                <code class="code">fixed</code> block.            </p>        </aside>    <p id="fa653d99">        Interaction of managed and unmanaged code is an additional problem for the Garbage Collector. For example, you need        to pass an object from the managed heap to, say, an external API library. As a small object heap is compacted        during collection, the object can be moved. This is a problem for the unmanaged code if it relies on the exact        object location. One of the solutions is to fix the object in the heap. In this case, GC gets a pinning handle        to the object which implies that the object cannot be moved.        Thus, if you see a <span class="control">Pinning handle</span> root, then probably the object is retained by some unmanaged code.        For example, the <code class="code">App</code> object always has a pinned reference.    </p>    <figure><img alt="Pinning handle root" title="Pinning handle root" src="/help/img/dotnet/2019.2/pinning_handle.png" id="06d7a200" width="116" height="126"></figure>        <p id="c8f8b3e8">            There is one more case when you can see a <span class="control">Pinning handle</span> in a snapshot.            Sometimes, it is not possible to correctly identify a <a href="#static-reference">static reference</a>:            Instead of a <span class="control">Static reference</span> root, you may see an array of objects <code class="code">Object[]</code>            retained by the <span class="control">Pinning handle</span> root. This is a true representation of how static references            work.        </p>        <figure><img alt="Pinning handle root instead of a static reference root" title="Pinning handle root instead of a static reference root" src="/help/img/dotnet/2019.2/pinning_handle_static_reference.png" id="397b13d3" width="133" height="68"></figure>    </div>    <div class="chapter"><h2 id="interior-local-variable" data-toc="Analyzing_GC_Roots#interior-local-variable">Interior local variable</h2>        <p id="5633634a">            As managed objects can be moved during Garbage Collection (see <a href="#pinning-handle">Pinning handle</a>),            it is not possible to use native pointers to track their location on the heap. In such a case,            <a href="https://docs.microsoft.com/en-us/cpp/extensions/interior-ptr-cpp-cli?view=vs-2019" data-external="true" target="_blank" rel="noopener noreferrer">interior pointers</a>            can be used. The interior pointer declares a pointer to inside a reference type, but not to the object itself.            If you see a <span class="control">Interior local variable</span> root that holds an object, then there is            probably an interior pointer that points to inside this object. For an example, refer to <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types" data-external="true" target="_blank" rel="noopener noreferrer">MSDN</a>.        </p>        <figure><img alt="Interior local variable" title="Interior local variable" src="/help/img/dotnet/2019.2/interior_local_variable_root.png" id="a7fd13e9" width="227" height="83"></figure>    </div>    <div class="chapter"><h2 id="refcounted-handle" data-toc="Analyzing_GC_Roots#refcounted-handle">Refcounted handle</h2>    <p id="b6a1795d">The root prevents garbage collection if the reference count of the object is a certain value.        If an object is passed to a COM library using COM Interop, CLR creates a RefCounted handle to this object. This        root is needed as COM is unable to perform garbage collection. Instead, it uses reference counting. If the        object is no longer needed, COM sets the count to 0. This means that RefCounted handle is no longer a root and        the object can be collected.    </p>    <p id="f87fcef9">Thus, if you see        <span class="control">RefCounted handle</span>, then, probably, the object is passed as an argument to unmanaged code.</p>    <figure><img alt="RefCounted handle root" title="RefCounted handle root" src="/help/img/dotnet/2019.2/refcounted_handle.png" id="c33ff3a7" width="145" height="65"></figure>    </div>    <div class="chapter"><h2 id="weak-handle" data-toc="Analyzing_GC_Roots#weak-handle">Weak handle</h2>    <p id="3c14dd42">As opposed to other roots, the Weak handle does not prevent referenced objects from garbage collection. Thus,        objects can be collected at any time but still can be accessed by the application. Access to such objects is        performed via an intermediate object of the <code class="code">WeakReference</code> type. Such an approach can be very efficient when        working with temporary data structures like cache.        As weak references do not survive full garbage collection, the weak reference handle can come only in        combination with other handles. For example,        <span class="control">Weak, RefCounted handle</span>.    </p>    <figure><img alt="Weak handle root" title="Weak handle root" src="/help/img/dotnet/2019.2/weak_handle.png" id="dd234eb0" width="175" height="108"></figure>    </div>    <div class="chapter"><h2 id="regular-handle" data-toc="Analyzing_GC_Roots#regular-handle">Regular handle</h2>    <p id="629de1e7">When handle type is undefined, dotMemory marks it as        <span class="control">Regular handle</span>. Typically, these are references to system        objects required during the entire app life time. For example, the        <code class="code">OutOfMemoryException</code>        object. To prevent its        collection, the environment references the object through a regular handle.    </p>    <figure><img alt="Regular handle root" title="Regular handle root" src="/help/img/dotnet/2019.2/regular_handle.png" id="5a8a6a19" width="174" height="65"></figure></div><div class="last-modified" data-skip-index="skip">Last modified: 8 August 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Navigating_to_Type_Declaration.html">Navigating to Type Declaration</a><a class="navigation-links__next" href="Analyzing_Traffic.html">Analyzing Memory Traffic</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>