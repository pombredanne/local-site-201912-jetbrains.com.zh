<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        .NET memory management, CLR memory management concepts, C# .NET garbage collection,
        garbage collector, .NET managed heap, .NET unmanaged heap, unmanaged memory,
        heap generations
    " data-skip-index="skip"><meta charset="UTF-8"><title>.NET内存管理概念-帮助|帮助点内存</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="NET_Memory_Management_Concepts" data-disqus-id="NET_Memory_Management_Concepts_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected>视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="NET_Memory_Management_Concepts.xml" data-toc="NET_Memory_Management_Concepts">.NET内存管理概念</h1>        <p id="8597541e">为了有效地使用dotMemory，您应该对.NET如何管理内存有一般的了解。以下列表总结了.NET内存概念。有关其他信息，您可以参考MSDN或Web中的其他材料。</p>    <div class="chapter"><h2 id="b5c5dc7b" data-toc="NET_Memory_Management_Concepts#b5c5dc7b">内存分配</h2>        <ul class="list _ul"><li class="list__item" id="36cf9b11"><p>垃圾收集器（GC）是.NET框架的一部分，它为.NET应用程序分配和释放内存。</p></li><li class="list__item" id="6f7c8e2f"><p>当启动新进程时，运行时将为该进程保留一个地址空间区域，称为托管堆。</p></li><li class="list__item" id="9cb4aa82"><p>对象在堆中连续分配。</p></li><li class="list__item" id="0c6f50d7"><p>内存分配是一个非常快速的过程，因为它只是将值添加到指针。</p></li><li class="list__item" id="44d62026">                <p id="43fbf28d">除了托管堆之外，应用程序始终会消耗一些不受GC托管的所谓的“非托管”内存。</p>                <aside class="note " rel="43fbf28d" id="d36672c0" data-title=""><p>*通常，.NET公共语言运行时本身，应用程序使用的动态库，图形缓冲区等需要它。</p></aside>            </li></ul>    </div>    <div class="chapter"><h2 id="7e130904" data-toc="NET_Memory_Management_Concepts#7e130904">内存释放</h2>        <ul class="list _ul"><li class="list__item" id="ed3b6710"><p>释放内存的过程称为垃圾回收。</p></li><li class="list__item" id="20a32284"><p>GC执行收集时，它仅释放应用程序不再使用的对象（例如，只能在方法执行期间访问方法中的局部变量，此后不再需要该变量）。</p></li><li class="list__item" id="1c45db75"><p>为了确定是否使用该对象，GC会检查应用程序的根目录-应用程序全局的强引用。通常，这些是全局和静态对象指针，局部变量和CPU寄存器。在<a href="Analyzing_GC_Roots.html">分析GC根中</a>了解有关可能的GC根的更多信息。</p></li><li class="list__item" id="5c660294"><p>对于每个活动的根，GC都会构建一个图形，其中包含从这些根可访问的所有对象。</p></li><li class="list__item" id="4052a664"><p>如果无法访问对象，GC会认为该对象不再使用，并从堆中删除该对象（释放该对象占用的内存）。</p></li><li class="list__item" id="b096910a"><p>删除对象后，GC会压缩内存中的可访问对象。</p><figure><img alt="基本概念1" title="基本概念1" src="/help/img/dotnet/2019.2/basic_concepts_1.png" id="8aaa9a1c" width="530" height="467"></figure>            <p></p></li></ul>    </div>    <div class="chapter"><h2 id="5b1c52c3" data-toc="NET_Memory_Management_Concepts#5b1c52c3">世代</h2>        <ul class="list _ul"><li class="list__item" id="94e809a4"><p>为了获得更好的内存释放性能，将托管堆分为几代：0、1和2。</p></li><li class="list__item" id="dd8bf84a"><p>刚创建对象时，会将它们放置到第0代（第0代）。</p></li><li class="list__item" id="6aabff04"><p>当Gen 0已满时（堆的大小和世代的大小由GC定义），GC将执行垃圾回收。在收集期间，GC从堆中删除所有无法访问的对象。所有可到达的对象都提升为第一代（第一代）。</p></li><li class="list__item" id="2f6a67e1"><p>Gen 0集合是一个相当快的操作。</p></li><li class="list__item" id="4ee541ef"><p>当第1代已满时，将执行第1代垃圾回收。将所有幸存的对象提升为第二代。Gen 0集合也发生在这里。</p></li><li class="list__item" id="fc63e570"><p>当Gen 2已满时，GC将执行完整的垃圾收集。首先执行第2代收集，然后进行第1代和第0代收集。如果仍然没有足够的内存用于新分配，则GC会引发OutOfMemory异常。</p></li><li class="list__item" id="1e8b9a1e"><p>在完全垃圾收集期间，GC必须通过堆中的所有对象，因此，此过程可能会对系统资源产生很大影响。</p><figure><img alt="基本概念2" title="基本概念2" src="/help/img/dotnet/2019.2/basic_concepts_2.png" id="8c217acd" width="338" height="528"></figure>            <p></p></li></ul>    </div>    <div class="chapter"><h2 id="0a45f50e" data-toc="NET_Memory_Management_Concepts#0a45f50e">大对象堆</h2>        <ul class="list _ul"><li class="list__item" id="781e491d"><p>由于性能原因，大对象（> 85KB）存储在托管堆的称为大对象堆（LOH）的单独段中。</p></li><li class="list__item" id="f358ddf5"><p>LOH中幸存的对象未压缩*。这意味着LOH随着时间的推移而变得支离破碎。</p><figure><img alt="基本概念3" title="基本概念3" src="/help/img/dotnet/2019.2/basic_concepts_3.png" id="563e6a77" width="521" height="191"></figure>            <p></p></li></ul>        <p id="d89c23c7">*从.NET Framework 4.5.1开始，您可以在完全垃圾回收期间强制GC压缩LOH。</p>        <br>    </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Basic_Concepts.html">基本概念</a> <a class="navigation-links__next" href="Typical_Profiling_Workflow.html">典型分析工作流程</a></div><section class="seealso" data-skip-index="skip"><div class="seealso__header"><h2>也可以看看</h2></div><div class="seealso__content"><div class="seealso__col" data-skip-index="skip"><h3>概念：</h3><ul class="list"><li class="list__item"><a href="Typical_Profiling_Workflow.html">典型的分析工作流程</a></li><li class="list__item"><a href="First_Look_at_the_dotMemory_s_User_Interface.html">首先看一下用户界面</a></li></ul></div></div></section></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>