<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        .NET memory management, CLR memory management concepts, C# .NET garbage collection,&#xA;        garbage collector, .NET managed heap, .NET unmanaged heap, unmanaged memory,&#xA;        heap generations&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>.NET Memory Management Concepts - Help | dotMemory</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="NET_Memory_Management_Concepts" data-disqus-id="NET_Memory_Management_Concepts_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="NET_Memory_Management_Concepts" id="NET_Memory_Management_Concepts.xml">.NET Memory Management Concepts</h1>        <p id="8597541e">To work with dotMemory effectively, you should have general understanding about how .NET manages memory.        The following lists summarize .NET memory concepts. For additional information, you may refer to MSDN or other        materials in the Web.    </p>    <div class="chapter"><h2 id="b5c5dc7b" data-toc="NET_Memory_Management_Concepts#b5c5dc7b">Memory allocation</h2>        <ul class="list _ul"><li class="list__item" id="36cf9b11"><p>Garbage Collector (GC) is the part of the .NET framework that allocates and releases memory for your                .NET                applications.            </p></li><li class="list__item" id="6f7c8e2f"><p>When a new process is started, the runtime reserves a region of address space for the process called the                managed heap.            </p></li><li class="list__item" id="9cb4aa82"><p>Objects are allocated in the heap contiguously one after another.</p></li><li class="list__item" id="0c6f50d7"><p>Memory allocation is a very fast process as it is just the adding of a value to a pointer.</p></li><li class="list__item" id="44d62026">                <p id="43fbf28d">                    In addition to the managed heap, an app always consumes some amount of so-called unmanaged* memory which                    is not managed by GC.                </p>                <aside class="note " data-title="" rel="43fbf28d" id="d36672c0"><p>                    *Generally, it is required by .NET Common Language Runtime itself, dynamic libraries employed by the                    app, graphics buffer, and so on.                </p></aside>            </li></ul>    </div>    <div class="chapter"><h2 id="7e130904" data-toc="NET_Memory_Management_Concepts#7e130904">Memory release</h2>        <ul class="list _ul"><li class="list__item" id="ed3b6710"><p>The process of releasing memory is called garbage collection.</p></li><li class="list__item" id="20a32284"><p>When GC performs a collection, it releases only objects that are no longer in use by the application                (for example, a local variable in a method can be accessed only during the method execution and after                this,                the variable is no longer needed).            </p></li><li class="list__item" id="1c45db75"><p>To determine whether the object is used or not, GC examines applicationâ€™s roots - strong references that                are                global to the application.                Typically, these are global and static object pointers, local variables, and CPU registers. Learn more                about                possible GC roots in <a href="Analyzing_GC_Roots.html">Analyzing GC Roots</a>.            </p></li><li class="list__item" id="5c660294"><p>For each active root, GC builds a graph that contains all the objects that are reachable from these                roots.            </p></li><li class="list__item" id="4052a664"><p>If an object is unreachable, GC considers it no longer in use and removes the object from the heap                (releases                the memory occupied by the object).            </p></li><li class="list__item" id="b096910a"><p>After the object is removed, GC compacts reachable objects in memory.                <figure><img alt="basic concepts 1" title="basic concepts 1" src="/help/img/dotnet/2019.2/basic_concepts_1.png" id="8aaa9a1c" width="530" height="467"></figure>            </p></li></ul>    </div>    <div class="chapter"><h2 id="5b1c52c3" data-toc="NET_Memory_Management_Concepts#5b1c52c3">Generations</h2>        <ul class="list _ul"><li class="list__item" id="94e809a4"><p>For better performance of memory release, the managed heap is divided into segments called generations:                0,                1, and 2.            </p></li><li class="list__item" id="dd8bf84a"><p>When objects are just created, they are placed to the Generation 0 (Gen 0).</p></li><li class="list__item" id="6aabff04"><p>When Gen 0 is full (the size of the heap and generations is defined by GC), GC performs a garbage                collection.                During the collection, GC removes all unreachable objects from the heap. All reachable objects are                promoted                to the Generation 1 (Gen 1).            </p></li><li class="list__item" id="2f6a67e1"><p>The Gen 0 collection is a rather quick operation.</p></li><li class="list__item" id="4ee541ef"><p>When Gen 1 is full, the Gen 1 garbage collection is performed. All objects that survive the collection                are                promoted to Gen 2.                The Gen 0 collection also takes place here.            </p></li><li class="list__item" id="fc63e570"><p>When Gen 2 is full, GC performs full garbage collection. First, Gen 2 collection is performed, after                this,                the Gen 1 and Gen 0 collections take place. If there is still not enough memory for new allocations, GC                raises the OutOfMemory exception.            </p></li><li class="list__item" id="1e8b9a1e"><p>During full garbage collection, GC has to pass through all objects in the heap, so, this process might                have                a great impact on system resources.                <figure><img alt="basic concepts 2" title="basic concepts 2" src="/help/img/dotnet/2019.2/basic_concepts_2.png" id="8c217acd" width="338" height="528"></figure>            </p></li></ul>    </div>    <div class="chapter"><h2 id="0a45f50e" data-toc="NET_Memory_Management_Concepts#0a45f50e">Large Object Heap</h2>        <ul class="list _ul"><li class="list__item" id="781e491d"><p>Due to performance reasons, large objects (&gt;85KB) are stored in a separate segment of the managed                heap                called Large Object Heap (LOH).            </p></li><li class="list__item" id="f358ddf5"><p>Survived objects in LOH are not compacted*. This means that LOH becomes fragmented over time.                <figure><img alt="basic concepts 3" title="basic concepts 3" src="/help/img/dotnet/2019.2/basic_concepts_3.png" id="563e6a77" width="521" height="191"></figure>            </p></li></ul>        <p id="d89c23c7">*Starting from .NET Framework 4.5.1, you can force GC to compact LOH during the full garbage collection.</p>        <br>    </div>    <div class="last-modified" data-skip-index="skip">Last modified: 8 August 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Basic_Concepts.html">Basic Concepts</a><a class="navigation-links__next" href="Typical_Profiling_Workflow.html">Typical Profiling Workflow</a></div><section class="seealso" data-skip-index="skip"><div class="seealso__header"><h2>See Also</h2></div><div class="seealso__content"><div class="seealso__col" data-skip-index="skip"><h3>Concepts:</h3><ul class="list"><li class="list__item"><a href="Typical_Profiling_Workflow.html">Typical Profiling Workflow</a></li><li class="list__item"><a href="First_Look_at_the_dotMemory_s_User_Interface.html">First Look at the User Interface</a></li></ul></div></div></section></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>