<html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotMemory tutorial, dotMemory memory leak, .NET memory leak, find detect memory leak,
        .NET memory leak profiler, C# check memory leak, C# memory leak example
    " data-skip-index="skip"><meta charset="UTF-8"><title>查找内存泄漏-帮助|帮助点内存</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="How_to_Find_a_Memory_Leak" data-disqus-id="How_to_Find_a_Memory_Leak_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotMemory帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary" selected>视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="How_to_Find_a_Memory_Leak.xml" data-toc="How_to_Find_a_Memory_Leak">查找内存泄漏</h1>            <div class="table-wrapper"><table width="50%" id="snapshots"><thead><tr valign="top" id="8abd6dd7" class="ijRowHead"><th id="cdec24a5" width="50%"></th><th id="65da2a1d"></th></tr></thead><tbody><tr id="c68c3142" class="ijRowOdd"><td id="ca6403cf">                <b id="54ded85f">样品申请</b>            </td><td id="48b8b236">                <ul class="list _ul"><li class="list__item" id="2be45c64">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2.git" rel="noopener noreferrer" data-external="true" target="_blank">生活游戏</a>                    </li></ul>            </td></tr><tr id="7931201c" class="ijRowEven"><td id="62d1376e">                <b id="af3fa90a">快照</b>            </td><td id="ba0b6d67">                <ul class="list _ul"><li class="list__item" id="db03cb25">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_Before_Fix.dmw</a>                    </li><li class="list__item" id="b128787d">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_After_First_Leak_Fix.dmw</a>                    </li><li class="list__item" id="f034c69e">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_Second_Leak_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_After_Second_Leak_Fix.dmw</a>                    </li></ul>            </td></tr><tr id="562c4fc8" class="ijRowOdd"><td id="40553125"></td><td id="99f1c74a"></td></tr></tbody></table></div>    <aside class="note " rel="snapshots" id="76351203" data-title=""><p>免责声明：本教程不应被视为定位和修复内存泄漏的通用指南。这只是让您感觉到其中一种可能的工作流程。</p></aside>    <p id="6ba1f72e">在本教程中，我们将看到如何使用dotMemory查找和修复应用程序中的内存泄漏。但是在继续之前，让我们就什么是内存泄漏达成一致。</p>    <div class="chapter"><h3 id="8165a399" data-toc="How_to_Find_a_Memory_Leak#8165a399">什么是内存泄漏？</h3>        <p id="000c65c3">根据最流行的定义，内存泄漏是由于“对象存储在内存中，但是运行代码无法访问”时错误的内存管理导致的。此外，“内存泄漏会随着时间的流逝而累积起来，如果不加以清除，则系统最终将耗尽内存。”</p>        <p id="6938ba91">实际上，如果我们严格遵循上面的定义，则.NET应用程序中不可能发生“经典”内存泄漏。垃圾收集器（GC）完全控制内存释放，并删除代码无法访问的所有对象。此外，在关闭应用程序后，GC会完全释放该应用程序占用的内存。尽管如此，第2点（由于泄漏导致内存耗尽）还是很真实的。当然，这不会导致系统崩溃，但是应用迟早会引发<code class="code">OutOfMemory</code>例外。</p>        <p id="90f119b0">为什么会发生这种情况？事实是，GC仅收集<a href="Getting_Started_with_dotMemory.html#app-roots">未引用的对象</a> 。如果有对您不知道的对象的引用，GC将不会收集该对象。因此，修复内存泄漏的主要策略是确定随着时间的推移会累加的对象（导致泄漏）以及将先前的对象保留在内存中的对象。</p>        <p id="5f3e1b8a">让我们尝试这种解决样本应用程序中泄漏的策略。</p>    </div>    <div class="chapter"><h2 id="aa00f5c4" data-toc="How_to_Find_a_Memory_Leak#aa00f5c4">样品申请</h2>        <p id="5c70b187">同样，我们将在本教程中使用的应用是Conway的《人生游戏》。请从<a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2" rel="noopener noreferrer" data-external="true" target="_blank">github</a>下载该应用程序，然后再继续进行操作。假设我们要退还一些用于“生命游戏”开发的资金，并决定添加一个向用户展示各种广告的窗口。按照最差的做法，每次用户启动“人生游戏”（点击“ <span class="control">开始”</span>按钮）时，我们都会显示广告窗口。当用户单击横幅时，他/她将被重定向到某个网站，并且广告窗口被关闭（用户也可以使用标准的“关闭”按钮来关闭窗口，尽管这不是我们真正想要的）。要更改广告，广告窗口使用计时器（基于<span class="control">DispatcherTimer</span>类）。您可以在<span class="filepath">AdWindow.cs</span>文件中看到<span class="control">AdWindow</span>类的实现。</p><figure><img alt="t2 gol应用" title="t2 gol应用" src="/help/img/dotnet/2019.2/t2_gol_app.png" id="bb3376d1" width="600" height="392"></figure>因此，该功能已添加，现在是测试它的最佳时间。让我们运行dotMemory并确保广告窗口不会影响应用程序的内存使用（换句话说，它已正确分配和收集）。<p></p>    </div>    <div class="chapter"><h2 id="step-1-run-the-profiler" data-toc="How_to_Find_a_Memory_Leak#step-1-run-the-profiler">步骤1。运行dotMemory</h2>        <aside class="tip sideblock" rel="step-1-run-the-profiler" id="bb5b0181" data-title="">            <p id="80f09e15">在此步骤中，我们直接在Visual Studio中运行分析会话，因为如果您要分析在IDE中已经打开的项目，此方法会更容易。不过，您始终可以选择<a href="Getting_Started_with_dotMemory.html#step-1-run-dotmemory">将dotMemory作为独立应用程序运行，并从中运行会话</a> 。</p>        </aside>        <ol class="list _decimal"><li class="list__item" id="97394ff3"><p>在Visual Studio中打开“人生游戏”解决方案。</p></li><li class="list__item" id="e86e9328"><p>使用菜单<span class="menupath" data-skip-index="skip">ReSharper |</span>运行dotMemory <span class="menupath" data-skip-index="skip">。简介|运行启动项目内存分析...。</span></p><figure><img alt="t2 reshaper菜单更新dM" title="t2 reshaper菜单更新dM" src="/help/img/dotnet/2019.2/t2_resharper_menu_upd_dM.png" id="efd16426" width="576" height="372"></figure>这将打开“ <span class="control">探查器配置”</span>窗口。<p></p></li><li class="list__item" id="dbed4a87"><p>在“ <span class="control">探查器配置”</span>窗口中，选择<span class="control">从开始收集内存分配和流量数据</span> 。这将告诉dotMemory在应用启动后立即开始收集分析数据。指定选项后，窗口应如下所示：</p><figure><img alt="T2 Profiler配置" title="T2 Profiler配置" src="/help/img/dotnet/2019.2/t2_profiler_conf.png" id="5f450840" width="503" height="343"></figure>            <p></p></li><li class="list__item" id="2b06493b"><p>单击<span class="control">运行</span>以启动分析会话。这将运行我们的应用程序，并在dotMemory中打开“分析”主页面。</p></li></ol>    </div>    <div class="chapter"><h2 id="t2_step2" data-toc="How_to_Find_a_Memory_Leak#t2_step2">第2步。获取快照</h2>        <aside class="tip sideblock" rel="t2_step2" id="06f2599e" data-title="">            <p id="09258ccb">如果要跳过“获取快照”步骤，则可以<a href="#snapshots">下载</a>本教程使用<a href="#snapshots">的快照</a> 。</p>        </aside>        <p id="96edeb66">应用程序运行后，我们可以获得内存快照。当我们要测试新的广告窗口以及它们如何影响内存使用时，我们需要拍摄两个快照：一个快照显示在窗口之后（我们将使用该快照作为比较的基础），另一个快照在广告窗口已关闭。需要第二个快照以确保GC从内存中删除我们的窗口。</p>        <ol class="list _decimal"><li class="list__item" id="852a9420"><p>通过单击应用程序中的<span class="control">开始</span>按钮来启动游戏。广告窗口将会出现。</p><figure><img alt="t2 gol应用" title="t2 gol应用" src="/help/img/dotnet/2019.2/t2_gol_app.png" id="ce3b0f53" width="600" height="392"></figure>            <p></p></li><li class="list__item" id="81c14c7c"><p>单击dotMemory中的“ <span class="control">获取快照”</span>按钮。</p><figure><img alt="t2获取快照1" title="t2获取快照1" src="/help/img/dotnet/2019.2/t2_get_snapshot1.png" id="85ee6a30" width="800" height="548"></figure>这将捕获数据并将快照添加到快照区域。获取快照不会中断分析过程，因此允许我们获取另一个快照。<p></p></li><li class="list__item" id="869835e4"><p>关闭应用程序中的广告窗口。</p></li><li class="list__item" id="c4d1e963"><p>单击dotMemory中的“ <span class="control">获取快照”</span>按钮，再<span class="control">获取一次快照</span> 。</p></li><li class="list__item" id="e3e99315"><p>通过关闭“生命游戏”应用程序结束分析会话。现在，主页包含两个快照。</p><figure><img alt="t2获取快照2" title="t2获取快照2" src="/help/img/dotnet/2019.2/t2_get_snapshot2.png" id="5035b87b" width="800" height="548"></figure>            <p></p></li></ol>    </div>    <div class="chapter"><h2 id="t2_step3" data-toc="How_to_Find_a_Memory_Leak#t2_step3">第三步比较快照</h2>        <aside class="tip sideblock" rel="t2_step3" id="1a0d818f" data-title="">            <p id="f395e127">如果您跳过了<a href="#t2_step2">步骤2。获取快照</a> ，您可以将以下快照用于此步骤： <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_Before_Fix.dmw</a> 。</p>        </aside>        <p id="6e2fbda7">现在，我们将比较和对比两个收集的快照。我们想看什么？如果一切正常，则广告窗口应出现在第一个快照中，而在第二个快照中不存在。让我们来看看。</p>        <ol class="list _decimal"><li class="list__item" id="0c727bec"><p>单击<span class="control">添加到</span>每个快照的比较以将它们添加到比较区域。添加快照的顺序并不重要，因为dotMemory始终使用旧快照作为比较的基础。</p><figure><img alt="t2快照比较区域" title="t2快照比较区域" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_area.png" id="901e1a74" width="800" height="381"></figure>            <p></p></li><li class="list__item" id="5f95c658"><p>在比较区域中单击“ <span class="control">比较</span> ”。这将打开“ <span class="control">快照”比较</span>视图。</p><figure><img alt="t2快照比较视图" title="t2快照比较视图" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_view.png" id="da5ee158" width="800" height="532"></figure>该视图显示在快照之间已创建（“ <span class="control">新对象”</span>列）和已删除（“ <span class="control">死对象”</span>列）多少个特定类的<span class="control">对象</span> 。生存对象显示了有多少对象在垃圾回收中生存了，换句话说，在两个快照中都存在。目前，我们对<code class="code">AdWindow</code>类。<p></p></li><li class="list__item" id="c1d989b3"><p>为了减轻对<code class="code">AdWindow</code>类，让我们按对象所属的名称空间对所有对象进行排序。为此，请在表顶部的“ <span class="control">分组依据”</span>列表中单击“ <span class="control">命名空间”</span> 。</p></li><li class="list__item" id="80135c2f"><p>打开<code class="code">GameOfLife</code>命名空间。</p><figure><img alt="t2快照比较名称空间" title="t2快照比较名称空间" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_namespace.png" id="5bc02473" width="800" height="312"></figure>那是什么？的<code class="code">GameOfLife.AdWindow</code>对象位于“ <span class="control">幸存的对象”</span>列中，这意味着广告窗口仍处于活动状态。关闭窗口后，应该已经从堆中删除了相应的对象。但是，某些原因阻止了它的收集。<p></p></li></ol>        <p id="979f2c68">现在是时候开始调查，找出为什么我们的广告窗口没有被删除的时候了！</p>    </div>    <div class="chapter"><h2 id="a3289aad" data-toc="How_to_Find_a_Memory_Leak#a3289aad">第四步。分析快照</h2>        <aside class="tip sideblock" rel="a3289aad" id="fbd44d44" data-title="">            <p id="c9eb6864">如果您跳过了<a href="#t2_step2">步骤2。获取快照</a> ，此步骤可以使用以下快照： <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_Before_Fix.dmw</a> ， <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_After_First_Leak_Fix.dmw</a> 。</p>        </aside>                                                                                                                <p id="246fb167">如“ <a href="Getting_Started_with_dotMemory.html">如何开始使用dotMemory”</a>教程中所述，您应该将dotMemory的工作视为犯罪调查。您可以通过分析大量可疑对象（对象）来开始调查，并不断缩小范围，直到找到引起问题的对象为止。您的推理链显示在dotMemory窗口左侧的所谓“分析路径”中。</p>        <p id="67d41d74">让我们尝试一下这种方法：</p>        <ol class="list _decimal"><li class="list__item" id="d6d949b7"><p>打开幸存者<code class="code">GameOfLife.AdWindow</code>实例。为此，请在“ <span class="control">幸存对象”</span>列中单击数字<span class="control">1</span> 。 <code class="code">GameOfLife.AdWindow</code>类。</p><figure><img alt="t2选择快照" title="t2选择快照" src="/help/img/dotnet/2019.2/t2_select_snapshot.png" id="cf9afca3" width="295" height="115"></figure>由于对象在两个快照中都存在，因此dotMemory将提示您指定应在哪个快照中显示对象。当然，我们对应该收集窗口的最后一个快照很感兴趣。<p></p></li><li class="list__item" id="f101841d"><p><span class="control">在较新的快照中</span>选择“ <span class="control">打开“幸存的对象””，</span>然后单击“ <span class="control">确定”</span> 。</p><figure><img alt="t2 adwindow实例" title="t2 adwindow实例" src="/help/img/dotnet/2019.2/t2_adwindow_instance.png" id="a3fea421" width="800" height="456"></figure>这将向我们显示实例“ <code class="code">AdWindow</code>快照＃1和＃2中都存在的类”。请注意，实例的可能视图列表与对象集之一不同。例如，对象实例的默认视图是“ <span class="control">传出引用”</span> ，它显示了实例对其他对象的引用树。但是，我们对由引用的对象不感兴趣<code class="code">AdWindow</code> ，但仅限于引用它的用户，换句话说，将广告窗口保留在内存中。为了解决这个问题，我们可以简单地切换到“ <span class="control">密钥保留路径”</span>视图。该视图显示了保留路径图。请注意，该视图<b id="44ef1334">不会</b>显示<b id="44ef1334">所有可能的路径</b> ，而只会显示彼此最不相同的<b id="44ef1334">路径</b> 。这排除了大量非常相似的保留路径，并简化了分析。<p></p></li><li class="list__item" id="a1b31b70"><p>在视图列表中，单击“ <span class="control">密钥保留路径</span> ”。</p><figure><img alt="t2实例保留路径" title="t2实例保留路径" src="/help/img/dotnet/2019.2/t2_instance_retention_paths.png" id="6d4d0cc1" width="800" height="676"></figure>如您所见，事件处理程序将广告窗口保留在内存中<code class="code">EventHandler</code> ，依次由的实例引用<code class="code">DispatcherTimer</code>类。<figure><img alt="t2滴答事件" title="t2滴答事件" src="/help/img/dotnet/2019.2/t2_tick_event.png" id="af336126" width="137" height="58"></figure>上方的文字<code class="code">DispatcherTimer</code>实例为我们提供了另外一条线索-该实例通过<code class="code">Tick</code>事件处理程序。现在，让我们找出哪种方法将我们的实例订阅到<code class="code">Tick</code>事件处理程序，并仔细查看代码。<p></p></li><li class="list__item" id="49ee479e">点击<code class="code">EventHandler</code>图中的实例。<figure><img alt="t2事件处理程序实例" title="t2事件处理程序实例" src="/help/img/dotnet/2019.2/t2_eventhandler_instance.png" id="c5208a88" width="800" height="436"></figure>这将打开<code class="code">EventHandler</code>默认的“ <span class="control">发送参考”</span>视图中的instance *。现在，我们所需要做的就是确定创建实例的方法。<aside class="note " rel="c4c5a67f" id="19a7d34b" data-title="">                    <p id="96144811">*从形式上讲，dotMemory现在向您显示“ <code class="code">EventHandler</code>主导“ <code class="code">AdWindow</code>快照＃1和＃2中都存在的类”。顺便说一句，如果您现在查看Analysis Path，您将看到我们调查的路径，该路径从比较两个快照开始，以我们的可疑对象<span class="control">EventHandler System结束</span> 。</p>                </aside>            </li><li class="list__item" id="844b2aba"><p>要快速找到所需的方法，只需切换到“ <span class="control">创建堆栈跟踪”</span>视图。</p><figure><img alt="t2实例堆栈跟踪" title="t2实例堆栈跟踪" src="/help/img/dotnet/2019.2/t2_instance_stack_trace.png" id="0df70dcd" width="741" height="450"></figure>这里是！实际创建计时器的堆栈中的最新调用是<code class="code">AdWindow</code>构造函数。让我们在代码中找到它。<p></p></li><li class="list__item" id="62720360"><p>使用GameOfLife解决方案切换到Visual Studio，然后找到<code class="code">AdWindow</code>构造函数。</p><div class="code-block" data-lang="csharp">公共AdWindow（窗口所有者）{..._adTimer =新的DispatcherTimer {间隔= TimeSpan。FromSeconds（3）}; _adTimer。勾选+ = ChangeAds； _adTimer。开始（）; }</div>如您所见，我们的广告窗口使用<code class="code">ChangeAds</code>处理事件的方法。但是，为什么在关闭广告窗口后将其保留在内存中？事实是，我们为窗口的事件订阅了窗口，但忘记了取消订阅。因此，解决此泄漏的方法非常简单：我们需要添加一些<code class="code">Unsubscribe()</code>关闭广告窗口时应调用的方法。实际上，代码中已经包含这样的方法，而您要做的就是取消注释<code class="code">Unsubscribe();</code>窗口的一行<code class="code">OnClosed</code>事件。最后，代码应如下所示：<div class="code-block" data-lang="csharp">受保护的重写void OnClosed（EventArgs e）{Unsubscribe（）;基础。OnClosed（e）; } public void Unsubscribe（）{_adTimer。勾选-= ChangeAds; }</div>            <p></p></li><li class="list__item" id="e9e02b9d">                <aside class="tip sideblock" rel="e9e02b9d" id="24a7a8aa" data-title="">                    <p id="99cef46f">您可以跳过此步骤并下载修复后拍摄的快照： <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_After_First_Leak_Fix.dmw</a> 。</p>                </aside>现在，为确保泄漏已修复，让我们构建解决方案并再次运行分析。为此，您只需重复<a href="#t2_step2">步骤2。获取快照</a>并执行<a href="#t2_step3">步骤3。比较快照</a> 。<figure><img alt="修复了t2快照比较" title="修复了t2快照比较" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_fixed.png" id="0079d5a2" width="800" height="381"></figure>而已！的<code class="code">AdWindow</code>现在，实例位于“ <span class="control">死对象”</span>列中，这意味着在获取第二张快照时已成功收集了该实例。泄漏已修复！</li></ol>        <p id="1f03df94">实话实说，这种泄漏确实经常发生。实际上，通常如此，dotMemory会<i id="476216a9">自动</i>检查您的应用程序是否存在此类泄漏。</p>        <p id="dac4c0e6">因此，如果打开包含泄漏的第二个快照并查看“ <span class="control">检查”</span>视图，您会注意到<span class="control">事件处理程序泄漏</span>检查已经包含了<code class="code">AdWindow</code>宾语。</p>        <figure><img alt="t2检查" title="t2检查" src="/help/img/dotnet/2019.2/t2_inspections.png" id="ba6fcab5" width="800" height="445"></figure>    </div>    <div class="chapter"><h2 id="675b9fca" data-toc="How_to_Find_a_Memory_Leak#675b9fca">第五步检查其他泄漏</h2>        <aside class="tip sideblock" rel="675b9fca" id="5de7740c" data-title="">            <p id="70329f01">如果您跳过了<a href="#t2_step2">步骤2。获取快照</a> ，可以将以下快照用于此步骤： <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_Second_Leak_Fix.dmw" rel="noopener noreferrer" data-external="true" target="_blank">Find_Memory_Leak_After_Second_Leak_Fix.dmw</a> 。</p>        </aside>        <p id="16481433">我们已经修复了事件处理程序泄漏，现在垃圾收集器已成功收集了广告窗口。但是导致泄漏的计时器又如何呢？如果一切正常，还应该收集计时器，并且第二个快照中应该不存在该计时器。让我们来看看。</p>        <ol class="list _decimal"><li class="list__item" id="a242fdfe"><p>在dotMemory中打开第二个快照。为此，请单击“ <span class="control">分析路径”中</span>的“ <span class="control">分析GameOfLife.exe”</span>步骤（调查的开始），然后单击第二个快照的“ <span class="control">Snapshot＃2”</span>链接。</p><figure><img alt="t2第二次泄漏会话" title="t2第二次泄漏会话" src="/help/img/dotnet/2019.2/t2_2nd_leak_session.png" id="5ea97d10" width="800" height="599"></figure>            <p></p></li><li class="list__item" id="e6cac52a"><p>通过单击“ <span class="control">类型”</span> ，打开快照的“按<span class="control">类型</span> <span class="control">分组”</span>视图。</p></li><li class="list__item" id="4b4cade7"><p>在打开的“ <span class="control">按类型分组”</span>视图中，在过滤器字段中输入<i id="6c56d702">dispatchertimer</i> 。这将缩小列表范围，仅在类名中保留包含此模式的对象。如您所见，有7 <code class="code">System.Windows.Threading.DispatcherTimer</code>堆中的对象。</p><figure><img alt="t2第二泄漏类型列表" title="t2第二泄漏类型列表" src="/help/img/dotnet/2019.2/t2_2nd_leak_type_list.png" id="3181c93f" width="739" height="403"></figure>            <p></p></li><li class="list__item" id="3fff6aea"><p>双击打开该对象集。</p><figure><img alt="t2第二泄漏计时器obj设置" title="t2第二泄漏计时器obj设置" src="/help/img/dotnet/2019.2/t2_2nd_leak_timer_obj_set.png" id="c61120cc" width="740" height="405"></figure>这将在“ <span class="control">按类型分组”</span>视图中打开集。现在，我们需要确保该集合不包含广告窗口创建的计时器。由于计时器是在<code class="code">AdWindow</code>构造函数，最简单的方法是使用<span class="control">Back Traces</span>视图查看集合。<p></p></li><li class="list__item" id="9bcf4c8c"><p>单击视图列表中的<span class="control">Back Traces</span> 。该视图将向我们显示从直接创建对象的调用开始，一直到堆栈中的第一个调用的调用。</p><figure><img alt="t2第二次泄漏回线" title="t2第二次泄漏回线" src="/help/img/dotnet/2019.2/t2_2nd_leak_back_traces.png" id="ccc131c8" width="740" height="404"></figure>不幸的是， <code class="code">AdWindow.ctor(Window owner)</code>调用仍在此处，这意味着未收集此调用创建的计时器。无论是否关闭了广告窗口并将其从内存中删除，它都存在于快照中。这看起来像是我们应该分析的另一个内存泄漏。<p></p></li><li class="list__item" id="beaae48e"><p>双击<code class="code">AdWindow.ctor(Window owner)</code>呼叫。 dotMemory将向我们显示<code class="code">DispatcherTimer</code>此调用创建的类。默认情况下，将使用“外发<span class="control">引用”</span>视图。反过来，我们想找出该实例如何保留在内存中。因此，让我们使用“ <span class="control">密钥保留路径”</span>视图。</p></li><li class="list__item" id="f43dd9ce"><p>单击“ <span class="control">密钥保留路径”</span> 。如您所见，有两个主要的保留路径。</p><figure><img alt="t2第二泄漏关键路径" title="t2第二泄漏关键路径" src="/help/img/dotnet/2019.2/t2_2nd_leak_key_paths.png" id="9fdc2f42" width="741" height="633"></figure>计时器的第一个保留路径将我们引向<code class="code">DispatcherTimer</code>列表，它是全局的，并将所有计时器存储在应用程序中。第二种方式表明计时器也被保留<code class="code">DispatcherOperationCallback</code>宾语。该对象是运行计时器时创建的委托。这意味着计时器仍在运行。一件奇特的事<code class="code">DispatcherTimer</code> class是仅在计时器停止后才从全局计时器列表中删除实例。因此，为解决泄漏问题，我们必须在关闭广告窗口之前停止计时器。让我们在代码中做到这一点！<p></p></li><li class="list__item" id="bcb3102a"><p>打开<span class="filepath">AdWindow.cs</span>文件，其中包含<code class="code">AdWindow</code>类。实际上，修复将非常简单。我们需要做的就是添加<code class="code">adTimer.Stop();</code>线到<code class="code">Unsubscribe()</code>方法。修复之后，该方法应如下所示：</p><div class="code-block" data-lang="csharp">公共无效的Unsubscribe（）{_adTimer。勾选-= ChangeAds; _adTimer。停止（）; }</div>            <p></p></li><li class="list__item" id="25047d86"><p>重建解决方案。</p></li><li class="list__item" id="8f703669"><p>重复<a href="#t2_step2">步骤2。获取快照</a> 。</p></li><li class="list__item" id="cbc722b8"><p>在“ <span class="control">按类型分组”</span>视图中打开第二个快照，然后找到该快照的所有对象。 <code class="code">System.Windows.Threading.DispatcherTimer</code>类型。</p><figure><img alt="t2第二次泄漏修复" title="t2第二次泄漏修复" src="/help/img/dotnet/2019.2/t2_2nd_leak_fixed.png" id="10a9eb2c" width="739" height="391"></figure>如您所见，只有6个<code class="code">DispatcherTimer</code>对象而不是7。为了确保垃圾收集器收集了广告窗口使用的计时器，让我们使用“ <span class="control">后跟踪”</span>视图查看这些计时器。<p></p></li><li class="list__item" id="2e1dc224"><p>双击<span class="control">DispatcherTimer</span>对象，然后在视图列表中单击<span class="control">Back Traces</span> 。</p><figure><img alt="t2第二次泄漏修复后的痕迹" title="t2第二次泄漏修复后的痕迹" src="/help/img/dotnet/2019.2/t2_2nd_leak_fixed_back_traces.png" id="bc216952" width="741" height="391"></figure>大！没有<code class="code">AdWindow</code>列表中的构造函数，这意味着泄漏已成功修复。<p></p></li></ol>        <p id="f78f5c08">当然，这种泄漏似乎并不严重，特别是对于我们的应用程序而言。如果我们不使用dotMemory，我们甚至可能根本没有注意到这个问题。不过，在其他应用中（例如，服务器端的应用全天候运行24/7），此泄漏可能会在一段时间后通过引起<code class="code">OutOfMemory</code>例外。</p>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年8月8日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Getting_Started_with_dotMemory.html">dotMemory入门</a> <a class="navigation-links__next" href="How_to_Optimize_Memory_Traffic.html">优化内存流量</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>