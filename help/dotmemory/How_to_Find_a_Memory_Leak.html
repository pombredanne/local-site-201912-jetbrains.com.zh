<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        dotMemory tutorial, dotMemory memory leak, .NET memory leak, find detect memory leak,&#xA;        .NET memory leak profiler, C# check memory leak, C# memory leak example&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Find a Memory Leak - Help | dotMemory</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="How_to_Find_a_Memory_Leak" data-disqus-id="How_to_Find_a_Memory_Leak_dm"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotMemory Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotMemory 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="How_to_Find_a_Memory_Leak" id="How_to_Find_a_Memory_Leak.xml">Find a Memory Leak</h1>            <div class="table-wrapper"><table width="50%" id="snapshots"><thead><tr valign="top" id="8abd6dd7" class="ijRowHead"><th id="cdec24a5" width="50%"></th><th id="65da2a1d"></th></tr></thead><tbody><tr id="c68c3142" class="ijRowOdd"><td id="ca6403cf">                <b id="54ded85f">Sample application</b>            </td><td id="48b8b236">                <ul class="list _ul"><li class="list__item" id="2be45c64">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2.git" data-external="true" target="_blank" rel="noopener noreferrer">Game of Life</a>                    </li></ul>            </td></tr><tr id="7931201c" class="ijRowEven"><td id="62d1376e">                <b id="af3fa90a">Snapshots</b>            </td><td id="ba0b6d67">                <ul class="list _ul"><li class="list__item" id="db03cb25">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_Before_Fix.dmw</a>                    </li><li class="list__item" id="b128787d">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_After_First_Leak_Fix.dmw</a>                    </li><li class="list__item" id="f034c69e">                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_Second_Leak_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_After_Second_Leak_Fix.dmw</a>                    </li></ul>            </td></tr><tr id="562c4fc8" class="ijRowOdd"><td id="40553125"></td><td id="99f1c74a"></td></tr></tbody></table></div>    <aside class="note " data-title="" rel="snapshots" id="76351203"><p>        Disclaimer: This tutorial should not be treated as a universal guideline for locating and fixing memory leaks.        It is only about giving you a feel of one of the possible workflows.    </p></aside>    <p id="6ba1f72e">        In this tutorial, we'll see how you can use dotMemory to locate and fix memory leaks in your apps. But before        moving on, let's agree on what a memory leak is.    </p>    <div class="chapter"><h3 id="8165a399" data-toc="How_to_Find_a_Memory_Leak#8165a399">What is a memory leak?</h3>        <p id="000c65c3">            According to the most popular definition, a memory leak is a result of incorrect memory management when "an object is stored            in            memory but cannot be accessed by the running code." In addition, "memory leaks add up over time, and if they            are            not cleaned up, the system eventually runs out of memory."        </p>        <p id="6938ba91">            Actually, if we'll strictly follow the definition above, "classic" memory leaks are not possible in .NET apps.            Garbage Collector (GC) fully controls memory release and removes all objects that cannot be accessed by the            code.            Moreover, after the app is closed, GC entirely frees the memory occupied by the app. Nevertheless, point #2            (memory            exhaustion because of a leak) is quite real. Of course, this won't crash the system, but sooner or later the            app            will raise            an <code class="code">OutOfMemory</code> exception.        </p>        <p id="90f119b0">            Why can this happen? The thing is, GC collects only            <a href="Getting_Started_with_dotMemory.html#app-roots">unreferenced objects</a>.            If there's a reference to an object you don't know about, GC won't collect the object.            Therefore, the main tactic in fixing memory leaks is to determine            objects that add up over time (causing the leaks) as well as the objects that retain the former ones in            memory.        </p>        <p id="5f3e1b8a">            Let's try this tactic for fixing a leak in our sample application.        </p>    </div>    <div class="chapter"><h2 id="aa00f5c4" data-toc="How_to_Find_a_Memory_Leak#aa00f5c4">Sample application</h2>        <p id="5c70b187">            Once again, the app we'll use for our tutorial is Conway's Game of Life. Please download the application            from            <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2" data-external="true" target="_blank" rel="noopener noreferrer">github</a>            before proceeding any further.            Let's assume we want to return some money spent on the Game of Life development and decide to add a            window that show various ads to users. Following worst practices, we show our ad window every time a user            starts Game of Life (clicks the <span class="control">Start</span> button). When a user clicks a banner, he/she is            redirected to some website and the ad window is closed (the user may also close the window using the            standard            close button, though            that's not what we really want). To change ads, the ad window uses a timer (based on the            <span class="control">DispatcherTimer</span>            class).            You can see the implementation of the <span class="control">AdWindow</span> class in the            <span class="filepath">AdWindow.cs</span>            file.            <figure><img alt="t2 gol app" title="t2 gol app" src="/help/img/dotnet/2019.2/t2_gol_app.png" id="bb3376d1" width="600" height="392"></figure>            So, the feature is added and now is the best time to test it. Let's run dotMemory and ensure that the ad            window            doesn't affect the application's memory usage (in other words, it is correctly allocated and collected).        </p>    </div>    <div class="chapter"><h2 id="step-1-run-the-profiler" data-toc="How_to_Find_a_Memory_Leak#step-1-run-the-profiler">Step 1. Run dotMemory</h2>        <aside class="tip sideblock" data-title="" rel="step-1-run-the-profiler" id="bb5b0181">            <p id="80f09e15">                In this step, we run a profiling session right from Visual Studio as this way is easier in case you want to profile                the project that is already opened in the IDE. Nevertheless, you always has an option                <a href="Getting_Started_with_dotMemory.html#step-1-run-dotmemory">to run dotMemory as                    a standalone app and run the session from it</a>.            </p>        </aside>        <ol class="list _decimal"><li class="list__item" id="97394ff3"><p>Open the Game of Life solution in Visual Studio.</p></li><li class="list__item" id="e86e9328"><p>Run dotMemory using the menu                <span data-skip-index="skip" class="menupath">ReSharper | Profile | Run Startup Project Memory Profiling...</span>.                <figure><img alt="t2 resharper menu upd dM" title="t2 resharper menu upd dM" src="/help/img/dotnet/2019.2/t2_resharper_menu_upd_dM.png" id="efd16426" width="576" height="372"></figure>                This will open the <span class="control">Profiler Configuration</span> window.            </p></li><li class="list__item" id="dbed4a87"><p>                In the                <span class="control">Profiler Configuration</span>                window, select                <span class="control">Collect memory allocation and traffic data from start</span>. This will tell                dotMemory to start collecting profiling data right after the app is launched.                Here's what the window should look like after you specify the options:                <figure><img alt="t2 profiler conf" title="t2 profiler conf" src="/help/img/dotnet/2019.2/t2_profiler_conf.png" id="5f450840" width="503" height="343"></figure>            </p></li><li class="list__item" id="2b06493b"><p>                Click <span class="control">Run</span> to start the profiling session. This will run our app and open the main                Analysis page in                dotMemory.            </p></li></ol>    </div>    <div class="chapter"><h2 id="t2_step2" data-toc="How_to_Find_a_Memory_Leak#t2_step2">Step 2. Get snapshots</h2>        <aside class="tip sideblock" data-title="" rel="t2_step2" id="06f2599e">            <p id="09258ccb">                If you want to skip the "get snapshots" step, you can                <a href="#snapshots">                    download the snapshots                </a>                that were used for this tutorial.            </p>        </aside>        <p id="96edeb66">            Once the app is running, we can get a memory snapshot. As we want to test our new ad windows and how they            affect            memory usage, we'll need to take two snapshots: one right after the windows are displayed (we'll use this            snapshot as a basis for comparison), and another after the ad windows are closed. The second snapshot is            needed            to ensure that GC removes our windows from memory.        </p>        <ol class="list _decimal"><li class="list__item" id="852a9420"><p>                Start the game by clicking the <span class="control">Start</span> button in the app. The ad window will appear.                <figure><img alt="t2 gol app" title="t2 gol app" src="/help/img/dotnet/2019.2/t2_gol_app.png" id="ce3b0f53" width="600" height="392"></figure>            </p></li><li class="list__item" id="81c14c7c"><p>                Click the <span class="control">Get Snapshot</span> button in dotMemory.                <figure><img alt="t2 get snapshot1" title="t2 get snapshot1" src="/help/img/dotnet/2019.2/t2_get_snapshot1.png" id="85ee6a30" width="800" height="548"></figure>                This will capture the data and add the snapshot to the snapshot area. Getting a snapshot doesn't                interrupt                the                profiling process, thus allowing us to get another snapshot.            </p></li><li class="list__item" id="869835e4"><p>Close the ad window in the application.</p></li><li class="list__item" id="c4d1e963"><p>                Get a snapshot one more time by clicking the <span class="control">Get Snapshot</span> button in dotMemory.            </p></li><li class="list__item" id="e3e99315"><p>                End the profiling session by closing the Game of Life application.                The main page now contains two snapshots.                <figure><img alt="t2 get snapshot2" title="t2 get snapshot2" src="/help/img/dotnet/2019.2/t2_get_snapshot2.png" id="5035b87b" width="800" height="548"></figure>            </p></li></ol>    </div>    <div class="chapter"><h2 id="t2_step3" data-toc="How_to_Find_a_Memory_Leak#t2_step3">Step 3. Compare snapshots</h2>        <aside class="tip sideblock" data-title="" rel="t2_step3" id="1a0d818f">            <p id="f395e127">                If you skipped <a href="#t2_step2">Step 2. Get snapshots</a>, you can use the following snapshots for this step:                <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_Before_Fix.dmw</a>.            </p>        </aside>        <p id="6e2fbda7">            Now, we'll compare and contrast the two collected snapshots. What do we want to see? If everything works            fine,            the ad window should be present in the first snapshot but absent in the second. Let's take a look.        </p>        <ol class="list _decimal"><li class="list__item" id="0c727bec"><p>                Click                <span class="control">Add to comparison</span>                for each snapshot to add them to the comparison area. The order in which you add                snapshots is not important as dotMemory always uses the older snapshot as the basis for comparison.                <figure><img alt="t2 snapshot comparison area" title="t2 snapshot comparison area" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_area.png" id="901e1a74" width="800" height="381"></figure>            </p></li><li class="list__item" id="5f95c658"><p>                Click <span class="control">Compare</span> in the comparison area. This will open the                <span class="control">Snapshots comparison</span>                view.                <figure><img alt="t2 snapshot comparison view" title="t2 snapshot comparison view" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_view.png" id="da5ee158" width="800" height="532"></figure>                The view shows how many objects of a certain class were created (the                <span class="control">New objects</span>                column) and removed (the                <span class="control">Dead objects</span>                column) between snapshots. Survived objects shows how many objects                have survived garbage collection, or, in other words, exist in both snapshots. Currently, we're                interested                in the <code class="code">AdWindow</code> class.            </p></li><li class="list__item" id="c1d989b3"><p>                To ease the finding of the <code class="code">AdWindow</code> class, let's sort all objects by the namespace they                belong to. To do this, click                <span class="control">Namespace</span>                in the <span class="control">Group by</span> list on top of the table.            </p></li><li class="list__item" id="80135c2f"><p>Open the <code class="code">GameOfLife</code> namespace.                <figure><img alt="t2 snapshot comparison namespace" title="t2 snapshot comparison namespace" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_namespace.png" id="5bc02473" width="800" height="312"></figure>                What's that? The                <code class="code">GameOfLife.AdWindow</code>                object is in the <span class="control">Survived objects</span> column, which means that the ad                window is still alive. After we closed the window, the corresponding object should have been removed                from                the heap.                Nevertheless, something has prevented it from being collected.            </p></li></ol>        <p id="979f2c68">            It's time to start our investigation and find out why our ad window has not been removed!        </p>    </div>    <div class="chapter"><h2 id="a3289aad" data-toc="How_to_Find_a_Memory_Leak#a3289aad">Step 4. Analyze the snapshot</h2>        <aside class="tip sideblock" data-title="" rel="a3289aad" id="fbd44d44">            <p id="c9eb6864">                If you skipped                <a href="#t2_step2">Step 2. Get snapshots</a>, you can use the following snapshots for this step:                <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_Before_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_Before_Fix.dmw</a>, <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_After_First_Leak_Fix.dmw</a>.            </p>        </aside>                                                                                                                <p id="246fb167">            As mentioned in the <a href="Getting_Started_with_dotMemory.html">How to Get Started with dotMemory</a> tutorial,            you should think of your work            in            dotMemory as of crime investigation. You start your investigation by analyzing a huge list of suspects            (objects)            and continuously narrow the list until you find the one that causes the issue. Your chain of reasoning is            shown            in the so-called Analysis Path on the left side of the dotMemory window.        </p>        <p id="67d41d74">            Let's try this approach in action:        </p>        <ol class="list _decimal"><li class="list__item" id="d6d949b7"><p>                Open the survived <code class="code">GameOfLife.AdWindow</code> instance. To do this, click the number                <span class="control">1</span>                in the <span class="control">Survived objects</span> column next to the                <code class="code">GameOfLife.AdWindow</code>                class.                <figure><img alt="t2 select snapshot" title="t2 select snapshot" src="/help/img/dotnet/2019.2/t2_select_snapshot.png" id="cf9afca3" width="295" height="115"></figure>                As the object exists in both snapshots, dotMemory will prompt you to specify in which snapshot the                object                should be shown. Of course, we're interested in the last snapshot where the window should have been                collected.            </p></li><li class="list__item" id="f101841d"><p>                Select                <span class="control">Open "Survived Objects" in the newer snapshot</span>                and click <span class="control">OK</span>.                <figure><img alt="t2 adwindow instance" title="t2 adwindow instance" src="/help/img/dotnet/2019.2/t2_adwindow_instance.png" id="a3fea421" width="800" height="456"></figure>                This will show us the instance "The instance of the                <code class="code">AdWindow</code>                class that exist both in snapshot #1 and #2". Note that the list of possible views                for instances differs from the one of an object set. For example, the default view for an object                instance                is <span class="control">Outgoing References</span> that shows the tree of instance's references to other objects.                Nevertheless, we're interested not in the objects that are referenced by <code class="code">AdWindow</code>,                but only in those that reference it, or, in other words, retain the ad window in memory. To                figure this out, we can simply switch to the <span class="control">Key Retention Paths</span> view. This view shows                the graph of retention paths. Note that the view shows                <b id="44ef1334">not all possible paths</b>, but only those that                differ from each other most significantly. This excludes a huge number                of very similar retention paths and simplifies the analysis.            </p></li><li class="list__item" id="a1b31b70"><p>                Click <span class="control">Key Retention Paths</span> in the list of views.                <figure><img alt="t2 instance retention paths" title="t2 instance retention paths" src="/help/img/dotnet/2019.2/t2_instance_retention_paths.png" id="6d4d0cc1" width="800" height="676"></figure>                As you can see, the ad window is retained in memory by the event handler <code class="code">EventHandler</code>,                which,                in turn, is referenced by an instance of the                <code class="code">DispatcherTimer</code>                class.                <figure><img alt="t2 tick event" title="t2 tick event" src="/help/img/dotnet/2019.2/t2_tick_event.png" id="af336126" width="137" height="58"></figure>                The text above the <code class="code">DispatcherTimer</code> instance gives us one more clue -                the instance is referenced via the <code class="code">Tick</code> event handler.                Now, let's find out which method subscribes our instance to the <code class="code">Tick</code> event                handler and take a thorough look at the code.            </p></li><li class="list__item" id="49ee479e">                Click the <code class="code">EventHandler</code> instance in the graph.                <figure><img alt="t2 eventhandler instance" title="t2 eventhandler instance" src="/help/img/dotnet/2019.2/t2_eventhandler_instance.png" id="c5208a88" width="800" height="436"></figure>                This will open the <code class="code">EventHandler</code> instance* in the default                <span class="control">Outgoing References</span>                view. Now, all we need is to determine the method                that creates our instance.                <aside class="note " data-title="" rel="c4c5a67f" id="19a7d34b">                    <p id="96144811">                        * Formally speaking, dotMemory now shows you the "Instance of the                        <code class="code">EventHandler</code>                        class that dominates the "The instance of the                        <code class="code">AdWindow</code>                        class that exist both in snapshot #1 and #2".                        By the way, if you now look at Analysis Path, you'll see                        the path of our investigation which starts from comparing two snapshots and ends with our                        suspect â€“                        <span class="control">EventHandler System</span>.                    </p>                </aside>            </li><li class="list__item" id="844b2aba"><p>                To quickly find the required method, simply switch to the                <span class="control">Creation Stack Trace</span>                view.                <figure><img alt="t2 instance stack trace" title="t2 instance stack trace" src="/help/img/dotnet/2019.2/t2_instance_stack_trace.png" id="0df70dcd" width="741" height="450"></figure>                Here it is! The latest call in the stack that actually creates the timer is the                <code class="code">AdWindow</code> constructor.                Let's                find                it in the code.            </p></li><li class="list__item" id="62720360"><p>                Switch to Visual Studio with the GameOfLife solution and locate the                <code class="code">AdWindow</code>                constructor.                <div class="code-block" data-lang="csharp">
public AdWindow(Window owner)
{
    ...
    _adTimer = new DispatcherTimer {Interval = TimeSpan.FromSeconds(3)};
    _adTimer.Tick += ChangeAds;
    _adTimer.Start();
}
                </div>                As you can see, our ad window uses the                <code class="code">ChangeAds</code>                method to handle the event.                But why is the ad window kept in memory after we close it? The thing is that we subscribed the window to                the                timer's                event but forgot to unsubscribe it. Therefore, the fix of this leak is quite simple: we need to add some                <code class="code">Unsubscribe()</code>                method which should be called when closing the ad window. In fact, the code already contains                such a method, and all you need to do is uncomment the                <code class="code">Unsubscribe();</code>                line in the window's                <code class="code">OnClosed</code>                event. Finally, the code should look like this:                <div class="code-block" data-lang="csharp">
protected override void OnClosed(EventArgs e)
{
    Unsubscribe();
    base.OnClosed(e);
}

public void Unsubscribe()
{
    _adTimer.Tick -= ChangeAds;
}
                </div>            </p></li><li class="list__item" id="e9e02b9d">                <aside class="tip sideblock" data-title="" rel="e9e02b9d" id="24a7a8aa">                    <p id="99cef46f">                        You can skip this step and download the snapshots taken after the fix:                        <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_First_Leak_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_After_First_Leak_Fix.dmw</a>.                    </p>                </aside>                Now, to make sure the leak is fixed, let's build our solution and run the profiling again. To do this,                you can simply repeat the steps <a href="#t2_step2">Step 2. Get snapshots</a> and                <a href="#t2_step3">Step 3. Compare Snapshots</a>.                <figure><img alt="t2 snapshot comparison fixed" title="t2 snapshot comparison fixed" src="/help/img/dotnet/2019.2/t2_snapshot_comparison_fixed.png" id="0079d5a2" width="800" height="381"></figure>                That's it! The <code class="code">AdWindow</code> instance is now in the                <span class="control">Dead objects</span>                column which means it was successfully                collected by the time of getting the second snapshot. The leak is fixed!            </li></ol>        <p id="1f03df94">            Truth be told, this kind of leak does occur quite often. So often, in fact, that dotMemory            <i id="476216a9">automatically</i>            checks your app for this type of leaks.        </p>        <p id="dac4c0e6">            Thus, if you open the second snapshot that contains the leak and look at the            <span class="control">Inspections</span>            view, you'll notice that the            <span class="control">Event handlers leak</span>            check already contains the <code class="code">AdWindow</code> object.        </p>        <figure><img alt="t2 inspections" title="t2 inspections" src="/help/img/dotnet/2019.2/t2_inspections.png" id="ba6fcab5" width="800" height="445"></figure>    </div>    <div class="chapter"><h2 id="675b9fca" data-toc="How_to_Find_a_Memory_Leak#675b9fca">Step 5. Check for other leaks</h2>        <aside class="tip sideblock" data-title="" rel="675b9fca" id="5de7740c">            <p id="70329f01">                If you skipped <a href="#t2_step2">Step 2. Get snapshots</a>, you can use the following snapshots for this step:                <a href="https://github.com/DarthWeirdo/GoL_dotMemory_Tutorial2/raw/master/Snapshots/Find_Memory_Leak_After_Second_Leak_Fix.dmw" data-external="true" target="_blank" rel="noopener noreferrer">Find_Memory_Leak_After_Second_Leak_Fix.dmw</a>.            </p>        </aside>        <p id="16481433">We've fixed the event handler leak, and the ad window is now successfully collected by garbage collector.            But what about the timer that caused the leak? If everything works fine, the timer should be collected as            well            and should be absent in the second snapshot. Let's take a look.        </p>        <ol class="list _decimal"><li class="list__item" id="a242fdfe"><p>                Open the second snapshot in dotMemory. To do this, click the                <span class="control">Profiling GameOfLife.exe</span>                step (the beginning of your                investigation) in the Analysis Path and then click the                <span class="control">Snapshot #2</span>                link for the second snapshot.                <figure><img alt="t2 2nd leak session" title="t2 2nd leak session" src="/help/img/dotnet/2019.2/t2_2nd_leak_session.png" id="5ea97d10" width="800" height="599"></figure>            </p></li><li class="list__item" id="e6cac52a"><p>Open the <span class="control">Group by Types</span> view for the snapshot by clicking                <span class="control">Types</span>.            </p></li><li class="list__item" id="4b4cade7"><p>                In the opened                <span class="control">Group by Types</span>                view, enter <i id="6c56d702">dispatchertimer</i> in the filter field. This will narrow the list down,                leaving only objects that contain this pattern in their class names.                As you can see, there are 7 <code class="code">System.Windows.Threading.DispatcherTimer</code> objects in the heap.                <figure><img alt="t2 2nd leak type list" title="t2 2nd leak type list" src="/help/img/dotnet/2019.2/t2_2nd_leak_type_list.png" id="3181c93f" width="739" height="403"></figure>            </p></li><li class="list__item" id="3fff6aea"><p>Open this object set by double-clicking it.                <figure><img alt="t2 2nd leak timer obj set" title="t2 2nd leak timer obj set" src="/help/img/dotnet/2019.2/t2_2nd_leak_timer_obj_set.png" id="c61120cc" width="740" height="405"></figure>                This will open the set in the <span class="control">Group by Types</span> view. Now, we need to ensure that this set                doesn't contain the timer created by the ad window. As the timer was created in the                <code class="code">AdWindow</code>                constructor, the easiest way to do this is to                look at the set using the                <span class="control">Back Traces</span>                view.            </p></li><li class="list__item" id="9bcf4c8c"><p>                Click <span class="control">Back Traces</span> in the list of views.                The view will show us calls starting from the one that directly created the object, and descending to the                first                call in the stack.                <figure><img alt="t2 2nd leak back traces" title="t2 2nd leak back traces" src="/help/img/dotnet/2019.2/t2_2nd_leak_back_traces.png" id="ccc131c8" width="740" height="404"></figure>                Unfortunately, the <code class="code">AdWindow.ctor(Window owner)</code> call is still here, meaning that the timer                created by this call was not collected. It exists in the snapshot regardless of the fact that the ad                window                was closed and removed from memory. This looks like one more memory leak that we should analyze.            </p></li><li class="list__item" id="beaae48e"><p>Double-click the <code class="code">AdWindow.ctor(Window owner)</code> call.                dotMemory will show us the instance of the <code class="code">DispatcherTimer</code> class created by this call.                By default, the <span class="control">Outgoing References</span> view will be used. We, in turn, want to find                out how this instance is retained in memory. So, let's use the                <span class="control">Key Retention Paths</span>                view.            </p></li><li class="list__item" id="f43dd9ce"><p>                Click <span class="control">Key Retention Paths</span>.                As you can see, there are two main retention paths.                <figure><img alt="t2 2nd leak key paths" title="t2 2nd leak key paths" src="/help/img/dotnet/2019.2/t2_2nd_leak_key_paths.png" id="9fdc2f42" width="741" height="633"></figure>                The first retention path of our timer leads us to the                <code class="code">DispatcherTimer</code>                list, which is global and stores all timers in the application.                The second way shows that the timer is also retained by the                <code class="code">DispatcherOperationCallback</code>                object.                This object is a delegate that is created when you run the timer. This means that the timer is still                running.                One peculiar thing of the                <code class="code">DispatcherTimer</code>                class is that the instance is removed from the global timer list only                after the timer is stopped. Therefore, to fix the leak, we must stop the timer before the ad window is                closed.                Let's do this in the code!            </p></li><li class="list__item" id="bcb3102a"><p>                Open the <span class="filepath">AdWindow.cs</span> file which contains the implementation of the                <code class="code">AdWindow</code>                class. Actually, the fix will be quite                simple. All we need to do is add the <code class="code">adTimer.Stop();</code> line to the                <code class="code">Unsubscribe()</code>                method. After the fix, the                method should look like this:                <div class="code-block" data-lang="csharp">
public void Unsubscribe()
{
    _adTimer.Tick -= ChangeAds;
    _adTimer.Stop();
}
                </div>            </p></li><li class="list__item" id="25047d86"><p>Rebuild the solution.</p></li><li class="list__item" id="8f703669"><p>                Repeat <a href="#t2_step2">Step 2. Get snapshots</a>.            </p></li><li class="list__item" id="cbc722b8"><p>                Open the second snapshot in the <span class="control">Group by Types</span> view and find                all objects of the <code class="code">System.Windows.Threading.DispatcherTimer</code> type.                <figure><img alt="t2 2nd leak fixed" title="t2 2nd leak fixed" src="/help/img/dotnet/2019.2/t2_2nd_leak_fixed.png" id="10a9eb2c" width="739" height="391"></figure>                As you can see, there are only 6                <code class="code">DispatcherTimer</code>                objects instead of 7.                To ensure that garbage collector collected the timer used by the ad window, let's look at                these timers using the <span class="control">Back Traces</span> view.            </p></li><li class="list__item" id="2e1dc224"><p>                Double-click the                <span class="control">DispatcherTimer</span>                objects and then click                <span class="control">Back Traces</span> in the list of views.                <figure><img alt="t2 2nd leak fixed back traces" title="t2 2nd leak fixed back traces" src="/help/img/dotnet/2019.2/t2_2nd_leak_fixed_back_traces.png" id="bc216952" width="741" height="391"></figure>                Great! There is no <code class="code">AdWindow</code> constructor in the list,                which means that the leak has been successfully fixed.            </p></li></ol>        <p id="f78f5c08">            Of course, this type of leak doesn't seem critical, especially for our application.            If we didn't use dotMemory, we may have never even noticed the issue. Nevertheless, in other apps            (for example, server-side ones working 24/7) this leak could manifest itself after some time by causing            an <code class="code">OutOfMemory</code> exception.        </p>    </div><div class="last-modified" data-skip-index="skip">Last modified: 8 August 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Getting_Started_with_dotMemory.html">Get Started with dotMemory</a><a class="navigation-links__next" href="How_to_Optimize_Memory_Traffic.html">Optimize Memory Traffic</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>