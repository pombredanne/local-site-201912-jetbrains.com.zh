<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><title>依赖构建-帮助|帮助团队城市</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v2/app.css"></head><body  data-id="Dependent Build" data-breadcrumbs="teamcity-documentation.md|TeamCity Documentation/concepts.md|Concepts/dependent-build.md|Dependent Build" data-main-title="Dependent Build" data-edit-url="https://github.com/JetBrains/teamcity-documentation/edit/2019.1/topics/dependent-build.md"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索TeamCity帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>TeamCity 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="dependent-build.md" data-toc="Dependent Build">依赖构建</h1><p id="c56f0344">在TeamCity中，一种构建配置可以取决于一种或多种配置。可以指定两种类型的依赖关系：</p><ul class="list _ul"><li class="list__item" id="7048379f"><a href="#Snapshot-Dependency">快照依赖</a></li><li class="list__item" id="40d8bc43"><a href="#Artifact-Dependency">工件依赖</a></li></ul><p id="55a233b8"><i id="c0bb742c">工件依赖关系</i>只是一种将一个构件生成的构件移植到另一个构件中的方法。如果没有相应的<i id="63afe128">快照依赖性</i> ，则主要在构建配置在源方面不相关时使用。例如，一个构建为其他构建提供了可重用的组件。<br>快照依存关系会影响构建的处理方式，并暗示构建之间的关联性很高，一个构建是另一构建的逻辑部分。</p><a name="SnapshotDependency"></a><a name="Snapshot-Dependency"></a><div class="chapter"><h2 id="DependentBuild-SnapshotDependency">快照依赖</h2><p id="097c7231"><i id="0fe084f2">快照依赖关系</i>是一个强大的概念，它允许在TeamCity中的构建配置之间表达源级别的依赖关系。主要目标是通过创建与快照依赖项链接的不同构建配置来允许复杂的构建过程。特别是，这允许使用灵活的重用规则将单个整体构建划分为一组相互关联的构建（ <a href="build-chain.html">构建链</a> ）。TeamCity遵循在此级别上定义构建结构的声明式样式（声明依赖关系，而不是添加构建触发器），因为它允许更灵活，更强大的功能。</p><p id="382eaebc">有关典型快照依赖项用法和相关博客文章的描述，请参阅<a href="build-dependencies-setup.html">构建依赖项设置</a> ： <a href="https://blog.jetbrains.com/teamcity/2019/09/build-chains-teamcitys-blend-of-pipelines-part-1-getting-started/" rel="noopener noreferrer" data-external="true" target="_blank">2019年9月</a> ， <a href="http://blog.jetbrains.com/teamcity/2016/03/teamcity-take-on-build-pipelines/" rel="noopener noreferrer" data-external="true" target="_blank">2016</a> <a href="https://blog.jetbrains.com/teamcity/2019/09/build-chains-teamcitys-blend-of-pipelines-part-1-getting-started/" rel="noopener noreferrer" data-external="true" target="_blank">年</a> <a href="http://blog.jetbrains.com/teamcity/2016/03/teamcity-take-on-build-pipelines/" rel="noopener noreferrer" data-external="true" target="_blank">3月</a>和<a href="http://blog.jetbrains.com/teamcity/2012/04/teamcity-build-dependencies-2/" rel="noopener noreferrer" data-external="true" target="_blank">2012</a> <a href="http://blog.jetbrains.com/teamcity/2016/03/teamcity-take-on-build-pipelines/" rel="noopener noreferrer" data-external="true" target="_blank">年</a> <a href="http://blog.jetbrains.com/teamcity/2012/04/teamcity-build-dependencies-2/" rel="noopener noreferrer" data-external="true" target="_blank">4月</a> 。</p><p id="5e0e5092">构建配置A对构建配置B的快照依赖性确保在A的构建可以开始之前，A的每个构建都有一个B的<a href="snapshot-dependencies.html#Suitable-Builds">“合适的”构建</a> 。当A和B的两个版本属于同一链并且实施修订同步时，它们使用相同的源快照（如果VCS根不同，则源的修订相同或同时进行）。如果未强制执行修订同步，则在将完成的构建B升级为A时，构建A可以使用最新的修订（请参阅<a href="build-chain.html#Disabling-Revisions-Synchronization-Between-Chain-Parts">Build Chain中的</a>更多信息）。</p><p id="fe4207bd">具有快照依赖项的构建的构建结果页面允许查看所有依赖项构建及其错误（如果有）。</p><p id="b9d5e69f">快照依赖项通过以下方式更改了构建行为：</p><ul class="list _ul"><li class="list__item" id="52fdd37f"><p>当一个构建排队时，其快照所依赖的所有构建配置中的构建也会传递；然后，TeamCity确定构建要使用的修订（“检查更改”过程）。</p></li><li class="list__item" id="451d9d89"><p>如果某些构建配置已经通过匹配更改启动了构建（“适当的构建”），并且快照依赖项具有“ <i id="90eb6ac8">如果有合适的</i>选项， <i id="90eb6ac8">则不运行新的构建</i> ”选项，TeamCity通过使用已经完成的构建而不是排队的构建。然后将静默删除相应的排队构建。此过程可以执行多次，因为虽然链的构建仍保留在队列中，但是新的构建可能会开始并结束。</p></li><li class="list__item" id="33f76028"><p>通过快照依赖关系链接的所有构建都是由TeamCity使用源版本的明确说明启动的。计算修订版本，使其对应于相同的时间点（对于同一VCS根目录，它是相同的修订版本号）。对于排队的构建链（所有与快照依赖关系链接的构建），要使用的修订版是在将构建添加到队列后确定的。此时，将检查链的所有VCS根目录是否有更改，并且当前版本已在构建中固定；</p></li><li class="list__item" id="a354a3fb"><p>如果指向相同构建配置<b id="663f88a6">的同一链</b>上的<b id="663f88a6">构建</b>具有快照依赖关系和工件依赖关系，则TeamCity确保从相同源的构建中下载工件。</p></li><li class="list__item" id="b11d5dc3"><p>默认情况下，不会清除作为构建链一部分的构建，但可以在每个构建配置的基础上进行切换。有关更多详细信息，请参阅<a href="clean-up.html">清理</a>说明。</p></li></ul><p id="9cf60369">根据依赖关系，拓扑构建可以顺序或并行运行。</p><p id="a5dbe68a">可通过快照依赖项选项自定义在构建失败的情况下延续构建链的行为。对于每个失败或无法启动的依赖项，您可以选择以下四个选项之一：</p><ul class="list _ul"><li class="list__item" id="715ecafd"><p><b id="bc208956">运行构建，但添加问题</b> ：将运行从属构建并将问题添加到它，将其状态更改为失败（如果之前未将问题静音）</p></li><li class="list__item" id="63bad57d"><p><b id="0526ee9b">运行构建，但不要添加问题</b> ：依赖的构建将运行，并且不会添加任何问题</p></li><li class="list__item" id="dee6b0fe"><p><b id="b36c1870">使构建无法启动</b> ：依赖的构建将无法运行，并将被标记为“无法启动”</p></li><li class="list__item" id="4cf46fc9"><p><b id="06bde271">取消构建</b> ：依赖的构建将不会运行，并将被标记为“已取消”。</p></li></ul><p id="393d4f3b">链的构建可以通过以下方式<a href="predefined-build-parameters.html#Dependencies-Properties">引用</a>先前构建中的<a href="predefined-build-parameters.html#Dependencies-Properties">参数</a> <code class="code">dep.<configurationId>.<parameterName></code>句法。</p><p id="c22ee45e">当触发具有快照相关性的构建时，有一个<a href="predefined-build-parameters.html#Overriding-Dependencies-Properties">特殊的支持</a>将参数向下推。通过定义一个参数来完成<code class="code">reverse.dep.<configurationId>.<parameterName></code>名称。</p><p id="12045949">在为链中的构建设置<b id="6c9d6ee9">触发器时</b> ，建议的方法是： <i id="4c252ff6">考虑结果</i> –您希望在流程结束时获得的构建，并在其相应的“顶部”构建配置中配置触发器。顶层依赖的构建配置中不需要触发器，因为触发顶层时，其构建将自动放入队列中。<br>另请参见VCS触发器的相关“在快照依赖项上的更改触发” <a href="configuring-vcs-triggers.html#Trigger-a-build-on-changes-in-snapshot-dependencies">设置</a>和“版本控制设置”配置部分中的“显示快照依赖项上的更改” <a href="build-dependencies-setup.html#show-changes-from-dependencies">复选框</a> 。</p><p id="a04a903d">让我们考虑一个示例，以说明快照依赖项如何工作。</p><p id="9e8e4a18">假设我们有两个构建配置，即A和B，并且配置A对配置B具有快照依赖性，并且执行了修订同步。</p><aside class="tip sideblock" rel="9e8e4a18" id="db701f9f" data-title=""><p id="d8da7315">如果与快照依赖项连接的构建配置<a href="configuring-vcs-roots.html">共享同一组VCS根</a> ，则所有构建将在相同的源上运行。否则，如果VCS根不同，则VCS中的更改将对应于同一时间。</p></aside><ol class="list _decimal"><li class="list__item" id="44019220"><p>触发配置A的生成时，它将自动触发配置B的生成，并且两个生成都将放入“生成队列”中。版本B首先开始，版本A将在队列中等待，直到版本B完成（ <a href="snapshot-dependencies.html">如果未设置其他特定选项</a> ）。</p></li><li class="list__item" id="d2e2796b"><p>将版本B和A添加到队列中后，TeamCity会调整源以包括在这些版本中。所有构建都将使用将构建添加到队列时获取的源来运行。</p></li><li class="list__item" id="aab27557"><p>当构建B完成并且成功完成时，TeamCity将开始运行构建A。</p></li></ol><aside class="tip sideblock" rel="2a6cdad7" id="3b4cc3f3" data-title=""><p id="39757492">请注意，在构建开始运行时，要包含在构建A中的更改可能不是最新的。在这种情况下，构建A成为<a href="history-build.html">历史构建</a> 。</p></aside><p id="a20bd05f">上面的示例将快照依赖项的核心基础知识展示为一个简单的过程，没有任何其他选项。有关快照相关性选项，请参阅“ <a href="snapshot-dependencies.html">快照相关性”</a>页面。</p></div><a name="ArtifactDependency"></a><a name="Artifact-Dependency"></a><div class="chapter"><h2 id="DependentBuild-ArtifactDependency">工件依赖</h2><aside class="tip sideblock" rel="DependentBuild-ArtifactDependency" id="3cd7b936" data-title=""><p id="4cc883ca">请注意，如果为同一构建配置同时配置了快照依赖项和工件依赖项，则要使其从具有相同源的<b id="d116f8e9">构建</b>中获取工件，必须在工件依赖项中选择“ <b id="d116f8e9">从同一链构建”</b>选项。</p></aside><p id="15517b09">工件依赖关系为您提供了一种方便的方法，可以在另一个构建中使用一个构建的输出（ <a href="build-artifact.html">工件</a> ）。配置工件依赖项后，必须在构建开始之前将必要的工件下载到代理。然后，您可以使用构建结果的“ <b id="ebc6c1cc">依赖关系”</b>选项卡查看在构建中使用了哪些工件，或在哪个构建中使用了当前构建的工件。</p><p id="554b304d">要创建和配置工件依赖项，请使用“ <b id="b593d03d"><a href="artifact-dependencies.html">依赖关系”</a></b>构建配置设置页面。如果您需要在构建脚本内部或本地下载工件，则可以使用<a href="rest-api.html">REST API</a>或<a href="artifact-dependencies.html">Ivy Ant任务</a> 。</p><p id="9183abfc"><b id="010f4993">清理文物的注意事项</b></p><p id="b7ef3acf">如果工件是由其他内部版本下载的，而这些内部版本尚未清除，则可能无法<a href="clean-up.html">清除</a>它们。对于具有配置的工件依赖关系的构建配置，可以指定是否可以清除此配置从其他构建下载的工件。此设置在<a href="clean-up.html">清理策略</a>页面上可用。</p><hr id="82223cf8"><p id="52387c90"><b id="738d8869">也可以看看：</b></p><p id="3cd4b5b9"><b id="0b47458a">概念</b> ： <a href="build-artifact.html">构建工件</a> | <a href="build-dependencies-setup.html">构建依赖项设置</a><br><b id="11ddf405">管理员指南</b> ： <a href="configuring-dependencies.html">配置依赖关系</a></p><hr id="68377627"></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>