<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><title>配置VCS触发器-帮助|团队城市</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v2/app.css"></head><body  data-id="Configuring VCS Triggers" data-breadcrumbs="teamcity-documentation.md|TeamCity Documentation/administrator-s-guide.md|Administrator's Guide/managing-projects-and-build-configurations.md|Managing Projects and Build Configurations/creating-and-editing-build-configurations.md|Creating and Editing Build Configurations/configuring-build-triggers.md|Configuring Build Triggers/configuring-vcs-triggers.md|Configuring VCS Triggers" data-main-title="Configuring VCS Triggers" data-edit-url="https://github.com/JetBrains/teamcity-documentation/edit/2019.1/topics/configuring-vcs-triggers.md"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索TeamCity帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>TeamCity 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="configuring-vcs-triggers.md" data-toc="Configuring VCS Triggers">配置VCS触发器</h1><p id="202241bd">每当TeamCity在已配置的<a href="vcs-root.html">VCS根目录中</a>检测到新更改并在挂起的更改中显示更改时，VCS触发器就会自动开始新的构建。只能将一个VCS触发器添加到构建配置中。</p><p id="27422449">一旦构建配置中有未决的更改，具有默认设置的新VCS触发器将触发构建：根据版本控制的VCS根<a href="configuring-vcs-roots.html#Common-VCS-Root-Properties">检查间隔检查</a>轮询VCS <a href="configuring-vcs-roots.html#Common-VCS-Root-Properties">更改</a> ，以遵守<a href="configuring-vcs-post-commit-hooks-for-teamcity.html">VCS提交挂钩（</a>如果已配置）。只有与<a href="vcs-checkout-rules.html">检出规则</a>匹配的更改才显示为未决，因此由触发器处理。如果在短时间内完成几次签入并由TeamCity一起发现，则只会<b id="0f86493b">触发一个构建</b> 。</p><p id="e325c9c0">在检测到最后一个更改之后，可以将一个<a href="#Quiet-Period-Settings">静默时间段</a>配置为等待一段时间而不更改，然后再对构建进行排队。</p><p id="14e57902">这两个选项的全局默认值为60秒，可以在“ <b id="e2d69f28">管理” |“</b>配置”中为服务器配置。 <b id="e2d69f28">全局设置</b>页面。</p><p id="84e0b2a8">您可以使用以下所述的选项来调整VCS触发器以适应您的需求：</p><p id="8a988d68"></p><ul class="list" data-skip-index="skip"><li class="list__item"><a href="#ConfiguringVCSTriggers-Triggerabuildonchangesinsnapshotdependencies">触发快照依赖关系变化的构建</a></li><li class="list__item"><a href="#ConfiguringVCSTriggers-Per-check-inTriggering">每次签入触发</a><ul class="list _bullet"><li class="list__item"><a href="#ConfiguringVCSTriggers-QuietPeriodSettings">安静期设置</a></li><li class="list__item"><a href="#ConfiguringVCSTriggers-BuildQueueOptimizationSettings">构建队列优化设置</a></li></ul></li><li class="list__item"><a href="#ConfiguringVCSTriggers-VCSTriggerRules">VCS触发规则</a><ul class="list _bullet"><li class="list__item"><a href="#ConfiguringVCSTriggers-GeneralSyntax">一般语法</a><ul class="list _bullet"><li class="list__item"><a href="#ConfiguringVCSTriggers-TriggerRulesExamples">触发规则范例</a></li></ul></li><li class="list__item"><a href="#ConfiguringVCSTriggers-BranchFilter">分支过滤器</a></li><li class="list__item"><a href="#ConfiguringVCSTriggers-TriggerRulesandBranchFilterCombined">触发规则和分支过滤器结合</a></li><li class="list__item"><a href="#ConfiguringVCSTriggers-TriggeringaBuildonBranchMerge">触发分支合并构建</a></li></ul></li></ul><p></p><a name="Triggerabuildonchangesinsnapshotdependencies"></a><a name="Trigger-a-build-on-changes-in-snapshot-dependencies"></a><div class="chapter"><h2 id="ConfiguringVCSTriggers-Triggerabuildonchangesinsnapshotdependencies">触发快照依赖关系变化的构建</h2><p id="3ee48f37">如果您有<a href="build-chain.html">构建链</a> （即，许多通过<a href="dependent-build.html#Snapshot-Dependency">快照依赖项</a>互连的构建），则将在链中的最终构建中配置触发器。这是下图中的<i id="eb4f5f47">包装设置</i> 。</p><a name="trigger-on-ssdep-chngs"></a><p id="ed8f216b">VCS构建触发器具有另一个<a href="#Trigger-a-build-on-changes-in-snapshot-dependencies">选项</a> ，可以更改构建链的触发行为。启用此选项后，即使在依赖关系中（而非最终构建中）检测到更改，也会触发整个构建链。</p><p id="030364b2">让我们从示例中构建一条链： <code class="code">pack setup</code> - 依赖于取决于 - <code class="code">tests</code> - 依赖于取决于 - <code class="code">compile</code> 。</p><p id="a9186f07"></p><figure><img alt="编译测试包" title="编译测试包" src="/help/img/teamcity/2019.1/compile-test-pack.png" id="8428d778" width="300" height="161"></figure><p></p><p id="dbd73bd2">在VCS触发器中设置<code class="code">pack setup</code>配置时，通常会在TeamCity检测到更改时触发整个构建链<code class="code">pack setup</code> ;改变在<code class="code">compile</code>将触发<code class="code">compile</code>仅而非整个链条。如果您希望整个链在VCS更改时被触发<code class="code">compile</code> ，添加VCS触发器，并在链的最终构建配置中启用“ <i id="c892b5aa" origin="teamcity-help">在快照依赖</i> <a href="#Trigger-a-build-on-changes-in-snapshot-dependencies">项的</a> <i id="c892b5aa" origin="teamcity-help">更改时触发</i> ” <a href="#Trigger-a-build-on-changes-in-snapshot-dependencies">选项</a> ， <code class="code">pack setup</code> 。如果快照依赖项中的任何一个发生更改，这将不会更改生成的执行顺序，只会触发整个构建链。在此设置中，不需要任何VCS触发器<code class="code">compile</code>要么<code class="code">tests</code>构建配置。</p><p id="23d51e4e">如果指定了触发规则（ <a href="#VCS-Trigger-Rules">如下所述</a> ），则它们将应用于所有更改（包括来自快照依赖项的更改），并且只有与规则匹配的更改才会触发构建链。</p><p id="390be20c">另请参阅“ <a href="build-dependencies-setup.html">构建依赖关系”</a>页面上的详细信息。</p></div><a name="Per-check-inTriggering"></a><a name="Per-check-in-Triggering"></a><div class="chapter"><h2 id="ConfiguringVCSTriggers-Per-check-inTriggering">每次签入触发</h2><p id="c676ca33">如果<b id="4b313ac2">未</b>启用此选项，则可以由不同的提交者进行多次签入；并且一旦检测到它们，TeamCity将仅将一个包含所有这些更改的构建添加到队列中。</p><p id="64bbe4a9">如果您拥有快速的构建和足够的构建代理，则可以使TeamCity <b id="c893b197">为每个签入</b>启动一个新的构建<b id="c893b197">，以</b>确保没有其他更改进入同一构建。<br>为此，请选择“ <b id="e1786db5">在每个签入中触发构建”</b>选项。如果选择“ <b id="7720fb6d">如果它们来自同一提交者</b> ，则<b id="7720fb6d">包括在构建中包括多个签入”</b>选项，并且TeamCity将检测到许多待处理的更改，它将按用户分组并开始仅具有单个用户更改的构建。</p><p id="38ad63cb">这有助于弄清谁的更改使构建中断或导致新的测试失败（如果出现此问题）。</p><p id="3b1c517e"><a name="quietPeriod"></a><a name="ConfiguringVCSTriggers-quietPeriod"></a></p><a name="QuietPeriodSettings"></a><a name="Quiet-Period-Settings"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-QuietPeriodSettings">安静期设置</h3><p id="5893348d">通过指定静默期，可以确保在由多个VCS检入组成的非原子检入中间不会触发构建。</p><p id="32b2f5e4"><b id="47321b72">静默期</b>是指TeamCity在检测到最后一次VCS更改并将构建添加到队列之间保持的时间段（以秒为单位）。如果在该时间段内在“构建配置”中检测到新的VCS更改，则该时间段从新的更改检测时间开始。仅当在静默期内未检测到新的VCS更改时，才将构建版本添加到队列中。</p><p id="14b1ebf0">请注意，实际的静默期将不小于构建配置的VCS根之间的最大<a href="configuring-vcs-roots.html#Common-VCS-Root-Properties">更改间隔检查时间</a> ，因为TeamCity必须确保在静默期至少收集一次更改。</p><p id="a816a4d7">静默期可以设置为默认值（60秒，可以在“ <b id="9d65e907">管理”</b> |“ <b id="693cde14">全局设置”</b>页面上<b id="693cde14">全局</b>更改），也可以<b id="693cde14">设置</b>为构建配置的自定义值。</p><aside class="note " rel="a816a4d7" id="a41b65e3" data-title=""><p id="7257e8c6">请注意，当通过设置了VCS静默期的触发器触发构建时，该构建将以固定的VCS版本放入队列中。这样可以确保仅在包含特定更改的情况下开始构建。在某些情况下，此构建以后可以成为<a href="history-build.html">历史构建</a> 。</p></aside><a name="queue-optimization"></a></div><a name="BuildQueueOptimizationSettings"></a><a name="Build-Queue-Optimization-Settings"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-BuildQueueOptimizationSettings">构建队列优化设置</h3><p id="0eebe660">默认情况下，TeamCity <a href="build-queue.html#Build-Queue-Optimization-by-TeamCity">优化构建队列</a> ：可以将已排队的构建替换为已开始的构建或更新的队列构建。您可以通过取消选中相应的框来禁用此默认行为。</p><p id="dcb41878"><a name="buildTriggerRules"></a><a name="ConfiguringVCSTriggers-buildTriggerRules"></a></p></div></div><a name="VCSTriggerRules"></a><a name="VCS-Trigger-Rules"></a><div class="chapter"><h2 id="ConfiguringVCSTriggers-VCSTriggerRules">VCS触发规则</h2><a name="vcs-trigger-rules"></a><p id="7a054657">如果未指定触发规则，则在检测到构建配置的任何更改时触发构建。您可以通过更改VCS根设置并指定“ <a href="vcs-checkout-rules.html">签出规则”</a>来控制检测到哪些更改。</p><p id="bedd7d2c">要限制触发构建的更改，请使用VCS触发规则。您可以在文本区域中手动添加这些规则（每行一个），或使用“ <b id="ac98377d">添加新规则”</b>选项来生成它们。</p><p id="84f63c26"></p><figure><img alt="添加触发规则" title="添加触发规则" src="/help/img/teamcity/2019.1/addRule.png" id="3dd5ded0" width="450" height="610"></figure><p></p><p id="9456a3a4">每个规则都以“ include”（以“ <code class="code">+</code> ”或“排除”（以“ <code class="code">-</code> ”）。</p><a name="GeneralSyntax"></a><a name="General-Syntax"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-GeneralSyntax">一般语法</h3><a name="general-syntax"></a><p id="430aa31f">单个规则的一般语法为：</p><div class="code-block" data-lang="bash">+ |-[：[user = VCS_username;] [root = VCS_root_id;] [comment = VCS_comment_regexp]]：Ant_like_wildcard</div><a name="OR-syntax-tip"></a><aside class="tip sideblock" rel="ConfiguringVCSTriggers-GeneralSyntax" id="a7124550" data-title=""><p id="25beb1bb">在这里， <i id="ee451e9e" origin="teamcity-help">管道</i>符号<code class="code">|</code>代表<b id="14e8d8fc" origin="teamcity-help">OR</b>命令，如正则表达式中一样：use <code class="code">+</code>用于包括， <b id="a61e888f" origin="teamcity-help">或</b> <code class="code">-</code>排除。</p></aside><p id="7d1397b2">哪里：</p><ul class="list _ul"><li class="list__item" id="3f6cb96f"><p><b id="ed1d66a4">Ant_like_wildcard</b> ：与更改的文件路径匹配的<a href="wildcards.html">通配符</a> 。只要<code class="code">*</code>和<code class="code">**</code>支持模式， <code class="code">?</code> <b id="0a021620">不</b>支持的模式。规则中的文件路径可以是相对的（不是以<code class="code">/</code>要么<code class="code">\</code> ）以匹配代理或绝对路径（以<code class="code">/</code> ），以匹配相对于VCS根的VCS路径。对于更改中的每个文件，找到最特定的规则（与最长文件路径匹配的规则）。如果存在至少一个具有匹配“包含”规则的文件或没有匹配“排除”规则的文件，则触发构建。</p></li><li class="list__item" id="0e939e7c"><p><b id="0c94d117"><a href="managing-users-and-user-groups.html">VCS_username</a></b> ：如果指定，则仅将规则限制为具有相应<a href="managing-users-and-user-groups.html#VCS-Usernames">VCS username</a>的用户所做的更改。</p></li><li class="list__item" id="2e2717be"><p><b id="aafd6965">VCS_root_id</b> ：如果指定，则仅将规则限制为来自相应VCS根目录的更改。</p></li><li class="list__item" id="62696433"><p><b id="8f722cf9">VCS_comment_regexp</b> ：如果指定，则将规则仅限制为VCS注释中包含指定文本的更改。使用<a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum" rel="noopener noreferrer" data-external="true" target="_blank">Java正则表达式</a>模式来匹配注释中的文本（请参见下面的示例）。如果注释文本包含匹配的文本部分，则规则匹配；否则，规则不匹配。为了匹配整个文本，请添加<code class="code">^</code>和<code class="code">$</code>特殊字符。</p></li></ul><aside class="tip sideblock" rel="eaa68593" id="41b6b067" data-title=""><p id="c8b3e3e6">指定规则时，请注意，一旦输入任何<code class="code">+</code>规则，TeamCity会将隐式默认值从“包括所有”更改为“排除所有”。<br>要包含所有文件，请使用<code class="code">+:.</code>规则。</p><p id="c584f014">而且，规则是根据路径特定性进行排序的。如果您有明确的包含规则<code class="code">/some/path</code>和排除规则<code class="code">-:user=some_user:.</code>对于所有路径，提交到<code class="code">/some/path</code>从<code class="code">some_user</code>将被<b id="0781f06d">包括在内，</b>除非您立即为此用户和该路径添加特定的排除规则，例如<code class="code">-:user=some_user:/some/path/**</code></p></aside><a name="TriggerRulesExamples"></a><a name="Trigger-Rules-Examples"></a><div class="chapter"><h4 id="ConfiguringVCSTriggers-TriggerRulesExamples">触发规则范例</h4><a name="trigger-rules-examples"></a><div class="table-wrapper"><table width="100%" id="a4d1ad69"><thead><tr id="dd178121" class="ijRowHead"><th width="200" id="0c4a3d0a"><p id="074817d1">例</p></th><th id="96d82f19"><p id="c0544ac4">描述</p></th></tr></thead><tbody><tr id="da3a104f" class="ijRowOdd"><td id="f4e8f676"><p id="10416ac7"><code class="code">+:.</code></p></td><td id="84501068"><p id="dae55d8d">包括所有文件</p></td></tr><tr id="6a68abe2" class="ijRowEven"><td id="df32f210"><p id="6d1bfcb8"><code class="code">-:**.html</code></p></td><td id="dded774d"><p id="6e5e5735">排除所有<code class="code">.html</code>文件触发构建。</p></td></tr><tr id="165265b2" class="ijRowOdd"><td id="f8811655"><p id="a3e671f5"><code class="code">-:user=techwriter;root=InternalSVN:/misc/doc/*.xml</code></p></td><td id="54efc7bb"><p id="0c6066e0">排除由以下情况触发的构建<code class="code">.xml</code>由<a href="managing-users-and-user-groups.html#VCS-Usernames">VCS用户</a> “ techwriter”签入的文件<code class="code">misc/doc</code>名为<i id="c0b64163">Internal SVN</i>的VCS根目录（在VCS设置中定义）。请注意，该路径是绝对路径（以“ /”开头），因此文件路径是从VCS根目录匹配的。</p></td></tr><tr id="5feb6bfc" class="ijRowEven"><td id="113819a3"><p id="73bec0d7"><code class="code">-:lib/**</code></p></td><td id="0b59a574"><p id="4696acc5">防止通过更新更新触发构建<code class="code">lib</code>生成源的目录（显示在代理上）。请注意，该路径是相对的，因此所有放置到目录中的文件（通过处理VCS根<a href="vcs-checkout-rules.html">检出规则</a> ）都不会触发构建。</p></td></tr><tr id="1d5b070f" class="ijRowOdd"><td id="3012a634"><p id="79ad46ff"><code class="code">-:comment=minor:**</code></p></td><td id="7d13aae4"><p id="18cc3835">如果更改检查在注释中包含单词“ minor”，则阻止构建触发。</p></td></tr><tr id="5b49dcf0" class="ijRowEven"><td id="a536adf7"><p id="6999a3ca"><code class="code">-:comment=^oops$:**</code></p></td><td id="1d428abf"><p id="ab839e43">如果注释仅由单词“ oops”组成，则不会触发（根据<a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum" rel="noopener noreferrer" data-external="true" target="_blank">Java正则表达式</a>原则） <code class="code">^</code>和<code class="code">$</code>在模式中代表字符串的开头和结尾）。</p></td></tr></tbody></table></div></div></div><a name="BranchFilter"></a><a name="Branch-Filter"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-BranchFilter">分支过滤器</h3><p id="9009d108">在<a href="branch-filter.html">分支过滤器中</a>了解更多信息。</p></div><a name="TriggerRulesandBranchFilterCombined"></a><a name="Trigger-Rules-and-Branch-Filter-Combined"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-TriggerRulesandBranchFilterCombined">触发规则和分支过滤器结合</h3><p id="dfd745f5">触发器规则和分支过滤器通过<b id="97aa36bf">AND</b>结合在一起，这意味着<b id="e9076c0e">仅在同时满足两个条件时才</b>触发构建。</p><p id="e9fef7ee">例如，如果您在触发规则字段中指定注释文本并提供分支规范，则仅当提交具有特殊文本并且在由分支过滤器匹配的分支中时，才会触发构建。</p></div><a name="TriggeringaBuildonBranchMerge"></a><a name="Triggering-a-Build-on-Branch-Merge"></a><div class="chapter"><h3 id="ConfiguringVCSTriggers-TriggeringaBuildonBranchMerge">触发分支合并构建</h3><p id="56f2b670">VCS触发器完全了解分支，一旦在分支中检测到签入，就会触发构建。</p><p id="b46db370">当更改从一个分支合并/快速转发到另一个分支时，严格来说，代码中没有实际更改。默认情况下，VCS触发器的行为如下：</p><ul class="list _ul"><li class="list__item" id="830f853f"><p>合并/快速转发两个非默认分支时：构建中的更改是针对同一分支中的先前构建进行计算的，因此，如果在不同分支中的同一提交上存在构建，则触发器将开始构建另一个分支指向相同的提交。</p></li><li class="list__item" id="fe636057"><p>如果默认分支是合并/快速转发中的分支之一，则更改将始终根据默认分支进行计算，如果默认分支中存在相同版本的构建，TeamCity将不会在同一分支上运行新构建修订。</p></li></ul><hr id="78b9d62d"></div></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>