<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><title>构建依赖项设置-帮助|帮助团队城市</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v2/app.css"></head><body  data-id="Build Dependencies Setup" data-breadcrumbs="teamcity-documentation.md|TeamCity Documentation/administrator-s-guide.md|Administrator's Guide/managing-projects-and-build-configurations.md|Managing Projects and Build Configurations/creating-and-editing-build-configurations.md|Creating and Editing Build Configurations/configuring-dependencies.md|Configuring Dependencies/build-dependencies-setup.md|Build Dependencies Setup" data-main-title="Build Dependencies Setup" data-edit-url="https://github.com/JetBrains/teamcity-documentation/edit/2019.1/topics/build-dependencies-setup.md"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索TeamCity帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>TeamCity 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="build-dependencies-setup.md" data-toc="Build Dependencies Setup">构建依赖项设置</h1><p id="523a6cbc">该页面旨在根据示例为您提供有关TeamCity中依赖项工作方式的一般思路。有关依赖项的描述，请参见<a href="dependent-build.html">Dependent Build</a> 。</p><p id="d53f4ebc">在此页：</p><p id="e8996f34"></p><ul class="list" data-skip-index="skip"><li class="list__item"><a href="#BuildDependenciesSetup-Introduction">介绍</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Basics">基本</a></li><li class="list__item"><a href="#BuildDependenciesSetup-ArtifactDependencies">工件依赖</a></li><li class="list__item"><a href="#BuildDependenciesSetup-SnapshotDependencies">快照依存关系</a><ul class="list _bullet"><li class="list__item"><a href="#BuildDependenciesSetup-WhentoCreateBuildChain">何时创建构建链</a></li><li class="list__item"><a href="#BuildDependenciesSetup-BuildChainsinTeamCityUI">在TeamCity UI中建立链</a></li><li class="list__item"><a href="#BuildDependenciesSetup-HowSnapshotDependenciesWork">快照依存关系如何运作</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Example1">例子1</a><ul class="list _bullet"><li class="list__item"><a href="#BuildDependenciesSetup-WhatHappensWhenBuildAisTriggered">触发构建A时会发生什么</a></li><li class="list__item"><a href="#BuildDependenciesSetup-WhatHappensWhenBuildBisTriggered">触发构建B时会发生什么</a></li></ul></li><li class="list__item"><a href="#BuildDependenciesSetup-Example2">例子2</a></li><li class="list__item"><a href="#BuildDependenciesSetup-AdvancedSnapshotDependenciesSetup">高级快照依赖项设置</a><ul class="list _bullet"><li class="list__item"><a href="#BuildDependenciesSetup-Reusingbuilds">重用构建</a></li><li class="list__item"><a href="#BuildDependenciesSetup-TurnedoffEnforcedRevisionsSynchronization">关闭强制修订同步</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Runbuildonthesameagent">在同一代理上运行构建</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Buildbehaviorifdependencyhasfailed">如果依赖项失败，则生成行为</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Triggeronchangesinsnapshotdependencies">触发快照依赖项的更改</a></li><li class="list__item"><a href="#BuildDependenciesSetup-Parametersindependentbuilds">依赖版本中的参数</a></li></ul></li></ul></li><li class="list__item"><a href="#BuildDependenciesSetup-MiscellaneousNotesonUsingDependencies">有关使用依赖项的其他说明</a></li></ul><p></p><a name="Introduction"></a><a name="Introduction"></a><div class="chapter"><h2 id="BuildDependenciesSetup-Introduction">介绍</h2><p id="d9d6d2b2">在许多情况下，在一个构建中使用另一个构建的输出以及在同一源上顺序运行多个构建是很方便的。考虑一个典型的示例：您有一个跨平台项目，在获得生产版本之前，必须在Windows和macOS下对其进行测试。这种简单情况的最佳工作流程是：</p><ol class="list _decimal"><li class="list__item" id="71bb2457"><p>编译您的项目。</p></li><li class="list__item" id="86033ddd"><p>在Windows和macOS上同时在同一源上运行测试</p></li><li class="list__item" id="e0e42714"><p>当然，如果在两个操作系统下都通过了测试，则在相同的来源上构建发行版。</p></li></ol><p id="aa845f7a">这可以通过在TeamCity中配置构建配置之间的依赖关系来轻松实现，如下所示：</p><p id="03baf771"></p><figure><img alt="编译测试包" title="编译测试包" src="/help/img/teamcity/2019.1/compile-test-pack.png" id="dd4a4504" width="350" height="161"></figure><p></p><p id="736f9c4b">在<i id="4983cdde">compile</i> ， <i id="44c3edc7">tests（win）</i> ， <i id="b0d7e308">tests（mac）</i>和<i id="b040a509">pack setup</i>是构建配置的地方，测试自然<b id="64a77399">取决于</b>编译，这意味着它们应等待编译准备就绪。</p></div><a name="Basics"></a><a name="Basics"></a><div class="chapter"><h2 id="BuildDependenciesSetup-Basics">基本</h2><p id="a1c6cf9d">通常被称为<i id="8e244ba9">构建管道</i> ，在TeamCity中，类似的概念称为<i id="557ad21d"><a href="build-chain.html">构建链</a></i> 。在详细介绍TeamCity中的工作原理之前，让我们澄清一下此处给出的图表背后的图例（包括简介中的图例）：</p><div class="table-wrapper"><table width="100%" id="cc34ee1d"><thead><tr id="46229a47" class="ijRowHead"><th width="150px" id="254719af"></th><th id="285bd001"></th></tr></thead><tbody><tr id="5b13c82d" class="ijRowOdd"><td id="e8181797"><p id="2a24edd3"><img alt="buildConfiguration" title="buildConfiguration" src="/help/img/teamcity/2019.1/buildConfiguration.png" id="06862ee8" width="70" height="31" class="inline-icon-70"></p></td><td id="70400e6c"><p id="1fbe5144">构建配置。</p></td></tr><tr id="e2521ca0" class="ijRowEven"><td id="96708e1d"><p id="8792ff46"><img alt="dependent.png" title="dependent.png" src="/help/img/teamcity/2019.1/dependency.png" id="539c91fa" width="201" height="31" class="inline-icon-201"></p></td><td id="a3faf5b8"><p id="e72a6018">2个构建配置之间的<a href="#Snapshot-Dependencies">快照依赖</a>关系。请注意，箭头显示了触发构建配置的顺序， <a href="build-chain.html">构建链</a>流程，这意味着B在A之前执行。但是，依存关系的配置方向相反（A快照取决于B）。之所以这样绘制箭头，是因为在<a href="#Build-Chains-in-TeamCity-UI">TeamCity UI中</a>您可以找到构建链的可视化表示形式，这些视觉表示始终根据构建链的流程进行显示。<br>通常，在添加快照依赖项时，还需要使用来自同一配置的“从同一链构建”选项添加工件依赖项，以传输先前的构建结果并在构建中也使用它们。</p></td></tr><tr id="0e8085f7" class="ijRowOdd"><td id="598e220e"><p id="7dbdc0d3"><img alt="artifactDependency.png" title="artifactDependency.png" src="/help/img/teamcity/2019.1/artifactDependency.png" id="82d1f6dd" width="201" height="31" class="inline-icon-201"></p></td><td id="fa447480"><p id="9511f6a3"><a href="#Artifact-Dependencies">工件依赖</a> 。箭头显示了工件流，依赖性在相反的方向上配置。</p></td></tr></tbody></table></div><p id="ddc66fb1">如您所注意到的，TeamCity有两种类型的依赖关系： <b id="97a62965">工件</b>依赖关系和<b id="60478a24">快照</b>依赖关系。用两个词来说，第一个允许在另一个构建中使用一个构建的输出，而第二个则可以按特定顺序但在相同的源上从多个构建配置触发构建。<br>经常将这两个依赖项配置在一起，因为工件依赖项不会影响构建触发方式，而快照依赖项本身不会重用工件，有时您可能只需要其中之一。</p><p id="4e3ceaaf">在构建配置设置的专用页面上配置依赖项。</p><p id="7e425af7">现在，让我们看看如何使用工件和快照依赖项以及它们如何工作。</p></div><a name="ArtifactDependencies"></a><a name="Artifact-Dependencies"></a><div class="chapter"><h2 id="BuildDependenciesSetup-ArtifactDependencies">工件依赖</h2><p id="d254c686"><i id="2c20d2dd">工件依赖关系</i>允许在另一个构建中重用一个构建（或其一部分）的输出。</p><p id="c587bf27"><img alt="artifactDependency" title="artifactDependency" src="/help/img/teamcity/2019.1/artifactDependency.png" id="8a08ac05" width="150" height="31" class="inline-icon-150"></p><p id="87b10fa2">如果构建配置<b id="c7fa58e8">A</b>对<b id="d589f2bf">B</b>具有工件依赖关系，那么在<b id="4f659435">A</b>的构建开始之前，将<b id="cd56a473">B</b>的工件下载到构建代理。请注意，您可以灵活地调整<a href="artifact-dependencies.html">工件规则，</a>以配置应采用哪些工件以及应将它们准确放置在何处。</p><p id="0208c6f8">如果出于某种原因您需要将工件依赖项信息与代码库一起存储而不是存储在TeamCity中，则可以配置<a href="artifact-dependencies.html#Configuring-Artifact-Dependencies-Using-Ant-Build-Script">Ivy Ant任务</a>以在构建脚本中获取工件。</p><p id="6fa17bc4">如果同时配置了快照和工件依赖项，并且在工件依赖项设置中选择了“ <i id="83e5f4a9">从同一链构建</i> ”选项，TeamCity将确保从相同源的构建中下载工件。</p></div><a name="SnapshotDependencies"></a><a name="Snapshot-Dependencies"></a><div class="chapter"><h2 id="BuildDependenciesSetup-SnapshotDependencies">快照依存关系</h2><p id="073e5cf5"><i id="146a5eb0">快照依赖关系</i>是两个构建配置之间的依赖关系，它允许<b id="74fa05de">按特定顺序</b>从两个构建配置<b id="74fa05de">中</b>启动构建，并确保它们使用<b id="b15f98bf">相同的源快照</b> （对应于同一时刻的源修订）。</p><p id="9749d6ff">当您有许多通过快照依赖项相互连接的内部版本时，它们形成了一个<b id="996abefe"><a href="build-chain.html">构建链</a></b> 。</p><a name="WhentoCreateBuildChain"></a><a name="When-to-Create-Build-Chain"></a><div class="chapter"><h3 id="BuildDependenciesSetup-WhentoCreateBuildChain">何时创建构建链</h3><p id="4321461b">创建<a href="build-chain.html">构建链</a>的最常见用例是在不同平台上运行项目的相同测试套件。例如，您可能需要构建发行版，并希望确保测试可以在不同的平台和环境上正确运行。为此，如果集成成功，则可以指示TeamCity首先运行一个集成版本，然后再运行一个发布版本。</p><p id="2475e5ce">另一种情况是，您的测试花费的时间太长，因此您必须将它们提取到单独的构建配置中，但是还需要确保它们使用相同的源快照。</p></div><a name="BuildChainsinTeamCityUI"></a><a name="Build-Chains-in-TeamCity-UI"></a><div class="chapter"><h3 id="BuildDependenciesSetup-BuildChainsinTeamCityUI">在TeamCity UI中建立链</h3><p id="2edffb07">定义快照依赖项并触发至少一个<a href="build-chain.html">构建链</a>后，“ <b id="7a1e45d2">构建链”</b>选项卡将显示在<b id="53a83b61">项目主页</b>和相关构建配置的<b id="b305e3e8">主页上</b> ，从而提供所有构建链的可视化表示以及一种重新构建构建链的方法。使用原始提取的同一组资源手动运行任何链式步骤。</p><figure><img alt="Build-Chains1.png" title="Build-Chains1.png" src="/help/img/teamcity/2019.1/Build-Chains1.png" id="0f93a033" width="1755" height="542"></figure> <a href="build-chain.html">学到更多</a><p></p></div><a name="HowSnapshotDependenciesWork"></a><a name="How-Snapshot-Dependencies-Work"></a><div class="chapter"><h3 id="BuildDependenciesSetup-HowSnapshotDependenciesWork">快照依存关系如何运作</h3><p id="79b15fc6">要了解快照依赖性的工作原理，请考虑模块依赖性，因为这些概念是相似的。但是，让我们从基础开始。假设，我们有一个<a href="build-chain.html">构建链</a> ：</p><p id="aa807c12"><img alt="a1 a2 an" title="a1 a2 an" src="/help/img/teamcity/2019.1/a1-a2-an.png" id="97540384" width="300" height="31" class="inline-icon-300"></p><ol class="list _decimal"><li class="list__item" id="1e16818e"><p>如果触发了A1的构建，则整个构建链A1 ...AN已添加到<a href="build-queue.html">构建队列</a> ，但<b id="075dcf3c">反之则不然！</b> -如果触发了构建AN，则无论如何都不会影响构建链，仅运行AN。</p></li><li class="list__item" id="c5f85e3d"><p>构建<b id="4e89b014">从AN到A1顺序</b>运行。直到构建Ak成功完成，构建A（k-1）才开始。</p></li><li class="list__item" id="c50481d8"><p>链中的所有构建都将使用相同的源快照，即使用显式的源修订版本规范，该规范是在将构建链添加到队列时计算的。</p></li></ol><p id="538ace8a">现在，让我们进入细节和示例。</p></div><a name="Example1"></a><a name="Example-1"></a><div class="chapter"><h3 id="BuildDependenciesSetup-Example1">例子1</h3><p id="0d7a0f73">假设我们有以下<a href="build-chain.html">构建链</a> ，没有其他选项-纯快照依赖项。</p><p id="75ae9b6f"><img alt="美国广播公司" title="美国广播公司" src="/help/img/teamcity/2019.1/ABC.png" id="724f9a13" width="250" height="31" class="inline-icon-250"></p><a name="WhatHappensWhenBuildAisTriggered"></a><a name="What-Happens-When-Build-A-is-Triggered"></a><div class="chapter"><h4 id="BuildDependenciesSetup-WhatHappensWhenBuildAisTriggered">触发构建A时会发生什么</h4><ol class="list _decimal"><li class="list__item" id="81aea850"><p>TeamCity解析整个构建链并将所有构建（A，B和C）排入队列。TeamCity知道构建将严格按照顺序运行，因此在构建B成功完成之前它不会运行构建A，并且不会成功运行构建A。运行版本B，直到版本C成功完成。</p></li><li class="list__item" id="13b328a1"><p>将构建添加到队列后，TeamCity开始检查整个构建链中的更改并同步它们-所有构建都必须以相同的源快照开始。<br>请注意，如果与快照依赖项连接的构建配置<a href="configuring-vcs-roots.html#VCS-Roots-in-TeamCity">共享同一组VCS根</a> ，则所有构建都将在相同的源上运行。否则，如果VCS根不同，则VCS中的更改将对应于同一时间。</p></li><li class="list__item" id="6d622a43"><p>构建C完成后，构建B开始，依此类推。如果构建C失败，默认情况下，TeamCity将不会进一步从链执行构建，但是此行为是可<a href="snapshot-dependencies.html#on-failed-dependency">配置的</a> 。</p></li></ol></div><a name="WhatHappensWhenBuildBisTriggered"></a><a name="What-Happens-When-Build-B-is-Triggered"></a><div class="chapter"><h4 id="BuildDependenciesSetup-WhatHappensWhenBuildBisTriggered">触发构建B时会发生什么</h4><p id="20d3c9b8">对于构建链B-> C，将执行相同的过程。版本A不会受到影响，也不会运行。</p></div></div><a name="Example2"></a><a name="Example-2"></a><div class="chapter"><h3 id="BuildDependenciesSetup-Example2">例子2</h3><p id="9d17b287"></p><figure><img alt="B1 B2 A" title="B1 B2 A" src="/help/img/teamcity/2019.1/B1-B2-A.png" id="5412313a" width="160" height="161"></figure><p></p><p id="d129eb90">触发最终版本A后，TeamCity会解析该构建链并将所有版本（A，B1和B2）排队。直到B1和B2都准备好，构建A才会开始。<br>在这种情况下，哪个版本-B1或B2-首先开始并不重要。与第一个示例一样，将所有构建都添加到队列中后，TeamCity会检查整个构建链中的更改并进行同步。</p></div><a name="AdvancedSnapshotDependenciesSetup"></a><a name="Advanced-Snapshot-Dependencies-Setup"></a><div class="chapter"><h3 id="BuildDependenciesSetup-AdvancedSnapshotDependenciesSetup">高级快照依赖项设置</h3><a name="Reusingbuilds"></a><a name="Reusing-builds"></a><div class="chapter"><h4 id="BuildDependenciesSetup-Reusingbuilds">重用构建</h4><p id="6138fc60">属于<a href="build-chain.html">构建链的</a>所有构建都放入<a href="build-queue.html">队列中</a> 。但是，除了强制执行构建链中所有构建的运行之外，TeamCity可以检查是否已经存在合适的构建，即使用所需源快照的完成构建。匹配的排队构建将不会运行，并且将从<a href="build-queue.html#Build-Queue-Optimization-by-TeamCity">队列中删除</a> ，并且TeamCity将把依赖关系链接到“合适的”构建。要启用此功能，请在配置快照依赖项选项时选择“ <i id="fc0beaa9">如果有合适的版本，则不要运行新版本</i> ”。</p><p id="50f7e897">允许您控制如何重新使用构建的另一个选项称为“ <i id="d24eab3f">仅使用合适的构建成功的构建</i> ”，这在有合适的构建时可能会有所帮助，但不会成功。通常，当链中的构建失败时，TeamCity不会继续处理链的其余部分。但是，启用此选项后，TeamCity将再次在这些源上运行此失败的构建。什么时候有帮助？例如，当构建失败是由于连接到VCS时的问题引起的。</p></div><a name="TurnedoffEnforcedRevisionsSynchronization"></a><a name="Turned-off-Enforced-Revisions-Synchronization"></a><div class="chapter"><h4 id="BuildDependenciesSetup-TurnedoffEnforcedRevisionsSynchronization">关闭强制修订同步</h4><p id="b3ca2039">如果在创建快照依赖项时禁用“ <i id="05d2d480"><a href="snapshot-dependencies.html#enforce-rev-sync">强制修订同步</a></i> ”选项，则当构建从一个零件升级到另一个零件时，TeamCity将能够对链零件使用不同的修订（在<a href="build-chain.html#Disabling-Revisions-Synchronization-Between-Chain-Parts">Build Chain中有</a>更多信息）。</p><p id="34e67b06">让我们探索一个<a href="deployment-build-configuration.html">部署链</a>的示例：</p><p id="12f405ba"><img alt="dis enf rev sync" title="dis enf rev sync" src="/help/img/teamcity/2019.1/dis-enf-rev-sync.png" id="795f74c5" width="350" height="31" class="inline-icon-350"></p><p id="9f252d7c">具有以下构建配置：</p><ul class="list _ul"><li class="list__item" id="736aada5"><p>D：编译</p></li><li class="list__item" id="34bb9f7e"><p>C：集成测试</p></li><li class="list__item" id="d5f08402"><p>B：系统测试</p></li><li class="list__item" id="d078cdec"><p>答：部署</p></li></ul><p id="a0425634">在此，在<i id="b3e26e32">版本</i> B的快照相关性中禁用了“ <i id="b3e26e32">强制修订同步</i> ”选项，而C和A在启用此选项的情况下具有快照相关性（默认状态）。基于这些设置，TeamCity将在D和C之间以及B和A之间同步修订，但它将能够对链零件DC和BA使用不同的修订。</p><p id="3953abe4">在我们的示例中，D和C的版本为1，B的版本为2，A的版本为3。</p><p id="9565795a">如果要在不进行集成测试C的情况下使用最新的部署配置A运行较早的编译版本D，则可以将版本D直接升级为B。然后它将B与A的较新版本同步，并使用版本3运行B和A。</p><p id="0391e5d2">通过为链中不同构建配置的依赖性启用和禁用此选项，您可以更好地控制设置并使其更加灵活。</p><p id="b4390685">为防止版本之间发生冲突，请避免配置链，其中从属版本（A）必须将版本与其多个直接依存版本（B）和（C） <i id="7af887a6">同步</i> ，并且这些版本在其快照中具有“ <i id="7af887a6">强制执行版本同步</i> ”选项的不同状态对其他构建的依赖（D）。<br>请改用以下有效链：</p><p id="be2f83d7">1。已为DBA构建流程启用了同步，但已为DCA禁用了同步。</p><p id="24b54337"></p><figure><img alt="有效捕捉流1" title="有效捕捉流1" src="/help/img/teamcity/2019.1/valid-snap-flow1.png" id="c8a1503d" width="240" height="171"></figure><p></p><p id="eef7f58f">2。已为DB和DC启用同步，但为BA和CA禁用同步。</p><p id="65f95a70"></p><figure><img alt="有效捕捉流2" title="有效捕捉流2" src="/help/img/teamcity/2019.1/valid-snap-flow2.png" id="d77ffd19" width="240" height="171"></figure><p></p></div><a name="Runbuildonthesameagent"></a><a name="Run-build-on-the-same-agent"></a><div class="chapter"><h4 id="BuildDependenciesSetup-Runbuildonthesameagent">在同一代理上运行构建</h4><p id="121d3472">此选项设计用于以下情况：构建链中的构建修改了系统环境，而下一个构建依赖于该系统状态，因此必须在同一构建代理上运行。</p></div><a name="Buildbehaviorifdependencyhasfailed"></a><a name="Build-behavior-if-dependency-has-failed"></a><div class="chapter"><h4 id="BuildDependenciesSetup-Buildbehaviorifdependencyhasfailed">如果依赖项失败，则生成行为</h4><p id="70b25bc5">如果依赖关系失败，则可以<a href="snapshot-dependencies.html#on-failed-dependency">配置</a>最终的构建行为。</p></div><a name="Triggeronchangesinsnapshotdependencies"></a><a name="Trigger-on-changes-in-snapshot-dependencies"></a><div class="chapter"><h4 id="BuildDependenciesSetup-Triggeronchangesinsnapshotdependencies">触发快照依赖项的更改</h4><a name="trigger-on-ssdep-chngs"></a><p id="4e6ddda2">VCS构建触发器具有另一个<a href="configuring-vcs-triggers.html#Trigger-a-build-on-changes-in-snapshot-dependencies">选项</a> ，可以更改构建链的触发行为。启用此选项后，即使在依赖关系中（而非最终构建中）检测到更改，也会触发整个构建链。</p><p id="1010318c">让我们从示例中构建一条链： <code class="code">pack setup</code> - 依赖于取决于 - <code class="code">tests</code> - 依赖于取决于 - <code class="code">compile</code> 。</p><p id="7c0ad5b8"></p><figure><img alt="编译测试包" title="编译测试包" src="/help/img/teamcity/2019.1/compile-test-pack.png" id="6a5b4f15" width="300" height="161"></figure><p></p><p id="bae8df4f">在VCS触发器中设置<code class="code">pack setup</code>配置时，通常会在TeamCity检测到更改时触发整个构建链<code class="code">pack setup</code> ;改变在<code class="code">compile</code>将触发<code class="code">compile</code>仅而非整个链条。如果您希望整个链在VCS更改时被触发<code class="code">compile</code> ，添加VCS触发器，并在链的最终构建配置中启用“ <i id="1cd61fcf">在快照依赖</i> <a href="configuring-vcs-triggers.html#Trigger-a-build-on-changes-in-snapshot-dependencies">项的</a> <i id="1cd61fcf">更改时触发</i> ” <a href="configuring-vcs-triggers.html#Trigger-a-build-on-changes-in-snapshot-dependencies">选项</a> ， <code class="code">pack setup</code> 。如果快照依赖项中的任何一个发生更改，这将不会更改生成的执行顺序，只会触发整个构建链。在此设置中，不需要任何VCS触发器<code class="code">compile</code>要么<code class="code">tests</code>构建配置。</p><p id="b7c3d416"><a name="show-changes-from-dependencies"></a><a name="BuildDependenciesSetup-show-changes-from-dependencies"></a></p><p id="6fb64c46"><b id="e6356f35">依赖关系的变化</b></p><p id="cc804b07">对于具有快照依赖项的构建配置，您可以启用传递性显示这些依赖项的更改。该设置称为“ <i id="39d7783d">显示快照依赖关系中的更改</i> ”，并且在构建配置管理页面的“版本控制设置”步骤的高级选项中可用。</p><p id="716593f5">启用此设置会影响构建配置的暂挂更改，构建历史记录，更改日志和发布日志中的更改。依赖项的更改标记为<img alt="deps_changes_marker.gif" title="deps_changes_marker.gif" src="/help/img/teamcity/2019.1/deps_changes_marker.gif" id="c5dc4bd2" width="16" height="16" class="inline-icon-16"> 。例如：</p><p id="08d54343"></p><figure><img alt="更改弹出" title="更改弹出" src="/help/img/teamcity/2019.1/changes_popup.png" id="e4b584d4" width="350" height="226"></figure><p></p><p id="a0ac7477">启用此设置后，带有“仅在有待处理的更改时才生成<a href="configuring-schedule-triggers.html">触发器</a> ”的“ <a href="configuring-schedule-triggers.html">计划触发器</a> ”选项也将考虑依赖项的更改。</p></div><a name="Parametersindependentbuilds"></a><a name="Parameters-in-dependent-builds"></a><div class="chapter"><h4 id="BuildDependenciesSetup-Parametersindependentbuilds">依赖版本中的参数</h4><p id="2e8b7877">TeamCity提供了使用当前构建所依赖的构建所提供的属性的功能（通过快照或工件依赖性）。当构建A依赖于构建B时，您可以将属性从构建B传递到构建A，即，属性只能沿构建链流的方向传递，反之亦然。<br>有关如何使用以前的内置链中的参数的详细信息，请参阅“ <a href="predefined-build-parameters.html#Dependencies-Properties">依赖项属性”</a>部分。</p></div></div></div><a name="MiscellaneousNotesonUsingDependencies"></a><a name="Miscellaneous-Notes-on-Using-Dependencies"></a><div class="chapter"><h2 id="BuildDependenciesSetup-MiscellaneousNotesonUsingDependencies">有关使用依赖项的其他说明</h2><p id="ee0813a7"><b id="dec5e2c2">建立链条和清理</b></p><p id="6d8c4205">默认情况下，TeamCity会保留清理链中的构建，但您可以关闭该选项。有关更多详细信息，请参阅<a href="clean-up.html">清理</a>说明。</p><p id="0c4dcfdb"><b id="1e052ae8">工件依赖和清理</b></p><p id="4f819e42">如果工件是由其他内部版本下载的，而这些内部版本尚未清除，则可能无法<a href="clean-up.html">清除</a>它们。对于具有配置的工件依赖关系的构建配置，可以指定是否可以清除此配置从其他构建下载的工件。此设置在<a href="clean-up.html">清理策略</a>页面上可用。</p><hr id="e04b7f4a"></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>