<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><title>工件依赖关系-帮助|帮助团队城市</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v2/app.css"></head><body  data-id="Artifact Dependencies" data-breadcrumbs="teamcity-documentation.md|TeamCity Documentation/administrator-s-guide.md|Administrator's Guide/managing-projects-and-build-configurations.md|Managing Projects and Build Configurations/creating-and-editing-build-configurations.md|Creating and Editing Build Configurations/configuring-dependencies.md|Configuring Dependencies/artifact-dependencies.md|Artifact Dependencies" data-main-title="Artifact Dependencies" data-edit-url="https://github.com/JetBrains/teamcity-documentation/edit/2019.1/topics/artifact-dependencies.md"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索TeamCity帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>TeamCity 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="artifact-dependencies.md" data-toc="Artifact Dependencies">工件依赖</h1><p id="89b36bf3">此页面详细说明TeamCity <a href="dependent-build.html#Artifact-Dependency">工件依赖项的</a>配置。</p><p id="5f2d60f4">在此页：</p><p id="b6e70263"></p><ul class="list" data-skip-index="skip"><li class="list__item"><a href="#ArtifactDependencies-ConfiguringArtifactDependenciesUsingWebUI">使用Web UI配置工件依赖关系</a></li><li class="list__item"><a href="#ArtifactDependencies-ConfiguringArtifactDependenciesUsingAntBuildScript">使用Ant构建脚本配置工件依赖项</a></li><li class="list__item"><a href="#ArtifactDependencies-Build-levelauthentication">构建级别认证</a></li></ul><p></p><p id="f079bada"><b id="b2966516">构建配置设置|依存关系| “工件依赖性”</b>部分允许配置依赖性。使用工件依赖项列表最后一列中的相应选项，可以临时或永久禁用配置的依赖项。</p><a name="ConfiguringArtifactDependenciesUsingWebUI"></a><a name="Configuring-Artifact-Dependencies-Using-Web-UI"></a><div class="chapter"><h2 id="ArtifactDependencies-ConfiguringArtifactDependenciesUsingWebUI">使用Web UI配置工件依赖关系</h2><p id="193eae7f"><b id="14286187">要将构件依赖项添加到构建配置中：</b></p><ol class="list _decimal"><li class="list__item" id="39abd965"><p><a href="creating-and-editing-build-configurations.html">创建/编辑构建配置时</a> ，请打开“ <b id="fa62985e">依赖关系”</b>页面。</p></li><li class="list__item" id="f53877ee"><p>单击<b id="886afb19">添加新工件依赖项</b>链接并指定以下设置：</p></li></ol><div class="table-wrapper"><table width="100%" id="3bbf7d63"><thead><tr id="22e1c7fb" class="ijRowHead"><th id="b9d068a7"><p id="f218dff1">选项</p></th><th id="b6bc0d0a"><p id="516cc962">描述</p></th></tr></thead><tbody><tr id="20197afb" class="ijRowOdd"><td id="3807090c"><p id="a292970c">取决于</p></td><td id="4de069f5"><p id="3b3bc50b">为当前的构建配置指定构建配置。可以在相同构建配置的先前构建上配置依赖项。</p></td></tr><tr id="685ac23d" class="ijRowEven"><td id="ce8a0f0a"><p id="9d60864a">从获取文物</p></td><td id="e53690e2"><p id="0de02b79">指定要获取工件的构建的类型：上次成功构建，上一次<a href="pinned-build.html">固定的构建</a> ，上一次完成的构建，从同一链进行的构建（当您具有<a href="snapshot-dependencies.html">快照依赖性</a>并希望从具有相同的来源），具有特定内部版本号的构建或具有指定标签的最后完成的内部版本。</p><aside class="note " rel="0de02b79" id="50b85ffd" data-title=""><ul class="list _ul"><li class="list__item" id="29438790"><p>选择构建配置时，请考虑您的<a href="clean-up.html">清理策略设置</a> 。<br>定期清理和删除内部版本，因此内部版本配置可能依赖于不存在的内部版本。如果从具有特定编号的构建中获取工件，则在清理过程中不会删除该特定构建。</p></li><li class="list__item" id="af249f9f"><p>如果为构建配置配置了对最后完成的构建的按源依赖性和对工件的依存性，那么将从具有相同源的构建中获取工件。</p></li></ul></aside></td></tr><tr id="2ddfeb9c" class="ijRowOdd"><td id="3f2fb562"><p id="95ccec89">内部编号</p></td><td id="3d0e08db"><p id="8ddda38c"><i id="b3f9e101">如果</i> <i id="d57ae7b1">在“</i> <i id="1b844b4a"><b id="3941630d">从获取工件”</b></i> <i id="9f708d31">列表中</i> <i id="b3f9e101">选择了</i> <i id="16c3802b"><b id="6a092c35">具有特定内部版本号的内部版本，</b></i> <i id="b3f9e101">则会出现此字段</i> 。<br>在此指定工件的确切内部<a href="configuring-general-settings.html#Build-Number-Format">版本号</a> 。</p></td></tr><tr id="326fb586" class="ijRowEven"><td id="dd247c19"><p id="0cac2b7a">构建标签</p></td><td id="774fbf22"><p id="f359b10b"><i id="4df7604e">如果</i> <i id="05a777ac">在“</i> <i id="ee0d8895"><b id="1e1ba6d5">从获取工件”</b></i> <i id="b0ce9fa7">列表中</i> <i id="4df7604e">选择</i> <i id="406bb001"><b id="a443104a">了带有指定标签的最后完成的构建，</b></i> <i id="4df7604e">则会显示此字段</i> 。<br>在此处指定要使用工件的构建的标记。解决依赖关系时，TeamCity将使用给定的标签查找最后一次成功的构建并使用其构件。</p></td></tr><tr id="78fe85c4" class="ijRowOdd"><td id="4a80f693"><p id="3b4570be">建立分支</p></td><td id="91f6b874"><p id="b5edbab8"><i id="24ce7b39">如果依赖项具有在VCS Root设置中<a href="working-with-feature-branches.html#Configuring-branches">指定</a>的<a href="working-with-feature-branches.html#Configuring-branches">分支，</a>则会显示此字段</i> 。允许设置<a href="working-with-feature-branches.html">分支</a>以将源构建限制为仅包含分支的构建。如果未指定，则使用默认分支。将使用逻辑分支名称（在构建的UI中显示）。不支持模式。</p></td></tr><tr id="0103a4f3" class="ijRowEven"><td id="ea319caa"><p id="fd61f599">工件规则</p></td><td id="8016ccc1"><p id="4e12fee0">在这里，您可以指定要下载的源构建的工件，以及在从属构建开始之前将其下载到的代理上的位置。</p><p id="3e88771b">换行符分隔的规则集。每个规则必须具有以下语法：</p><p id="72e8c19a"><code class="code">[+:|-:]SourcePath[!ArchivePath][=>DestinationPath]</code></p><p id="dd79576f">每个规则都指定要从“源”构建中下载的文件。<i id="521fd93d">SourcePath</i>应该相对于“源”构建的工件目录。该路径可以标识特定的文件，目录，也可以使用通配符来匹配多个文件。支持<a href="wildcards.html">类似Ant的通配符</a> 。<br>下载的工件将保持“源”目录结构从第一个开始<code class="code">*</code>要么<code class="code">?</code> 。<br><i id="05fcef7e">DestinationPath</i>在代理上指定要放置已下载工件的目标目录。如果路径是相对路径（建议使用），则将根据构建签出目录进行解析。如果需要，可以在下载工件之前清理目标目录。如果目标路径为空，则工件将直接下载到结帐根目录。</p><p id="2a62a95a">基本示例：</p><ul class="list _ul"><li class="list__item" id="4cfa61c2"><p>使用<code class="code">a/b/**=>lib</code>从下载所有文件<code class="code">a/b</code>源构建的目录到<code class="code">lib</code>目录。如果有<code class="code">a/b/c/file.txt</code>源构建工件中的文件，它将被下载到文件中<code class="code">lib/c/file.txt</code> 。</p></li><li class="list__item" id="222f396b"><p>同时，工件依赖<code class="code">**/*.txt=>lib</code>将保留目录结构： <code class="code">a/b/c/file.txt</code>来自源构建工件的文件将下载到<code class="code">lib/a/b/c/file.txt</code> 。</p></li></ul><p id="c823fc9a"><i id="80f6970b">ArchivePath</i>用于提取下载的<a href="configuring-general-settings.html#Artifact-Paths">压缩</a>工件。支持Zip，7-zip，jar，tar和tar.gz。<br><i id="43b9acc9">ArchivePath</i>遵循<i id="53eca667">SourcePath的</i>一般规则：允许使用类似ant的通配符，存档中匹配的文件将放置在与第一个通配符匹配相对应的目录中（相对于目标路径）<br>例如： <code class="code">release.zip!*.dll</code>该命令将提取位于根目录下的所有.dll文件<code class="code">release.zip</code>神器。</p><p id="4922915a">存档处理示例：</p><ul class="list _ul"><li class="list__item" id="34155ca2"><p><code class="code">release-*.zip!*.dll=>dlls</code>将从所有符合以下条件的档案中提取* .dll： <code class="code">release-*.zip</code>模式的<code class="code">dlls</code>目录。</p></li><li class="list__item" id="d8dcbeaa"><p><code class="code">a.zip!**=>destination</code>将解压整个档案，保存路径信息。</p></li><li class="list__item" id="b599fc20"><p><code class="code">a.zip!a/b/c/**/*.dll=>dlls</code>将从中提取所有.dll文件<code class="code">a/b/c</code>及其子目录<code class="code">dlls</code>目录，不带<code class="code">a/b/c</code>字首。</p></li></ul><p id="73f9223a"><code class="code">+:</code>和<code class="code">-:</code>可用于包含或排除特定文件的下载或解压缩。如<code class="code">+:</code>前缀可以省略：规则默认为包含式，并且至少需要一个包含式。规则的顺序并不重要。对于每个工件，将应用最特定的规则（第一个通配符之前的前缀最长的规则）。排除文件时，将忽略<i id="ebce7f26">DestinationPath</i> ：根本不会下载该文件。文件也可以从解压缩文件中排除。应用于归档内容的规则集由归档本身匹配的规则集确定。</p><p id="d633aed0">专用模式示例：</p><ul class="list _ul"><li class="list__item" id="24d3bd74"><p><code class="code">**/*.txt=>texts</code><br><code class="code">-:bad/exclude.txt</code>将从所有目录下载所有* .txt文件，不包括<code class="code">exclude.txt</code>来自<code class="code">bad</code>目录</p></li><li class="list__item" id="73bd9c97"><p><code class="code">+:release-*.zip!**/*.dll=>dlls</code><code class="code">-:release-0.0.1.zip!Bad.dll</code>将从以下位置下载并解压缩所有dll <code class="code">release-*.zip</code>文件到<code class="code">dlls</code>目录。的<code class="code">Bad.dll</code>来自的文件<code class="code">release-0.0.1.zip</code>将被跳过</p></li><li class="list__item" id="190d078f"><p><code class="code">**/*.*=>target</code><br><code class="code">-:excl/**/*.*</code><br><code class="code">+:excl/must_have.txt=>target</code>将所有工件下载到<code class="code">target</code>目录。不会从<code class="code">excl</code>目录，但文件名为<code class="code">must_have.txt</code></p></li></ul><aside class="tip sideblock" rel="413c65a8" id="db9b2495" data-title=""><p id="1cc55d61">点击<img alt="ArtifactsBrowserIcon.png" title="ArtifactsBrowserIcon.png" src="/help/img/teamcity/2019.1/ArtifactsBrowserIcon.png" id="8fcf3b7b" width="19" height="23" class="inline-icon-19">图标以调用工件浏览器。TeamCity将尝试根据指定的设置定位工件，并将其显示在树中。从树中选择所需的工件，TeamCity将把它们的路径放入输入字段中。</p></aside><p id="9fbd9a0a">放置在<code class="code">.teamcity</code>目录被认为是<a href="build-artifact.html#Hidden-Artifacts">隐藏的</a> 。默认情况下，通配符会忽略这些工件。<br>如果您要包含来自<code class="code">.teamcity</code>出于任何目的的目录，请确保添加以以下内容开头的工件路径<code class="code">.teamcity</code>明确地。</p><p id="90dc34db">访问隐藏工件的示例：</p><ul class="list _ul"><li class="list__item" id="cdfde2fa"><code class="code">.teamcity/properties/*.properties</code></li><li class="list__item" id="52c06bff"><code class="code">.teamcity/*.*</code></li></ul><p id="bb76c31e">默认情况下，允许将工件依赖项下载到<a href="agent-work-directory.html">代理工作目录</a> ，而禁止将<a href="agent-home-directory.html">代理主目录下载</a> 。要覆盖默认设置，请通过在指定的逗号分隔路径中设置自定义规则来下载工件。 <a href="build-agent-configuration.html"><code class="code">buildAgent.properties</code></a> ： <code class="code">teamcity.artifactDependenciesResolution.blackList</code>和<code class="code">teamcity.artifactDependenciesResolution.whiteList</code> 。将路径列入黑名单，除非将其列入白名单，否则禁止将工件下载到该目录。</p></td></tr><tr id="70c9b886" class="ijRowOdd"><td id="62914b25"><p id="3cb6400d">下载工件之前清理目标路径</p></td><td id="a0718334"><p id="3695cd66">在复制工件之前，请选中此选项以删除目标目录的内容。它将适用于所有包容性规则</p></td></tr></tbody></table></div><p id="c4e970a9">您可以随时启动具有<a href="triggering-a-custom-build.html#Promoting-Build">自定义工件依赖项</a>的构建。</p></div><a name="ConfiguringArtifactDependenciesUsingAntBuildScript"></a><a name="Configuring-Artifact-Dependencies-Using-Ant-Build-Script"></a><div class="chapter"><h2 id="ArtifactDependencies-ConfiguringArtifactDependenciesUsingAntBuildScript">使用Ant构建脚本配置工件依赖项</h2><p id="529f9031">本节描述如何在构建脚本中下载TeamCity构建工件。这些说明还可以用于从TeamCity外部下载工件。</p><p id="85a01e1f">为了处理构建之间的工件依赖关系，该解决方案比在TeamCity UI中配置依赖关系要复杂得多，但可以提供更大的灵活性。例如，以这种方式管理依赖项将允许您启动个人构建并验证您的构建仍与依赖项兼容。</p><p id="c87bdce7"><b id="a4a76176">通过Ant构建脚本配置依赖项：</b></p><p id="0c27ea21">1。下载常春藤。</p><aside class="tip sideblock" rel="0c27ea21" id="9758a206" data-title=""><p id="a15c2903">TeamCity本身充当常春藤存储库。您可以<a href="http://ant.apache.org/ivy/" rel="noopener noreferrer" data-external="true" target="_blank">在此处</a>阅读有关Ivy依赖项管理器的更多信息。</p></aside><p id="0e258a59">2。将Ivy添加到构建的类路径中。</p><p id="5b1b5e28">3。创建<code class="code">ivyconf.xml</code>文件，其中包含有关TeamCity存储库的一些元信息。该文件具有以下内容：</p><div class="code-block" data-lang="markup">
<ivysettings>
<property name="ivy.checksums" value=""></property>
<caches defaultcache="${teamcity.build.tempDir}/.ivy/cache"></caches>
<statuses>
    <status name="integration" integration="true"></status>
</statuses>
<resolvers>
    <url name="teamcity-rep" alwayscheckexactrevision="yes" checkmodified="true">
        <ivy pattern="http://YOUR_TEAMCITY_HOST_NAME/httpAuth/repository/download/[module]/[revision]/teamcity-ivy.xml"></ivy>
        <artifact pattern="http://YOUR_TEAMCITY_HOST_NAME/httpAuth/repository/download/[module]/[revision]/[artifact](.[ext])"></artifact>
    </url>
</resolvers>
<modules>
    <module name=".*" organisation=".*" matcher="regexp" resolver="teamcity-rep"></module>
</modules>
</ivysettings>

</div><p id="e64bd8c9">4。更换<code class="code">YOUR_TEAMCITY_HOST_NAME</code>使用您的TeamCity服务器的主机名。</p><p id="708bdb4e">5，地点<code class="code">ivyconf.xml</code>在您的目录中<code class="code">build.xml</code>将运行。</p><p id="edbe557c">6。在同一目录中创建<code class="code">ivy.xml</code>定义要下载哪些工件以及将它们放置在何处的文件，例如：</p><div class="code-block" data-lang="markup"><ivy-module version="1.3">
  <info organisation="YOUR_ORGANIZATION" module="YOUR_MODULE"></info>
  <dependencies>
    <dependency name="BUILD_TYPE_EXT_ID" org="org" rev="BUILD_REVISION">
      <include name="ARTIFACT_FILE_NAME_WITHOUT_EXTENSION" ext="ARTIFACT_FILE_NAME_EXTENSION" matcher="exactOrRegexp"></include>
    </dependency>
  </dependencies>
</ivy-module>

</div><p id="c6cfcb70">哪里：</p><ul class="list _ul"><li class="list__item" id="5ad19a9a"><p><code class="code">YOUR_ORGANIZATION</code>替换为您的组织名称。</p></li><li class="list__item" id="f74a9a0b"><p><code class="code">YOUR_MODULE</code>用将使用工件的项目或模块的名称替换。</p></li><li class="list__item" id="701145f5"><p><code class="code">BUILD_TYPE_EXT_ID</code>用下载了工件的构建配置的<a href="build-configuration.html#Status-Display-for-Set-of-Build-Configurations">外部ID</a>替换。</p></li><li class="list__item" id="49490386"><code class="code">BUILD_REVISION</code>可以是内部版本号或以下字符串之一：*<code class="code">latest.lastFinished</code><ul class="list _ul"><li class="list__item" id="ad0026bf"><code class="code">latest.lastSuccessful</code></li><li class="list__item" id="66c410e8"><code class="code">latest.lastPinned</code></li></ul></li><li class="list__item" id="a8c68773"><p><code class="code">TAG_NAME.tcbuildtag</code> -使用TAG_NAME标签标记的最新版本</p></li></ul><ul class="list _ul"><li class="list__item" id="f866da15"><p><code class="code">ARTIFACT_FILE_NAME_WITHOUT_EXTENSION</code>没有扩展名部分的工件的文件名或正则表达式。</p></li><li class="list__item" id="7ba447e9"><p><code class="code">ARTIFACT_FILE_NAME_EXTENSION</code>工件文件名的扩展部分。</p></li></ul><p id="fb48f95b">7。修改您的<code class="code">build.xml</code>文件并添加用于下载工件的任务，例如（适用于Ant 1.6及更高版本）：</p><div class="code-block" data-lang="markup">< <target name="fetchArtifacts" description="Retrieves artifacts for TeamCity" xmlns:ivy="antlib:org.apache.ivy.ant"><taskdef uri="antlib:org.apache.ivy.ant" resource="org/apache/ivy/ant/antlib.xml"></taskdef> <classpath><pathelement location="${basedir}/lib/ivy-2.0.jar"></pathelement><pathelement location="${basedir}/lib/commons-httpclient-3.0.1.jar"></pathelement><pathelement location="${basedir}/lib/commons-logging.jar"></pathelement><pathelement location="${basedir}/lib/commons-codec-1.3.jar"></pathelement></classpath> <ivy:configure file="${basedir}/ivyconf.xml"></ivy:configure> <!--<ivy:cleancache />--> <ivy:retrieve pattern="${basedir}/[artifact].[ext]"></ivy:retrieve></target>

</div><aside class="note " rel="ac3c9932" id="ac4a7f97" data-title=""><ul class="list _ul"><li class="list__item" id="ff7c01fc"><p><code class="code">commons-httpclient</code> ， <code class="code">commons-logging</code>和<code class="code">commons-codec</code>要在<code class="code">classpath</code>常春藤任务。</p></li><li class="list__item" id="a0648b1f"><p>要在检索依赖项之前清理常春藤缓存目录，请取消注释<code class="code"><ivy:cleancache /></code>上例中的元素。</p></li></ul></aside><p id="e42db7a0">工件存储库受基本身份验证的保护。要访问工件，您需要向凭证提供凭证。 <ivy:configure></ivy:configure>任务。例如：</p><div class="code-block" data-lang="markup"><ivy:configure file="${basedir}/ivyconf.xml" host="TEAMCITY_HOST" realm="TeamCity" username="USER_ID" passwd="PASSWORD"></ivy:configure>

</div><p id="417d51d8">哪里<code class="code">TEAMCITY_HOST</code>是TeamCity服务器的主机名或IP地址（无端口和Servlet上下文）。<br>如<code class="code">USER_ID/PASSWORD</code>您可以使用普通TeamCity用户的用户名/密码（该用户应具有相应的权限来访问源构建配置的工件）或系统属性<code class="code">teamcity.auth.userId/teamcity.auth.password</code> 。</p></div><a name="Build-levelauthentication"></a><a name="Build-level-authentication"></a><div class="chapter"><h2 id="ArtifactDependencies-Build-levelauthentication">构建级别认证</h2><p id="2d9d87b8">系统属性<code class="code">teamcity.auth.userId</code>和<code class="code">teamcity.auth.password</code>存储自动生成的生成唯一性值，可用于在TeamCity服务器上进行身份验证。这些值仅在构建运行期间有效。该生成的用户具有有限的权限，该权限允许进行与构建相关的操作。用户的主要目的是使用身份验证从构建脚本中的其他TeamCity构建中下载工件。</p><p id="d44f590b">使用属性比使用真实用户凭据更可取，因为使用该属性，服务器可以跟踪构建所下载的工件。如果工件是通过构建配置工件依赖项或使用提供的属性下载的，则构建使用的特定工件将显示在构建结果页面的“ <b id="d18b80d9">依赖关系”</b>选项卡上。另外，可以将用来获取工件的构建配置为具有不同的<a href="clean-up.html">清理</a>逻辑。</p><hr id="40423e74"><p id="20d00a4c"><b id="2bd60c51">也可以看看：</b></p><p id="5b9ac5f6"><b id="f634d8ba">概念</b> ： <a href="dependent-build.html">依赖构建</a></p><hr id="da3f6d60"></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>