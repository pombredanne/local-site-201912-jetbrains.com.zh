<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v2/analytics.js"></script><title>REST API-帮助|帮助团队城市</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v2/app.css"></head><body  data-id="REST API" data-breadcrumbs="teamcity-documentation.md|TeamCity Documentation/extending-teamcity.md|Extending TeamCity/rest-api.md|REST API" data-main-title="REST API" data-edit-url="https://github.com/JetBrains/teamcity-documentation/edit/2019.1/topics/rest-api.md"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索TeamCity帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>TeamCity 2019.1帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="rest-api.md" data-toc="REST API">REST API</h1><p id="222b67b7"></p><ul class="list" data-skip-index="skip"><li class="list__item"><a href="#RESTAPI-Generalinformation">一般信息</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-GeneralUsagePrinciples">一般用法原则</a></li><li class="list__item"><a href="#RESTAPI-RESTAuthentication">REST认证</a></li><li class="list__item"><a href="#RESTAPI-Superuseraccess">超级用户访问</a></li><li class="list__item"><a href="#RESTAPI-RESTAPIVersions">REST API版本</a></li><li class="list__item"><a href="#RESTAPI-URLStructure">网址结构</a></li><li class="list__item"><a href="#RESTAPI-Locator">定位器</a></li><li class="list__item"><a href="#RESTAPI-SupportedHTTPMethods">支持的HTTP方法</a></li></ul></li><li class="list__item"><a href="#RESTAPI-ResponseFormats">回应格式</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-FullandPartialResponses">全部和部分回复</a></li><li class="list__item"><a href="#RESTAPI-Logging">记录中</a></li><li class="list__item"><a href="#RESTAPI-CORSSupport">CORS支持</a></li><li class="list__item"><a href="#RESTAPI-APIClientRecommendations">API客户端建议</a></li></ul></li><li class="list__item"><a href="#RESTAPI-TeamCityDataEntitiesRequests">TeamCity数据实体请求</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-ProjectsandBuildConfiguration/TemplatesLists">项目和构建配置/模板列表</a></li><li class="list__item"><a href="#RESTAPI-ProjectSettings">项目设定</a></li><li class="list__item"><a href="#RESTAPI-ProjectFeatures">项目特色</a></li><li class="list__item"><a href="#RESTAPI-VCSRoots">VCS根</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-VCSrootinstancelocator">VCS根实例定位器</a></li></ul></li><li class="list__item"><a href="#RESTAPI-BuildConfigurationAndTemplateSettings">构建配置和模板设置</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-BuildConfigurationLocator">构建配置定位器</a></li></ul></li><li class="list__item"><a href="#RESTAPI-BuildRequests">生成请求</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-BuildLocator">生成定位器</a></li><li class="list__item"><a href="#RESTAPI-QueuedBuilds">排队构建</a></li><li class="list__item"><a href="#RESTAPI-TriggeringaBuild">触发构建</a></li><li class="list__item"><a href="#RESTAPI-Buildnodeexample">构建节点示例</a></li><li class="list__item"><a href="#RESTAPI-BuildTags">构建标签</a></li><li class="list__item"><a href="#RESTAPI-BuildPinning">构建固定</a></li><li class="list__item"><a href="#RESTAPI-BuildCanceling/Stopping">构建取消/停止</a></li><li class="list__item"><a href="#RESTAPI-BuildArtifacts">建立文物</a></li><li class="list__item"><a href="#RESTAPI-Authentication">认证方式</a></li><li class="list__item"><a href="#RESTAPI-OtherBuildRequests">其他构建请求</a></li><li class="list__item"><a href="#RESTAPI-Changes">变化</a></li><li class="list__item"><a href="#RESTAPI-Revisions">修订版</a></li><li class="list__item"><a href="#RESTAPI-Snapshotdependencies">快照依存关系</a></li><li class="list__item"><a href="#RESTAPI-Artifactdependencies">工件依赖</a></li><li class="list__item"><a href="#RESTAPI-BuildParameters">构建参数</a></li><li class="list__item"><a href="#RESTAPI-BuildFields">建造领域</a></li><li class="list__item"><a href="#RESTAPI-Statistics">统计</a></li><li class="list__item"><a href="#RESTAPI-BuildLog">构建日志</a></li></ul></li><li class="list__item"><a href="#RESTAPI-TestsandBuildProblems">测试和构建问题</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-MutedTestsandBuildProblems">静音测试和构建问题</a></li></ul></li><li class="list__item"><a href="#RESTAPI-Investigations">调查</a></li><li class="list__item"><a href="#RESTAPI-Agents">代理商</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-AgentPools">代理商池</a></li><li class="list__item"><a href="#RESTAPI-AssigningProjectstoAgentPools">将项目分配到座席池</a></li></ul></li><li class="list__item"><a href="#RESTAPI-Users">用户数</a></li><li class="list__item"><a href="#RESTAPI-UserGroups">用户组</a></li><li class="list__item"><a href="#RESTAPI-UserAccessTokens">用户访问令牌</a></li><li class="list__item"><a href="#RESTAPI-AuditRecords">审核记录</a></li></ul></li><li class="list__item"><a href="#RESTAPI-Other">其他</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-DataBackup">数据备份</a></li><li class="list__item"><a href="#RESTAPI-TypedParametersSpecification">类型参数规格</a></li><li class="list__item"><a href="#RESTAPI-BuildStatusIcon">生成状态图标</a></li><li class="list__item"><a href="#RESTAPI-TeamCityLicensingInformationRequests">TeamCity许可信息请求</a></li><li class="list__item"><a href="#RESTAPI-CCTray">CCTray</a></li></ul></li><li class="list__item"><a href="#RESTAPI-RequestExamples">索取范例</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-RequestSendingTool">请求发送工具</a><ul class="list _bullet"><li class="list__item"><a href="#RESTAPI-Creatinganewproject">创建一个新项目</a></li><li class="list__item"><a href="#RESTAPI-Makinguserasystemadministrator">使用户成为系统管理员</a></li></ul></li></ul></li></ul><p></p><a name="Generalinformation"></a><a name="General-information"></a><div class="chapter"><h2 id="RESTAPI-Generalinformation">一般信息</h2><p id="350aabc9">REST API是<b id="35d90ec1">自TeamCity 5.0以来</b>捆绑提供的开源<a href="https://github.com/JetBrains/teamcity-rest" rel="noopener noreferrer" data-external="true" target="_blank">插件</a> 。</p><p id="cca440a2">要使用REST API，应用程序会向TeamCity服务器发出HTTP请求并解析响应。</p><p id="0a4a87f5">TeamCity REST API可用于将应用程序与TeamCity集成，以及用于那些希望编写与TeamCity服务器交互的脚本的人。TeamCity的REST API允许通过URL路径访问资源（实体）。</p><aside class="tip sideblock" rel="0a4a87f5" id="1e31bfa1" data-title=""><p id="5fa1e1ba">此页面上的URL示例假定您可以通过<a href="http://teamcity:8111" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111</a> URL访问TeamCity服务器的Web UI。</p></aside><a name="GeneralUsagePrinciples"></a><a name="General-Usage-Principles"></a><div class="chapter"><h3 id="RESTAPI-GeneralUsagePrinciples">一般用法原则</h3><p id="a894c859">本文档不是完整的指南，只会提供一些对使用API有用的初步知识。</p><p id="47e2382a">您可以通过在浏览器中打开<a href="http://teamcity:8111/app/rest/server" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server</a> URL开始：此页面将为您提供一些探索API的指针。</p><p id="2327390c">使用<a href="http://teamcity:8111/app/rest/application.wadl" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / application.wadl</a>获取受支持的请求和参数名称的完整列表。这是发现受支持请求及其参数的主要来源。同样的数据也通过<a href="https://swagger.io/tools/open-source/getting-started/" rel="noopener noreferrer" data-external="true" target="_blank">Swagger</a>格式通过<a href="http://teamcity:8111/app/rest/swagger.json" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / swagger.json</a>端点<a href="http://teamcity:8111/app/rest/swagger.json" rel="noopener noreferrer" data-external="true" target="_blank">公开</a> 。</p><p id="694fd562">确保在使用API之前通读本节。</p><p id="3769cc44">有关错误响应中包含的支持的<a href="#Locator">定位器尺寸</a>的列表，请使用<code class="code">$help</code>定位器。</p><p id="87885313">实验并阅读返回的错误消息：在大多数情况下，它们应该引导您提出正确的请求。</p><p id="233ed0f8">假设您想进一步了解代理商，并在<code class="code">/app/rest/server</code>回应） <code class="code">/app/rest/agents</code>网址。</p><ul class="list _ul"><li class="list__item" id="07836ba9"><p>尝试<code class="code">/app/rest/agents/</code>请求-查看授权代理列表，获取<code class="code">default</code>通过代理元素链接到代理的方式<code class="code">href</code>属性。</p></li><li class="list__item" id="763a43e3"><p>通过获取单个代理商的详细信息<code class="code">/app/rest/agents/id:10</code>网址（从<code class="code">href</code>用于上一个请求的元素之一）。</p></li><li class="list__item" id="32e3b88c"><p>如果您将请求发送给<code class="code">/app/rest/agents/$help</code> ， 要么<code class="code">/app/rest/agents/aaa:bbb</code> （提供不受支持的定位器维度），您将获得支持的维度列表，以通过业务代表的<a href="#Locator">定位器</a>查找业务代表。</p></li><li class="list__item" id="0feca347"><p>返回的座席数据的大多数属性（ <code class="code">name</code> ， <code class="code">connected</code> ， <code class="code">authorized</code> ）可以用作<code class="code"><field name></code>在里面<code class="code">app/rest/agents/<agentLocator>/<field name></code>请求。此外，如果您向<code class="code">app/rest/agents/id:10/test</code> URL，您将在错误消息中获得受支持字段的列表。</p></li></ul></div><a name="RESTAuthentication"></a><a name="REST-Authentication"></a><div class="chapter"><h3 id="RESTAPI-RESTAuthentication">REST认证</h3><p id="c2490ae3">您可以通过以下方式对REST API进行身份验证：</p><ul class="list _ul"><li class="list__item" id="a0806d09"><p>从<b id="4ac34f6f">Teamcity 2019.1开始</b> ，访问REST API的首选方法是使用<a href="configuring-authentication-settings.html#Token-Based-Authentication">基于令牌的HTTP身份验证</a> 。提供在“ <b id="e2a1e5a3">我的设置和工具” |“</b>生成”中生成的个人TeamCity访问令牌<b id="e2a1e5a3">。</b> HTTP标头中的<b id="e2a1e5a3">访问令牌</b> <code class="code">Authorization: Bearer <token-value></code> 。例如：</p><div class="code-block" data-lang="bash">curl --header“授权：承载<token-value>” http：// teamcity：8111 / app / rest / builds</token-value></div><p></p></li><li class="list__item" id="e5485a15"><p>使用基本的HTTP身份验证（使用某些身份验证可能会很慢，请参阅下文）。在请求中提供有效的TeamCity用户名和密码。您可以通过以下方式强制进行基本身份验证： <code class="code">httpAuth</code>之前<code class="code">/app/rest</code>部分，例如<a href="http://teamcity:8111/httpAuth/app/rest/builds" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / httpAuth / app / rest / builds</a> 。</p></li><li class="list__item" id="78e7413b"><p>以<a href="guest-user.html">访客用户</a>身份使用服务器访问权限（如果启用）包括<code class="code">guestAuth</code>之前<code class="code">/app/rest</code>部分，例如<a href="http://teamcity:8111/guestAuth/app/rest/builds" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / guestAuth / app / rest / builds</a> 。</p></li><li class="list__item" id="57621a06"><p>如果您正在检查REST <code class="code">GET</code>来自浏览器的请求，并且您已在浏览器中登录到TeamCity，则可以使用<code class="code">/app/rest</code> URL，例如<a href="http://teamcity:8111/app/rest/builds" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds。</a>当使用带有非内置模块的基本HTTP身份验证时，身份验证可能会很慢。如果要使用基本HTTP身份验证而不是基于令牌的身份验证，请考虑使用<a href="http://youtrack.jetbrains.com/issue/TW-14209#comment=27-485445" rel="noopener noreferrer" data-external="true" target="_blank">会话重用方法</a>在顺序请求之间重用身份验证。</p></li></ul><p id="dbb0d01c">如果您在TeamCity构建中执行请求，则对于有限的与构建相关的操作集（例如下载工件），可以使用以下值： <a href="artifact-dependencies.html#Build-level-authentication"><code class="code">teamcity.auth.userId/teamcity.auth.password</code></a>系统属性作为基本凭据（在TeamCity设置中，您可以将其引用为<code class="code">%system.teamcity.auth.userId%</code>和<code class="code">%system.teamcity.auth.password%</code> ）。</p><p id="6c23c202">在内部版本中，对当前内部版本详细信息的请求如下所示：</p><div class="code-block" data-lang="bash">curl -u“％system.teamcity.auth.userId％：％system.teamcity.auth.password％”“％teamcity.serverUrl％/ httpAuth / app / rest / builds / id：％teamcity.build.id％”</div></div><a name="Superuseraccess"></a><a name="Superuser-access"></a><div class="chapter"><h3 id="RESTAPI-Superuseraccess">超级用户访问</h3><p id="f0409e84">您可以将<a href="super-user.html">超级用户帐户</a>与REST API结合使用：只需不提供用户名，并将生成的密码登录到服务器日志中即可。</p></div><a name="RESTAPIVersions"></a><a name="REST-API-Versions"></a><div class="chapter"><h3 id="RESTAPI-RESTAPIVersions">REST API版本</h3><p id="38909b30">随着REST API从一个TeamCity版本发展到另一个版本，协议中可能会有不兼容的更改。</p><p id="97979236">在<a href="http://teamcity:8111/app/rest/" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest /</a>或<a href="http://teamcity:8111/app/rest/latest" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / latest</a> URL下，可获得最新版本。在<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest /下<version></version></a>可以使用其他版本的URL。我们的总体政策是为TeamCity提供至少一个以前的版本。REST API协议版本是首次引入此协议的TeamCity版本。</p><p id="54c4fed5">例如，在TeamCity 2019.1中，您可以使用<code class="code">2018.1</code>代替<code class="code"><version></code>获取最新版本的REST API或<code class="code">2017.2</code> ， <code class="code">2017.1</code> ， <code class="code">10.0</code> ， <code class="code">9.1</code> ， <code class="code">9.0</code> ， <code class="code">8.1</code> ， <code class="code">8.0</code>获取该协议的早期版本。</p><p id="8c2c6138">有关API的重大更改，请参见相关的<a href="upgrade-notes.html">升级说明</a>部分。请注意，对返回对象的添加（例如新的XML属性或元素）不被视为主要更改，并且不会导致协议版本增加。此外，标有的端点<code class="code">Experimental</code>发表评论<code class="code">application.wadl</code>在将来的版本中可能会更改，恕不另行通知。</p><aside class="note " rel="8c2c6138" id="c54b71bb" data-title=""><p id="23896647">此页面上的示例使用<code class="code">/app/rest</code>相对网址；如有必要，将其替换为包含该版本的版本。</p></aside></div><a name="URLStructure"></a><a name="URL-Structure"></a><div class="chapter"><h3 id="RESTAPI-URLStructure">网址结构</h3><p id="16d57835">TeamCity API中URL的一般结构为<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcityserver：port / <authtype>/ app / rest / <apiversion>/ <restapipath>？<parameters></parameters></restapipath></apiversion></authtype></a></p><p id="23fc6125">哪里</p><ul class="list _ul"><li class="list__item" id="25173c87"><p><code class="code">teamcityserver</code>和<code class="code">port</code>定义服务器名称和TeamCity使用的端口。该页面使用<a href="http://teamcity:8111/" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 /</a>作为示例URL。</p></li><li class="list__item" id="05028b3e"><p><code class="code"><authType></code> （可选）是要使用的<a href="#REST-Authentication">身份验证类型</a> ，这是通用的TeamCity功能。</p></li><li class="list__item" id="1c108ce2"><p><code class="code">app/rest</code>是TeamCity REST API的根路径</p></li><li class="list__item" id="dbbc4e58"><p><code class="code"><apiVersion></code> （可选）是对特定版本的REST API的引用。</p></li><li class="list__item" id="797423dc"><p><code class="code"><restApiPath>?<parameters></code>是URL的REST API部分。<br>获取多个物品的典型方法是使用<code class="code"><restApiPath></code>以...的形式<code class="code">.../app/rest/<items></code> （例如， ” <code class="code">.../app/rest/builds</code> ”）。这些URL定期接受<a href="#Locator">locator</a>参数，该参数可以过滤返回的项目。个别项目可以通过以下形式的URL定期寻址： <code class="code">.../app/rest/<items>/<item_locator></code> 。该URL始终返回单个项目。如果<code class="code"><item_locator></code>定位器匹配多个项目，第一个返回。多个和单个项目请求均定期支持<a href="#Full-and-Partial-Responses">fields</a>参数。</p></li></ul></div><a name="Locator"></a><a name="Locator"></a><div class="chapter"><h3 id="RESTAPI-Locator">定位器</h3><p id="0122dd74">在许多地方，您可以指定一个过滤器字符串，该字符串定义在请求中要过滤/影响哪些实体。在REST API的范围内，此字符串表示形式称为“定位器”。</p><p id="d70c4c86">定位符格式可以是：</p><ul class="list _ul"><li class="list__item" id="6324bf1a"><p>单一值：不含以下符号的文本：<code class="code">,:-( )</code></p></li><li class="list__item" id="10c77e92"><p>维度，您可以使用多个条件过滤实体： <code class="code"><dimension1>:<value1>,<dimension2>:<value2>,<dimension3>:(<dimension3.1>:<value3.1>,<dimension3.2>:<value3.2>)</code>请注意，嵌套定位符应放在括号内。有关最受欢迎的定位符描述，请参考下面的每个实体描述。如果不确定特定定位器支持什么，请发送带有“ $ help”作为定位器值的请求。作为响应，您将获得有关定位器支持内容的文本描述。如果发送了带有无效定位符的请求，则错误消息通常会提示错误并列出支持的定位符尺寸。</p></li></ul><aside class="note " rel="d4efb54c" id="9311728e" data-title=""><p id="4a4abab5">如果单个值包含“，”符号，则应将其括在括号中： <code class="code">(<value>)</code> 。维度的值也可以编码为Base64url（RFC4648中的“ URL和文件名安全类型为base64”）并以<code class="code"><dimension>:($base64:<base64-encoded-value>)</code>代替<code class="code"><dimension>: <value></code> 。</p></aside><p id="c198892e">例子：</p><ul class="list _ul"><li class="list__item" id="d1fae2b2"><p>使用<a href="http://teamcity:8111/app/rest/projects" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects</a>获取项目列表。</p></li><li class="list__item" id="87d16f97"><p>使用<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectslocator></projectslocator></a> ，例如<a href="http://teamcity:8111/app/rest/projects/id:RESTAPIPlugin" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / id：RESTAPIPlugin</a> （使用示例ID）来获取REST API插件项目的完整数据。</p></li><li class="list__item" id="f319d3b9"><p>使用<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / id：bt284 / builds？locator = <buildlocator></buildlocator></a> ，例如<a href="http://teamcity:8111/app/rest/buildTypes/id:bt284/builds?locator=status:SUCCESS,tag:EAP" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / id：bt284 / builds？locator = status：SUCCESS，tag：EAP</a> （使用示例ID）来获取构建。</p></li><li class="list__item" id="870448d4"><p>使用<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds /？locator = <buildlocator></buildlocator></a>通过构建定位器获取构建。</p></li></ul></div><a name="SupportedHTTPMethods"></a><a name="Supported-HTTP-Methods"></a><div class="chapter"><h3 id="RESTAPI-SupportedHTTPMethods">支持的HTTP方法</h3><ul class="list _ul"><li class="list__item" id="3988d5fe"><p>GET：检索请求的数据。例如， <code class="code">.../app/rest/entities</code>通常会检索实体列表， <code class="code">.../app/rest/entities/<entity locator></code>检索单个实体</p></li><li class="list__item" id="c3b8ee2d"><p>POST：根据提交的有效负载创建实体。要创建新实体，通常需要将单个实体数据（即通过GET检索到的数据）发布到<code class="code">.../app/rest/entities</code>网址。发布XML时，请确保指定“ <code class="code">Content\-Type: application/xml</code> “ HTTP标头。</p></li><li class="list__item" id="025c660a"><p>PUT：从提交的有效载荷中更新数据。接受与通过GET请求检索到相同URL相同的数据格式。支持某些URL等实体<code class="code">.../app/rest/entities/<entity locator></code></p></li><li class="list__item" id="7724ed7d"><p>DELETE：删除网址中的数据，例如<code class="code">.../app/rest/entities/<entity locator></code></p></li></ul></div></div><a name="ResponseFormats"></a><a name="Response-Formats"></a><div class="chapter"><h2 id="RESTAPI-ResponseFormats">回应格式</h2><p id="363cbc28">TeamCity REST API根据HTTP“接受”标头以以下格式返回HTTP响应：</p><div class="table-wrapper"><table class=" wide" width="100%" id="124c586a"><thead><tr id="836e807d" class="ijRowHead"><th id="0f01a98c"><p id="20729a21">格式</p></th><th id="5d637bd3"><p id="f5603184">回应类型</p></th><th id="fad7cb40"><p id="8232f3ca">HTTP“接受”标头值</p></th></tr></thead><tbody><tr id="02e7de3c" class="ijRowOdd"><td id="724bff1e"><p id="e83232d3">纯文本</p></td><td id="333c0d06"><p id="78ef3f5d">单值响应</p></td><td id="d6382760"><p id="87ad4c12">文字/纯文字</p></td></tr><tr id="f569d2a0" class="ijRowEven"><td id="543c48b0"><p id="56b437e3">XML格式</p></td><td id="6fef02ee"><p id="bdb077b7">复杂价值反应</p></td><td id="56e5eb85"><p id="473bfeef">应用程序/ xml</p></td></tr><tr id="8faf81ac" class="ijRowOdd"><td id="da5be691"><p id="4eab02f8">JSON格式</p></td><td id="f74fdb20"><p id="4ea9dd58">复杂价值反应</p></td><td id="a20fa081"><p id="04d0e082">应用程序/ json</p></td></tr></tbody></table></div><a name="FullandPartialResponses"></a><a name="Full-and-Partial-Responses"></a><div class="chapter"><h3 id="RESTAPI-FullandPartialResponses">全部和部分回复</h3><p id="ad37007e">默认情况下，当请求实体列表时，仅基本字段包含在响应中。当请求单个条目时，将返回所有字段。复杂字段值可以完整或基本形式返回，具体取决于特定实体。</p><p id="b01fdab6">对于大多数请求，可以更改为XML和JSON响应返回的字段集。通过提供<b id="b5cc72ad">字段</b>请求参数来完成此操作，该参数描述了要在响应中返回的顶级实体和子实体的字段。参数的示例语法为： <code class="code">field,field2(field2_subfield1,field2_subfield1)</code> 。这基本上意味着“包括<code class="code">field</code>和<code class="code">field2</code>顶级实体的<code class="code">field2</code>包括<code class="code">field2_subfield1</code>和<code class="code">field2_subfield1</code>字段”。字段规范的顺序不起作用。</p><p id="30705258">例子：</p><ul class="list _ul"><li class="list__item" id="e0e0e93a"><a href="http://teamcity.jetbrains.com/app/rest/buildTypes?locator=affectedProject:(id:TeamCityPluginsByJetBrains)&fields=buildType(id,name,project)" rel="noopener noreferrer" data-external="true" target="_blank">http://teamcity.jetbrains.com/app/rest/buildTypes?locator=affectedProject:(id:TeamCityPluginsByJetBrains)&fields=buildType(id,name,project）</a></li><li class="list__item" id="08d1328b"><a href="http://teamcity.jetbrains.com/app/rest/builds?locator=buildType:(id:bt345),count:10&fields=count,build(number,status,statusText,agent,lastChange,tags,pinned)" rel="noopener noreferrer" data-external="true" target="_blank">http://teamcity.jetbrains.com/app/rest/builds?locator=buildType:(id:bt345),count:10&fields=count,build(number,status,statusText,agent,lastChange,tags,pinned）</a></li></ul><p id="e2d4d11a">此时，响应有时可能包含未特别要求的字段/元素。在将来的版本中可能会更改，因此建议指定客户端使用的所有字段/元素。</p></div><a name="Logging"></a><a name="Logging"></a><div class="chapter"><h3 id="RESTAPI-Logging">记录中</h3><p id="f6c6f16e">您可以在中获取有关错误和REST请求处理的详细信息<code class="code">logs\teamcity-rest.log</code> <a href="teamcity-server-logs.html">服务器日志</a> 。</p><p id="5ef6ec68">您可以在中获取有关错误和REST请求处理的详细信息<code class="code">logs\teamcity-rest.log</code> <a href="teamcity-server-logs.html">服务器日志</a> 。</p><p id="1232d62a">如果您在响应请求时遇到错误并希望调查原因，请查看与<a href="#Logging">休息相关的服务器日志</a> 。</p><p id="6b502902">要获取有关每个已处理请求的详细信息，请打开调试日志记录（例如，将Logging Preset设置为<code class="code">debug-rest</code>在“ <a href="teamcity-monitoring-and-diagnostics.html#Debug-Logging">管理/诊断”</a>页面上，或修改Log4J <code class="code">jetbrains.buildServer.server.rest</code>类别）。</p></div><a name="CORSSupport"></a><a name="CORS-Support"></a><div class="chapter"><h3 id="RESTAPI-CORSSupport">CORS支持</h3><p id="ee66f07c">可以将TeamCity REST API配置为允许使用以下命令进行<a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing" rel="noopener noreferrer" data-external="true" target="_blank">跨域请求</a> <code class="code">rest.cors.origins</code> <a href="configuring-teamcity-server-startup-properties.html#TeamCity-internal-properties">内部财产</a> 。</p><p id="d91a7a75">要允许来自特定域的页面请求，请将页面地址（包括<b id="850106d4">协议和端口</b> ， <b id="fe6d8db7">不要使用通配符</b> ）添加到以逗号分隔的<a href="configuring-teamcity-server-startup-properties.html#TeamCity-internal-properties">内部属性中</a> <code class="code">rest.cors.origins</code> ， 例如， <code class="code">rest.cors.origins=http://myinternalwebpage.org.com:8080,https://myinternalwebpage.org.com</code> 。</p><p id="cf463d3a">要启用对<a href="https://youtrack.jetbrains.com/issue/TW-27606" rel="noopener noreferrer" data-external="true" target="_blank">预检OPTIONS请求的</a>支持：</p><ol class="list _decimal"><li class="list__item" id="7aae297b"><p>添加<code class="code">rest.cors.optionsRequest.allowUnauthorized=true</code> <a href="configuring-teamcity-server-startup-properties.html#TeamCity-internal-properties">内部财产</a> 。</p></li><li class="list__item" id="b2622c76"><p><b id="a0da9c19">重新启动</b> TeamCity服务器。</p></li><li class="list__item" id="aec89f53"><p>使用<code class="code">/app/rest/latest</code>请求的URL。不使用<code class="code">/app/rest</code> ，请勿使用<code class="code">httpAuth</code>字首。如果那没有帮助，请启用调试<a href="#Logging">日志记录</a>并查找相关消息。如果不存在，请捕获浏览器流量和消息以调查情况。</p></li></ol></div><a name="APIClientRecommendations"></a><a name="API-Client-Recommendations"></a><div class="chapter"><h3 id="RESTAPI-APIClientRecommendations">API客户端建议</h3><p id="5a511f01">使用REST API开发客户端时，请考虑以下建议：</p><ul class="list _ul"><li class="list__item" id="429abba5"><p>使根REST API URL可配置（例如，允许为<code class="code">app/rest/<version></code>网址的一部分）。如有必要，这将允许将客户端定向到其他版本的API。</p></li><li class="list__item" id="52b662c8"><p>忽略（不出错）客户端不知道的项目属性和子项目。有时会在不更改版本的情况下将新的子项目添加到API中，这将确保客户端不受更改的影响。</p></li><li class="list__item" id="03d7fdee"><p>设置较大的请求超时（并使它们可配置）。某些API调用可能要花费几分钟，尤其是在大型服务器上。</p></li><li class="list__item" id="ed6202ba"><p>使用HTTP会话发出连续的请求（使用从第一个经过身份验证的响应返回的TCSESSIONID cookie，而不是一直提供原始凭据）。这样可以节省身份验证时间，这对于外部身份验证提供程序而言可能非常重要。</p></li><li class="list__item" id="38b38041"><p>请求项目列表时要提防部分答案：默认情况下，对某些请求进行分页。价值<code class="code">count</code>响应中的属性指示当前页面上的项目数，并且可以有更多页面可用。如果您需要处理更多（或所有）项目，请阅读并处理<code class="code">nextHref</code>项目集合的响应实体的属性。如果存在该属性，则意味着通过提供的URL查询时可能还有更多项目。相关的定位器尺寸为<code class="code">count</code> （页数限制）和<code class="code">lookupLimit</code> （搜索深度）。即使返回<code class="code">count</code>为0，并不意味着如果存在“ nextHref”属性，则不再有其他项。</p></li><li class="list__item" id="71317b77"><p>不要增加<code class="code">lookupLimit</code>在定位器中的价值，无需再三思。这样做的直接效果是增加服务器负载，并且可能需要增加CPU和内存量。假定那些增加默认限制的用户了解服务器性能的负面影响。</p></li><li class="list__item" id="df29d799"><p>不要滥用对TeamCity API执行自动请求的能力：不要过于频繁地查询API并将请求的数据限制为仅必要（使用适当的<a href="#Locator">定位符</a>并指定必要的<a href="#Full-and-Partial-Responses">字段</a> ）。根据请求检查负载下的服务器行为。如果花费时间来处理请求，请确保不要频繁重复请求。</p></li></ul></div></div><a name="TeamCityDataEntitiesRequests"></a><a name="TeamCity-Data-Entities-Requests"></a><div class="chapter"><h2 id="RESTAPI-TeamCityDataEntitiesRequests">TeamCity数据实体请求</h2><a name="ProjectsandBuildConfiguration/TemplatesLists"></a><a name="Projects-and-Build-Configuration/Templates-Lists"></a><div class="chapter"><h3 id="RESTAPI-ProjectsandBuildConfiguration/TemplatesLists">项目和构建配置/模板列表</h3><p id="2f16a326">项目清单： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/projects" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects</a> 。</p><p id="32beb401">项目详情： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator></projectlocator></a> ，在哪里<code class="code"><projectLocator></code>可<code class="code">id:<internal_project_id></code>要么<code class="code">name:<project%20name></code> 。</p><p id="fde5321c">构建配置列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/buildTypes" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes</a> 。</p><p id="165b0e2c">项目的构建配置列表： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>buildTypes</projectlocator></a> 。</p><p id="1c40d27d">获取具有指定项目在“概述”页面上配置的子项目“构建配置”数据及其顺序的项目：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / projects？locator = selectedByUser：current＆fields = count，project（id，parentProjectId，projects（count，project（id），$ locator（selectedByUser：current）），buildTypes（count ，buildType（id），$ locator（selectedByUser：current））</div><p id="a017df3a">特定项目的模板列表： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ templates</projectlocator></a> 。</p><p id="983c9a07">服务器上所有模板的列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/buildTypes?locator=templateFlag:true" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes？locator = templateFlag：true</a> 。</p></div><a name="ProjectSettings"></a><a name="Project-Settings"></a><div class="chapter"><h3 id="RESTAPI-ProjectSettings">项目设定</h3><p id="d361e408">获取项目详细信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator></projectlocator></a> 。</p><p id="f6d6218a">删除项目： <code class="code">DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator></projectlocator></a> 。</p><p id="68a78ef6">创建一个新的空项目：将纯文本（名称）POST到<a href="http://teamcity:8111/app/rest/projects/" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects /</a> 。</p><p id="18a5ad76">创建（或复制）项目：</p><div class="code-block" data-lang="bash">开机自检XML <newprojectdescription name="New Project Name" id="newProjectId" copyallassociatedsettings="true"><parentproject locator="id:project1"></parentproject><sourceproject locator="id:project2"></sourceproject></newprojectdescription>
 

</div><p id="9b742129">到<a href="http://teamcity:8111/app/rest/projects" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects</a> 。另请参阅<a href="https://confluence.jetbrains.com/display/TCD18/REST+API#RESTAPI-exampleNewProjectCurl" rel="noopener noreferrer" data-external="true" target="_blank">示例</a> 。</p><p id="cb79e034">编辑项目参数： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ parameters / <parameter_name></parameter_name></projectlocator></a> （根据“ Accept”标头生成XML，JSON和纯文本，接受纯文本以及XML和JSON）。还支持的请求： <code class="code">.../parameters/<parameter_name>/name</code>和<code class="code">.../parameters/<parameter_name>/value</code> 。</p><p id="7cf22768">项目名称/说明/存档状态： <code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ <field_name></field_name></projectlocator></a> （接受/产生文字/纯文字），其中<code class="code"><field_name></code>是其中之一<code class="code">name</code> ， <code class="code">description</code> ， <code class="code">archived</code> 。</p><p id="1af6c312">项目的父项目： <code class="code">GET/PUT XML</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ parentProject</projectlocator></a> 。</p></div><a name="ProjectFeatures"></a><a name="Project-Features"></a><div class="chapter"><h3 id="RESTAPI-ProjectFeatures">项目特色</h3><p id="fc6316c5">项目功能（例如，问题跟踪器，版本设置，自定义图表，共享资源和第三方报告选项卡）在“项目”节点下并通过专用请求显示为条目。</p><p id="307bed6e">项目功能列表： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ projectFeatures</projectlocator></a> 。</p><p id="2677616a">要过滤功能，请添加<code class="code">?locator=<projectFeaturesLocator></code> URL，例如查找GitHub类型的所有问题跟踪器功能，请使用定位器<code class="code">type:IssueTracker,property(name:type,value:GithubIssues)</code> 。</p><p id="425b1344">创建功能： <code class="code">POST</code>至<code class="code">/projects/<projectLocator>/projectFeatures</code> 。</p><p id="813552cf">编辑功能： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ projectFeatures / <featureid></featureid></projectlocator></a> 。</p></div><a name="VCSRoots"></a><a name="VCS-Roots"></a><div class="chapter"><h3 id="RESTAPI-VCSRoots">VCS根</h3><p id="f5b4678d">列出所有VCS根目录： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/vcs-roots" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-roots</a> 。</p><p id="2f865e15">添加<code class="code">locator=<vcsRootLocator></code>参数以仅列出匹配的VCS根目录。</p><p id="390475f3">获取VCS根目录的详细信息/删除VCS根目录： <code class="code">GET/DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-roots / <vcsrootlocator></vcsrootlocator></a> ，在哪里<code class="code"><vcsRootLocator></code>可<code class="code">id:<internal VCS root id></code>或其他VCS根定位符。</p><p id="f8f65835">创建一个新的VCS根目录： <code class="code">POST VCS root XML</code> （类似于GET请求获取的有关VCS根详细信息的内容）到<a href="http://teamcity:8111/app/rest/vcs-roots" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-roots</a> 。</p><p id="f2a46f62">还支持：</p><ul class="list _ul"><li class="list__item" id="245d5182"><code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-roots / <vcsrootlocator>/ properties /<property_name></property_name></vcsrootlocator></a></li><li class="list__item" id="89a31662"><code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-roots / <vcsrootlocator>/<field_name></field_name></vcsrootlocator></a></li></ul><p id="8c684d43">哪里<code class="code"><field_name></code>是<code class="code">id</code> ， <code class="code">name</code> ， <code class="code">project</code> （将项目定位器发布到<code class="code">project</code>将VCS根目录与特定项目相关联）。</p><p id="798a60e5">列出<b id="e7d3cc3e">VCS根实例</b> ： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-root-instances？locator = <vcsrootinstanceslocator></vcsrootinstanceslocator></a> 。</p><p id="0cbb7118"><a href="vcs-root.html">“ VCS根目录”</a>是在TeamCity UI中配置的设置，“ VCS根实例”是内部TeamCity实体，该实体是从“ VCS根目录”派生的，以执行实际的VCS操作。如果VCS根目录没有对参数的％引用，则单个VCS根目录对应于单个“ VCS根实例”。如果VCS根目录具有对参数的％引用，并且在将VCS根目录附加到不同配置或运行自定义构建时，该引用解析为其他值，则单个“ VCS根目录”可以生成多个“ VCS根实例”。</p><p id="b26279c8"><b id="2869ff56">从TeamCity 10.0开始</b> ：</p><p id="204e8f33">有两个专用于版本控制存储库中的<a href="configuring-vcs-post-commit-hooks-for-teamcity.html">提交挂钩的</a>端点： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-root-instances / checkingForChangesQueue？locator =<vcsrootinstanceslocator></vcsrootinstanceslocator></a></p><p id="cb78b5ad">它计划检查匹配的VCS根实例的更改，并返回匹配的VCS根实例的列表（就像<code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-root-instances？locator = <vcsrootinstanceslocator></vcsrootinstanceslocator></a> ）： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / vcs-root-instances / commitHookNotification？locator =<vcsrootinstanceslocator></vcsrootinstanceslocator></a></p><p id="ba0967e9">它计划检查匹配的VCS根实例的更改，并在执行成功的情况下，对执行的操作（HTTP响应202）返回纯文本的人类可读消息。</p><p id="8c6c548e">两者执行相同的操作（将VCS根实例与<code class="code"><locator></code> ）添加到“检查更改”流程的队列中，只是它们产生的响应有所不同。</p><p id="3e21124f">请注意，由于匹配的VCS根实例与<code class="code">../app/rest/vcs-root-instances?locator=<locator></code>请求，这意味着默认情况下， <b id="5f87ec1e">仅前100个匹配</b> ，其余的则被忽略。如果达到此限制，请考虑调整<code class="code"><locator></code>以匹配较少的实例（建议）或增加限制，例如，通过添加“ <code class="code">,count:1000</code> ”到定位器。</p><a name="VCSrootinstancelocator"></a><a name="VCS-root-instance-locator"></a><div class="chapter"><h4 id="RESTAPI-VCSrootinstancelocator">VCS根实例定位器</h4><p id="78713cab">一些支持<code class="code"><vcsRootInstancesLocator></code>从上面：</p><ul class="list _ul"><li class="list__item" id="3fc1ff73"><p><code class="code">type:<VCS root type></code> –指定版本控制的VCS根实例（例如，“ jetbrains.git”，“ mercurial”，“ svn”）。</p></li><li class="list__item" id="dcaf97b8"><p><code class="code">vcsRoot:(<vcsRootLocator>)</code> –与以下项匹配的VCS根对应的VCS根实例： <code class="code"><vcsRootLocator></code> 。</p></li><li class="list__item" id="1d4546ce"><p><code class="code">buildType:(<buildTypeLocator>)</code> –连接到匹配的构建配置的VCS根实例。</p></li><li class="list__item" id="9a1a6864"><p><code class="code">property:(name:<name>,value:<value>,matchType:<matching>)</code> –具有名称属性的VCS根实例<code class="code"><name></code>和值匹配条件<code class="code"><matchType></code> （例如，等于，包含）按值<code class="code"><value></code> 。</p></li></ul></div></div><a name="BuildConfigurationAndTemplateSettings"></a><a name="Build-Configuration-And-Template-Settings"></a><div class="chapter"><h3 id="RESTAPI-BuildConfigurationAndTemplateSettings">构建配置和模板设置</h3><p id="5775b80e">构建配置/模板详细信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildconfigurationlocator></buildconfigurationlocator></a> 。</p><p id="9bc0062c">请参阅“ <a href="#Build-Configuration-Locator">构建配置定位器”</a>上的详细信息。</p><p id="45557015">请注意，由于没有事务，例如在TeamCity中支持设置编辑，因此将同时考虑通过REST API修改的所有设置。这可能会导致触发一半配置的生成以及其他问题。如果此方面对您的情况很重要，请确保在更改配置设置之前暂停构建配置。</p><p id="2ce46590">要获取几种构建配置的汇总状态，请参见“ <a href="#Build-Status-Icon">构建状态图标”</a>部分。</p><p id="1a782a0c">获取/设置暂停的构建配置状态： <code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/暂停</buildtypelocator></a> （将“ true”或“ false”文本作为text / plain输入）。</p><p id="0c80df08">构建配置设置： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ settings / <setting_name></setting_name></buildtypelocator></a> 。</p><p id="86fc076c">构建配置参数： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ parameters / <parameter_name></parameter_name></buildtypelocator></a> 。</p><p id="613e57dd">它根据“ Accept”标头生成XML，JSON和纯文本，接受纯文本，XML和JSON。的<code class="code">.../parameters/<parameter_name>/name</code>和<code class="code">.../parameters/<parameter_name>/value</code>请求也受支持。</p><p id="04a5c7db">构建配置步骤： <code class="code">GET/DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ steps / <step_id></step_id></buildtypelocator></a> 。</p><p id="c9d9d697">创建构建配置步骤： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ steps</buildtypelocator></a> 。</p><p id="beeb7cb7">发布的XML / JSON与GET请求检索到的相同<code class="code">.../steps/<step_id></code>除了安全设置（例如密码）：这些不包含在响应中，应在回发之前提供。`</p><p id="a2215df7">功能，触发器，代理要求，工件和快照依存关系遵循与以下URL相同的模式：</p><ul class="list _ul"><li class="list__item" id="482def8a"><a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ features /<id></id></buildtypelocator></a></li><li class="list__item" id="1e21c3e3"><a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ triggers /<id></id></buildtypelocator></a></li><li class="list__item" id="a656897a"><a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ agent-requirements /<id></id></buildtypelocator></a></li><li class="list__item" id="95af58c2"><a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ artifact-dependencies /<id></id></buildtypelocator></a></li><li class="list__item" id="5a8985f3"><a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ snapshot-dependencies /<id></id></buildtypelocator></a></li></ul><p id="7ead943e"><b id="5e7ee9f6">从TeamCity 10开始</b> ，可以禁用/启用工件依赖项和代理要求。</p><p id="ac403c9a">禁用/启用工件依赖项： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ artifact-dependencies / <id>/ disabled</id></buildtypelocator></a> 。</p><p id="482530b0">将“ true”或“ false”文本作为文本/纯文本。</p><p id="ed5f1a58">禁用/启用代理要求： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ agent-requirements / <id>/ disabled</id></buildtypelocator></a> 。</p><p id="b9c512c4">将“ true”或“ false”文本作为文本/纯文本。</p><p id="f889c87a">构建配置VCS根目录： <code class="code">GET/DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ vcs-root-entries / <id></id></buildtypelocator></a> 。</p><p id="527d4c46">将VCS根目录附加到构建配置： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ vcs-root-entries</buildtypelocator></a> 。</p><p id="4b684673">发布的XML / JSON与GET请求对<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ vcs-root-entries /的</buildtypelocator></a>检索相同。 <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank"><buildtypelocator><id></id></buildtypelocator></a>除了安全设置（例如密码）：这些不包含在响应中，应在回发之前提供。</p><p id="777cea97">使用所有设置创建一个新的构建配置： <code class="code">POST</code> <a href="http://teamcity:8111/app/rest/buildTypes" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes</a> 。</p><p id="af860238">发布的XML / JSON与GET请求检索的相同。注意<code class="code">/app/rest/project/XXX/buildTypes</code>仍使用以前的版本表示法并接受另一个实体。</p><p id="4477d90b">创建一个新的空构建配置： <code class="code">POST</code>纯文本（名称）为<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ buildTypes</projectlocator></a> 。</p><p id="055a1f5a">复制构建配置：</p><div class="code-block" data-lang="bash">开机自检XML <newbuildtypedescription name="Conf Name" sourcebuildtypelocator="id:XXX" copyallassociatedsettings="true" sharevcsroots="false"></newbuildtypedescription>
 

</div><p id="6f630c75">到<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <projectlocator>/ buildTypes</projectlocator></a> 。</p><p id="62ea1375"><b id="2f64f789">从TeamCity 2017.2开始</b> ：</p><p id="e6a70803">从模板读取，分离并附加构建配置： <code class="code">GET/DELETE/POST/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ templates</buildtypelocator></a> 。</p><p id="6fb65fd3"><b id="a551fa68">在2017.2之前</b> ：</p><p id="6a48c7a1">从模板读取，分离并附加构建配置： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <buildtypelocator>/ template</buildtypelocator></a> 。</p><p id="2ecb0b63">Put接受带有“文本/纯文本” Content-Type的模板定位符。</p><p id="bc9f097b">设置内部编号计数器：</p><div class="code-block" data-lang="bash">curl -v-基本-用户<username>：- <password>请求PUT http：// <teamcity.url>/ app / rest / buildTypes / <buildtypelocator>/ settings / buildNumberCounter-数据- <new number="">标题“ Content-Type：text / plain”</new></buildtypelocator></teamcity.url></password></username></div><p id="761e089f">设置内部版本号格式：</p><div class="code-block" data-lang="bash">curl -v-基本-用户<username>：- <password>请求PUT http：// <teamcity.url>/ app / rest / buildTypes / <buildtypelocator>/ settings / buildNumberPattern --data <new format="">--header“内容类型：文本/纯文本”</new></buildtypelocator></teamcity.url></password></username></div><a name="BuildConfigurationLocator"></a><a name="Build-Configuration-Locator"></a><div class="chapter"><h4 id="RESTAPI-BuildConfigurationLocator">构建配置定位器</h4><p id="b1d1b9a3">最常用的值<code class="code"><buildTypeLocator></code>是<code class="code">id:<buildConfigurationOrTemplate_id></code>和<code class="code">name:<Build%20Configuration%20name></code> 。</p><p id="7a90fbe0"><b id="d74af5ed">从TeamCity 2017.2开始</b> ，以下<a href="build-configuration.html#Build-Configuration-Types">类型</a>之一支持<i id="e990ee53">实验</i> <a href="build-configuration.html#Build-Configuration-Types">类型</a>定位器： <code class="code">regular</code> ， <code class="code">composite</code> ， 要么<code class="code">deployment</code> 。</p><p id="61627c26">其他受支持的<a href="#Locator">尺寸</a>为（这些处于<i id="ad7ab215">实验</i>状态）：</p><ul class="list _ul"><li class="list__item" id="554d35dc"><p><code class="code">internalId</code> –构建配置的内部ID。</p></li><li class="list__item" id="ed95c079"><p><code class="code">project</code> – <code class="code"><projectLocator></code>将构建配置限制为属于单个项目的构建配置。</p></li><li class="list__item" id="2c2d4d76"><p><code class="code">affectedProject</code> – <code class="code"><projectLocator></code>将构建配置限制在单个项目下（递归）。</p></li><li class="list__item" id="b7902335"><p><code class="code">template</code> – <code class="code"><buildTypeLocator></code>模板以仅列出使用该模板的构建配置。</p></li><li class="list__item" id="5c24b97e"><p><code class="code">templateFlag</code> –布尔值，仅获取模板或仅获取非模板。</p></li><li class="list__item" id="99c05fe7"><p><code class="code">paused</code> –布尔值，用于过滤已暂停/未暂停的构建配置。</p></li></ul></div></div><a name="BuildRequests"></a><a name="Build-Requests"></a><div class="chapter"><h3 id="RESTAPI-BuildRequests">生成请求</h3><p id="5e33c101">列表构建： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds /？locator = <buildlocator></buildlocator></a> 。</p><p id="2d674d20">获取特定版本的详细信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator></buildlocator></a> 。</p><p id="cdc46846">还支持<code class="code">DELETE</code>删除构建。</p><p id="5b335086">获取项目中的构建配置列表，以及每个构建配置中最后完成的构建的状态：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / buildTypes？locator = affectedProject：（id：ProjectId）＆fields = buildType（id，name，builds（$ locator（running：false，canceled：false，count：1），建立（数字，状态，状态文本））</div><a name="BuildLocator"></a><a name="Build-Locator"></a><div class="chapter"><h4 id="RESTAPI-BuildLocator">生成定位器</h4><p id="c831a876">在与构建相关的请求中使用<a href="#Locator">定位器</a> ，您可以过滤要在与构建相关的请求中返回的构建。在REST API的范围内，它称为“构建定位器”。</p><p id="aa35ca53">对于某些请求，将应用默认过滤，该过滤仅返回“正常”构建（未取消，未启动失败，不是个人的默认构建（在分支构建配置中）且未取消的完成构建），除非这些类型的通过定位器特别要求构建。要关闭此默认过滤器并处理所有构建，请添加<code class="code">defaultFilter:false</code>构建定位器的尺寸。默认过滤根据指定的定位器尺寸而有所不同。例如，当<code class="code">agent</code>要么<code class="code">user</code>尺寸已存在，个人，已取消和无法启动构建均包含在结果中。</p><p id="e103aef4">受支持的构建定位器的示例：</p><ul class="list _ul"><li class="list__item" id="af78aea9"><p><code class="code">id:<internal build id></code> –需要引用特定<a href="working-with-build-results.html#Internal-Build-ID">内部版本</a>时，请使用<a href="working-with-build-results.html#Internal-Build-ID">内部内部版本ID</a> 。</p></li><li class="list__item" id="7fb85a52"><p><code class="code">number:<build number></code> –按构建号查找构建，前提是已经指定了构建配置。</p></li><li class="list__item" id="2c35147b"><p><code class="code"><dimension1>:<value1>,<dimension2>:<value2></code> –根据多个条件查找构建。</p></li></ul><p id="d89015ad">支持的构建定位器尺寸列表：</p><ul class="list _ul"><li class="list__item" id="8ab783dc"><p><code class="code">project:<project locator></code> –将列表限制为指定项目的构建（属于该项目正下方的任何构建类型）。</p></li><li class="list__item" id="d3a0b69d"><p><code class="code">affectedProject:<project locator></code> –将列表限制为指定项目的构建（属于该项目下直接或间接的任何构建类型）</p></li><li class="list__item" id="44e703df"><p><code class="code">buildType:(<buildTypeLocator>),defaultFilter:false</code> –指定构建配置的所有构建</p></li><li class="list__item" id="f5021386"><p><code class="code">tag:<tag></code> – <b id="bf7bad03">从TeamCity 10开始</b> ，获取标记的版本。例如，如果指定标签列表<code class="code">tag:<tag1></code> ， <code class="code">tag:<tag2></code> ，仅返回包含所有指定标签的内部版本。遗产<code class="code">tags:<tags></code>支持定位器以实现兼容性。</p></li><li class="list__item" id="013c12e5"><p><code class="code">status:<SUCCESS/FAILURE/ERROR></code> –仅以指定状态构建列表。</p></li><li class="list__item" id="70138311"><p><code class="code">user:(<userLocator>)</code> –将限制构建为仅由指定用户触发的构建。</p></li><li class="list__item" id="07bf29db"><p><code class="code">personal:<true/false/any></code> –通过个人标志限制建筑。默认情况下，不包括个人版本。</p></li><li class="list__item" id="52a7900a"><p><code class="code">canceled:<true/false/any></code> –通过取消标志建立限制。默认情况下，不包括已取消的内部版本。</p></li><li class="list__item" id="aa28e511"><p><code class="code">failedToStart:<true/false/any></code> –通过启动失败标志限制构建。默认情况下，不包括已取消的内部版本。</p></li><li class="list__item" id="a02e5e9c"><p><code class="code">state:<queued/running/finished></code> –按指定状态限制构建。</p></li><li class="list__item" id="155a723e"><p><code class="code">running:<true/false/any></code> –通过运行标志限制构建。默认情况下，不包括正在运行的内部版本。</p></li><li class="list__item" id="5c4b1a2b"><p><code class="code">state:running,hanging:true</code> –获取挂起的构建（ <b id="19cb7b33">自TeamCity 10.0起</b> ）。</p></li><li class="list__item" id="a4dc40ab"><p><code class="code">pinned:<true/false/any></code> –通过固定标志建立限制。</p></li><li class="list__item" id="3dd76270"><p><code class="code">branch:<branch locator></code> –按分支限制构建。 <code class="code"><branch locator></code>可以是显示在用户界面中的分支名称，或者<code class="code">(name:<name>,default:<true/false/any>,unspecified:<true/false/any>,branched:<true/false/any></code> ）。默认情况下，仅返回默认分支中的构建。要检索所有构建，请添加以下内容<code class="code">locator: branch:default:any</code> 。整个路径如下所示： <code class="code">/app/rest/builds/?locator=buildType:One_Git,branch:default:any</code> 。</p></li><li class="list__item" id="2ae64274"><p><code class="code">revision:<REVISION></code> –按修订版本查找构建，例如具有修订版本的给定构建配置的所有构建： <code class="code">/app/rest/builds?locator=revision:(REVISION),buildType:(id:BUILD_TYPE_ID)</code> 。请参阅<a href="#Revisions">下面的</a>更多信息。</p></li><li class="list__item" id="8dbb3d69"><p><code class="code">agentName:<name></code> –仅返回构建的座席名称在具有指定名称的座席上运行。</p></li><li class="list__item" id="2a7b8d52"><p><code class="code">sinceBuild:(<buildLocator>)</code> –将构建列表仅限制在指定的构建之后</p></li><li class="list__item" id="178ff829"><p><code class="code">sinceDate:<date></code> –将构建列表仅限制在指定日期之后开始的构建。该日期应与REST API返回的日期格式相同（例如， <code class="code">20130305T170030+0400</code> ）。</p></li><li class="list__item" id="dd27475b"><p><code class="code">queuedDate/startDate/finishDate:(date:<time-date>,build:<build locator>,condition:<before/after>)</code> –根据构建定位器指定的时间过滤构建，例如，对于2017年11月23日20:34:46 GMT + 1时区使用后完成的构建： <code class="code">finishDate:(date:20171123T203446%2B0100,condition:after)</code> 。</p></li><li class="list__item" id="79021644"><p><code class="code">count:<number></code> –仅提供指定数量的构建。</p></li><li class="list__item" id="f16b9ed3"><p><code class="code">start:<number></code> –从指定位置（从零开始）开始，从列表中列出构建。</p></li><li class="list__item" id="8f34dc9b"><p><code class="code">lookupLimit:<number></code> –仅将处理限制为最新的N个版本（默认为5000）。如果最新的N个构建均不符合构建定位符的其他指定条件，则对于单个构建请求返回404响应，对于多个构建请求返回空集合。请参阅上一<a href="#API-Client-Recommendations">节中的</a>相关说明。</p></li></ul></div><a name="QueuedBuilds"></a><a name="Queued-Builds"></a><div class="chapter"><h4 id="RESTAPI-QueuedBuilds">排队构建</h4><p id="41aba73e"><code class="code">GET</code> <a href="http://teamcity:8111/app/rest/buildQueue" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue</a></p><p id="5576142f">支持的定位器：</p><ul class="list _ul"><li class="list__item" id="494266ed"><code class="code">project:<locator></code></li><li class="list__item" id="750520cd"><code class="code">buildType:<locator></code></li></ul><p id="90c59b93">获取排队构建的详细信息： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/buildQueue/id:XXX" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue / id：XXX</a> 。</p><p id="02aa8d57">对于具有快照相关性的排队构建，可以在以下版本中进行修订： <code class="code">revisions</code>如果修订是固定的，则排队构建节点的元素（对于没有快照依赖项的常规构建则不是）。</p><p id="c6161e11">为排队的构建获取兼容的代理（对于可运行“无代理”的构建有用）： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/buildQueue/id:XXX/compatibleAgents" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue / id：XXX / compatibleAgents</a> 。</p><p id="3927718d"><b id="c330bd0c">例子</b> ：</p><p id="467d98f2">列出每个项目的排队构建： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue？locator = project： <locator></locator></a> 。</p><p id="71e11d8e">列出每个构建配置的排队构建： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue？locator = buildType： <locator></locator></a> 。</p></div><a name="TriggeringaBuild"></a><a name="Triggering-a-Build"></a><div class="chapter"><h4 id="RESTAPI-TriggeringaBuild">触发构建</h4><p id="abe92adb">要开始构建，请发送<code class="code">POST</code>向<a href="http://teamcity:8111/app/rest/buildQueue" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildQueue请求</a> ，其<a href="http://teamcity:8111/app/rest/buildQueue" rel="noopener noreferrer" data-external="true" target="_blank">内容</a>带有“构建”节点（请参见下文），该节点与排队构建或完成构建的详细信息相同。排队的构建详细信息将返回。</p><p id="4e655a29">开始构建时，对排队构建的请求（ <code class="code">/app/rest/buildQueue/XXX</code> ）将返回运行/完成的构建数据。这样，您可以通过使用<code class="code">href</code>生成触发时返回的生成详细信息的属性，直到生成具有<code class="code">state="finished"</code>属性。</p></div><a name="Buildnodeexample"></a><a name="Build-node-example"></a><div class="chapter"><h4 id="RESTAPI-Buildnodeexample">构建节点示例</h4><p id="39fa3408">构建配置的基本构建：</p><div class="code-block" data-lang="markup"><build>
    <buildtype id="buildConfID"></buildtype>
</build>
 

</div><p id="1fba0eb1">构建一个带有固定代理，注释和自定义参数的标记为个人的分支：</p><div class="code-block" data-lang="markup"><build personal="true" branchname="logicBuildBranch">
    <buildtype id="buildConfID"></buildtype><agent id="3"></agent> <comment><text>建立触发评论</text></comment> <properties><property name="env.myEnv" value="bbb"></property></properties>
</build>
 

</div><p id="7c3b6d0f">排队到代理池的构建分配：</p><div class="code-block" data-lang="markup"><build>...
  <agent><pool id="N"></pool></agent> ...
</build>
 

</div><p id="e3075fb3">建立在给定修订的基础上，在构建之前强制重建所有依赖项并清除源，并在触发时移至构建队列。（请注意，更改应该是TeamCity已知的（在UI中显示为构建配置，更多关于<a href="#Changes">“ lastChanges”元素</a> ）：</p><div class="code-block" data-lang="markup"><build>
  <triggeringoptions cleansources="true" rebuildalldependencies="true" queueattop="true"></triggeringoptions>
  <buildtype id="buildConfID"></buildtype>
   <lastchanges>
    <change locator="version:a286767fc1154b0c2b93d5728dd5bbcdefdfaca,buildType:(id:buildConfID)"></change>
  </lastchanges>
</build>
 

</div><p id="a72bde7d">构建触发的示例命令行：</p><div class="code-block" data-lang="bash">curl -v -u用户：密码http：//teamcity.server.url：8111 / app / rest / buildQueue-请求POST --header“ Content-Type：application / xml” --data-binary @ build.xml</div></div><a name="BuildTags"></a><a name="Build-Tags"></a><div class="chapter"><h4 id="RESTAPI-BuildTags">构建标签</h4><p id="57f27491">获取标签： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ tags /</buildlocator></a> 。</p><p id="5bb7bfcf">替换标签： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ tags /</buildlocator></a> （输入与GET返回的相同的XML或JSON）。</p><p id="eef8af6f">添加标签： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ tags /</buildlocator></a> （发布与GET返回的XML或JSON相同的XML或JSON，或者仅发布纯文本标签名称； <code class="code"><buildLocator></code>这里应仅匹配单个版本）。</p></div><a name="BuildPinning"></a><a name="Build-Pinning"></a><div class="chapter"><h4 id="RESTAPI-BuildPinning">构建固定</h4><p id="f62764e6">获取当前的引脚状态： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ pin /</buildlocator></a> （返回“ true”或“ false”文本）。</p><p id="e80ec4ce">销： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ pin /</buildlocator></a> （将请求数据中的文本添加为该操作的注释）。</p><p id="15ad3302">取消固定： <code class="code">DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ pin /</buildlocator></a> （请求数据中的文本作为操作的注释添加； <code class="code"><buildLocator></code>这里应该只匹配单个版本）。</p></div><a name="BuildCanceling/Stopping"></a><a name="Build-Canceling/Stopping"></a><div class="chapter"><h4 id="RESTAPI-BuildCanceling/Stopping">构建取消/停止</h4><p id="81968a36">取消正在运行或排队的构建：POST <code class="code"><buildCancelRequest comment='CommentText' readdIntoQueue='false'/></code>项目到正在运行或已排队的构建的URL。例：</p><div class="code-block" data-lang="bash">curl -v -u用户：密码--request POST“ http：// teamcity：8111 / app / rest / buildQueue / <buildlocator>” --data“ <buildcancelrequest comment="" readdintoqueue="false"></buildcancelrequest> “ --header”内容类型：application / xml“</buildlocator></div><p id="85d6332d">停止正在运行的构建并将其读入队列：POST <code class="code"><buildCancelRequest comment='CommentText' readdIntoQueue='true' /></code>项目到正在运行的版本的URL。例：</p><div class="code-block" data-lang="bash">curl -v -u用户：密码--request POST“ http：// teamcity：8111 / app / rest / builds / <buildlocator>” --data“ <buildcancelrequest comment="" readdintoqueue="true"></buildcancelrequest> “ --header”内容类型：application / xml“</buildlocator></div><p id="1a07ee5d">见<code class="code">canceledInfo</code>构建项目的元素（可通过<code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator></buildlocator></a> ）。</p></div><a name="BuildArtifacts"></a><a name="Build-Artifacts"></a><div class="chapter"><h4 id="RESTAPI-BuildArtifacts">建立文物</h4><p id="212efd73">返回由以下内容确定的构建的构建工件文件的内容： <a href="#Build-Locator"><code class="code"><build_locator></code></a> ： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <build_locator>/ artifacts / content / <path></path></build_locator></a> 。 <code class="code"><path></code>对于构建构件的根，可以为空，也可以为构建构件内的路径。该路径可以跨越档案内容，例如， <code class="code">dir/path/archive.zip!/path_within_archive</code> 。</p><ul class="list _ul"><li class="list__item" id="fc8dc2cc"><p>媒体类型：应用程序/八位位组流或更特定的媒体类型（由工件文件扩展名确定）。</p></li><li class="list__item" id="89db8aa8"><p>可能的错误：如果指定的路径引用目录，则为400。</p></li></ul><p id="21bdf401">返回有关构建工件的信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <build_locator>/ artifacts / metadata / <path></path></build_locator></a> 。</p><ul class="list _ul"><li class="list__item" id="096decc5"><p>媒体类型：application / xml或application / json。</p></li></ul><p id="ed3dd845">返回目录和归档的工件子项列表： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <build_locator>/ artifacts / children / <path></path></build_locator></a> 。</p><ul class="list _ul"><li class="list__item" id="d54e2308"><p>媒体类型：application / xml或application / json。</p></li><li class="list__item" id="3fa1aa8e"><p>可能的错误：如果工件既不是目录也不是存档，则为400。</p></li></ul><p id="74fc4945">返回包含指定路径下的工件列表的归档文件： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <build_locator>/ artifacts / archived / <path>？locator = pattern： <wildcard></wildcard></path></build_locator></a> 。可选的<code class="code">locator</code>参数可以有文件<code class="code"><wildcard></code>将文件限制为仅与<a href="wildcards.html">通配符</a>匹配的文件。 <code class="code"><artifact relative name></code>支持使用<code class="code">!/</code>档案名称后的定界符。</p><ul class="list _ul"><li class="list__item" id="89f340ba"><p>媒体类型：application / zip。</p></li><li class="list__item" id="42253693"><p>可能的错误：如果工件既不是目录也不是存档，则为400。</p></li></ul><p id="f7770d35"><b id="0a679941">例子</b> ：</p><div class="code-block" data-lang="bash">获取http：// teamcity：8111 / app / rest / builds / id：100 / artifacts / children / my-great-tool-0.1.jar！/ META-INF获取http：// teamcity：8111 / app / rest / builds / buildType：（id：Build_Intallers），状态：SUCCESS / artifacts / metadata / my-great-tool-0.1.jar！/META-INF/MANIFEST.MF GET http：// teamcity：8111 / app / rest / builds / buildType：（id：Build_Intallers），编号：16.7.0.2/artifacts/metadata/my-great-tool-0.1.jar！/lib/commons-logging-1.1.1.jar！/META-INF/MANIFEST.MF获取http：// teamcity：8111 / app / rest / builds / buildType：（id：Build_Intallers），tag：release / artifacts / content / my-great-tool-0.1.jar！/lib/commons-logging-1.1。 1.jar！/META-INF/MANIFEST.MF</div></div><a name="Authentication"></a><a name="Authentication"></a><div class="chapter"><h4 id="RESTAPI-Authentication">认证方式</h4><p id="8ad75d9d">如果您从TeamCity构建中下载工件，请考虑<a href="#REST-Authentication">使用以下</a>值： <code class="code">teamcity.auth.userId/teamcity.auth.password</code>系统属性作为下载工件请求的凭据：这样，TeamCity将有一种方式来记录一个内部版本使用了另一个内部的工件，并将其显示在内部版本的“ <b id="b99a11b9">依赖关系”</b>选项卡上。</p></div><a name="OtherBuildRequests"></a><a name="Other-Build-Requests"></a><div class="chapter"><h4 id="RESTAPI-OtherBuildRequests">其他构建请求</h4></div><a name="Changes"></a><a name="Changes"></a><div class="chapter"><h4 id="RESTAPI-Changes">变化</h4><p id="d736947f"><code class="code"><changes></code>表示更改的方式与在TeamCity UI的内部版本的<a href="working-with-build-results.html#Changes">更改</a>中显示的方式相同。在大多数情况下，这些是当前版本与先前版本之间的提交。的<code class="code"><changes></code>标记默认情况下不包含在构建中，它仅具有href属性。如果执行href中指定的请求，您将获得所需的更改。</p><p id="82434320">获取构建中包含的所有更改的列表： <code class="code">GET http://teamcity:8111/app/rest/changes?locator=build:(id:<buildId>)</code> 。</p><p id="9358750e">获取单个更改的详细信息： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/changes/id:changeId" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / changes / id：changeId</a> 。</p><p id="0cc2383d">获取有关已更改文件操作的信息：“文件”节点列出已更改的文件。有关更改的文件操作的信息通过<code class="code">changeType</code>列出的文件的以下属性之一： <code class="code">added</code> ， <code class="code">edited</code> ， <code class="code">removed</code> ， <code class="code">copied</code>要么<code class="code">unchanged</code> 。</p><p id="177891f7">通过定位器过滤所有更改： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / changes？locator = <changelocator></changelocator></a> 。</p><p id="90ce5eb6">请注意，更改ID是更改的内部ID，而不是修订。可以在REST API列出的更改节点中或更改详细信息的URL中看到该ID（如<code class="code">modId</code> ）。</p><p id="9dbd6f51">获取项目的所有更改： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/changes?locator=project:projectId" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / changes？locator = project：projectId</a> 。</p><p id="4a483c33">获取由其ID标识的特定更改以来的构建配置中的所有更改： <code class="code">http://teamcity:8111/app/rest/changes?locator=buildType:(id:buildConfigurationId),sinceChange:(id:changeId)</code> 。</p><p id="3f0485b6">获取构建配置的待定更改： <code class="code">http://teamcity:8111/app/rest/changes?locator=buildType:(id:BUILD_CONF_ID),pending:true</code> 。</p><p id="2825303b">的<code class="code"><lastChanges></code>标签包含有关构建中最后一次提交的信息。触发构建时，其嵌套<code class="code"><change></code>元素可以包含<code class="code">locator</code>字段，指定用于构建触发的更改。</p></div><a name="Revisions"></a><a name="Revisions"></a><div class="chapter"><h4 id="RESTAPI-Revisions">修订版</h4><p id="920b6e69">的<code class="code"><revisions></code>在TeamCity UI中的版本的“ <a href="working-with-build-results.html#Changes">更改”</a>选项卡上，与修订表标记相同：它列出了与此版本关联的所有VCS存储库的修订，这些修订将由代理上的版本签出。修订版本可能与TeamCity已知的更改相对应，也可能与之不符。例如，对于新创建的构建配置和VCS根目录，修订将没有相应的更改。</p><p id="00826b65">获取具有指定版本的所有版本： <code class="code">http://teamcity:8111/app/rest/builds?locator=revision(version:XXXX)</code> 。</p><p id="d340094f"><b id="de254efa">从TeamCity 10开始</b> ， <code class="code"><versionedSettingsRevision></code>添加以表示版本的<a href="storing-project-settings-in-version-control.html">版本设置</a>的修订。</p></div><a name="Snapshotdependencies"></a><a name="Snapshot-dependencies"></a><div class="chapter"><h4 id="RESTAPI-Snapshotdependencies">快照依存关系</h4><p id="ac47d51a">可以检索特定构建的整个构建链（所有快照依赖关系链接的构建）：</p><div class="code-block" data-lang="bash">http：// teamcity：8111 / app / rest / builds？locator = snapshotDependency :(至：（id：XXXX），includeInitial：true），defaultFilter：false`</div><p id="7f09d72b">这将递归获取ID为XXXX的构建的所有快照依赖关系构建。</p><p id="ee2def8b">可以找到特定构建的所有依赖快照的构建：</p><div class="code-block" data-lang="bash">http：// teamcity：8111 / app / rest / builds？locator = snapshotDependency :(至：（id：XXXX），includeInitial：true），defaultFilter：false`</div></div><a name="Artifactdependencies"></a><a name="Artifact-dependencies"></a><div class="chapter"><h4 id="RESTAPI-Artifactdependencies">工件依赖</h4><p id="b3b69743"><b id="a760d326">从TeamCity 10.0.3开始</b> ，具有以下实验功能：</p><p id="de5afe6d">获取所有具有给定ID（从TeamCity Web UI中交付的工件）的版本中下载工件的版本： <code class="code">GET http://teamcity:8111/app/rest/builds?locator=artifactDependency:(from:(id:<build ID>),recursive:false)</code> 。</p><p id="16ccbc7a">获取具有给定ID（由TeamCity Web UI中下载的工件）的所有工件已由其下载的工件： <code class="code">GET http://teamcity:8111/app/rest/builds?locator=artifactDependency:(to:(id:<build ID>),recursive:false)</code> 。</p></div><a name="BuildParameters"></a><a name="Build-Parameters"></a><div class="chapter"><h4 id="RESTAPI-BuildParameters">构建参数</h4><p id="99196fe9">获取构建的<a href="predefined-build-parameters.html">参数</a> ： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / id： <build_id>/ resulting-properties</build_id></a> 。</p></div><a name="BuildFields"></a><a name="Build-Fields"></a><div class="chapter"><h4 id="RESTAPI-BuildFields">建造领域</h4><p id="34e52c5c">获取单一版本的字段： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ <field_name></field_name></buildlocator></a> 。这接受/产生文本/纯文本，其中<code class="code"><field_name></code>是其中之一<code class="code">number</code> ， <code class="code">status</code> ， <code class="code">id</code> ， <code class="code">branchName</code> ，以及其他构建的Bean属性。</p></div><a name="Statistics"></a><a name="Statistics"></a><div class="chapter"><h4 id="RESTAPI-Statistics">统计</h4><p id="766abd4a">获取单个构建的统计信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ statistics /</buildlocator></a> 。仅列出标准/捆绑统计信息值。另请参阅<a href="custom-chart.html">自定义图表</a> 。</p><p id="61c7e2c9">获取单个构建统计信息值： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ statistics / <value_name></value_name></buildlocator></a> 。</p><p id="c8c1f628">获取构建列表的统计信息：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / builds？locator = BUILDS_LOCATOR＆fields = build（id，number，status，buildType（id，name，projectName），statistics（property（property（name，value））））`</div></div><a name="BuildLog"></a><a name="Build-Log"></a><div class="chapter"><h4 id="RESTAPI-BuildLog">构建日志</h4><p id="8c3ca481">通过REST请求下载构建日志不支持，但有一个方法来下载所描述的日志文件<a href="build-log.html#Viewing-Build-Log">在这里</a> 。</p></div></div><a name="TestsandBuildProblems"></a><a name="Tests-and-Build-Problems"></a><div class="chapter"><h3 id="RESTAPI-TestsandBuildProblems">测试和构建问题</h3><p id="39881070">列出构建问题： <code class="code">GET http://teamcity:8111/app/rest/problemOccurrences?locator=build:(BUILD_LOCATOR)</code> 。</p><p id="474b6dc6">列出测试： <code class="code">GET http://teamcity:8111/app/rest/testOccurrences?locator=<locator dimension>:<value></code> 。</p><p id="210536b6"><b id="f7d11835">支持的定位器</b> ：</p><ul class="list _ul"><li class="list__item" id="53508278"><p><code class="code">build:(<build locator>)</code> –在构建中进行测试。</p></li><li class="list__item" id="9576b5ac"><p><code class="code">build:(<build locator>),muted:true</code> –在构建中被忽略的失败测试。</p></li><li class="list__item" id="284aa72d"><p><code class="code">currentlyFailing:true,affectedProject:<project_locator></code> –在指定的项目下当前失败的测试（递归）。</p></li><li class="list__item" id="fb01e67b"><p><code class="code">currentlyMuted:true,affectedProject:<project_locator></code> –当前在指定项目下静音的测试（递归）。另请参阅项目的“静音问题”选项卡。</p></li></ul><p id="b138a1d8"><b id="ab7a8005">例子</b> ：</p><p id="e36adafb">列出所有构建的测试： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / testOccurrences？locator = build： <buildlocator></buildlocator></a> 。</p><p id="a589e67a">获取个人测试历史记录： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / testOccurrences？locator = test： <testlocator></testlocator></a> 。</p><p id="164df87d">列出在构建运行时被静音的构建测试： <code class="code">GET http://teamcity:8111/app/rest/testOccurrences?locator=build:(id:XXX),muted:true</code> 。</p><p id="978911b1">列出当前已静音的测试（自失败以来已静音）： <code class="code">GET http://teamcity:8111/app/rest/testOccurrences?locator=build:(id:XXX),currentlyMuted:true</code> 。</p><p id="11177af1"><b id="85d3e1eb">支持的测试定位器</b> ：</p><ul class="list _ul"><li class="list__item" id="4a574037"><p><code class="code">id:<internal test id></code>在测试历史记录页面上作为URL的一部分提供</p></li><li class="list__item" id="f7ad9aed"><code class="code">name:<full test name></code></li></ul><p id="e49ca7de"><b id="ed98b226">从TeamCity 10开始</b> ，提供了对公开单个测试调用/运行的实验性支持：</p><p id="963d0618">获取测试调用：</p><div class="code-block" data-lang="bash">http：// teamcity：8111 / app / rest / testOccurrences？locator = build：（id：XXX），test：（id：XXX）＆fields = $ long，testOccurrence（$ short，invocations（$ long））</div><p id="8d561d04">列出所有测试运行，并平整所有调用：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / testOccurrences？locator = build：（id：XXX），test：（id：XXX），expandInvocations：true</div><a name="MutedTestsandBuildProblems"></a><a name="Muted-Tests-and-Build-Problems"></a><div class="chapter"><h4 id="RESTAPI-MutedTestsandBuildProblems">静音测试和构建问题</h4><p id="d57e738f"><b id="db8342b2">从TeamCity 2017.2开始</b></p><p id="1f696fd0">列出所有静音测试并生成问题： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/mutes" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / mutes</a> 。</p><p id="502d214c">取消测试静音或产生问题： <code class="code">DELETE</code> <a href="http://teamcity:81111/app/rest/mutes/id:XXXX" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：81111 / app / rest / mutes / id：XXXX</a> 。</p><p id="0f107150">使测试静音或产生问题： <code class="code">POST</code>到<a href="http://teamcity:8111/app/rest/mutes" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / mutes</a> 。使用与返回的相同的XML或JSON <code class="code">GET</code> 。</p></div></div><a name="Investigations"></a><a name="Investigations"></a><div class="chapter"><h3 id="RESTAPI-Investigations">调查</h3><p id="aa4e4fd9">列出Root项目及其子项目中的调查： <a href="http://teamcity:8111/app/rest/investigations" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / investigations</a> 。</p><p id="796e9b7e"><b id="ff3e931d">支持的定位器：</b></p><ul class="list _ul"><li class="list__item" id="c787bfe7"><code class="code">test: (id:TEST_NAME_ID)</code></li><li class="list__item" id="2b4db566"><code class="code">test: (name:FULL_TEST_NAME)</code></li><li class="list__item" id="1cb3130d"><code class="code">assignee: (<user_locator>)</code></li><li class="list__item" id="b95f394e"><code class="code">buildType:(id:XXXX)</code></li></ul><p id="9dc370e2">获得有关特定测试的调查结果：</p><div class="code-block" data-lang="bash">http：// teamcity：8111 / app / rest / investigations？locator = test：（id：TEST_NAME_ID）http：// teamcity：8111 / app / rest / investigations？locator = test：（name：FULL_TEST_NAME）</div><p id="a3b62e69">获取分配给用户的调查： <code class="code">http://teamcity:8111/app/rest/investigations?locator=assignee:(<user locator>)</code> 。</p><p id="1170c0b8">获取有关构建配置的调查： <code class="code">http://teamcity:8111/app/rest/investigations?locator=buildType:(id:XXXX)</code> 。</p><p id="7f747c9e">分配/替换调查： <code class="code">POST/PUT</code>到<a href="http://teamcity:8111/app/rest/investigations" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / investigations</a> （接受一次调查）和<i id="593d633e">对多项调查的</i>实验<i id="593d633e">支持</i> ： <code class="code">POST/PUT</code>到<a href="http://teamcity:8111/app/rest/investigations/multiple" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / investigations / multiple</a> （接受调查列表）。使用与GET返回的相同的XML或JSON。</p></div><a name="Agents"></a><a name="Agents"></a><div class="chapter"><h3 id="RESTAPI-Agents">代理商</h3><p id="1f9d6e9c">列表代理（默认情况下仅包括授权代理）： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/agents" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents</a> 。</p><p id="dd950888">列出所有连接的授权代理： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/agents?locator=connected:true,authorized:true" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents？locator = connected：true，authorized：true</a> 。</p><p id="d792c3e4">列出所有授权的代理商： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/agents?locator=authorized:true" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents？locator = authorized：true</a> 。</p><p id="3809a823">列出所有启用的授权代理： <code class="code">GET http://teamcity:8111/app/rest/agents?locator=enabled:true,authorized:true</code> 。</p><p id="7f5289f3">列出所有代理（包括未授权的代理）： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/agents?locator=authorized:any" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents？locator = authorized：any</a> 。该请求使用默认过滤（取决于指定的定位器尺寸，其他可以具有默认隐含值）。要禁用此过滤，请添加<code class="code">,defaultFilter:false</code>到定位器。</p><p id="6b04b965">启用/禁用代理： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator>/启用</agentlocator></a> （将“ true”或“ false”文本作为text / plain输入）。看一个<a href="http://devnet.jetbrains.net/message/5462246#5462246" rel="noopener noreferrer" data-external="true" target="_blank">例子</a> 。</p><p id="ef9b346b">授权/取消授权代理商： <code class="code">PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator>/已授权</agentlocator></a> （将“ true”或“ false”文本作为text / plain）。</p><p id="056c8223">在启用/禁用和授权/取消授权代理时添加注释：</p><p id="4dd9800b">代理启用/授权的数据在<code class="code">enabledInfo</code>和<code class="code">authorizedInfo</code>节点：</p><div class="code-block" data-lang="markup"><agent id="1" name="agentName" href="/app/rest/agents/id:1" typeid="1" connected="true" enabled="true" authorized="true" uptodate="true" ip="...........">
 <enabledinfo status="true"><comment><user id="1" href="/app/rest/users/id:1" username="userName"></user> <timestamp>20160406T175040 + 0300新</timestamp> <text>评论</text></comment></enabledinfo> <authorizedinfo status="true"><comment><user id="1" href="/app/rest/users/id:1" username="userName"></user> <timestamp>20160406T183033 + 0300</timestamp></comment></authorizedinfo> ....
</agent>
 

</div><p id="6deeeace"><code class="code">GET</code>和<code class="code">PUT</code>请求支持以下URL： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator>/ enabledInfo</agentlocator></a>和<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator>/ authorized</agentlocator></a> 。</p><p id="6b5bc74b">上<code class="code">PUT</code>仅考虑状态和评论/文本子项：</p><div class="code-block" data-lang="bash">curl -v -u用户：密码--request PUT“ http：// teamcity：8111 / app / rest / agents / id：1 / enabledInfo” --data“ <enabledinfo status="false"><comment><text>commentText</text></comment></enabledinfo> ” --header“内容类型：application / xml</div><p id="35a16513">获取/放置代理的单个字段： <code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator>/ <field_name></field_name></agentlocator></a> 。</p><p id="9592d4ea">删除构建代理： <code class="code">DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agents / <agentlocator></agentlocator></a> 。</p><a name="AgentPools"></a><a name="Agent-Pools"></a><div class="chapter"><h4 id="RESTAPI-AgentPools">代理商池</h4><p id="a5722465">列出所有代理程序池： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/agentPools" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agentPools</a> 。</p><p id="417521c1">获取/修改/删除ID为“ ID”的代理池： <code class="code">GET/PUT/DELETE</code> <a href="http://teamcity:8111/app/rest/agentPools/id:ID" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agentPools / id：ID</a> 。</p><p id="4da54dde">添加代理池： <code class="code">POST</code>的<code class="code">agentPool name='PoolName'</code> <a href="http://teamcity:8111/app/rest/agentPools" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / agentPools的元素</a> 。</p><p id="9174603b">将代理程序从上一个池移至该池： <code class="code">POST <agent id='YYY'/></code>到池的代理<a href="http://teamcity.url/app/rest/agentPools/id:XXX/agents" rel="noopener noreferrer" data-external="true" target="_blank">http：//teamcity.url/app/rest/agentPools/id：XXX / agents</a> 。</p><p id="92eb7e16">例：</p><div class="code-block" data-lang="bash">curl -v -u用户：密码[http：//teamcity.url/app/rest/agentPools/id：XXX / agents]（http：//teamcity.url/app/rest/agentPools/id：XXX / agents） --request POST --header“ Content-Type：application / xml” --data“ <agent id="1"></agent> ”</div></div><a name="AssigningProjectstoAgentPools"></a><a name="Assigning-Projects-to-Agent-Pools"></a><div class="chapter"><h4 id="RESTAPI-AssigningProjectstoAgentPools">将项目分配到座席池</h4><p id="430f99df">将项目添加到池中： <code class="code">POST</code>的<code class="code"><project></code>节点到<a href="http://teamcity.url/app/rest/agentPools/id:XXX/projects" rel="noopener noreferrer" data-external="true" target="_blank">http：//teamcity.url/app/rest/agentPools/id：XXX / projects</a> 。</p><p id="f2747a9c">从池中删除项目： <code class="code">DELETE</code> <a href="http://teamcity.url/app/rest/agentPools/id:XXX/projects/id:YYY" rel="noopener noreferrer" data-external="true" target="_blank">http：//teamcity.url/app/rest/agentPools/id：XXX / projects / id：YYY</a> 。</p></div></div><a name="Users"></a><a name="Users"></a><div class="chapter"><h3 id="RESTAPI-Users">用户数</h3><p id="b6a3a016">用户列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/users" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users</a> 。</p><p id="7f50e175">获取特定的用户详细信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator></userlocator></a> 。</p><p id="4cb9f807">创建一个用户： <code class="code">POST</code> <a href="http://teamcity:8111/app/rest/users" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users</a> 。</p><p id="a4d3e186">更新/删除特定用户： <code class="code">PUT/DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator></userlocator></a> 。</p><p id="91658927">为了<code class="code">POST</code>和<code class="code">PUT</code>请求用户，以相应的GET请求检索的形式发布数据。仅支持以下属性/元素：名称，用户名，电子邮件，密码，角色，组，属性。</p><p id="2606e2e5">使用用户角色： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ roles</userlocator></a> 。</p><p id="7c3a2565"><code class="code"><userLocator></code>可以是以下形式：</p><ul class="list _ul"><li class="list__item" id="7dcb8084"><p><code class="code">id:<internal user id></code> –通过内部ID引用用户</p></li><li class="list__item" id="5162d164"><p><code class="code">username:<user's username></code> –通过用户名/登录名引用用户</p></li></ul><p id="15d3eb28">用户的单个字段： <code class="code">GET/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ <field_name></field_name></userlocator></a> 。</p><p id="6632d346">用户的单一属性： <code class="code">GET/DELETE/PUT</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ properties / <property_name></property_name></userlocator></a> 。</p></div><a name="UserGroups"></a><a name="User-Groups"></a><div class="chapter"><h3 id="RESTAPI-UserGroups">用户组</h3><p id="eff29010">组列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/userGroups" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / userGroups</a> 。</p><p id="c32d9332">组内的用户列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/userGroups/key:Group_Key" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / userGroups / key：Group_Key</a> 。</p><p id="7627c55d">创建一个组： <code class="code">POST</code> <a href="http://teamcity:8111/app/rest/userGroups" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / userGroups</a> 。</p><p id="f69b7821">删除群组： <code class="code">DELETE</code> <a href="http://teamcity:8111/app/rest/userGroups/key:Group_Key" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / userGroups / key：Group_Key</a> 。</p></div><a name="UserAccessTokens"></a><a name="User-Access-Tokens"></a><div class="chapter"><h3 id="RESTAPI-UserAccessTokens">用户访问令牌</h3><p id="cfae71df">访问令牌列表： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ tokens</userlocator></a> 。</p><p id="3625b637">创建访问令牌： <code class="code">POST</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ tokens / <tokenname></tokenname></userlocator></a> 。</p><p id="af7e0953">删除访问令牌： <code class="code">DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / users / <userlocator>/ tokens / <tokenname></tokenname></userlocator></a> 。</p></div><a name="AuditRecords"></a><a name="Audit-Records"></a><div class="chapter"><h3 id="RESTAPI-AuditRecords">审核记录</h3><p id="43aa4a0c">要访问用户操作的记录（也可在TeamCity的“ <b id="758ca728"><a href="tracking-user-actions.html">审核”</a></b>页面上使用），请使用以下请求：</p><p id="88b4a702"><code class="code">GET</code> <a href="http://teamcity:8111/app/rest/audit" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / audit</a></p><p id="f3ea9222">您可以按用户，系统操作，构建类型等（使用<code class="code">GET</code> <a href="http://teamcity:8111/app/rest/audit?locator=$help" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / audit？locator = $ help</a>查看所有可用的过滤器）。</p></div></div><a name="Other"></a><a name="Other"></a><div class="chapter"><h2 id="RESTAPI-Other">其他</h2><a name="DataBackup"></a><a name="Data-Backup"></a><div class="chapter"><h3 id="RESTAPI-DataBackup">数据备份</h3><p id="d2775ad9">开始备份：</p><div class="code-block" data-lang="bash">POST http：// teamcity：8111 / app / rest / server / backup？includeConfigs = true＆includeDatabase = true＆includeBuildLogs = true＆fileName =</div><p id="589d974b">哪里<code class="code"><fileName></code>是要将备份保存到的文件的前缀。该文件将在默认备份目录中创建（请参阅<a href="creating-backup-from-teamcity-web-ui.html">更多信息</a> ）。获取当前备份状态（空闲/正在运行）： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/server/backup" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / backup</a> 。</p></div><a name="TypedParametersSpecification"></a><a name="Typed-Parameters-Specification"></a><div class="chapter"><h3 id="RESTAPI-TypedParametersSpecification">类型参数规格</h3><p id="df758783">列出<a href="typed-parameters.html">类型参数</a> ：</p><ul class="list _ul"><li class="list__item" id="be569818"><p>对于项目： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / projects / <locator>/ parameters</locator></a></p></li><li class="list__item" id="fa27c526"><p>对于构建配置： <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters</locator></a></p></li></ul><p id="822371a6">返回的信息是： <code class="code">parameters count</code> ， <code class="code">property name</code> ， <code class="code">value</code>和<code class="code">type</code> 。的<code class="code">rawValue</code>的<code class="code">type</code> element是用户界面中定义的<a href="typed-parameters.html#Adding-Parameter-Specification">参数规范</a> 。</p><p id="4c8b310d">获取特定参数的详细信息： <code class="code">GET</code>到<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters / <name></name></locator></a> 。</p><p id="c7c9959f">接受/返回纯文本，XML，JSON。向请求提供<a href="#Response-Formats">相关的Content-Type标头</a> 。</p><p id="870fbbc9">创建一个新参数： <code class="code">POST</code>与返回的相同XML或JSON或纯文本<code class="code">GET</code>到<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters /</locator></a> 。请注意，例如<a href="typed-parameters.html">安全参数</a> <code class="code">type=password</code>列出了，但是响应中未包含这些值，因此应在回发之前修改结果。</p><p id="d203d480"><b id="5e3ef523">从TeamCity 9.1开始</b> ，可以部分更新参数（当前处于实验状态）：</p><ul class="list _ul"><li class="list__item" id="3ba87588"><p>名称： <code class="code">PUT</code>与返回的XML或JSON相同<code class="code">GET</code>到<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters / NAME</locator></a></p></li><li class="list__item" id="67dd03e9"><p>类型： <code class="code">GET/PUT</code>接受XML和JSON作为返回<code class="code">GET</code>到URL <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters / NAME / type</locator></a></p></li><li class="list__item" id="879f3402"><p>类型的rawValue： <code class="code">GET/PUT</code>接受纯文本<a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / buildTypes / <locator>/ parameters / NAME / type / rawValue</locator></a></p></li></ul></div><a name="BuildStatusIcon"></a><a name="Build-Status-Icon"></a><div class="chapter"><h3 id="RESTAPI-BuildStatusIcon">生成状态图标</h3><p id="142f664b">代表构建状态的图标：</p><ul class="list _ul"><li class="list__item" id="a676d922"><p>.svg图标（ <b id="d79163a3">推荐</b> ）： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/statusIcon.svg</buildlocator></a></p></li><li class="list__item" id="f7a9c2d4"><p>.png图标： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / builds / <buildlocator>/ statusIcon</buildlocator></a></p></li><li class="list__item" id="7bd905fd"><p>代表多个构建的构建状态的图标（ <b id="191e1df5">自TeamCity 10.0起</b> ）： <code class="code">GET</code>请求和<code class="code">strob</code>构建定位器尺寸。</p></li></ul><p id="15968ae5"><b id="3342df67">请求示例</b> ：</p><p id="20ca9743">对于具有<code class="code">PROJECT_ID</code> ID：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / builds / aggregated / strob：（buildType :(项目：（id：PROJECT_ID）））/ statusIcon.svg</div><p id="e8969e7d">对于带有配置的构建配置中的所有活动分支<code class="code">BUILD_CONF_ID</code> ID：</p><div class="code-block" data-lang="bash">GET http：// teamcity：8111 / app / rest / builds / aggregated / strrob :(分支：（buildType：（id：BUILD_CONF_ID），policy：active_history_and_active_vcs_branches），locator：（buildType：（id：BUILD_CONF_ID）））/ statusIcon .svg</div><p id="82301858">要求<code class="code">/app/rest/builds/aggregated/<build locator></code>状态由构建列表计算： <code class="code">app/rest/builds?locator=<build locator></code> 。这允许通过简单的方式将构建状态图标嵌入到任何HTML页面中<code class="code">img</code>标签：</p><p id="be97e6e1">对于带有<code class="code">BUILD_CONF_ID</code> ID：</p><p id="90cc823d">上次构建的状态：</p><div class="code-block" data-lang="markup"><img src="http://teamcity:8111/app/rest/builds/buildType:(id:BUILD_CONF_ID)/statusIcon">
 

</div><p id="e617afc8">标有的最后一个构建的状态<code class="code">myTag</code>标签：</p><div class="code-block" data-lang="markup"><img src="http://teamcity:8111/app/rest/builds/buildType:(id:BUILD_CONF_ID),tag:myTag/statusIcon">
 

</div><p id="9440e8bd"><img alt="BuildSuccessfulStatus.png" title="BuildSuccessfulStatus.png" src="/help/img/teamcity/2019.1/BuildSuccessfulStatus.png" id="d4a1898c" width="106" height="20" class="inline-icon-106"></p><p id="50906a58">支持所有其他<a href="#Build-Locator">构建定位器</a> 。</p><p id="749d9618">例如，您可以使用以下markdown标记为ID为的构建配置添加GitHub存储库的构建状态<code class="code">TeamCityPluginsByJetBrains_TeamcityGoogleTagManagerPlugin_Build</code>和启用了访客身份验证的服务器<a href="https://teamcity.jetbrains.com" rel="noopener noreferrer" data-external="true" target="_blank">https://teamcity.jetbrains.com</a> ：</p><div class="code-block" data-lang="markup">[！[构建状态]（https://teamcity.jetbrains.com/guestAuth/app/rest/builds/buildType：（id：TeamCityPluginsByJetBrains_TeamcityGoogleTagManagerPlugin_Build）/statusIcon.svg）]（https://teamcity.jetbrains.com/viewType.html？ buildTypeId = TeamCityPluginsByJetBrains_TeamcityGoogleTagManagerPlugin_Build）</div><p id="7f774672">如果返回的图像包含“无权获取数据”文本（ <img alt="no-permission-to-get-data.png" title="no-permission-to-get-data.png" src="/help/img/teamcity/2019.1/no-permission-to-get-data.png" id="0d569cc9" width="201" height="20" class="inline-icon-201"> ），请确保满足以下条件之一：</p><ul class="list _ul"><li class="list__item" id="61682229"><p>服务器启用了<a href="guest-user.html">来宾用户访问权限</a> ，并且来宾用户有权访问引用的构建配置，或者</p></li><li class="list__item" id="6f0d4b50"><p>引用的构建配置具有“启用状态窗口小部件” <a href="configuring-general-settings.html#Enable-Status-Widget">选项</a> <b id="929f9037">ON</b> 。</p></li><li class="list__item" id="bf74a99a"><p>您使用同一浏览器登录到TeamCity服务器，并且您有权查看引用的构建配置。请注意，这对GitHub页面中的嵌入式图像无济于事，因为GitHub从服务器端检索图像。</p></li></ul></div><a name="TeamCityLicensingInformationRequests"></a><a name="TeamCity-Licensing-Information-Requests"></a><div class="chapter"><h3 id="RESTAPI-TeamCityLicensingInformationRequests">TeamCity许可信息请求</h3><p id="de1a0c61"><b id="859a0a00">从TeamCity 10开始</b> ：</p><p id="5692b659">许可信息： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/server/licensingData" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / licensingData</a> 。</p><p id="aab2a1e7">许可证密钥列表： <code class="code">GET</code> <a href="http://teamcity:8111/app/rest/server/licensingData/licenseKeys" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / licensingData / licenseKeys</a> 。</p><p id="ace4b369">许可证密钥详细信息： <code class="code">GET</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / licensingData / licenseKeys / <license_key></license_key></a> 。</p><p id="6c27597b">添加许可证密钥： <code class="code">POST</code> text / plain用换行符分隔的键，用于<a href="http://teamcity:8111/app/rest/server/licensingData/licenseKeys" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / licensingData / licenseKeys</a> 。</p><p id="cdaf047a">删除许可证密钥： <code class="code">DELETE</code> <a href="javascript:void(0);" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / server / licensingData / licenseKeys / <license_key></license_key></a> 。</p></div><a name="CCTray"></a><a name="CCTray"></a><div class="chapter"><h3 id="RESTAPI-CCTray">CCTray</h3><p id="c2b70596">可通过<a href="http://teamcity:8111/app/rest/cctray/projects.xml" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / app / rest / cctray / projects.xml</a>获得与CCTray兼容的XML。</p><p id="95f87922">没有身份验证（仅对来宾用户可用的构建配置）： <a href="http://teamcity:8111/guestAuth/app/rest/cctray/projects.xml" rel="noopener noreferrer" data-external="true" target="_blank">http：// teamcity：8111 / guestAuth / app / rest / cctray / projects.xml</a> 。</p><p id="d7234a57">默认情况下，CCTray格式的XML不包括暂停的构建配置。该网址接受<code class="code">locator</code>使用标准<a href="#Build-Configuration-Locator">构建配置定位器</a>代替参数。</p></div></div><a name="RequestExamples"></a><a name="Request-Examples"></a><div class="chapter"><h2 id="RESTAPI-RequestExamples">索取范例</h2><a name="RequestSendingTool"></a><a name="Request-Sending-Tool"></a><div class="chapter"><h3 id="RESTAPI-RequestSendingTool">请求发送工具</h3><p id="9e25b734">您可以使用<a href="http://en.wikipedia.org/wiki/CURL" rel="noopener noreferrer" data-external="true" target="_blank">curl</a>命令行工具与TeamCity REST API进行交互。</p><p id="feb7bb1c">示例命令：</p><div class="code-block" data-lang="bash">curl -v-基本-用户USERNAME：PASSWORD-请求POST“ http：// teamcity：8111 / app / rest / users /” --data @ data.xml --header“内容类型：application / xml ”</div><p id="2b544bce">哪里<code class="code">USERNAME</code> ， <code class="code">PASSWORD</code> ， <code class="code">teamcity:8111</code>用实际值代替，并且<code class="code">data.xml</code>文件包含要发送到服务器的数据。</p><a name="Creatinganewproject"></a><a name="Creating-a-new-project"></a><div class="chapter"><h4 id="RESTAPI-Creatinganewproject">创建一个新项目</h4><p id="70a1c6be">使用卷曲工具：</p><div class="code-block" data-lang="bash">curl -v -u用户：PASSWORD http：// teamcity：8111 / app / rest / projects --header“内容类型：application / xml” --data-binary“ <newprojectdescription name="New Project Name" id="newProjectId"><parentproject locator="id:project1"></parentproject></newprojectdescription> ”</div></div><a name="Makinguserasystemadministrator"></a><a name="Making-user-a-system-administrator"></a><div class="chapter"><h4 id="RESTAPI-Makinguserasystemadministrator">使用户成为系统管理员</h4><ol class="list _decimal"><li class="list__item" id="f0dc6458"><p>获取<a href="super-user.html">超级用户</a>令牌。</p></li><li class="list__item" id="7d10dd2a"><p>发出请求。</p></li><li class="list__item" id="34a45b36"><p>获取<a href="http://en.wikipedia.org/wiki/CURL" rel="noopener noreferrer" data-external="true" target="_blank">curl</a>命令行工具并使用命令行：</p></li></ol><div class="code-block" data-lang="bash">curl -v -u：SUPERUSER_TOKEN-请求PUT http：// teamcity：8111 / app / rest / users / username：USERNAME / roles / SYSTEM_ADMIN / g /</div><p id="cae9be1e">哪里<code class="code">SUPERUSER_TOKEN</code>是每个服务器启动时唯一的超级用户令牌； <code class="code">teamcity:8111</code> – TeamCity服务器URL； <code class="code">USERNAME</code> –要成为系统管理员的用户名。</p><aside class="tip sideblock" rel="cae9be1e" id="7f52ec98" data-title=""><p id="55060451">此外部<a href="https://gist.github.com/carlspring/6762356" rel="noopener noreferrer" data-external="true" target="_blank">发布</a>中提供了更多示例（适用于TeamCity 8.0）。</p></aside><hr id="772072c3"></div></div></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v2/app.js"></script></body></html>