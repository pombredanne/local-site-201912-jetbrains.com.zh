<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/help/app/v2/analytics.js"></script><meta charset="UTF-8"><title>Use Profiling API - Help | dotTrace</title><link rel="stylesheet" href="/help/app/v2/app.css"></head><body data-id="Use_Profiling_API" data-disqus-id="Use_Profiling_API_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotTrace Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2018.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="false"><h1 data-toc="Use_Profiling_API" id="Use_Profiling_API.xml">Use Profiling API</h1>    <aside class="warning " data-title="" rel="Use_Profiling_API.xml" id="414db9d6">        <p id="52284a95">            Disclaimer: This tutorial covers the usage of API only for the performance profiling method. The            implementation            of the timeline profiling API is very similar, with a few minor exceptions. For details on timeline            profiling API classes, refer to            <a href="Profiling_Guidelines__Advanced_Profiling_Using_dotTrace_API.html#timeline"><span>Timeline profiling</span></a>.        </p>    </aside>    <p id="208cddd8">In this tutorial, we'll learn how to use the profiling API in two main scenarios:</p>    <ul class="list _ul"><li class="list__item" id="6505d928"><p>            Profiling a specific part of the code.        </p></li><li class="list__item" id="097c57ef"><p>            Self-profiling of applications.        </p></li></ul>    <div class="chapter"><h2 id="efb3ccf0" data-toc="Use_Profiling_API#efb3ccf0">How the API works</h2>    <p id="cf63c91d">        The profiling API is the main part of the profiling SDK. Without going into details, the API provides a number        of        classes which allow you to control the profiling process. For example, you can start and stop collecting        profiling data, save collected snapshots and so on right from your application.    </p>    <p id="0e7aae22">Before going any further, let's take a little bit more detailed look at the API usage scenarios:</p>    <ul class="list _ul"><li class="list__item" id="8d52e4f3">            <p id="7c3f181a">                <b id="2b8fc4b9">Profiling a Specific Part of the Code</b>            </p>            <p id="701b9645">Typically, if your application is quite huge, you don't need to profile it entirely. The main point of                your                interest is the performance of some new functionality or a certain method. Using the dotTrace API, you                can                narrow the profiling scope. More specifically, the API allows you to start profiling measurements and                collect snapshots in the exact places of your code.            </p>        </li><li class="list__item" id="927bd885">            <p id="c34071c4">                <b id="f6fd197c">Self-Profiled Applications</b>            </p>            <p id="161b8aad">dotTrace API gives you a great opportunity to collect statistics about how your app behaves on end-user                desktops. Do they face any performance issues and where is the "weakest" point in your app? Due to high                PC hardware fragmentation, this information may be of great interest to you.            </p>            <p id="29f66ffd">For this purpose, the API allows you to attach the profiling engine* to the running process in the                background and take snapshots right from the code. Collected snapshots can be saved on the disk or                passed to any other app (for example, a client that will send them to your server over HTTP).                This is called self-profiling as the application, in some sense, profiles itself.            </p>            <aside class="note " data-title="" rel="29f66ffd" id="66d6fda2"><p>* Must be supplied with your app.</p></aside>        </li></ul>    <p id="b93727f2">Now, let's take some simple application and try both scenarios in action!</p>    </div>    <div class="chapter"><h2 id="9a139e35" data-toc="Use_Profiling_API#9a139e35">Prerequisites</h2>    <p id="84bfd988">Before we continue, please accomplish the following prerequisites:</p>    <ol class="list _decimal"><li class="list__item" id="b969dbc9"><p>Make sure you have Visual Studio and dotTrace installed on your computer.</p></li><li class="list__item" id="5ace11d4"><p>Download the sample application from            <a href="https://github.com/DarthWeirdo/dotTrace_API_Tutorial" data-external="true" target="_blank" rel="noopener noreferrer"><span>github</span></a>.        </p></li><li class="list__item" id="2d882e9d">Download and install            <a href="/profiler/download/#section=dottracesdk" data-external="true" target="_blank" rel="noopener noreferrer"><span>Profiling SDK</span></a>.            <p id="a4af211b">                IMPORTANT! If your domain policy is to treat the files downloaded from the Internet as unsafe, unblock                the zip archive using the Unblock button in file properties.                <figure><img alt="t4 unblock" title="t4 unblock" src="/help/img/dotnet/2018.3/t4_unblock.png" id="6fb478de" width="363" height="509"></figure>            </p>        </li></ol>    </div>    <div class="chapter"><h2 id="2cc9ed9e" data-toc="Use_Profiling_API#2cc9ed9e">Sample application</h2>    <p id="712dfe9d">For the example, we'll use the classic Conway's Game of Life application.        Our WPF-based implementation of Game of Life works in the following way:    </p>    <ul class="list _ul"><li class="list__item" id="f60807a6"><p>            A single instance of the            <code class="code" data-lang="Java">Grid</code>            class is responsible for storing, updating, and displaying of a huge number of            cells (instances of the            <code class="code" data-lang="Java">Cell</code>            class).        </p></li><li class="list__item" id="5bd98db0"><p>            Each next generation of cells is created once in 200 ms:            The            <code class="code" data-lang="Java">OnTimer</code>            event handler of the            <code class="code" data-lang="Java">DispatcherTimer</code>            instance            runs the            <code class="code" data-lang="Java">Grid.Update()</code>            method which calculates cell states for the next generation(<code class="code" data-lang="Java">Grid.UpdateToNextGeneration()</code>)            and updates graphics (<code class="code" data-lang="Java">Grid.UpdateGraphics()</code>).        </p></li></ul>    </div>    <div class="chapter"><h2 id="be07fe81" data-toc="Use_Profiling_API#be07fe81">Profiling a specific part of the code</h2>    <p id="7d092808">        Let's assume we have made some changes to the way we calculate the next generation. Now, we want to check how        the        performance has changed. The Profiling API allows us to profile nothing but the method we want -        <code class="code" data-lang="Java">Grid.Update()</code>.        All we need is to start collecting profiling data right before the method is executed and collect a snapshot        after the execution.    </p>    <ol class="list _decimal"><li class="list__item" id="da9588eb"><p>Open the GameOfLife solution in Visual Studio.</p></li><li class="list__item" id="780ef4cf">To use the Profiling API, you must reference the            <code class="code" data-lang="Java">JetBrains.Profiler.Windows.Api</code>            assembly which contains the            API classes. To do this:            <ul class="list _alpha-lower"><li class="list__item" id="44e0e53f"><p>In <span class="control">Solution Explorer</span>, right click <span class="control">References</span>.                </p></li><li class="list__item" id="a00eb2ec"><p>In the context menu, select                    <span class="control">Add Reference</span>.                    <figure><img alt="t4 add reference" title="t4 add reference" src="/help/img/dotnet/2018.3/t4_add_reference.png" id="7a757153" width="444" height="359"></figure>                </p></li><li class="list__item" id="ec3c02e8"><p>                    In the opened window, click                    <span data-skip-index="skip" class="menupath">Browse | Browse</span>                    and specify the path to                    <span class="filepath">JetBrains.Profiler.Windows.Api.dll</span>                    located in the main Profiling SDK directory.                    <figure><img alt="t4 api reference" title="t4 api reference" src="/help/img/dotnet/2018.3/t4_api_reference.png" id="c7f7d699" width="691" height="343"></figure>                </p></li><li class="list__item" id="cebe6dba"><p>                    Click <span class="control">OK</span>.                    <figure><img alt="t4 api reference 2" title="t4 api reference 2" src="/help/img/dotnet/2018.3/t4_api_reference_2.png" id="295c74f2" width="277" height="253"></figure>                </p></li></ul>        </li><li class="list__item" id="92d01ce8"><p>            Open the            <code class="code" data-lang="Java">OnTimer</code>            method of the <code class="code" data-lang="Java">MainWindow</code> class. As you see, it is the timer's event handler which updates            the <code class="code" data-lang="Java">Grid</code> instance by running the            <code class="code" data-lang="Java">_mainGrid.Update()</code>            method. This makes the            <code class="code" data-lang="Java">OnTimer</code>            event handler a perfect candidate for            injecting our API code.            <div class="code-block" data-lang="C#"><code class="code-block__wrapper"><span class="k">private</span> <span class="k">void</span> <span class="nf">OnTimer</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_mainGrid</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span>
    <span class="n">_genCounter</span><span class="p">++;</span>
    <span class="n">lblGenCount</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="s">&quot;Generations: &quot;</span> <span class="p">+</span> <span class="n">genCounter</span><span class="p">;</span>
<span class="p">}</span></code></div>            To control the profiling process, the API uses the static            <code class="code" data-lang="Java">PerformanceProfiler</code>            class. To start profiling, you            should first call the            <code class="code" data-lang="Java">Begin</code>            method (creates a blank snapshot) and the            <code class="code" data-lang="Java">Start</code>            method which actually starts            measurements.            <code class="code" data-lang="Java">Stop</code>            suspends measurements, while <code class="code" data-lang="Java">EndSave</code> initiates snapshot processing in dotTrace. Let's try out            these methods.        </p></li><li class="list__item" id="d9c13870"><p>            For example, we need to profile only a single execution of the            <code class="code" data-lang="Java">OnTimer</code>            event handler. To do this, we should start            profiling in the beginning of            <code class="code" data-lang="Java">OnTimer</code>            (with <code class="code" data-lang="Java">PerformanceProfiler.Begin</code> and            <code class="code" data-lang="Java">PerformanceProfiler.Start</code>) and take a            snapshot after the code is executed (with            <code class="code" data-lang="Java">ProfilingControl.Stop</code>            and <code class="code" data-lang="Java">PerformanceProfiler.EndSave</code>).            After the correction, the code should look like follows:            <div class="code-block" data-lang="C#"><code class="code-block__wrapper"><span class="k">if</span> <span class="p">(</span><span class="n">_genCounter</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Begin</span><span class="p">();</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">_mainGrid</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span>
<span class="n">_genCounter</span><span class="p">++;</span>
<span class="n">lblGenCount</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="s">&quot;Generations: &quot;</span> <span class="p">+</span> <span class="n">genCounter</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">_genCounter</span> <span class="p">==</span> <span class="m">2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">EndSave</span><span class="p">();</span>
<span class="p">}</span></code></div>            The <code class="code" data-lang="Java">genCounter</code> field (generation counter) helps us to start and stop the profiler just once            (to profile only a single <code class="code" data-lang="Java">_mainGrid.Update()</code> execution). The            <code class="code" data-lang="Java">PerformanceProfiler.IsActive</code>            is used to determine whether the API            is enabled. It must be checked only once. After the changes are made, let's run the profiling.        </p></li><li class="list__item" id="d4f0fa63"><p>            In Visual Studio, select the menu            <span data-skip-index="skip" class="menupath">ReSharper | Profile | Run Startup Configuration Performance Profiling...</span>.            This will open the profiler configuration window.        </p></li><li class="list__item" id="546f9796">            Change the <span class="control">Profiling type</span> to <span class="control">Tracing</span>*.            <aside class="note " data-title="" rel="7ecb144f" id="64171fef">                <p id="e5f98855">                    * The <span class="control">Tracing</span> type is much better suited for our case. The thing is in the                    <span class="control">Sampling</span>                    mode, dotTrace takes call stack information (samples) once in a period                    of time from 5 to 11 ms. As a single execution of the                    <code class="code" data-lang="Java">Update()</code>                    method probably takes less time, the chances it won't be detected by the                    profiler are quite high. In the tracing mode, dotTrace gets information about every function entry                    and exit right from CLR. That's why this method gives more detailed results.                </p>            </aside>        </li><li class="list__item" id="ed7d55c8"><p>Select <span class="control">Advanced</span> to see more profiling options.        </p></li><li class="list__item" id="bdc0c9af"><p>            Select the <span class="control">Use profiler API</span> option. This will make the API commands we added to the code            work.            The profiler configuration window should look like follows.            <figure><img alt="t4 profiling options" title="t4 profiling options" src="/help/img/dotnet/2018.3/t4_profiling_options.png" id="98d8d6dc" width="685" height="861"></figure>        </p></li><li class="list__item" id="0241de2f"><p>Click <span class="control">Run</span>.        </p></li><li class="list__item" id="80773eda"><p>            This will run the Game of Life application and open the profiling controller window.            <figure><img alt="t4 app" title="t4 app" src="/help/img/dotnet/2018.3/t4_app.png" id="14f7a6a0" width="786" height="513"></figure>            You might notice that the controller window doesn't have any controls.            Profiling is now controlled only by the Profiling API.        </p></li><li class="list__item" id="830e47ef"><p>            As the            <code class="code" data-lang="Java">OnTimer</code>            event handler is executed only when Game of Life is started, start the game using the            <span class="control">Start</span>            button.            Right after the second cells generation is generated, dotTrace will take a snapshot and open it in            Performance            Viewer.            <figure><img alt="t4 dT threads" title="t4 dT threads" src="/help/img/dotnet/2018.3/t4_dT_threads.png" id="5a31879f" width="784" height="513"></figure>        </p></li><li class="list__item" id="63d6160f"><p>            In Performance Viewer, expand the            <span class="control">Main</span>            thread node.            <figure><img alt="t4 dT threads details" title="t4 dT threads details" src="/help/img/dotnet/2018.3/t4_dT_threads_details.png" id="cb8e873c" width="784" height="513"></figure>            As you see, the thread view contains information only about a single call of the            <code class="code" data-lang="Java">Update()</code>            method. Just what we needed!        </p></li></ol>    </div>    <div class="chapter"><h2 id="9c13836a" data-toc="Use_Profiling_API#9c13836a">Self-profiled application</h2>    <p id="896826b8">        Now, let's move to a more complex scenario - a self-profiled application. For example, we are concerned about        application performance on end-users desktops and decide to collect such statistics. Here are some        considerations you should know about before implementing self-profiling:    </p>    <ul class="list _ul"><li class="list__item" id="8fdcfe0b"><p>            End-users don't have dotTrace installed; therefore, you must include SDK into your app's installation            package.        </p></li><li class="list__item" id="e3b8bd37"><p>            As end-users are not supposed to initiate profiling, the self-profiling session is initiated by the API.        </p></li><li class="list__item" id="9fd4b048"><p>            For this purpose, the API uses the static            <code class="code" data-lang="Java">SelfAttach</code> class located in the            <span class="filepath">JetBrains.Profiler.Windows.SelfApi.dll</span>            library. Calling the <code class="code" data-lang="Java">Attach</code> method prepares profiling configuration and executes            the profiler from the SDK folder.        </p></li><li class="list__item" id="7b4fe105">            As the profiler is attached to the already running process, there is a limitation* on the profiling type -            it could be either <span class="control">Sampling</span> or <span class="control">Timeline</span>.            <aside class="note " data-title="" rel="5916b882" id="8d560252"><p>* The limitation is related with the .NET internal architecture.</p></aside>        </li></ul>    <p id="85d201a8">Let's try self-profiling in action.</p>    <ol class="list _decimal"><li class="list__item" id="f89d11cc"><p>Open our Game of Life application in Visual Studio.</p></li><li class="list__item" id="8b2f0995">            To use the dotTrace API, you must reference the            <code class="code" data-lang="Java">JetBrains.Profiler.Windows.SelfApi</code> assembly which contains            the API classes. To do this:            <ul class="list _ul"><li class="list__item" id="9511a1eb"><p>In <span class="control">Solution Explorer</span>, right click                    <span class="control">References</span>.                </p></li><li class="list__item" id="d4e9f3b5"><p>In the context menu, select                    <span class="control">Add Reference</span>.</p></li><li class="list__item" id="c2b0efda"><p>                    In the opened window, click                    <span data-skip-index="skip" class="menupath">Browse | Browse</span> and specify the path to                    <span class="filepath">JetBrains.Profiler.Windows.SelfApi.dll</span>                    located in the main Profiling SDK directory.                </p></li><li class="list__item" id="bcf7b4f8"><p>                    Click OK.                    <figure><img alt="t4 self api reference" title="t4 self api reference" src="/help/img/dotnet/2018.3/t4_self_api_reference.png" id="c61ff6ec" width="275" height="271"></figure>                </p></li></ul>        </li><li class="list__item" id="6fb26144">            First, we need to initiate self-profiling using the            <code class="code" data-lang="Java">SelfAttach</code> class. This can be done anywhere in the application            before we call <code class="code" data-lang="Java">PerformanceProfiler</code>'s methods. In our case, this could be done in the            constructor of the main window. To do            this, open the  <code class="code" data-lang="Java">MainWindow()</code> constructor in            <span class="filepath">MainWindow.xaml.cs</span> and add the following lines to the end            of the constructor:            <div class="code-block" data-lang="C#"><code class="code-block__wrapper"><span class="n">SelfAttach</span><span class="p">.</span><span class="n">Attach</span><span class="p">(</span><span class="k">new</span> <span class="n">SaveSnapshotProfilingConfig</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ProfilingControlKind</span> <span class="p">=</span> <span class="n">ProfilingControlKind</span><span class="p">.</span><span class="n">Api</span><span class="p">,</span>
    <span class="n">SaveDir</span> <span class="p">=</span> <span class="s">&quot;C:\\Temp&quot;</span><span class="p">,</span>
    <span class="n">RedistDir</span> <span class="p">=</span> <span class="s">&quot;C:\\ProfilerSDK&quot;</span><span class="p">,</span>
    <span class="n">ProfilingType</span> <span class="p">=</span> <span class="n">ProfilingType</span><span class="p">.</span><span class="n">Performance</span><span class="p">,</span>
    <span class="n">SnapshotFormat</span> <span class="p">=</span> <span class="n">SnapshotFormat</span><span class="p">.</span><span class="n">Uncompressed</span><span class="p">,</span>
    <span class="n">ListFile</span> <span class="p">=</span> <span class="s">&quot;C:\\snapshot_list.xml&quot;</span>
<span class="p">});</span></code></div>            As you see, we pass an instance of the            <code class="code" data-lang="Java">SaveSnapshotProfilingConfig</code> class as a parameter to the            <code class="code" data-lang="Java">Attach</code> method.            This tells dotTrace how to process the resulting snapshot. In our case, we tell the profiler to save the snapshot            file on the disk. There is also one more option you can use instead:            <code class="code" data-lang="Java">ExecutableSnapshotProfilingConfig</code> will run an external            application passing the path to the snapshot as a command-line parameter. This option is of most interest in            case you're going to get snapshots from end-user computers remotely.            Public fields of the <code class="code" data-lang="Java">SaveSnapshotProfilingConfig</code> class allow us to specify the following            profiling options*:            <ul class="list _ul"><li class="list__item" id="d05e4e72"><p>                    <code class="code" data-lang="Java">ProfilingControlKind</code> defines how the profiling must be controlled.                    The <code class="code" data-lang="Java">ProfilingControlKind.API</code> value                    means we'll control the session by means of the API. You can also decide to control                    the session using the controller window or don't control it at all.                </p></li><li class="list__item" id="8afb336a"><p>                    <code class="code" data-lang="Java">SaveDir</code> specifies the location where we want to save snapshot files.                </p></li><li class="list__item" id="eb72817b"><p>RedistDir specifies the path to Profiling SDK.</p></li><li class="list__item" id="2dba4d95"><p>                    <code class="code" data-lang="Java">ProfilingType</code> defines the profiling method. E.g., if you want to perform                    timeline profiling, you should specify                    <code class="code" data-lang="Java">ProfilingType.Timeline</code> here.                </p></li><li class="list__item" id="b7be3922"><p>                    <code class="code" data-lang="Java">SnapshotFormat</code> defines the format of the snapshot files. <code class="code" data-lang="Java">Uncompressed</code> means                    that the snapshot will be saved as a number of uncompressed files which you can open in dotTrace                    without any additional actions. The default value <code class="code" data-lang="Java">Compressed</code> tells the API to save                    snapshot files in a single zip which is more convenient for further distribution.                </p></li><li class="list__item" id="56921526"><p>                    <code class="code" data-lang="Java">ListFile</code> stores file names of snapshots collected during profiling. This file is created                    automatically during profiling.                </p></li></ul>            <aside class="note " data-title="" rel="57ff09db" id="590a6a75">                <p id="b4bffb12">                    * Some of these parameters are optional. For more information about them, refer to                    <a href="API_Reference.html"><span>API Reference</span></a>.                </p>            </aside>        </li><li class="list__item" id="afcc947e"><p>            As mentioned in the beginning, the only possible profiling type when using self-profiling is            <span class="control">Sampling</span>. Due to this,            we cannot profile just a single execution of the            <code class="code" data-lang="Java">OnTimer</code> event handler as in the previous scenario. As the            <code class="code" data-lang="Java">OnTimer</code> execution probably takes less than the sampling time (5 – 11 ms),            the chances it won't be detected by the profiler are quite high. Therefore, we need to extend the            profiling scope and take performance results of, for example,            first 10 <code class="code" data-lang="Java">OnTimer</code> executions. To do this, in the            <code class="code" data-lang="Java">OnTimer</code> event handler, we must say the profiler to stop and save snapshot            only after the 10th Game of Life generation:            <div class="code-block" data-lang="C#"><code class="code-block__wrapper"><span class="k">while</span> <span class="p">(</span><span class="n">SelfAttach</span><span class="p">.</span><span class="n">State</span> <span class="p">!=</span> <span class="n">SelfApiState</span><span class="p">.</span><span class="n">Active</span><span class="p">)</span>
<span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">250</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">_genCounter</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Begin</span><span class="p">();</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">_mainGrid</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span>
<span class="n">_genCounter</span><span class="p">++;</span>
<span class="n">lblGenCount</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="err">$</span><span class="s">&quot;Generations: {_genCounter}&quot;</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">_genCounter</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
    <span class="n">PerformanceProfiler</span><span class="p">.</span><span class="n">EndSave</span><span class="p">();</span>
<span class="p">}</span></code></div>        </p></li><li class="list__item" id="c864a3a6"><p>Build and run the application.</p></li><li class="list__item" id="d572d9c6"><p>Start Game of Life using the <span class="control">Start</span> button. Wait until 10 generations pass.</p></li><li class="list__item" id="00a90955"><p>Check the folder you've specified as <code class="code" data-lang="Java">SaveDir</code>. If everything works fine, it should contain the            snapshot file.            <figure><img alt="t4 self api snapshot" title="t4 self api snapshot" src="/help/img/dotnet/2018.3/t4_self_api_snapshot.png" id="f817f149" width="697" height="371"></figure>            The resulting snapshot file can be then opened and inspected in dotTrace Performance Viewer.        </p></li></ol>    <p id="fd8c9a46">        Of course, the "real-life" self-profiling implementation may differ from the given example. Thus, it would be        great to handle main API exceptions, care for the cases when a user stops the game before the profiling is finished,        and so on. Nevertheless, the provided example contains the minimum you should know to implement self-profiling in        your application.    </p></div><div class="last-modified" data-skip-index="skip">Last modified: 15 March 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Profile_Static_Method.html">Profile Static Method</a><a class="navigation-links__next" href="Profiling_Guidelines__Starting_a_Profiling_Session.html">Running dotTrace</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/help/app/v2/app.js"></script></body></html>