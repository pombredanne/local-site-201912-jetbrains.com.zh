<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta name="robots" content="noindex"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/help/app/v2/analytics.js"></script><meta content="&#xA;        how to profile async calls, async await performance profiling, profiling asynctask&#xA;    " name="description" data-skip-index="skip"><meta charset="UTF-8"><title>Analyzing Async Calls - Help | dotTrace</title><link rel="stylesheet" href="/help/app/v2/app.css"></head><body data-id="Analyzing_Async_Calls" data-disqus-id="Analyzing_Async_Calls_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotTrace Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2018.3 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs" selected>Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="false"><h1 data-toc="Analyzing_Async_Calls" id="Analyzing_Async_Calls.xml">Analyzing Async Calls</h1>        <p id="9084c38a">        One of the downsides of asynchronous code is it's extremely difficult to profile it and analyze its        performance. This is because, when an asynchronous method is executed, control is switched to a different        thread and back, tangling the resulting call tree.    </p>    <p id="8668dba1">        dotTrace dramatically simplifies the analysis of asynchronous code: It marks all        <code class="code" data-lang="Java">async</code>        call nodes in        <span class="control">Call Tree</span>        and groups the corresponding <code class="code" data-lang="Java">await</code> time and continuation code        under that node. This means that you can quickly find all "parts" of an asynchronous call        in one place instead of searching for them in different call stacks.    </p>    <p id="f390ea2e">        To better understand how dotTrace treats asynchronous code, consider the following example        (the code is shown on the left, the corresponding <span class="control">Call Tree</span> on the right):    </p>    <figure><img alt="async calls expanded readasync" title="async calls expanded readasync" src="/help/img/dotnet/2018.3/async_calls_expanded_readasync.png" id="1efbdaac" width="1176" height="362"></figure>    <p id="293f1e35">        As you can see, all "parts" of the asynchronous call are shown inside the        <span class="control">async RunAsyncOperation</span>        node:        <ul class="list _ul"><li class="list__item" id="58d5f9dd"><p>                The total time of <code class="code" data-lang="Java">RunAsyncOperation</code> is calculated as                <br>                119 ms =                <code class="code" data-lang="Java">Init()</code>                101 ms +                <code class="code" data-lang="Java">ReadAsync()</code>                13 ms +                <code class="code" data-lang="Java">clr.dll</code>                3.7 ms +                <code class="code" data-lang="Java">FileStream.ctor()</code>                0.6 ms            </p></li><li class="list__item" id="b07868bf"><p>                The <code class="code" data-lang="Java">Init</code> method (101 ms) is executed on the Main thread, therefore, its time is added                to the total time of <code class="code" data-lang="Java">RunAsyncOperation</code>.            </p></li><li class="list__item" id="46369a8b"><p>                The <code class="code" data-lang="Java">ReadAsync</code> is started on the Main thread (13 ms) but the subsequent                task is run on a thread pool. Thus, the time of the                <span class="control">Task execution</span>                node (819 ms) is shown grey and is not added to the total time of <code class="code" data-lang="Java">RunAsyncOperation</code>.                <figure><img alt="async calls task execution" title="async calls task execution" src="/help/img/dotnet/2018.3/async_calls_task_execution.png" id="5d870362" width="461" height="71"></figure>            </p></li><li class="list__item" id="d02dc386"><p>                The <span class="control">await</span> time in our case is equal to the                <span class="control">Task execution</span>                time (819 ms) but in real life it can be higher as it also includes the time the task waits in schedule.            </p></li><li class="list__item" id="4b3571eb"><p>                The <span class="control">continuations</span> node is a continuation code which in our case                consists of a single <code class="code" data-lang="Java">ProcessFile</code> method (301 ms).                As this call is executed on the thread pool,                its time is also shown gray and is not                added to the total time of <code class="code" data-lang="Java">RunAsyncOperation</code>.            </p></li></ul>    </p>    <div class="chapter"><h2 id="d071496a" data-toc="Analyzing_Async_Calls#d071496a">Identifying the slowest async calls in Methods and Subsystems</h2>        <p id="4a5f07ca">            As you can see, the total <code class="code" data-lang="Java">async</code> call time does not include the time of all its parts in            <span class="control">Call Tree</span>. But what if you want to quickly identify the 'hot spots' - the slowest methods            in your app? For such kind of task it would be better if the <code class="code" data-lang="Java">async</code> method's total time            included the continuation code.            This is actually true for the <span class="control">Methods and Subsystems</span> list, but <span class="emphasis">only</span>            if you stand on the <span class="control">All Calls</span> node in <span class="control">Call Tree</span>.        </p>        <figure><img alt="async calls expanded readasync topmethods" title="async calls expanded readasync topmethods" src="/help/img/dotnet/2018.3/async_calls_expanded_readasync_topmethods.png" id="24f6558f" width="664" height="557"></figure>    </div>    <div class="chapter"><h2 id="c04d7965" data-toc="Analyzing_Async_Calls#c04d7965">Backtraces of the continuation code</h2>        <p id="efd18041">            Of course,            <span class="control">Backtraces</span>            of the continuation code will lead you back not just to the callback function but to the original            <code class="code" data-lang="Java">async</code>            method. This could be very helpful, e.g., when the continuation code throws an            exception and you need to identify its origin.        </p>        <figure><img alt="async calls backtraces" title="async calls backtraces" src="/help/img/dotnet/2018.3/async_calls_backtraces.png" id="1b4bea40" width="598" height="137"></figure>    </div>    <div class="chapter"><h2 id="478af866" data-toc="Analyzing_Async_Calls#478af866">Filtering by async call's total time</h2>        <p id="dd3f2571">            To apply the filter by async call's total time, either double-click the call node in <span class="control">Call Tree</span>            or right-click the node (or its <span class="control">await</span> or <span class="control">continuations</span> node)            and select <span class="control">Analyze Async Method</span> from the context menu.        </p>        <p id="afe709f8">            After you filter by an <code class="code" data-lang="Java">async</code> method's call time, dotTrace will leave only the time            intervals where the method was executed. Note that you can include or exclude continuation code            intervals (as well as the            <span class="control">await</span>            time node) by selecting the corresponding check boxes that appear in            <span class="control">Call Tree</span>.            <figure id="cd1bb8ec" width="604" height="688"><img class="js-gif" src="/help/img/dotnet/2018.3/async_await_filter.png" data-gif-src="/help/img/dotnet/2018.3/async_await_filter.animated.gif" width="604" style="width:604px;"></figure>        </p>        <p id="b0a15737">            Note that if you apply filters so that the continuation code will be out of scope            (e.g., a filter by Main thread), the            <span class="control">Continuations</span>            check box will not be shown.        </p>    </div>    <div class="chapter"><h2 id="b109f852" data-toc="Analyzing_Async_Calls#b109f852">Tasks in Call Tree</h2>        <p id="fa8960c5">            The aforementioned functionality works not only with            <code class="code" data-lang="Java">async/await</code>            but with all tasks based on the            <code class="code" data-lang="Java">Task</code>            class.            The <code class="code" data-lang="Java">Run</code> node contains the            <span class="control">Task execution</span>            node with the task delegate:            <figure><img alt="async calls task" title="async calls task" src="/help/img/dotnet/2018.3/async_calls_task.png" id="5d6ca758" width="920" height="256"></figure>        </p>    </div>    <div class="chapter"><h2 id="a00c7e12" data-toc="Analyzing_Async_Calls#a00c7e12">Asynchronous calls and events</h2>        <p id="836a3f67">            Last but not least worth to mention            <span class="control">Call Tree</span>            works with calls time as well as with all other types            of events            supported in the Timeline profiling mode, e.g., memory allocation or exceptions.            For example, you can view            how much memory a particular async method allocates:            <figure><img alt="async calls allocations" title="async calls allocations" src="/help/img/dotnet/2018.3/async_calls_allocations.png" id="1622b3ed" width="657" height="200"></figure>        </p>    </div><div class="last-modified" data-skip-index="skip">Last modified: 15 March 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Call_Tree.html">Call Tree</a><a class="navigation-links__next" href="Forecasting_Performance_Timeline.html">Forecasting Performance</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/help/app/v2/app.js"></script></body></html>