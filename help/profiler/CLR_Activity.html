<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>垃圾收集-帮助|帮助dotTrace</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="CLR_Activity" data-disqus-id="CLR_Activity_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="CLR_Activity.xml" data-toc="CLR_Activity">垃圾收集</h1>    <p id="2bcf00c6"><span class="control">垃圾收集</span>过滤器用于通过过滤执行GC的时间间隔来分析垃圾收集（GC）。</p>    <p id="3680a2a0">要了解<span class="control">垃圾收集</span>过滤器的工作原理，您应该熟悉基本的GC概念。</p>    <div class="chapter"><h2 id="e4998b5f" data-toc="CLR_Activity#e4998b5f">垃圾收集概念简介</h2>        <ul class="list _ul"><li class="list__item" id="1599a239"><p>对于桌面应用程序，.NET Framework提供了一种所谓的工作站GC模式。</p></li><li class="list__item" id="48df7128"><p>工作站垃圾收集有两种类型：前台垃圾回收和后台垃圾回收。</p></li><li class="list__item" id="8f5b45d9"><p>为了执行前台GC，垃圾收集器会挂起所有托管线程（触发该收集的线程除外）。这也会挂起主线程并导致UI冻结。这是“纯” <b id="fae0fbda">阻塞GC</b> 。</p></li><li class="list__item" id="192b0408"><p>                <b id="f7e25b76">后台GC</b>由单独的GC线程执行，并且在“最繁重的” Gen2收集期间不会挂起托管线程。但是，在Gen0和Gen1收集期间，必须暂停托管线程。因此，后台GC仍然包含较短的“阻塞GC”间隔。<i id="c65f968a">默认情况下，后台GC处于打开状态。</i>            </p></li><li class="list__item" id="62007908"><p>对于服务器应用程序，有一种特殊的服务器GC模式。与工作站GC相比，主要区别在于在服务器GC模式下，每个逻辑处理器都有其自己的托管堆和单独的GC线程。从Timeline Viewer中的性能分析的角度来看，后台GC和服务器GC之间没有巨大差异。</p></li></ul>        <p id="1c9eb469">在<a href="http://msdn.microsoft.com/en-us/library/ee787088(v=vs.110).aspx" rel="noopener noreferrer" data-external="true" target="_blank">MSDN中</a>了解有关GC类型的更多信息。</p>        <p id="1f538d36">为了帮助您区分何时执行特定类型的GC，dotTrace为您提供了“ <span class="control">垃圾回收：类型”</span>子过滤器。</p>    </div>    <div class="chapter"><h2 id="c0a7e7da" data-toc="CLR_Activity#c0a7e7da">垃圾收集：类型</h2>        <p id="d9afcb42">子过滤器显示特定类型的集合之间的总GC时间分布。</p>        <p id="f50afe84">使用此子过滤器分析垃圾回收：原因，线程和切换垃圾回收的方法。例如，如果看到大量的GC时间阻塞，则将“ <span class="control">事件”</span>筛选器切换到<span class="control">.NET内存分配</span>并确定分配的内存量最大的线程是有意义的。这些很可能是触发GC的线程。</p>        <figure><img alt="gc型子过滤器" title="gc型子过滤器" src="/help/img/dotnet/2019.2/gc_type_subfilter.png" id="3744188e" width="386" height="195" align="middle"></figure>        <p id="5ab6c2f0">            <img alt="位置1" title="位置1" src="/help/img/dotnet/2019.2/pos_1.png" id="c9de46b3" width="32" height="32" class="inline-icon-32"> GC类型：</p><ul class="list _ul"><li class="list__item" id="83f14cd2"><p>                    <span class="control">阻止</span> -阻止垃圾收集。除切换GC的线程以外的所有线程均被挂起。您分析的主要主题。</p></li><li class="list__item" id="27ba5d24"><p>                    <span class="control">后台</span> -由单独的GC线程执行，在“最重”的Gen2收集期间不会挂起托管线程。过多的背景GC也是优化的主题。</p></li><li class="list__item" id="704969bb"><p>                    <span class="control">在后台期间阻塞</span> -后台GC在Gen2收集期间不会挂起其他线程。但是，Gen0和Gen1集合（这是完整GC的必然部分）仍然需要挂起托管线程。因此，后台GC始终意味着较短的阻塞GC间隔。<span class="control">背景期间阻止</span>类型将过滤掉这些间隔。</p></li></ul>        <p></p>        <p id="20ca7550">            <img alt="位置2" title="位置2" src="/help/img/dotnet/2019.2/pos_2.png" id="9e76655a" width="31" height="31" class="inline-icon-31">所有选定线程的相应类型的GC花费的总时间总计。<br>        </p>        <p id="63119154">            <img alt="位置3" title="位置3" src="/help/img/dotnet/2019.2/pos_3.png" id="d75b82e4" width="31" height="30" class="inline-icon-31">在相应类型的GC上花费的时间相对于总选定时间的百分比。</p>        <section class="procedure-steps"><h3 id="170df90e">要应用垃圾收集：键入过滤器</h3><div id="b403c9e8"><p>在过滤器中选择所需的GC类型。</p></div></section>        <p id="69e6119d">选择GC类型后，其他过滤器将仅显示执行所选类型GC的时间间隔的数据。</p>        <figure><img alt="gc类型封锁" title="gc类型封锁" src="/help/img/dotnet/2019.2/gc_type_blocking.png" id="6b537a64" width="344" height="284" align="middle"></figure>        <aside class="note " rel="6b537a64" id="5ca19fa5" data-title="">            <p id="0195cf98">为了简化垃圾收集分析，“ <a href="Process_Overview.html">过程概述”</a>图用单独的条形显示了阻塞GC间隔。</p>        </aside>        <p id="e564b9f5">为了更好地理解dotTrace如何计算垃圾回收间隔，请考虑以下示例。</p>        <div class="chapter"><h3 id="example">例</h3>            <p id="87767854">例如，您的应用程序有两个线程：用户线程1和用户线程2。在某个时候，为了释放一些内存，用户线程＃1切换阻止Gen0，Gen1垃圾回收（下图的<b id="ec7e5e41">A1</b>间隔）。由于内存仍然不足，因此创建了GC线程。它执行完整的GC，其中包括Gen0，Gen1阻止集合（ <b id="e93d6fba">C3</b> ）和Gen2集合（ <b id="16a08d4c">B3</b>和<b id="62b2424d">D3</b> ），后者不阻止其他线程。</p>            <figure><img alt="clr活动1a" title="clr活动1a" src="/help/img/dotnet/2019.2/clr_activity_1a.png" id="5f0f846b" width="492" height="221"></figure>            <p id="761df07c">如果在“ <span class="control">线程”</span>图上选择所有三个线程，则过滤器将按以下方式计算GC时间：</p>            <p id="af0084c7">                <b id="506b9d8c">垃圾收集= A1 + B3 + C3 + D3</b>                <br>                <b id="6d7c5b8d">垃圾收集：阻塞= A1 + C3</b>                <br>                <b id="97bb8cc3">垃圾收集：背景= B3 + C3 + D3</b>                <br>                <b id="04a1e024">垃圾收集：后台= C3期间阻塞</b>                <br>            </p>            <p id="f8b0e9e3">需要注意的是，除了<span class="control">垃圾回收</span>事件，你也可以用在<span class="control">GC等待</span>子系统<a href="Subsystems.html">子系统</a> ，以评估在选定的时间间隔垃圾收集量。不要被<span class="control">垃圾收集</span>和<span class="control">GC等待中</span>显示的不同时间值所混淆。事实是， <span class="control">垃圾收集</span>仅针对实际执行GC的线程计算，而<span class="control">GC Wait</span>子系统时间包括GC阻止的所有线程的所有等待。给定上面的示例， <span class="control">GC Wait</span>将如下计算：</p>            <p id="8b3cae96">                <b id="15383792">GC等待= A1 + A2 + B3 + C1 + C2 + C3 + D3</b>            </p>        </div>    </div>    <div class="chapter"><h2 id="92dc90d6" data-toc="CLR_Activity#92dc90d6">垃圾收集：深度</h2>        <p id="d0797b00"><span class="control">垃圾收集：深度</span>子过滤器显示Gen0，Gen1和Gen2堆收集之间的GC时间分布。</p>        <p id="b725335b">请注意，Gen1集合也始终暗含Gen0堆段的集合。Gen2 GC（也称为完整GC）包括Gen1和Gen0集合。因此，用于在Gen1集合中执行Gen0集合的时间将汇总到Gen1 GC时间。Gen2 GC时间将包括它触发的Gen0和Gen1集合的时间。</p>        <figure><img alt="垃圾收集深度1" title="垃圾收集深度1" src="/help/img/dotnet/2019.2/garbage_collection_depth_1.png" id="2c2db6fb" width="422" height="185" align="middle"></figure>        <p id="127160f5">            <img alt="位置1" title="位置1" src="/help/img/dotnet/2019.2/pos_1.png" id="42503644" width="32" height="32" class="inline-icon-32">堆段名称。</p>        <p id="e405d3a6">            <img alt="位置2" title="位置2" src="/help/img/dotnet/2019.2/pos_2.png" id="e11b1fe4" width="31" height="31" class="inline-icon-31">所有选定线程的阻塞相应深度的GC所花费的总时间总计。<br>        </p>        <p id="57dd37c3">            <img alt="位置3" title="位置3" src="/help/img/dotnet/2019.2/pos_3.png" id="1b0f66e0" width="31" height="30" class="inline-icon-31">阻塞相应深度的GC所花费的时间相对于总选定时间的百分比。</p>        <section class="procedure-steps"><h3 id="a5546412">要应用垃圾收集：深度过滤器</h3><div id="fa2bb9ec"><p>在过滤器中选择所需的堆段名称。</p></div></section>        <p id="7b15bf9f">选择堆段之后，其他过滤器将仅显示发生选定深度的GC的时间间隔的数据。</p>        <figure><img alt="垃圾收集深度2" title="垃圾收集深度2" src="/help/img/dotnet/2019.2/garbage_collection_depth_2.png" id="8d753ad6" width="333" height="382" align="middle"></figure>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Debug_Output.html">调试输出</a> <a class="navigation-links__next" href="Exceptions.html">异常</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>