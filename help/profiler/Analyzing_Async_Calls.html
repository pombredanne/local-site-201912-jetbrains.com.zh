<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        how to profile async calls, async await performance profiling, profiling asynctask
    " data-skip-index="skip"><title>分析异步呼叫-帮助|帮助dotTrace</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Analyzing_Async_Calls" data-disqus-id="Analyzing_Async_Calls_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Analyzing_Async_Calls.xml" data-toc="Analyzing_Async_Calls">分析异步呼叫</h1>        <p id="fe9ad509">异步代码的缺点之一是很难对其进行概要分析并分析其性能。这是因为，当执行异步方法时，控制切换到另一个线程，然后又切换回原来的调用树，从而缠结了结果。</p>    <p id="13e012f5">dotTrace大大简化了异步代码的分析：它标记了所有<code class="code">async</code> <span class="control">呼叫树中的</span>呼叫节点并将相应的分组<code class="code">await</code>该节点下的时间和延续代码。这意味着您可以在一个地方快速找到异步调用的所有“部分”，而不是在不同的调用堆栈中搜索它们。</p>    <p id="3bfc1b0e">为了更好地理解dotTrace如何处理异步代码，请考虑以下示例（该代码显示在左侧，相应的<span class="control">调用树</span>显示在右侧）：</p>    <figure><img alt="异步调用扩展了readasync" title="异步调用扩展了readasync" src="/help/img/dotnet/2019.2/async_calls_expanded_readasync.png" id="9be85929" width="1176" height="362"></figure>    <p id="88c8ca5e">如您所见，异步调用的所有“部分”都显示在<span class="control">async RunAsyncOperation</span>节点内：</p><ul class="list _ul"><li class="list__item" id="09b39c95"><p>总时间<code class="code">RunAsyncOperation</code>计算为<br>119毫秒= <code class="code">Init()</code> 101毫秒以上<code class="code">ReadAsync()</code> 13毫秒+ <code class="code">clr.dll</code> 3.7毫秒+ <code class="code">FileStream.ctor()</code> 0.6毫秒</p></li><li class="list__item" id="feb04b5a"><p>的<code class="code">Init</code>方法（101 ms）在主线程上执行，因此，其时间被加到<code class="code">RunAsyncOperation</code> 。</p></li><li class="list__item" id="85f85646"><p>的<code class="code">ReadAsync</code>在主线程上启动（13毫秒），但随后的任务在线程池上运行。因此，“ <span class="control">任务执行”</span>节点的时间（819毫秒）显示为灰色，未添加到“ <span class="control">任务执行”</span>节点的总时间中<code class="code">RunAsyncOperation</code> 。</p><figure><img alt="异步调用任务执行" title="异步调用任务执行" src="/help/img/dotnet/2019.2/async_calls_task_execution.png" id="ef02b10d" width="461" height="71"></figure>            <p></p></li><li class="list__item" id="36aca39d"><p>在我们的情况下， <span class="control">等待</span>时间等于<span class="control">任务执行</span>时间（819毫秒），但在现实生活中，它可能会更高，因为它还包括任务按计划等待的时间。</p></li><li class="list__item" id="1100fe70"><p><span class="control">连续</span>节点是一个连续代码，在我们的示例中，该代码由一个<code class="code">ProcessFile</code>方法（301毫秒）。由于此调用是在线程池上执行的，因此其时间也显示为灰色，并且未添加到该线程的总时间中<code class="code">RunAsyncOperation</code> 。</p></li></ul>    <p></p>    <div class="chapter"><h2 id="92433f82" data-toc="Analyzing_Async_Calls#92433f82">识别方法和子系统中最慢的异步调用</h2>        <p id="17e0cac9">如您所见，总数<code class="code">async</code>通话时间不包括“ <span class="control">通话树”</span>中所有部分的时间。但是，如果您想快速识别“热点”（应用中最慢的方法）怎么办？对于此类任务，如果<code class="code">async</code>方法的总时间包括延续代码。对于“ <span class="control">方法和子系统”</span>列表，这实际上是正确的，但<span class="emphasis">前提</span>是您站在“ <span class="control">呼叫树”中</span>的“ <span class="control">所有呼叫”</span>节点上。</p>        <figure><img alt="异步调用扩展了readasync顶层方法" title="异步调用扩展了readasync顶层方法" src="/help/img/dotnet/2019.2/async_calls_expanded_readasync_topmethods.png" id="91ceb848" width="664" height="557"></figure>    </div>    <div class="chapter"><h2 id="f7eee7fa" data-toc="Analyzing_Async_Calls#f7eee7fa">延续代码的回溯</h2>        <p id="5415062d">当然，延续代码的<span class="control">Backtraces不仅</span>可以带您回到回调函数，还可以带您回到原始<code class="code">async</code>方法。这可能非常有帮助，例如，当连续代码引发异常并且您需要标识其起源时。</p>        <figure><img alt="异步调用回溯" title="异步调用回溯" src="/help/img/dotnet/2019.2/async_calls_backtraces.png" id="3323a2b2" width="598" height="137"></figure>    </div>    <div class="chapter"><h2 id="14b6af8a" data-toc="Analyzing_Async_Calls#14b6af8a">按异步呼叫的总时间过滤</h2>        <p id="3dafcba4">要按异步呼叫的总时间应用筛选器，请在“ <span class="control">呼叫树”中</span>双击呼叫节点，或右键单击该节点（或其<span class="control">等待</span>或<span class="control">继续</span>节点），然后从上下文菜单中选择“ <span class="control">分析异步方法</span> ”。</p>        <p id="1830d845">在您按<code class="code">async</code>方法的调用时间，dotTrace将仅保留执行该方法的时间间隔。请注意，您可以通过选择出现在“ <span class="control">呼叫树”中</span>的相应复选框来包括或排除连续代码间隔（以及<span class="control">等待</span>时间节点）。</p><figure id="97a77060" width="604" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/async_await_filter.png" width="604" data-gif-src="/help/img/dotnet/2019.2/async_await_filter.animated.gif" style="width:604px"></figure>        <p></p>        <p id="e067002b">请注意，如果您应用过滤器以使继续代码不在范围内（例如，按主线程进行的过滤），则不会显示“ <span class="control">继续”</span>复选框。</p>    </div>    <div class="chapter"><h2 id="2a5c1839" data-toc="Analyzing_Async_Calls#2a5c1839">调用树中的任务</h2>        <p id="3bc751fe">前述功能不仅适用于<code class="code">async/await</code>但所有任务都基于<code class="code">Task</code>类。的<code class="code">Run</code>节点包含带有任务委托的<span class="control">任务执行</span>节点：</p><figure><img alt="异步呼叫任务" title="异步呼叫任务" src="/help/img/dotnet/2019.2/async_calls_task.png" id="44050400" width="920" height="256"></figure>        <p></p>    </div>    <div class="chapter"><h2 id="6140c747" data-toc="Analyzing_Async_Calls#6140c747">异步调用和事件</h2>        <p id="a79a89c1">最后但并非最不值得一提的是，“ <span class="control">呼叫树”</span>可用于呼叫时间以及“时间轴”概要分析模式下支持的所有其他类型的事件，例如，内存分配或异常。例如，您可以查看特定异步方法分配了多少内存：</p><figure><img alt="异步呼叫分配" title="异步呼叫分配" src="/help/img/dotnet/2019.2/async_calls_allocations.png" id="8a3b63ac" width="657" height="200"></figure>        <p></p>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Call_Tree.html">通话树</a> <a class="navigation-links__next" href="Forecasting_Performance_Timeline.html">预测效果</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>