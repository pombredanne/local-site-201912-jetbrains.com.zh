<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>Profiling Types - Help | dotTrace</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode" data-article-props="&#xA;                {&#xA;                &#xA;            &#34;seeAlso&#34;:{&#xA;                                             &#xA;                &#34;&#34;: [&#xA;                &#xA;                ],                                 &#xA;                &#34;Concepts&#34;: [&#xA;                &#xA;        {&#34;href&#34;:&#34;Profiling_Guidelines__Setting_the_Right_Meter_Kind.html&#34;,&#34;title&#34;:&#34;Time Measurement Methods&#34;}&#xA;                ]&#xA;            }&#xA;        &#xA;                }&#xA;            " data-disqus-id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotTrace Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode" id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode.xml">Profiling Types</h1>    <p id="d6d5c243">        dotTrace provides three different types of performance profiling:        <ul class="list _ul"><li class="list__item" id="311e3725"><p>                Sampling            </p></li><li class="list__item" id="39e7bd0e"><p>                Tracing            </p></li><li class="list__item" id="b75ce81b"><p>                Line-by-line            </p></li></ul>        The <span class="control">Profiling type</span> is selected in        <a href="Profiler_Options.html">Profiler Options</a>        when configuring a profiling session.    </p>    <p id="a26d8c87">Let's look at performance profiling types in more details.</p>    <div class="chapter"><h2 id="sampling" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#sampling">Sampling</h2>        <p id="a8171726">            What is sampling? Sampling is a process or technique of taking samples.            A sample is a set of call stacks taken during a profiling session.            That leads us to two obvious questions: <i id="3f758a58">(1) how long is the pause between two given samples</i> and            <i id="7e8eb4c1">(2) how much time does it take to get a sample</i>.            The answers to these questions can help us estimate the accuracy of the sampling method.        </p>        <p id="8c8cb8b2">            dotTrace captures call stacks of all existing threads within the process,            sequentially without pauses. It also takes into account threads that are locked or sleeping.            The time required for capturing a call stack cannot be precisely determined because it depends on            the stack depth and the number of native and managed stack frames. Therefore, the time required            to take a sample necessarily varies from sample to sample and depends on the number of currently running            threads.        </p>        <p id="16ff94a3">            dotTrace makes pauses between taking samples. The pause is the time gone by            after dotTrace stops processing thread activities for the previous sample and            before it starts processing again for the next sample. The length of each pause is a random value            between 5 and 11 milliseconds. Random values help decrease the probability of having gaps in call stacks.            During such pauses application continues running normally.        </p>        <p id="c9d6abd7">            One consequence of this is that, since the time between samples is at least 5 milliseconds,            methods that run quickly enough may not be caught and shown in a snapshot. However, this does not prevent            dotTrace from getting the correct time data. Two situations are possible. If a method is fast and            is called many times, it will be caught and shown in a snapshot. If a method is fast, but is called rarely,            then it may be omitted in a snapshot, but its time will be included in total time of its parent.            In other words, if the total time of a method is significant, it will be counted.        </p>        <p id="43eac326">            All in all, this profiling method provides time data that helps reveal problem call stacks,            but it fails to provide numbers of function calls. Still this method is the fastest and can be            a solid first step to localize performance problems.        </p>    </div>    <div class="chapter"><h2 id="tracing" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#tracing">Tracing</h2>        <p id="fa17da06">            Unlike sampling, tracing revolves around a function, or more precisely, around function entry and exit.        </p>        <p id="73f40db2">            dotTrace receives notifications from CLR when a function is entered and then when it is left,            even if it is left because of an exception. The time between these two notifications is considered as            the execution time of the function.        </p>        <p id="df716e51">            On the one hand, you get all functions that were not inlined by JIT compiler and were executed            at that point in time, in a snapshot with their detailed timing data. On the other hand,            JIT compiler generates a specific prologue and epilogue for each function and that takes some extra time            for CLR to execute such pieces of code. dotTrace does not count and subtract this time            from total function time. As a result, total time might be distorted. The degree of distortion            depends on the number of function calls. The dependency is linear. The more times a function is called,            the bigger the distortion becomes. And the less time a function executes,            the less accurate its total time can be. For example, you have a very simple function            <code class="code">Inc() { _value++; }</code>, but it is called millions of times.            Of course it can be optimized and will take little time anyway.            However, if it runs under dotTrace and the tracing method has been chosen,            each call of this function adds some overhead which can be much more than the real function execution time.            As a result, total time can be more than it could be after using the sampling method or without using the            profiler.        </p>        <p id="6638be81">            Another overhead may be caused by CLR. CLR provides different kinds of optimizations.            Depending on CLR version and the chosen profiling method some optimizations may be disabled            or done in a different way, so the results may differ.        </p>        <p id="9da15523">            On the whole, you always get the correct number of function calls, but the total function time may be            inaccurate.            Because tracing takes more time than sampling and may also slow down your application significantly,            it is better to profile individual parts of an application or certain scenarios.        </p>    </div>    <div class="chapter"><h2 id="line-by-line" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#line-by-line">Line-by-Line</h2>        <p id="b21bb7e6">            This method is similar to tracing, but here the target of investigation is a statement, not a function.            In order to profile a function line by line, dotTrace requires            <a href="http://msdn.microsoft.com/en-us/library/ms241613.aspx" data-external="true" target="_blank" rel="noopener noreferrer">PDB files</a>.            If you do not have the corresponding PDB files, the method works as tracing.        </p>        <p id="e27a0a31">            dotTrace measures the time required to execute            <a href="http://msdn.microsoft.com/en-us/library/ms173143.aspx" data-external="true" target="_blank" rel="noopener noreferrer">a statement</a>            and how many times it is executed. As you can likely imagine, this method is even slower than tracing            because dotTrace performs time-counting work for each statement.        </p>        <p id="363e8c0b">            Line-by-line is an effective method after you have narrowed the scope of investigation            and want to concentrate on certain functions.        </p>    </div>    <div class="chapter"><h2 id="pros-and-cons" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#pros-and-cons">Pros and Cons</h2>        <p id="a6e269e2">            Taking everything into account, we can summarize the following table.        </p>        <div class="table-wrapper"><table class=" wide" width="100%" id="1fbb327f"><thead><tr id="976a1285" class="ijRowHead"><th id="e609f4ba" width="15%"><p>Method</p></th><th id="57edec90"><p>Pros</p></th><th id="59160e57"><p>Cons</p></th></tr></thead><tbody><tr id="e2653b6f" class="ijRowOdd"><td id="238103d7"><p>Sampling</p></td><td id="e91a1308">                    <ul class="list _ul"><li class="list__item" id="6e040fb3"><p>                            Time required to run an application under profiler does not change significantly                        </p></li><li class="list__item" id="2bc0326c"><p>                            Small snapshot                        </p></li><li class="list__item" id="23805fd9"><p>                            Low memory usage                        </p></li></ul>                </td><td id="bf71bb9f">                    <ul class="list _ul"><li class="list__item" id="004506c3"><p>                            Number of calls for a function is undefined                        </p></li><li class="list__item" id="af642ada"><p>                            Not all call stacks and functions are captured                        </p></li></ul>                </td></tr><tr id="04d1a197" class="ijRowEven"><td id="6f9385a8"><p>Tracing</p></td><td id="ef4274dc">                    <ul class="list _ul"><li class="list__item" id="c9e7e39b"><p>                            All call stacks and functions are captured, except inlined functions                        </p></li><li class="list__item" id="fa503a91"><p>                            Number of calls is defined correctly                        </p></li></ul>                </td><td id="9d2cf9d1">                    <ul class="list _ul"><li class="list__item" id="c2083ed0"><p>                            More time required to run an application under profiler                        </p></li><li class="list__item" id="708b4b59"><p>                            Snapshot may be quite large                        </p></li><li class="list__item" id="9d51a913"><p>                            Dependencies between time distortions and number of function calls                        </p></li><li class="list__item" id="d6fa4eda"><p>                            Higher memory usage                        </p></li></ul>                </td></tr><tr id="08300154" class="ijRowOdd"><td id="ee288708"><p>Line-by-line</p></td><td id="cd80c75a">                    <ul class="list _ul"><li class="list__item" id="64e57dce"><p>                            Possibility to study function in detail, statement level                        </p></li></ul>                </td><td id="0d99bd96">                    <ul class="list _ul"><li class="list__item" id="0bde2a0b"><p>                            More time required to run an application under profiler, compared to tracing                        </p></li><li class="list__item" id="3a648091"><p>                            Snapshot may be quite large                        </p></li><li class="list__item" id="725ed0fa"><p>                            Higher memory usage compared to tracing                        </p></li><li class="list__item" id="17f5ebb9"><p>                            PDB files are required                        </p></li></ul>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="5a1edcb8" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#5a1edcb8">Example</h2>        <p id="137163b4">            To demonstrate the differences between sampling and tracing profiling methods, let's take a simple            application            that recursively traverses a tree. Each node of the tree contains a full file path or full directory path.            During the application run we check whether a path matches a specific pattern or not.        </p>        <p id="84153765">            The main point is to see the difference in application execution time or establish that there is no            difference.        </p>        <p id="8116d6ff">            To calculate the time passed in real world during the profiling process, we have added code            that gets the current date and time, and subtracts start time from end time. The time is not constant.            It depends on operating system, CPU load, etc. The results may change from run to run,            so it is better to take average time. Consider the results below.        </p>        <div class="table-wrapper"><table class=" wide" width="100%" id="4252bca6"><thead><tr id="d3ed7b73" class="ijRowHead"><th id="21ff747c" width="30%"><p>Conditions</p></th><th id="b60b6257"><p>Average time</p></th><th id="036cc838"><p>Ratio</p></th></tr></thead><tbody><tr id="59b62538" class="ijRowOdd"><td id="3464139f"><p>Normal run, without profiler</p></td><td id="6a1c5eb8"><p>8910 milliseconds</p></td><td id="3c26fef7"></td></tr><tr id="df57d1fc" class="ijRowEven"><td id="6e9a3eaf"><p>Under profiler, sampling</p></td><td id="b7b33a21"><p>9043 milliseconds</p></td><td id="110b1dd0"><p>1.015</p></td></tr><tr id="dca86619" class="ijRowOdd"><td id="618f65a6"><p>Under profiler, tracing</p></td><td id="d3bf4f0e"><p>17426 milliseconds</p></td><td id="98962ed3"><p>1.956</p></td></tr></tbody></table></div>        <p id="a75c8d84">            Based on these results, we can make the following conclusions. First, the program execution slows down a bit            when we use the sampling method, and the time doubles when we use the tracing method.        </p>        <div class="table-wrapper"><table class=" wide" width="100%" id="3163ba4e"><thead><tr id="e9776859" class="ijRowHead"><th id="49d09cf9" width="30%"><p>Conditions</p></th><th id="1b8a1efb"><p>Average time</p></th><th id="4d05627b"><p>Ratio</p></th></tr></thead><tbody><tr id="f1e755b4" class="ijRowOdd"><td id="3bf70c9b"><p>Normal run, without profiler</p></td><td id="5fe2b34d"><p>207159 milliseconds</p></td><td id="3d7b8f46"></td></tr><tr id="b306c2d0" class="ijRowEven"><td id="69df11e1"><p>Under profiler, sampling</p></td><td id="465b73de"><p>209427 milliseconds</p></td><td id="85a59511"><p>1.011</p></td></tr><tr id="72c9adcb" class="ijRowOdd"><td id="d1be70f0"><p>Under profiler, tracing</p></td><td id="c22e755b"><p>418768 milliseconds</p></td><td id="57cd3a97"><p>1.999</p></td></tr></tbody></table></div>        <p id="31fbd976">            Second, the difference in time increases with the number of nodes that should be traversed.            The time may double or triple. While this may be a drawback,            you can also look at it as a trade-off between time and accuracy.        </p>        <p id="54f0eec0">            Compare the screenshots. On the first one you can see the <code class="code">IsMatch</code> function. The            function runs fast,            but it still takes 25 milliseconds. On the second screenshot no function can be found,            because the samples were taken between function executions. In this example, it is not essential            to have this function in both snapshots. However, it illustrates the common idea about the profiling            methods:            if the amount of time required to execute a function is less than 5 milliseconds, that function may be            omitted.            <br>            <figure><img alt="Profiling Guidelines Choosing the Right Profiling Method Tracing" title="Profiling Guidelines Choosing the Right Profiling Method Tracing" src="/help/img/dotnet/2019.2/Profiling_Guidelines__Choosing_the_Right_Profiling_Method__Tracing.png" id="34298216" width="620" height="298"></figure>            <br>            <figure><img alt="Profiling Guidelines Choosing the Right Profiling Method Sampling" title="Profiling Guidelines Choosing the Right Profiling Method Sampling" src="/help/img/dotnet/2019.2/Profiling_Guidelines__Choosing_the_Right_Profiling_Method__Sampling.png" id="9844841f" width="620" height="158"></figure>        </p>    </div>    <div class="chapter"><h2 id="b01595bd" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#b01595bd">Summary</h2>        <p id="89d121e9">            <br>Use line-by-line, if you know exactly what function causes problems.            This method helps you understand how the function executes.            <br>            <br>Use tracing, if you want to see numbers of function calls, or if information provided by sampling is            not enough.            <br>            <br>Use sampling in all other situations. It is recommended to use sampling if you look for            performance problems in your application for the first time.        </p>    </div>    <div class="last-modified" data-skip-index="skip">Last modified: 19 September 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Performance_Profiling.html">Performance Profiling</a><a class="navigation-links__next" href="Profiling_Guidelines__Setting_the_Right_Meter_Kind.html">Time Measurement Methods</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>