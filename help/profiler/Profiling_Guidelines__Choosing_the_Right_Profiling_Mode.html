<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><title>分析类型-帮助| dotTrace</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode" data-article-props="
                {
                
            " seeals=":{=" concept=":=" hre=":" profiling_guidelines__setting_the_right_meter_kind.htm="," titl=":" time="" measurement="" method="}=" ="" data-disqus-id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode.xml" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode">分析类型</h1>    <p id="d6d5c243">dotTrace提供了三种不同类型的性能分析：</p><ul class="list _ul"><li class="list__item" id="311e3725"><p>采样</p></li><li class="list__item" id="39e7bd0e"><p>追踪</p></li><li class="list__item" id="b75ce81b"><p>逐行</p></li></ul>配置概要分析会话时，在<a href="Profiler_Options.html">Profiler选项中</a>选择了<span class="control">概要分析类型</span> 。<p></p>    <p id="a26d8c87">让我们更详细地了解性能分析类型。</p>    <div class="chapter"><h2 id="sampling" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#sampling">采样</h2>        <p id="a8171726">什么是采样？采样是采样的过程或技术。一个样本是在概要分析会话期间获取的一组调用堆栈。这就引出了两个明显的问题： <i id="3f758a58">（1）两个给定样本之间的停顿时间为多长时间</i> ； <i id="7e8eb4c1">（2）获得一个样本需要多少时间</i> 。这些问题的答案可以帮助我们估算采样方法的准确性。</p>        <p id="8c8cb8b2">dotTrace可以连续捕获进程中所有现有线程的调用堆栈，而不会暂停。它还考虑了锁定或休眠的线程。无法精确确定捕获调用堆栈所需的时间，因为它取决于堆栈深度以及本机和托管堆栈帧的数量。因此，采样所需的时间在每个采样之间必然有所不同，并且取决于当前正在运行的线程数。</p>        <p id="16ff94a3">dotTrace在采样之间暂停。暂停是指dotTrace停止处理上一个样本的线程活动之后，又开始为下一个样本再次处理之前经过的时间。每个暂停的时间长度是5到11毫秒之间的随机值。随机值有助于降低在调用堆栈中出现间隙的可能性。在这种暂停期间，应用程序将继续正常运行。</p>        <p id="c9d6abd7">其结果之一是，由于采样之间的时间至少为5毫秒，因此可能无法捕获运行足够快的方法并将其显示在快照中。但是，这不会阻止dotTrace获取正确的时间数据。有两种情况。如果一种方法快速并且被多次调用，它将被捕获并显示在快照中。如果一种方法快速但很少被调用，则可以在快照中将其省略，但其时间将包括在其父级的总时间中。换句话说，如果一种方法的总时间很长，则将被计算在内。</p>        <p id="43eac326">总而言之，此概要分析方法提供了有助于揭示问题调用堆栈的时间数据，但无法提供大量函数调用。这种方法仍然是最快的方法，可以成为解决性能问题的坚实的第一步。</p>    </div>    <div class="chapter"><h2 id="tracing" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#tracing">追踪</h2>        <p id="fa17da06">与采样不同，跟踪围绕函数，或更准确地说，围绕函数的入口和出口。</p>        <p id="73f40db2">dotTrace会在输入一个函数然后离开该函数时从CLR接收通知，即使由于异常而离开该函数。这两个通知之间的时间被视为函数的执行时间。</p>        <p id="df716e51">一方面，您将获得所有未由JIT编译器内联的函数，并在该时间点执行这些函数，并附上详细的定时数据。另一方面，JIT编译器会为每个函数生成特定的序言和结尾，并且CLR需要花费一些额外的时间来执行这些代码。 dotTrace不会计算总功能时间并从中减去该时间。结果，总时间可能会失真。失真程度取决于函数调用的数量。相关性是线性的。调用函数的次数越多，失真就越大。函数执行的时间越短，其总时间就越不准确。例如，您有一个非常简单的功能<code class="code">Inc() { _value++; }</code> ，但它被称为数百万次。当然，可以对其进行优化，并且花费很少的时间。但是，如果它在dotTrace下运行并且已选择跟踪方法，则此函数的每次调用都会增加一些开销，这些开销可能比实际函数的执行时间长得多。结果，总时间可能会比使用采样方法或不使用探查器之后的总时间更长。</p>        <p id="6638be81">CLR可能会导致其他开销。 CLR提供了各种优化。根据CLR版本和所选的配置方法，某些优化可能会被禁用或以其他方式进行，因此结果可能会有所不同。</p>        <p id="9da15523">总的来说，您总是可以得到正确数量的函数调用，但是总的函数时间可能不准确。由于跟踪比采样花费更多的时间，而且还可能大大降低应用程序的速度，因此最好对应用程序的各个部分或某些方案进行概要分析。</p>    </div>    <div class="chapter"><h2 id="line-by-line" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#line-by-line">逐行</h2>        <p id="b21bb7e6">此方法类似于跟踪，但是这里的调查目标是语句，而不是函数。为了逐行分析功能，dotTrace需要<a href="http://msdn.microsoft.com/en-us/library/ms241613.aspx" rel="noopener noreferrer" data-external="true" target="_blank">PDB文件</a> 。如果您没有相应的PDB文件，则该方法将用作跟踪。</p>        <p id="e27a0a31">dotTrace度量执行<a href="http://msdn.microsoft.com/en-us/library/ms173143.aspx" rel="noopener noreferrer" data-external="true" target="_blank">一条语句</a>所需的时间以及执行<a href="http://msdn.microsoft.com/en-us/library/ms173143.aspx" rel="noopener noreferrer" data-external="true" target="_blank">该语句的</a>次数。可以想象，此方法比跟踪还要慢，因为dotTrace对每个语句执行时间计数工作。</p>        <p id="363e8c0b">在缩小研究范围并希望专注于某些功能之后，逐行是一种有效的方法。</p>    </div>    <div class="chapter"><h2 id="pros-and-cons" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#pros-and-cons">利弊</h2>        <p id="a6e269e2">考虑到所有因素，我们可以总结下表。</p>        <div class="table-wrapper"><table class=" wide" width="100%" id="1fbb327f"><thead><tr id="976a1285" class="ijRowHead"><th id="e609f4ba" width="15%"><p>方法</p></th><th id="57edec90"><p>优点</p></th><th id="59160e57"><p>缺点</p></th></tr></thead><tbody><tr id="e2653b6f" class="ijRowOdd"><td id="238103d7"><p>采样</p></td><td id="e91a1308">                    <ul class="list _ul"><li class="list__item" id="6e040fb3"><p>在事件探查器下运行应用程序所需的时间没有明显变化</p></li><li class="list__item" id="2bc0326c"><p>小快照</p></li><li class="list__item" id="23805fd9"><p>低内存使用</p></li></ul>                </td><td id="bf71bb9f">                    <ul class="list _ul"><li class="list__item" id="004506c3"><p>函数的调用次数未定义</p></li><li class="list__item" id="af642ada"><p>并非所有的调用堆栈和函数都被捕获</p></li></ul>                </td></tr><tr id="04d1a197" class="ijRowEven"><td id="6f9385a8"><p>追踪</p></td><td id="ef4274dc">                    <ul class="list _ul"><li class="list__item" id="c9e7e39b"><p>捕获所有调用堆栈和函数，但内联函数除外</p></li><li class="list__item" id="fa503a91"><p>通话次数已正确定义</p></li></ul>                </td><td id="9d2cf9d1">                    <ul class="list _ul"><li class="list__item" id="c2083ed0"><p>在分析器下运行应用程序需要更多时间</p></li><li class="list__item" id="708b4b59"><p>快照可能很大</p></li><li class="list__item" id="9d51a913"><p>时间失真与函数调用次数之间的依赖关系</p></li><li class="list__item" id="d6fa4eda"><p>更高的内存使用率</p></li></ul>                </td></tr><tr id="08300154" class="ijRowOdd"><td id="ee288708"><p>逐行</p></td><td id="cd80c75a">                    <ul class="list _ul"><li class="list__item" id="64e57dce"><p>可以详细研究职能，陈述水平</p></li></ul>                </td><td id="0d99bd96">                    <ul class="list _ul"><li class="list__item" id="0bde2a0b"><p>与跟踪相比，在探查器下运行应用程序需要更多时间</p></li><li class="list__item" id="3a648091"><p>快照可能很大</p></li><li class="list__item" id="725ed0fa"><p>与跟踪相比，内存使用量更高</p></li><li class="list__item" id="17f5ebb9"><p>需要PDB文件</p></li></ul>                </td></tr></tbody></table></div>    </div>    <div class="chapter"><h2 id="5a1edcb8" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#5a1edcb8">例</h2>        <p id="137163b4">为了演示采样和跟踪性能分析方法之间的区别，让我们以递归遍历树的简单应用程序为例。树的每个节点都包含完整的文件路径或完整的目录路径。在应用程序运行期间，我们检查路径是否匹配特定的模式。</p>        <p id="84153765">要点是查看应用程序执行时间的差异或确定没有差异。</p>        <p id="8116d6ff">为了计算在概要分析过程中在现实世界中经过的时间，我们添加了获取当前日期和时间并从结束时间中减去开始时间的代码。时间不固定。它取决于操作系统，CPU负载等。结果可能因运行而异，因此最好花平均时间。考虑下面的结果。</p>        <div class="table-wrapper"><table class=" wide" width="100%" id="4252bca6"><thead><tr id="d3ed7b73" class="ijRowHead"><th id="21ff747c" width="30%"><p>条件</p></th><th id="b60b6257"><p>平均时间</p></th><th id="036cc838"><p>比</p></th></tr></thead><tbody><tr id="59b62538" class="ijRowOdd"><td id="3464139f"><p>正常运行，无分析器</p></td><td id="6a1c5eb8"><p>8910毫秒</p></td><td id="3c26fef7"></td></tr><tr id="df57d1fc" class="ijRowEven"><td id="6e9a3eaf"><p>在分析器下，采样</p></td><td id="b7b33a21"><p>9043毫秒</p></td><td id="110b1dd0"><p>1.015</p></td></tr><tr id="dca86619" class="ijRowOdd"><td id="618f65a6"><p>在探查器下，跟踪</p></td><td id="d3bf4f0e"><p>17426毫秒</p></td><td id="98962ed3"><p>1.956</p></td></tr></tbody></table></div>        <p id="a75c8d84">基于这些结果，我们可以得出以下结论。首先，当使用采样方法时，程序执行速度会变慢，而使用跟踪方法时，时间会翻倍。</p>        <div class="table-wrapper"><table class=" wide" width="100%" id="3163ba4e"><thead><tr id="e9776859" class="ijRowHead"><th id="49d09cf9" width="30%"><p>条件</p></th><th id="1b8a1efb"><p>平均时间</p></th><th id="4d05627b"><p>比</p></th></tr></thead><tbody><tr id="f1e755b4" class="ijRowOdd"><td id="3bf70c9b"><p>正常运行，无分析器</p></td><td id="5fe2b34d"><p>207159毫秒</p></td><td id="3d7b8f46"></td></tr><tr id="b306c2d0" class="ijRowEven"><td id="69df11e1"><p>在分析器下，采样</p></td><td id="465b73de"><p>209427毫秒</p></td><td id="85a59511"><p>1.011</p></td></tr><tr id="72c9adcb" class="ijRowOdd"><td id="d1be70f0"><p>在探查器下，跟踪</p></td><td id="c22e755b"><p>418768毫秒</p></td><td id="57cd3a97"><p>1.999</p></td></tr></tbody></table></div>        <p id="31fbd976">其次，时间差随应遍历的节点数而增加。时间可能是两倍或三倍。尽管这可能是一个缺点，但您也可以将其视为时间和准确性之间的权衡。</p>        <p id="54f0eec0">比较屏幕截图。在第一个上，您可以看到<code class="code">IsMatch</code>功能。该函数运行速度很快，但仍需要25毫秒。在第二张屏幕截图中，找不到函数，因为样本是在函数执行之间进行的。在此示例中，在两个快照中都具有此功能不是必需的。但是，它说明了有关概要分析方法的一般思想：如果执行一个函数所需的时间少于5毫秒，则可以省略该函数。<br>            </p><figure><img alt="分析指南选择正确的分析方法跟踪" title="分析指南选择正确的分析方法跟踪" src="/help/img/dotnet/2019.2/Profiling_Guidelines__Choosing_the_Right_Profiling_Method__Tracing.png" id="34298216" width="620" height="298"></figure>            <br>            <figure><img alt="分析指南选择正确的分析方法抽样" title="分析指南选择正确的分析方法抽样" src="/help/img/dotnet/2019.2/Profiling_Guidelines__Choosing_the_Right_Profiling_Method__Sampling.png" id="9844841f" width="620" height="158"></figure>        <p></p>    </div>    <div class="chapter"><h2 id="b01595bd" data-toc="Profiling_Guidelines__Choosing_the_Right_Profiling_Mode#b01595bd">摘要</h2>        <p id="89d121e9">            <br>如果您确切知道哪个功能会导致问题，请逐行使用。此方法可帮助您了解函数的执行方式。<br>            <br>如果要查看函数调用次数，或者采样提供的信息不足，请使用跟踪。<br>            <br>在所有其他情况下使用采样。如果您是第一次在应用程序中发现性能问题，建议使用采样。</p>    </div>    <div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Performance_Profiling.html">性能分析</a> <a class="navigation-links__next" href="Profiling_Guidelines__Setting_the_Right_Meter_Kind.html">时间测量方法</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>