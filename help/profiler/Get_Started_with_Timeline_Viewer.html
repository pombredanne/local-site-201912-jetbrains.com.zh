<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotTrace tutorial, .NET C# performance profiling tutorial, .NET UI freezes, UI performance,
        .NET performance profiler, WPF performance, improve UI speed
    " data-skip-index="skip"><title>查找UI冻结的原因-帮助|帮助dotTrace</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Get_Started_with_Timeline_Viewer" data-disqus-id="Get_Started_with_Timeline_Viewer_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Get_Started_with_Timeline_Viewer.xml" data-toc="Get_Started_with_Timeline_Viewer">查找UI冻结的原因</h1>        <p id="5376427a">警告！本教程是为dotTrace 2016.2编写的。请注意，dotTrace 2016.3中对一些UI控件（例如过滤器）进行了重新设计。例如，“ <span class="control">分析主题”</span>过滤器中的所有控件都移到“ <span class="control">事件”</span>过滤器下。</p>    <p id="eef3c819">在本教程中，我们将详细介绍关键的分析步骤，并向您介绍Timeline Viewer用户界面。我们还将分析一个示例应用程序，并尝试确定其UI为何冻结的原因，这是非常常见的分析任务。</p>    <div class="chapter"><h2 id="sample_app" data-toc="Get_Started_with_Timeline_Viewer#sample_app">样品申请</h2>    <p id="244b5906">我们的示例应用程序用于反转文本文件中的行，例如， <code class="code">ABC</code> => <code class="code">CBA</code> 。使用“ <span class="control">选择文件”</span>按钮，用户可以选择一个或多个要处理的文本文件。“ <span class="control">处理文件”</span>按钮运行单独的<a href="http://msdn.microsoft.com/en-us/library/vstudio/system.componentmodel.backgroundworker" rel="noopener noreferrer" data-external="true" target="_blank">BackgroundWorker</a>线程，该线程反转文件中的行。进度显示在窗口的左上角。处理完成后，标签报告“ <span class="control">所有文件都已成功处理”</span> 。</p>    <p id="be684ac5">源代码可在<a href="https://github.com/DarthWeirdo/dotTrace_Timeline_Get_Started" rel="noopener noreferrer" data-external="true" target="_blank">github上找到</a> 。</p>    <figure><img alt="t1应用" title="t1应用" src="/help/img/dotnet/2019.2/t1_app.png" id="ebd04303" width="478" height="125"></figure>    <p id="04146c93">该应用程序有一个严重的缺点。开始文件处理后，用户会经历UI滞后，直到处理结束为止。</p>    <p id="d370060b">让我们使用时间轴分析来找出为什么发生这些冻结！*</p>    <aside class="note " rel="d370060b" id="8fe84b08" data-title=""><p>*本教程中显示的修复UI冻结的算法包含一些不必要的步骤，对您而言可能不是最佳选择。这是有意完成的，因为本教程的主要目标是使您熟悉时间轴分析概念。</p></aside>    </div>    <div class="chapter"><h2 id="run_profiler" data-toc="Get_Started_with_Timeline_Viewer#run_profiler">运行探查器并获取快照</h2>    <ol class="list _decimal"><li class="list__item" id="ef37c952"><p>在Visual Studio中打开<span class="filepath">MassFileProcessing.sln</span>解决方案。</p></li><li class="list__item" id="b0a6291e"><p>通过选择<span class="menupath" data-skip-index="skip">ReSharper |</span>运行分析器<span class="menupath" data-skip-index="skip">。简介|运行启动配置性能分析...。</span></p></li><li class="list__item" id="cc7cec7a"><p>在“ <span class="control">分析”类型中</span> ，选择“ <span class="control">时间轴”</span> 。</p><figure><img alt="t1分析选项" title="t1分析选项" src="/help/img/dotnet/2019.2/t1_profiling_options.png" id="41cd692b" width="684" height="488"></figure>        <p></p></li><li class="list__item" id="9f8c43b9"><p>点击<span class="control">运行</span> 。 dotTrace将运行我们的应用程序，并显示一个用于控制配置过程的特殊控制器窗口。</p><figure><img alt="t1分析控制器" title="t1分析控制器" src="/help/img/dotnet/2019.2/t1_profiling_controller.png" id="110f600f" width="550" height="83"></figure>现在，让我们尝试在我们的应用程序中重现性能问题。<p></p></li><li class="list__item" id="8913681b"><p>单击“ <span class="control">选择文件”，</span>然后在“ <i id="e9641eef">文本文件”文件</i>夹中选择应用程序随附的五个文本文件。</p><figure><img alt="t1应用" title="t1应用" src="/help/img/dotnet/2019.2/t1_app.png" id="b03d3821" width="478" height="125"></figure>        <p></p></li><li class="list__item" id="eff2f03d"><p>单击“ <span class="control">处理文件”</span>以开始文件处理。如您所见，该应用程序严重滞后。实际上，直到完成并显示“ <span class="control">所有文件已成功处理”消息</span> ，您甚至看不到文件处理的进度。</p></li><li class="list__item" id="2d120e55"><p>通过单击控制器窗口中的“ <span class="control">获取快照并等待”</span>来收集时间线概要分析快照。快照将在Visual Studio的单独<span class="control">Performance Profiler</span>工具窗口中打开。</p></li><li class="list__item" id="33f03b7b"><p>关闭应用程序。这也将关闭控制器窗口。</p></li></ol>    </div>    <div class="chapter"><h2 id="analyzing-a-timeline-profiling-snapshot" data-toc="Get_Started_with_Timeline_Viewer#analyzing-a-timeline-profiling-snapshot">分析时间线分析快照</h2>    <ol class="list _decimal"><li class="list__item" id="f09f183d">单击<span class="control">线程</span>以打开<span class="control">线程</span>工具窗口。默认情况下，它显示除非托管线程之外的所有应用程序线程。*请注意，您看到的所有过滤器值都是针对所有当前可见的线程计算的。为了进一步分析，我们对不执行任何工作的线程不感兴趣。因此，首先让我们摆脱它们。<aside class="note " rel="a78e6de7" id="6eca5626" data-title="">                <p id="6ab9697b">*您可以随时使用“ <span class="control">可见线程”</span>列表使它们可见。</p>            </aside>            <figure><img alt="t1线程" title="t1线程" src="/help/img/dotnet/2019.2/t1_threads.png" id="b9c5f8ee" width="614" height="380"></figure>        </li><li class="list__item" id="6a3d8dda"><p>在工具窗口中查看线程列表。它包含<span class="control">Main</span>应用程序线程，运行时用于终结对象的<span class="control">Finalizer</span>线程（在我们的应用程序中不起作用）以及<span class="control">Garbage Collection</span>线程（用于执行后台GC）。的<code class="code">BackgroundWorker</code>因为后台线程是由CLR线程池创建的，所以在我们的应用程序中处理文件的线程被标识为<span class="control">线程池</span> （ID 13456）。还有另外一个<span class="control">线程池</span> （ID 7416）不起作用。这可能是一些辅助CLR线程池。让我们隐藏<span class="control">终结器</span>和<span class="control">线程池</span> （ID 7416）线程与我们的分析无关。</p></li><li class="list__item" id="4a42980c"><p>在“ <span class="control">线程”</span>工具窗口中选择<span class="control">终结器</span>和<span class="control">线程池</span> （ID 7416）线程。</p></li><li class="list__item" id="dc03a3a3"><p>右键单击并选择“ <span class="control">隐藏选定的线程”</span> 。</p><figure><img alt="t1隐藏线程" title="t1隐藏线程" src="/help/img/dotnet/2019.2/t1_hide_threads.png" id="e31d88a8" width="616" height="409"></figure>        <p></p></li><li class="list__item" id="75b45481"><p>查看“ <span class="control">线程”</span>窗口。当前，以下过滤器应用于快照数据： <i id="893a64cc">“选择除隐藏之外的所有线程的生存期间隔”</i> 。</p><figure><img alt="t1隐藏线程" title="t1隐藏线程" src="/help/img/dotnet/2019.2/t1_hidden_threads.png" id="bc4bf38f" width="615" height="278"></figure>请注意其他过滤器中的数据如何受到影响。例如，现在为隐藏线程之外的所有线程计算<span class="control">线程</span>状态下的状态时间。<span class="control">顶部方法</span>和<span class="control">调用树</span>也已更改，仅显示来自过滤线程的调用。<p></p></li><li class="list__item" id="4058ac26"><span class="control">Threads</span>图的当前比例不允许我们看到<span class="control">13456 Thread Pool</span> （我们的<code class="code">BackgroundWorker</code>线程）的详细信息。让我们放大使其适合整个图。为此，请使用<kbd class="keystroke" data-bypass="true"><span class="keystroke__value">Mouse,Wheel</span></kbd>在<span class="control">线程</span>图上*。这<span class="control">将按</span>可见时间范围自动添加过滤器： <span class="control">1489 ms</span> 。注意此过滤器如何影响其他过滤器：将重新计算可见时间范围内的所有值。现在，以下过滤器将应用于快照数据： <i id="152e8fc4">“为隐藏的所有线程选择可见时间范围内的所有时间间隔”</i> 。<aside class="note " rel="152e8fc4" id="dde38ea9" data-title=""><p>*要平移图表，请在按住鼠标右键的同时将其拖动。</p></aside>            <figure><img alt="t1可见间隔过滤器" title="t1可见间隔过滤器" src="/help/img/dotnet/2019.2/t1_visible_interval_filter.png" id="3bd6aad5" width="619" height="333"></figure>        </li><li class="list__item" id="d64378b3"><p>看一下<span class="control">Threads</span>图。您看到的是线程状态如何随时间变化。例如，我们的<code class="code">BackgroundWorker</code>线程<span class="control">13456线程池</span>大约在16秒（在我们单击“ <span class="control">处理文件”</span>按钮之后）开始。大多数情况下，线程正在<span class="control">运行</span> （蓝色间隔丰富）。此外，还有一些线程处于<span class="control">等待</span>状态的间隔（浅蓝色间隔）。</p><figure><img alt="t1缩放的线程" title="t1缩放的线程" src="/help/img/dotnet/2019.2/t1_zoomed_thread.png" id="fa59b504" width="606" height="22"></figure>        <p></p></li><li class="list__item" id="c7f4168b">            <p id="c6d73d9e">查看“ <span class="control">线程”</span>工具窗口中的“进程概述”图*。除了<span class="control">CPU</span>利用率外，它还显示了两个事件图，它们可能对性能分析非常有帮助。<span class="control">UI冻结</span>栏显示冻结在创建<span class="control">13456线程池</span>后<span class="control">立即</span>开始。</p>            <p id="ec0e7b38">在此时间间隔内，还密集执行了垃圾收集<span class="control">GC</span> 。由于阻塞GC将挂起所有托管线程，这可能是UI冻结的潜在原因。</p>            <p id="f6a79c89">我们必须仔细研究这些事件。</p>            <aside class="note " rel="f6a79c89" id="e160a403" data-title=""><p>*时间轴模式在您的计算机上可能看起来略有不同，因为执行流程取决于多种因素（例如CPU内核的数量，应用程序执行期间的工作量等）。但是，无论您的系统配置如何，都必须进行冻结。</p></aside>            <figure><img alt="t1流程概述" title="t1流程概述" src="/help/img/dotnet/2019.2/t1_process_overview.png" id="06ab88db" width="611" height="268"></figure>        </li><li class="list__item" id="0d307e3a">首先，让我们删除可见的时间范围过滤器，因为我们不再需要它。为此，请单击“ <span class="control">线程”</span>工具窗口顶部*中的过滤器。该图将缩小。<aside class="note " rel="d060e064" id="2c2b166b" data-title="">                <p id="52c01d45">请注意， <span class="control">Performance Profiler</span>和“ <span class="control">线程”</span>工具窗口都为您提供了相同的过滤器集。在哪个窗口中打开或关闭特定过滤器都没有关系。所做的更改将应用于两个窗口中的数据。</p>            </aside>            <figure><img alt="t1移除过滤器" title="t1移除过滤器" src="/help/img/dotnet/2019.2/t1_remove_filter.png" id="53523dcf" width="194" height="112"></figure>        </li><li class="list__item" id="6d328a55">现在，让我们更彻底地研究UI冻结事件。此类冻结的主要潜在原因是什么？这些是：<ul class="list _ul"><li class="list__item" id="97b928a4"><p>长期或频繁阻止GC;</p></li><li class="list__item" id="363a0500"><p>UI线程被其他某个线程阻塞（例如，由于锁争用）；</p></li><li class="list__item" id="d5ea7b43"><p>和/或UI线程上的过多计算工作。</p></li></ul>我们将一一排除这些原因，直到只有真正的罪魁祸首。</li><li class="list__item" id="7bdcd8a2"><p>通过单击“ <span class="control">线程”</span>工具窗口的“进程概述”部分中的相应栏，选择<span class="control">UI冻结</span>事件。这将通过UI冻结事件应用过滤器。请注意，这不仅适用于冻结时间范围的过滤器，而且适用于<span class="control">主</span>线程的过滤器。后者是自动完成的，因为Main线程是唯一在我们的应用程序中处理UI交互的线程。因此，现在得到的过滤器是<i id="04734a13">“选择发生UI冻结事件的主线程上的所有时间间隔”</i> 。</p><figure><img alt="t1 ui冻结过滤器" title="t1 ui冻结过滤器" src="/help/img/dotnet/2019.2/t1_ui_freeze_filter.png" id="996c4239" width="616" height="352"></figure>        <p></p></li><li class="list__item" id="34984ead">            <p id="668476b1">现在，为确定冻结的真正原因，让我们研究其他过滤器值。我们应该分析的第一个潜在原因是GC过多。</p>            <p id="f32a77da">单击“ <span class="control">阻止GC”</span>以打开阻止GC过滤器并查看其值。</p>            <p id="3c37e01d">考虑到当前应用的过滤器，它显示冻结期间主线程被<span class="control">GC阻塞</span> （ <span class="control">阻塞GC</span>值）而不被（ <span class="control">阻塞GC</span>值<span class="control">排除</span> ）多长时间。</p>            <figure><img alt="t1阻止gc过滤器" title="t1阻止gc过滤器" src="/help/img/dotnet/2019.2/t1_blocking_gc_filter.png" id="73944316" width="259" height="101"></figure>            <p id="7c1de5ec"><span class="control">阻止GC</span>时间非常长（420毫秒，或所选间隔的10.2％），可能会对性能产生一些影响。但是，这几乎不可能是4秒冻结的原因。因此，我们可以从嫌疑人列表中排除过多的垃圾收集。</p>        </li><li class="list__item" id="ef500254"><p>单击“ <span class="control">排除阻止GC”</span>值。现在，结果过滤器为<i id="f01fb523">“在发生UI冻结事件且不执行阻塞GC的主线程上选择所有时间间隔”</i> 。</p></li><li class="list__item" id="2640d5fe">            <p id="0f146fcf">让我们调查“其他线程阻塞”和“主线程工作过多”的潜在原因。</p>            <p id="10d4d072">打开并查看“ <span class="control">线程状态”</span>中的值。此筛选器显示线程在特定状态下花费的总时间。考虑到当前应用的过滤器，它显示了冻结期间主线程的状态。</p>            <figure><img alt="t1线程状态过滤器" title="t1线程状态过滤器" src="/help/img/dotnet/2019.2/t1_thread_state_filter.png" id="1a43639f" width="196" height="125"></figure>            <p id="de39bc8e">看起来在大多数冻结时间（ <span class="control">92.9％</span>或<span class="control">3426 ms</span> ）中，线程在<span class="control">运行时</span>都在做一些工作。<span class="control">等待</span>状态的<span class="control">225 ms</span>值太小，这会自动从潜在原因中排除“其他线程阻塞”。因此，冻结的原因只能是主线程上的计算工作！</p>            <p id="a3b4baed">我们现在要做的就是查找冻结期间在<span class="control">Main</span>线程上执行的方法。我们可以为此使用“ <span class="control">顶级方法”</span>和“ <span class="control">调用树”</span>过滤器。</p>        </li><li class="list__item" id="a27c0e1c"><p>在“ <span class="control">线程状态”</span>过滤器中选择“ <span class="control">运行</span> ”。这将使结果过滤器<i id="aa4fa9b5">“选择在发生UI冻结且未执行阻塞GC时运行主线程的所有时间间隔”</i> 。过滤器列表如下所示：</p><figure><img alt="t1应用的过滤器" title="t1应用的过滤器" src="/help/img/dotnet/2019.2/t1_applied_filters.png" id="914f6fd2" width="596" height="49"></figure>现在，过滤器的“ <span class="control">顶部方法”</span>和“ <span class="control">调用树”</span>仅包含在这些时间间隔内执行的方法。<p></p></li><li class="list__item" id="036a13bc"><p>在“ <span class="control">性能分析器”</span>窗口中，单击“ <span class="control">主要方法”</span>以打开相应的过滤器。它显示了按用户执行时间排序的用户方法的简单列表。用户方法的执行时间计算为该方法自身的时间与它调用的所有系统方法的自身时间之和（直到堆栈中的下一个用户方法）。</p><figure><img alt="t1最佳方法" title="t1最佳方法" src="/help/img/dotnet/2019.2/t1_top_methods.png" id="1ef5e56c" width="612" height="138"></figure>如您所见，只有两种方法具有有意义的执行时间： <code class="code">App.Main</code>和<code class="code">MainWindow.ProcessInProgress</code> 。<p></p></li><li class="list__item" id="89888d38">看一下<span class="control">调用树</span> 。<figure><img alt="t1呼叫树" title="t1呼叫树" src="/help/img/dotnet/2019.2/t1_call_tree.png" id="f0d17254" width="716" height="193"></figure>如你看到的， <code class="code">App.Main</code>大部分时间都花在与处理Windows消息有关的许多系统方法中。*这是提供图形用户界面的任何应用程序的典型行为。这表明应用程序在消息循环中等待用户输入。分析快照时，我们可以简单地忽略这些方法。要找出导致冻结的方法，我们应该查看堆栈中的下一个用户方法，事实证明是<code class="code">MainWindow.ProcessInProgress</code> 。由于我们假定此方法由于一些计算工作而产生了滞后，因此让我们检查其源代码。<aside class="note " rel="0112f32b" id="c5b6da04" data-title=""><p>*为了简化对调用树的了解，过滤器默认情况下会折叠系统调用链。要展开链，请单击根系统调用旁边显示的图标。</p></aside>        </li><li class="list__item" id="9d371a18"><p>在“ <span class="control">调用树”中</span> ，右键单击<code class="code">ProcessInProgress</code>方法，然后在上下文菜单中选择“ <span class="control">导航到代码”</span> 。</p><figure><img alt="t1导航至代码" title="t1导航至代码" src="/help/img/dotnet/2019.2/t1_navigate_to_code.png" id="dafd38da" width="657" height="249"></figure>        <p></p></li><li class="list__item" id="f0aac286"><p>查看源代码。</p><div class="code-block" data-lang="csharp">私有void ProcessInProgress（对象发送者，ProgressChangedEventArgs e）{var upd =（ProgressUpdater）e。UserState; lblProgress。内容= $“文件{upd。{upd的CurrentFileNmb}。TotalFiles}：{e。ProgressPercentage}％“;}</div>看来此方法只是一个事件处理程序，它更新了主窗口上进度标签中文件处理操作的进度。这些计算看起来并不复杂，那么为什么会发生冻结呢？显然，经常调用此事件处理程序，以使主窗口无法应对标签的更新。让我们在代码中检查一下。<p></p></li><li class="list__item" id="aec456c0">进一步的代码研究*表明，此事件处理程序已订阅<code class="code">ProgressChanged</code>事件的背景工作者。当工作人员呼叫<code class="code">ReportProgress</code>方法。反过来，从<code class="code">ProcessFiles</code>后台工作者的方法。<aside class="note " rel="0fabb474" id="afe85a1c" data-title="">                <p id="9ece95ae">*如果您使用JetBrains ReSharper，则可以使用非常有用的“ <span class="control">检查此</span>功能”（按Ctrl + Shift + Alt + A）。它可以显示该方法的所有传入调用。</p>            </aside>    <div class="code-block" data-lang="csharp">...for（int j = 0; j <_lines。长度; j ++）{var line = _lines [j]; var stringReverser = new StringReverser（line）; _lines [j] = stringReverser。相反（）; if（j％5 == 0）{var p =（（float）（j +1）/ _lines。长度）* 100;工人。ReportProgress（（int）p，_updater）; }} ...
    </div>        </li><li class="list__item" id="f489f964"><p>这是造成我们性能问题的原因： <code class="code">ReportProgress</code>每次处理文本文件中的5行后，都会调用。由于行处理非常快， <code class="code">ReportProgress</code>对于系统而言，调用过于频繁。例如，让我们将此频率降低为每1000条线路一个呼叫。改善<code class="code">if</code>代码中的条件。</p><div class="code-block" data-lang="csharp">...if（j％1000 == 0）{float _p =（（float）（j +1）/ _lines。长度）* 100;工人。ReportProgress（（int）_p，_updater）; } ...
    </div>        <p></p></li><li class="list__item" id="70292e56"><p>重建解决方案并再次执行一次配置，如<a href="#run_profiler">运行Profiler和获取快照中所述</a> 。</p><figure><img alt="T1螺纹固定" title="T1螺纹固定" src="/help/img/dotnet/2019.2/t1_threads_fixed.png" id="200fe5fd" width="623" height="397"></figure>没有滞后了！时间轴也不会在文件处理期间检测到任何UI冻结。<p></p></li></ol>    </div>    <div class="chapter"><h2 id="4819ca5a" data-toc="Get_Started_with_Timeline_Viewer#4819ca5a">结论</h2>    <p id="aa3770e7">以下是本教程的主要内容：</p><ul class="list _ul"><li class="list__item" id="de2d053a"><p>与“经典”性能分析不同，在时间轴分析期间，dotTrace收集临时调用堆栈和线程状态数据。</p></li><li class="list__item" id="a7e1817a"><p>要分析时间线分析的结果，可以使用Visual Studio中的<span class="control">Performance Profiler</span>工具窗口或独立的<span class="control">时间线查看器</span>应用程序。</p></li><li class="list__item" id="a9fbb72b"><p>                <span class="control">Performance Profiler</span>和<span class="control">Timeline Viewer</span>是一组过滤器和图表，它们可视化应用程序的事件时间线，并允许您对收集的时间数据进行切片和切块。</p></li><li class="list__item" id="05d1c6d0"><p>每个过滤器都是双重用途的：它既显示数据，又让您设置特定条件。</p></li><li class="list__item" id="e1de7e85"><p>过滤器可以链接在一起。</p></li></ul>    <p></p></div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Get_Started_with_Timeline_Profiling_(Basic).html">时间轴分析入门可</a> <a class="navigation-links__next" href="Optimize_App_Performance_and_Memory_Traffic.html">优化应用程序性能和内存流量</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>