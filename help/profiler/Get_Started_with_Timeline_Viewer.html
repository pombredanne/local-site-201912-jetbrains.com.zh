<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        dotTrace tutorial, .NET C# performance profiling tutorial, .NET UI freezes, UI performance,&#xA;        .NET performance profiler, WPF performance, improve UI speed&#xA;    " name="description" data-skip-index="skip"><title>Find the Cause of a UI Freeze - Help | dotTrace</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Get_Started_with_Timeline_Viewer" data-disqus-id="Get_Started_with_Timeline_Viewer_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotTrace Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Get_Started_with_Timeline_Viewer" id="Get_Started_with_Timeline_Viewer.xml">Find the Cause of a UI Freeze</h1>        <p id="5376427a">        WARNING! This tutorial was written for dotTrace 2016.2. Please note that        some UI controls (e.g., filters) were significantly redesigned in dotTrace 2016.3.        For example, all controls from the <span class="control">Analysis Subject</span> filter were moved        under the <span class="control">Events</span> filter.    </p>    <p id="eef3c819">        In this tutorial, we will take a detailed look at the key profiling steps and introduce you to        the Timeline Viewer user interface. We will also profile a sample application and try to determine why its        UI freezes, which is a very common profiling task.    </p>    <div class="chapter"><h2 id="sample_app" data-toc="Get_Started_with_Timeline_Viewer#sample_app">Sample application</h2>    <p id="244b5906">        Our sample application is used to reverse lines in text files, e.g.,        <code class="code">ABC</code> =&gt; <code class="code">CBA</code>. With the <span class="control">Select Files</span>        button, user chooses one or more text files to be processed. The <span class="control">Process Files</span>        button runs a separate        <a href="http://msdn.microsoft.com/en-us/library/vstudio/system.componentmodel.backgroundworker" data-external="true" target="_blank" rel="noopener noreferrer">BackgroundWorker</a>        thread which reverses lines in the files. Progress is displayed in the left-hand corner of the window.        After processing is finished, the label reports        <span class="control">All files were successfully processed</span>.    </p>    <p id="be684ac5">        The source code is available on <a href="https://github.com/DarthWeirdo/dotTrace_Timeline_Get_Started" data-external="true" target="_blank" rel="noopener noreferrer">github</a>.    </p>    <figure><img alt="t1 app" title="t1 app" src="/help/img/dotnet/2019.2/t1_app.png" id="ebd04303" width="478" height="125"></figure>    <p id="04146c93">        The application has a serious drawback. After starting file processing, users experience UI lags that last until        processing is over.    </p>    <p id="d370060b">        Let's use timeline profiling to find out why these freezes happen!*    </p>    <aside class="note " data-title="" rel="d370060b" id="8fe84b08"><p>        * The algorithm of fixing UI freezes shown in this tutorial contains some unnecessary steps and may seem        suboptimal to you. This is done intentionally as the main goal of this tutorial is to acquaint you with timeline        profiling concepts.    </p></aside>    </div>    <div class="chapter"><h2 id="run_profiler" data-toc="Get_Started_with_Timeline_Viewer#run_profiler">Running the profiler and getting a snapshot</h2>    <ol class="list _decimal"><li class="list__item" id="ef37c952"><p>            Open the <span class="filepath">MassFileProcessing.sln</span> solution in Visual Studio.        </p></li><li class="list__item" id="b0a6291e"><p>            Run the profiler by choosing            <span data-skip-index="skip" class="menupath">ReSharper | Profile | Run Startup Configuration Performance Profiling...</span>.        </p></li><li class="list__item" id="cc7cec7a"><p>            In <span class="control">Profiling type</span>, select            <span class="control">Timeline</span>.            <figure><img alt="t1 profiling options" title="t1 profiling options" src="/help/img/dotnet/2019.2/t1_profiling_options.png" id="41cd692b" width="684" height="488"></figure>        </p></li><li class="list__item" id="9f8c43b9"><p>            Click <span class="control">Run</span>. dotTrace will run our application and display a special controller window            used to control the profiling process.            <figure><img alt="t1 profiling controller" title="t1 profiling controller" src="/help/img/dotnet/2019.2/t1_profiling_controller.png" id="110f600f" width="550" height="83"></figure>            Now, let's try to reproduce a performance issue in our app.        </p></li><li class="list__item" id="8913681b"><p>            Click <span class="control">Select Files</span>            and choose five text files that come with the application in the            <i id="e9641eef">Text Files</i> folder.            <figure><img alt="t1 app" title="t1 app" src="/help/img/dotnet/2019.2/t1_app.png" id="b03d3821" width="478" height="125"></figure>        </p></li><li class="list__item" id="eff2f03d"><p>            Click <span class="control">Process Files</span> to start file processing.            As you can see, the application lags very badly. Actually, you are even unable to see the progress of file            processing until it is finished and the            <span class="control">All files were processed successfully message</span>            is shown.        </p></li><li class="list__item" id="2d120e55"><p>            Collect a timeline profiling snapshot by clicking            <span class="control">Get Snapshot and Wait</span>            in the controller window. The snapshot will be opened in separate            <span class="control">Performance Profiler</span>            tool window in Visual Studio.        </p></li><li class="list__item" id="33f03b7b"><p>Close the application. This will also close the controller window.</p></li></ol>    </div>    <div class="chapter"><h2 id="analyzing-a-timeline-profiling-snapshot" data-toc="Get_Started_with_Timeline_Viewer#analyzing-a-timeline-profiling-snapshot">Analyzing a timeline profiling snapshot</h2>    <ol class="list _decimal"><li class="list__item" id="f09f183d">            Click <span class="control">Threads</span> to open the <span class="control">Threads</span> tool window.            By default, it shows all application threads excluding unmanaged threads.*            Note that all filter values you see are calculated for all currently visible threads.            For further analysis, we are not interested in threads that perform no work. So, first let's get rid of            them.            <aside class="note " data-title="" rel="a78e6de7" id="6eca5626">                <p id="6ab9697b">                    * You can make them visible at any time using the                    <span class="control">Visible Threads</span>                    list.                </p>            </aside>            <figure><img alt="t1 threads" title="t1 threads" src="/help/img/dotnet/2019.2/t1_threads.png" id="b9c5f8ee" width="614" height="380"></figure>        </li><li class="list__item" id="6a3d8dda"><p>            Look at the list of threads in the tool window. It contains the            <span class="control">Main</span>            application thread, the            <span class="control">Finalizer</span>            thread used by runtime for finalizing objects (does no work in our application),            and <span class="control">Garbage Collection</span> thread (used to perform background GC).            The <code class="code">BackgroundWorker</code> thread that processes files in our application was identified as            <span class="control">Thread Pool</span>            (ID 13456) because            background threads are created by the CLR Thread Pool. There's also one more            <span class="control">Thread Pool</span>            (ID 7416) that does no work. This is probably some auxiliary CLR thread pool.            Let's hide the            <span class="control">Finalizer</span>            and <span class="control">Thread Pool</span> (ID 7416) threads as irrelevant to our analysis.        </p></li><li class="list__item" id="4a42980c"><p>            Select the            <span class="control">Finalizer</span>            and <span class="control">Thread Pool</span> (ID 7416) threads in the            <span class="control">Threads</span>            tool window.        </p></li><li class="list__item" id="dc03a3a3"><p>            Right-click and select            <span class="control">Hide Selected Threads</span>.            <figure><img alt="t1 hide threads" title="t1 hide threads" src="/help/img/dotnet/2019.2/t1_hide_threads.png" id="e31d88a8" width="616" height="409"></figure>        </p></li><li class="list__item" id="75b45481"><p>            Look at the <span class="control">Threads</span> window. The following filter is currently applied to the snapshot            data: <i id="893a64cc">"Select lifetime intervals of all threads excepting hidden"</i>.            <figure><img alt="t1 hidden threads" title="t1 hidden threads" src="/help/img/dotnet/2019.2/t1_hidden_threads.png" id="bc4bf38f" width="615" height="278"></figure>            Note how the data in other filters were affected. For example, state times in            <span class="control">Thread State</span>            are now calculated for            all threads except the hidden ones.            <span class="control">Top Methods</span>            and            <span class="control">Call Tree</span>            have changed too, showing calls only from the filtered threads.        </p></li><li class="list__item" id="4058ac26">            The current scale of the            <span class="control">Threads</span>            diagram doesn't allow us to see the            <span class="control">13456 Thread Pool</span>            (our <code class="code">BackgroundWorker</code> thread)            in details. Let's zoom in so that it fits the entire diagram.            To do this, use <kbd data-bypass="true" class="keystroke"><span class="keystroke__value">Mouse,Wheel</span></kbd> on the            <span class="control">Threads</span>            diagram*.            This automatically adds the filter by visible time range:            <span class="control">1489 ms</span>. Note how this filter affects others: all            values are recalculated for the visible time range.            The following filter is now applied to the snapshot data:            <i id="152e8fc4">"Select all time intervals within the visible time range for all threads except hidden"</i>.            <aside class="note " data-title="" rel="152e8fc4" id="dde38ea9"><p>* To pan the diagram, drag it while holding the right mouse button.</p></aside>            <figure><img alt="t1 visible interval filter" title="t1 visible interval filter" src="/help/img/dotnet/2019.2/t1_visible_interval_filter.png" id="3bd6aad5" width="619" height="333"></figure>        </li><li class="list__item" id="d64378b3"><p>            Take a look at the <span class="control">Threads</span> diagram.            What you see is how thread states changed over time. For example, our            <code class="code">BackgroundWorker</code>            thread            <span class="control">13456 Thread Pool</span>            has started approximately at 16 s (after we clicked the            <span class="control">Process Files</span>            button). Most of the time the thread was            <span class="control">Running</span>            (rich blue intervals). Besides, there are intervals where the thread was in the            <span class="control">Waiting</span>            state (pale blue intervals).            <figure><img alt="t1 zoomed thread" title="t1 zoomed thread" src="/help/img/dotnet/2019.2/t1_zoomed_thread.png" id="fa59b504" width="606" height="22"></figure>        </p></li><li class="list__item" id="c7f4168b">            <p id="c6d73d9e">                Look at the Process Overview diagram in the <span class="control">Threads</span> tool window*.                In addition to <span class="control">CPU</span> utilization, it shows two event diagrams which may be very helpful                for the performance analysis. The                <span class="control">UI Freeze</span>                bar shows that the freeze started right after                <span class="control">13456 Thread Pool</span>                was created.            </p>            <p id="ec0e7b38">                Blocking Garbage Collection <span class="control">GC</span> was also intensively performed on this time interval.                As blocking GC suspends all managed threads, it may be the potential cause of the UI freeze.            </p>            <p id="f6a79c89">We must take a closer look at these events.</p>            <aside class="note " data-title="" rel="f6a79c89" id="e160a403"><p>                * The timeline pattern may look slightly different on your computer, as the execution flow depends on a                great variety of factors (like the number of CPU cores, their workload during the app execution, etc.).                Nevertheless,                the freeze must take place regardless of your system configuration.            </p></aside>            <figure><img alt="t1 process overview" title="t1 process overview" src="/help/img/dotnet/2019.2/t1_process_overview.png" id="06ab88db" width="611" height="268"></figure>        </li><li class="list__item" id="0d307e3a">            First, let's remove the visible time range filter as we no longer need it. To do this, click on the filter            in the top of the <span class="control">Threads</span> tool window*. The diagram will zoom back out.            <aside class="note " data-title="" rel="d060e064" id="2c2b166b">                <p id="52c01d45">                    Note that both <span class="control">Performance Profiler</span> and <span class="control">Threads</span> tool windows                    offer you the same set of filters. It doesn't matter in which window you turn on or off a particular                    filter. The changes will be applied to data in both windows.                </p>            </aside>            <figure><img alt="t1 remove filter" title="t1 remove filter" src="/help/img/dotnet/2019.2/t1_remove_filter.png" id="53523dcf" width="194" height="112"></figure>        </li><li class="list__item" id="6d328a55">            Now, let's investigate the UI freeze event more thoroughly.            What are the main potential causes of such freezes? These are:            <ul class="list _ul"><li class="list__item" id="97b928a4"><p>long or frequent blocking GCs;</p></li><li class="list__item" id="363a0500"><p>blocking of the UI thread by some other thread (for example, due to lock contention);</p></li><li class="list__item" id="d5ea7b43"><p>and/or excessive computational work on the UI thread.</p></li></ul>            We will proceed to exclude these causes one by one until only the true culprit remains.        </li><li class="list__item" id="7bdcd8a2"><p>            Select the            <span class="control">UI freeze</span>            event by clicking on the corresponding bar in the process overview section of the            <span class="control">Threads</span>            tool window. This will apply the            filter by the UI freeze event. Note that this applies not only the filter by the freeze time range, but also            the filter by the            <span class="control">Main</span>            thread. The latter is done automatically, as the Main thread is the only one that            processes the UI interaction in our application.            Thus, the resulting filter now is            <i id="04734a13">"Select all time intervals on the Main thread where the UI freeze event                took place"</i>.            <figure><img alt="t1 ui freeze filter" title="t1 ui freeze filter" src="/help/img/dotnet/2019.2/t1_ui_freeze_filter.png" id="996c4239" width="616" height="352"></figure>        </p></li><li class="list__item" id="34984ead">            <p id="668476b1">Now, to identify the true cause of this freeze, let's investigate other filter values.                The first potential cause we should analyze is excessive blocking GCs.            </p>            <p id="f32a77da">Click <span class="control">Blocking GC</span> to open the blocking GC filter and take a look                at the values.            </p>            <p id="3c37e01d">                Taking                into account the currently applied filters, it shows how long the Main thread was                (<span class="control">Blocking GC</span> value)                and was not (<span class="control">Exclude Blocking GC</span> value) blocked by GC during the freeze.            </p>            <figure><img alt="t1 blocking gc filter" title="t1 blocking gc filter" src="/help/img/dotnet/2019.2/t1_blocking_gc_filter.png" id="73944316" width="259" height="101"></figure>            <p id="7c1de5ec">                The <span class="control">Blocking GC</span> time is quite high                (420 ms, or 10.2% of the selected interval) and probably may have some                impact on performance. Nevertheless, it could hardly be the cause of the 4-second freeze. Thus, we may                exclude                excessive garbage collection from our list of suspects.            </p>        </li><li class="list__item" id="ef500254"><p>            Click the            <span class="control">Exclude Blocking GC</span>            value. The resulting filter now is            <i id="f01fb523">"Select all time intervals on the Main                thread where the UI freeze event took place and no blocking GC is performed"</i>.        </p></li><li class="list__item" id="2640d5fe">            <p id="0f146fcf">Let's investigate the potential causes "Blocking by some other thread" and "Excessive work on the Main                thread."            </p>            <p id="10d4d072">Open and take a look at the values in <span class="control">Thread State</span>.                This filter shows total time spent by threads in a certain state. Taking into                account the currently applied filters, it shows states of the Main thread during the freeze.            </p>            <figure><img alt="t1 thread state filter" title="t1 thread state filter" src="/help/img/dotnet/2019.2/t1_thread_state_filter.png" id="1a43639f" width="196" height="125"></figure>            <p id="de39bc8e">                It appears that most of the freeze time (<span class="control">92.9%</span>, or <span class="control">3426 ms</span>), the                thread                was doing some work as it was <span class="control">Running</span>.                The <span class="control">225 ms</span> value of the                <span class="control">Waiting</span>                state is too small, which automatically excludes "Blocking by some other thread" from                potential causes. Therefore, the cause of the freeze can only be computational work on the Main thread!            </p>            <p id="a3b4baed">                All we need to do now is find methods that were executed on the                <span class="control">Main</span>                thread during the freeze. We can use                the <span class="control">Top Methods</span> and                <span class="control">Call Tree</span>                filters for this.            </p>        </li><li class="list__item" id="a27c0e1c"><p>            Select            <span class="control">Running</span>            in the            <span class="control">Thread State</span>            filter. This will make the resulting filter            <i id="aa4fa9b5">"Select all time intervals                where the Main thread was running when the UI freeze took place and no blocking GC was performed"            </i>.            The list of filters will look as follows:            <figure><img alt="t1 applied filters" title="t1 applied filters" src="/help/img/dotnet/2019.2/t1_applied_filters.png" id="914f6fd2" width="596" height="49"></figure>            Now, the filters            <span class="control">Top Methods</span>            and            <span class="control">Call Tree</span>            contain only methods executed during these time intervals.        </p></li><li class="list__item" id="036a13bc"><p>            In the <span class="control">Performance Profiler</span> window, click <span class="control">Top Methods</span> to            open the corresponding filter. It shows a plain list of user methods sorted by their            execution time. The execution time of a user method is calculated as the sum of the method's own time            and own time of all system methods it calls (down to the next user method in the stack).            <figure><img alt="t1 top methods" title="t1 top methods" src="/help/img/dotnet/2019.2/t1_top_methods.png" id="1ef5e56c" width="612" height="138"></figure>            As you can see, there are only two methods with meaningful execution time:            <code class="code">App.Main</code>            and            <code class="code">MainWindow.ProcessInProgress</code>.        </p></li><li class="list__item" id="89888d38">            Look at the <span class="control">Call Tree</span>.            <figure><img alt="t1 call tree" title="t1 call tree" src="/help/img/dotnet/2019.2/t1_call_tree.png" id="f0d17254" width="716" height="193"></figure>            As you can see,            <code class="code">App.Main</code>            spends most of the time in a number of system methods related to processing Windows            messages.* This is typical behavior for any application that provides a graphical user interface.            This indicates that the application waits for user            input in a message loop. We can simply ignore these methods when analyzing the snapshot. To find out what            method causes the freeze, we should look at the next user method in the stack, which turns out to be            <code class="code">MainWindow.ProcessInProgress</code>.            Since we assumed that lags took place due to some computational work in this method, let's check its source            code.            <aside class="note " data-title="" rel="0112f32b" id="c5b6da04"><p>                * To ease understanding of the call tree, the filter folds system call chains by default.                To unfold the chain, click the icon shown against the root system call.            </p></aside>        </li><li class="list__item" id="9d371a18"><p>            In            <span class="control">Call Tree</span>, right-click on the            <code class="code">ProcessInProgress</code>            method and select <span class="control">Navigate to Code</span> in the context            menu.            <figure><img alt="t1 navigate to code" title="t1 navigate to code" src="/help/img/dotnet/2019.2/t1_navigate_to_code.png" id="dafd38da" width="657" height="249"></figure>        </p></li><li class="list__item" id="f0aac286"><p>            Look at the source code.    <div class="code-block" data-lang="csharp">
private void ProcessInProgress(object sender, ProgressChangedEventArgs e)
{
    var upd = (ProgressUpdater) e.UserState;
    lblProgress.Content = $"File {upd.CurrentFileNmb} of {upd.TotalFiles}: {e.ProgressPercentage}%";
}
    </div>            It appears that this method is just an event handler that updates the progress of file processing operation            in the progress label on the main window. These computations don't look complex, so why did the freezes            occur?            Apparently, this event handler is called so often that the main window cannot cope with updating the label.            Let's check            this out in our code.        </p></li><li class="list__item" id="aec456c0">            Further code investigation* shows that this event handler is subscribed to the            <code class="code">ProgressChanged</code>            event of the            background worker. This event occurs when the worker calls the            <code class="code">ReportProgress</code>            method. In turn, it is called            from the <code class="code">ProcessFiles</code> method of the background worker.            <aside class="note " data-title="" rel="0fabb474" id="afe85a1c">                <p id="9ece95ae">                    * If you use JetBrains ReSharper, you can employ the very helpful                    <span class="control">Inspect This</span>                    feature (press Ctrl+Shift+Alt+A).                    It can show you all incoming calls to the method.                </p>            </aside>    <div class="code-block" data-lang="csharp">
...
for (int j = 0; j &lt; _lines.Length; j++)
{
    var line = _lines[j];
    var stringReverser = new StringReverser(line);
    _lines[j] = stringReverser.Reverse();

    if (j % 5 == 0)
    {
        var p = ((float)(j + 1) / _lines.Length) * 100;
        Worker.ReportProgress((int) p, _updater);
    }
}
...
    </div>        </li><li class="list__item" id="f489f964"><p>            Here is the cause of our performance issues:            <code class="code">ReportProgress</code>            is called each time after 5 lines in a text file            are processed. As lines are processed very quickly,            <code class="code">ReportProgress</code>            is called too frequently for the system.            Let's reduce this frequency, for instance, to one call per 1000 lines. Improve the            <code class="code">if</code>            condition in the code.    <div class="code-block" data-lang="csharp">
...
if (j % 1000 == 0)
{
    float _p = ((float)(j + 1) / _lines.Length) * 100;
    Worker.ReportProgress((int) _p, _updater);
}
...
    </div>        </p></li><li class="list__item" id="70292e56"><p>            Rebuild the solution and perform profiling one more time as described in <a href="#run_profiler">            Running the Profiler and Getting a Snapshot</a>.            <figure><img alt="t1 threads fixed" title="t1 threads fixed" src="/help/img/dotnet/2019.2/t1_threads_fixed.png" id="200fe5fd" width="623" height="397"></figure>            No lags any more! Timeline also doesn't detect any UI freezes during file processing.        </p></li></ol>    </div>    <div class="chapter"><h2 id="4819ca5a" data-toc="Get_Started_with_Timeline_Viewer#4819ca5a">Conclusion</h2>    <p id="aa3770e7">        Here are the main tutorial takeaways:        <ul class="list _ul"><li class="list__item" id="de2d053a"><p>                Unlike "classic" performance profiling, during timeline profiling dotTrace collects temporal call stack                and thread state data.            </p></li><li class="list__item" id="a7e1817a"><p>                To analyze the results of timeline profiling, you can use either a <span class="control">Performance Profiler</span>                tool window in Visual Studio or standalone <span class="control">Timeline Viewer</span> application.            </p></li><li class="list__item" id="a9fbb72b"><p>                <span class="control">Performance Profiler</span> as well as                <span class="control">Timeline Viewer</span> is a set of filters and diagrams that visualize the event timeline                of your application and allow you to slice and dice the collected temporal data.            </p></li><li class="list__item" id="05d1c6d0"><p>                Each filter is dual-purpose: it both displays data and lets you set a specific condition.            </p></li><li class="list__item" id="e1de7e85"><p>                Filters can be chained together.            </p></li></ul>    </p></div><div class="last-modified" data-skip-index="skip">Last modified: 19 September 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Get_Started_with_Timeline_Profiling_(Basic).html">Get Started with Timeline Profiling</a><a class="navigation-links__next" href="Optimize_App_Performance_and_Memory_Traffic.html">Optimize App Performance and Memory Traffic</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>