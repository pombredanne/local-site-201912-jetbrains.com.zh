<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotTrace tutorial, .NET C# performance profiling tutorial, .NET boosting improving performance,
        .NET application performance management, ASP.NET performance monitorings, SQL requests performance,
        HTTP requests performance
    " data-skip-index="skip"><title>时间轴分析入门-帮助|帮助dotTrace</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Get_Started_with_Timeline_Profiling_(Basic)" data-disqus-id="Get_Started_with_Timeline_Profiling_(Basic)_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Get_Started_with_Timeline_Profiling_(Basic).xml" data-toc="Get_Started_with_Timeline_Profiling_(Basic)">时间轴分析入门</h1>        <p id="8abffea2">与“经典” <a href="Performance_Profiling.html">性能分析不同</a> ，在时间轴分析期间，dotTrace收集临时调用堆栈和线程状态数据。您会获得有关通话时间的相同数据，但绑定到时间轴。这样，您不仅可以分析典型的“最慢的方法是什么？问题，还有事件顺序确实重要的问题，例如UI冻结，垃圾回收过多，工作负载分配不均，文件I / O不足等。</p>    <div class="chapter"><h2 id="1542ea8a" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#1542ea8a">运行探查器并获取快照</h2>        <p id="cd8e8e9a">要开始时间线分析，只需在<a href="Configuring_Profiling_Session.html">配置会话</a>时选择<span class="control">时间线</span>分析类型。</p>        <p id="c51809c6">收集快照的过程与<a href="Get_Started_with_Performance_Viewer.html#get_snapshots">性能分析过程</a>完全相同。您只需在应用程序执行期间单击“ <span class="control">获取快照并等待”</span>按钮。要分析收集的时间轴分析快照，您应该使用一个单独的dotTrace组件，称为<a href="Timeline_Viewer_Concepts.html">Timeline Viewer</a> 。</p>    </div>    <div class="chapter"><h2 id="83f314df" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#83f314df">首先看一下时间轴用户界面</h2>        <aside class="tip sideblock" rel="83f314df" id="4a8014fd" data-title="">            <p id="08d626a2">dotTrace提供了两种分析时间轴分析结果的方式：</p><ul class="list _ul"><li class="list__item" id="724d4037"><p>在Visual Studio中，使用<span class="control">Performance Profiler</span>工具窗口。</p></li><li class="list__item" id="f5a8caca"><p>使用独立的时间线查看器应用程序。</p></li></ul>从用户体验的角度来看，这两个对应部分几乎相同， <a href="Analyzing_Concurrency_Profiling_Results_Timeline_.html#timeline-viewer-integrated-into-visual-studio">差异很小</a> 。<p></p>            <p id="d435bc5b">在本教程中，我们将使用时间轴查看器。但是，教程的所有步骤也可以在Visual Studio的<span class="control">Performance Profiler</span>工具窗口中复制。</p>        </aside>        <p id="4bdcda19">让我们做些离题，看看“时间轴查看器”的用户界面。</p>        <figure><img alt="时间轴第一眼" title="时间轴第一眼" src="/help/img/dotnet/2019.2/timeline_first_look.png" id="9b9717e0" width="800" height="450"></figure>        <p id="125b72c3">查看器中的分析工作流程非常简单：您要做的就是使用过滤器将收集的时间数据切成薄片并将其切成小块。</p>        <p id="a97c70e8">那么，过滤器在哪里？实际上，您在屏幕上看到的几乎所有UI元素不仅显示数据，还允许应用特定的过滤器。过滤器工作的结果始终是由特定条件选择的一组时间间隔或点事件。例如，单击<span class="control">事件|文件操作</span>将告诉dotTrace <i id="2dc15ea9">在应用程序执行文件I / O操作的所有线程上选择所有时间间隔</i> 。在“ <span class="control">线程”</span>列表中单击“ <span class="control">主</span>线程”将<i id="d18f9291">选择“主线程的生存期”</i> 。</p>        <p id="74c2b889">当然，过滤器可以链接在一起。如果依次激活上述两个过滤器，则会得到最终的过滤器： <i id="5007ad0b">选择Main线程执行文件I / O操作的所有时间间隔</i> 。通过仔细组合过滤器，您可以研究应用程序的几乎每个方面。</p>    </div>    <div class="chapter"><h2 id="3ea0eb75" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#3ea0eb75">如何</h2>        <p id="ddc91114">现在，让我们看一下最重要的Timeline Viewer用例。在本节中，您将找到如何：</p>        <ul class="list" data-skip-index="skip"><li class="list__item"><a href="#cpu">查找并选择高CPU使用率的时间间隔</a></li><li class="list__item"><a href="#call_tree">找到最慢的方法并查看其调用树</a></li><li class="list__item"><a href="#subsystems">快速了解方法中发生的事情</a></li><li class="list__item"><a href="#backtraces">查看方法的父调用</a></li><li class="list__item"><a href="#find_by_name">按名称查找方法</a></li><li class="list__item"><a href="#ui_freeze">查找导致UI冻结的原因</a></li><li class="list__item"><a href="#allocation">查找导致过多内存分配的原因</a></li><li class="list__item"><a href="#http">跟踪HTTP请求</a></li></ul>        <div class="chapter"><h3 id="cpu" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#cpu">查找并选择高CPU使用率的时间间隔</h3>当您需要评估整体应用程序性能并查找具有最高使用时间的方法时，CPU使用率较高的时间间隔是最重要的。您可以使用“ <a href="Process_Overview.html">流程”概览</a>图快速找到并选择此类间隔：<figure id="f70c2b00" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/find_cpu_usage.png" width="960" data-gif-src="/help/img/dotnet/2019.2/find_cpu_usage.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="call_tree" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#call_tree">找到最慢的方法并查看其调用树</h3>找到感兴趣的时间间隔后，下一步就是在该时间间隔上找到最慢的方法并检查方法的调用树。后者将帮助您确定“为什么该方法缓慢”或“该方法的大部分子调用在大部分时间中占据了什么位置”。您可以使用“ <a href="Plain_List.html">方法和子系统”</a>列表组成的“ <span class="control">调用堆栈”</span>窗口来执行这两种操作（显示间隔中具有最高自身/总时间的方法）和“ <a href="Call_Tree.html">调用树”</a> ：<figure id="86e1aa8e" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/slowest_method_call_tree.png" width="960" data-gif-src="/help/img/dotnet/2019.2/slowest_method_call_tree.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="subsystems" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#subsystems">快速了解方法中发生的事情</h3>从版本2017.1开始，时间轴查看器提供了超级有用的<a href="Subsystems.html">子系统</a>功能。子系统的目的是快速回答主要问题“我的应用程序中到底发生了什么？”以及更具体的问题，例如“是什么导致性能下降？”。或“什么分配了这么多的内存？”。性能下降是否与文件操作，JIT，字符串处理或代码中的过多工作有关？子系统过滤器是一个单一位置，向您显示选定时间间隔内的时间如何在各种活动之间分配。在下面的示例中，“子系统”栏显示该方法的主要时间被锁争用占用：<br>            <figure id="d44de28b" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/going_on_method.png" width="960" data-gif-src="/help/img/dotnet/2019.2/going_on_method.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="backtraces" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#backtraces">查看方法的父调用</h3>在检查有问题的方法时，不仅要检查其子调用，而且要了解如何自行调用该方法，这一点很重要。为此，您可以将“ <span class="control">呼叫树”</span>切换到“ <a href="Call_Tree.html#backtraces">回溯”</a>模式。在这种模式下，您可以看到堆栈中第一个方法的执行路径（因此，在某种意义上， <span class="control">Backtraces</span>是倒置的<span class="control">Call Tree</span> ）：<br>            <figure id="578b95b4" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/parent_calls.png" width="960" data-gif-src="/help/img/dotnet/2019.2/parent_calls.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="find_by_name" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#find_by_name">按名称查找方法</h3>有时，您需要检查某些特定方法的性能：该方法需要花费多长时间，在时间轴上确切地在何处被调用等等。在这种情况下，您可以通过其名称找到所需的方法。例如，在下面的示例中，我们将找到<code class="code">Factorial</code>方法：<br>            <figure id="dedb1869" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/find_by_name.png" width="960" data-gif-src="/help/img/dotnet/2019.2/find_by_name.animated.gif" style="width:960px"></figure>            <p id="b18035db">请注意，在“时间轴查看器”找到该方法之后，它还会自动通过此方法应用过滤器。</p>        </div>        <div class="chapter"><h3 id="ui_freeze" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#ui_freeze">查找导致UI冻结的原因</h3>UI冻结的分析是dotTrace表现出最佳状态的领域。自动检测到应用程序的GUI冻结的时间间隔。通常，您只需要选择一个UI冻结并检查“ <a href="Plain_List.html">方法和子系统”</a>列表：<br>            <figure id="4102a906" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/ui_freeze_cause.png" width="960" data-gif-src="/help/img/dotnet/2019.2/ui_freeze_cause.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="allocation" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#allocation">查找导致过多内存分配的原因</h3>过多的内存分配，或更正确地说，其以垃圾回收形式产生的后果可能会对应用程序性能产生很大影响。因此，对于性能分析而言，了解应用程序中内存分配的来源非常重要。下面的示例显示如何使用“ <a href="Memory_Allocation.html">内存分配”</a>事件来确定分配最多内存的方法和子系统：<br>            <figure id="bad10f91" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/memory_allocation.png" width="960" data-gif-src="/help/img/dotnet/2019.2/memory_allocation.animated.gif" style="width:960px"></figure>        </div>        <div class="chapter"><h3 id="http" data-toc="Get_Started_with_Timeline_Profiling_(Basic)#http">跟踪HTTP请求</h3>分析Web应用程序中的性能缺陷时，跟踪HTTP请求的能力非常重要。 dotTrace允许您以与任何应用程序性能管理（APM）系统相同的方式跟踪事务，即，您可以过滤对特定URL的请求，查看其背后的HTTP方法以及服务器为处理请求而执行的所有操作。请求，例如SQL事务或.NET代码。此外，dotTrace具有优于APM系统的显着优势，因为它提供了完整的调用树分析功能：<br>            <figure id="616c0dd4" width="960" data-theme="light"><img class="js-gif" src="/help/img/dotnet/2019.2/http_request_tracing.png" width="960" data-gif-src="/help/img/dotnet/2019.2/http_request_tracing.animated.gif" style="width:960px"></figure>        </div>    </div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Get_Started_with_Performance_Viewer.html">性能分析入门</a> <a class="navigation-links__next" href="Get_Started_with_Timeline_Viewer.html">查找UI冻结的原因</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>