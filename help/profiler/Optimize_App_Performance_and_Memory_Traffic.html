<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en-US"><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="//resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta content="&#xA;        dotTrace how to, dotTrace tutorial, .NET performance tutorial, .NET memory management,&#xA;        .NET memory performance&#xA;    " name="description" data-skip-index="skip"><title>Optimize App Performance and Memory Traffic - Help | dotTrace</title><link rel="stylesheet" href="//resources.jetbrains.com/storage/help-app/v3/app.css"></head><body data-id="Optimize_App_Performance_and_Memory_Traffic" data-disqus-id="Optimize_App_Performance_and_Memory_Traffic_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label for="search-box__input" class="search-box__label"><input type="text" class="search-box__input" id="search-box__input" placeholder="Search dotTrace Help"></label><div class="search-box__clear" title="Clear"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">Send feedback</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2 Help</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">Keymap:</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option data-group="secondary" value="rs">ReSharper 2.x/IntelliJ IDEA</option><option data-group="primary" value="vs">Visual Studio</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Optimize_App_Performance_and_Memory_Traffic" id="Optimize_App_Performance_and_Memory_Traffic.xml">Optimize App Performance and Memory Traffic</h1>        <p id="82eca913">        WARNING! This tutorial was written for dotTrace 2016.2. Please note that        some UI controls (e.g., filters) were significantly redesigned in dotTrace 2016.3.        For example, all controls from the <span class="control">Analysis Subject</span> filter were moved        under the <span class="control">Events</span> filter.    </p>    <p id="8430df8d">        It is well known that memory traffic impacts heavily on application performance: The higher the traffic, the        slower your app. The problem is not in how frequently your application allocates memory (that is almost free as        far as performance goes), but in how your application collects memory that's no longer needed.        The convenience of the garbage collection (GC) mechanism that does this, unfortunately, has its cost.    </p>    <p id="691e406b">        First, GC itself demands some CPU time. For example, one of its stages is the detection of unused objects, a        complex operation involving building object reference graphs. Second, to perform the Gen0 and Gen1 GCs*, garbage        collector must obtain exclusive access to a part of the managed heap. This, in turn, suspends all managed        threads except        the one that triggered the "blocking GC." As the user interface thread is also suspended, users may experience        UI freezes at these moments.    </p>    <p id="48851ece">        That is why you should always try to optimize your application to reduce memory traffic and minimize the impact        of GCs on        app responsiveness.    </p>    <p id="36261d10">        In this tutorial, we will learn how to use timeline profiling to detect excessive GCs and their causes.    </p>    <aside class="note " data-title="" rel="36261d10" id="d3e90d0d"><p>        * By default, the so-called background garbage collection is enabled for desktop applications.        Background GC is performed by a separate GC thread and does not suspend managed threads during the "heaviest"        Gen2 collections. Nevertheless, during Gen0 and Gen1 collections managed threads have to be suspended.        Therefore, background GC involves short "blocking GC" intervals.    </p></aside>    <div class="chapter"><h2 id="sample-application" data-toc="Optimize_App_Performance_and_Memory_Traffic#sample-application">Sample application</h2>    <p id="b57ae8cf">        We use the same basic sample application as in the        <a href="Get_Started_with_Timeline_Viewer.html">Get Started with Timeline Profiling</a>        tutorial. This application is used to reverse lines in text files, e.g.        <code class="code">ABC</code>        =&gt; <code class="code">CBA</code>.    </p>    <p id="a0edeb2d">        The source code for the app is available at        <a href="https://github.com/DarthWeirdo/dotTrace_Improving_Performance" data-external="true" target="_blank" rel="noopener noreferrer">github</a>.    </p>    <figure><img alt="t2 working app" title="t2 working app" src="/help/img/dotnet/2019.2/t2_working_app.png" id="79941f18" width="478" height="125"></figure>    <p id="92963cdb">With the        <span class="control">Select Files</span>        button, a user chooses the text files to be processed. The        <span class="control">Process Files</span>        button runs a        separate        <code class="code">BackgroundWorker</code>        thread (named <span class="control">FileProcessing</span>) which reverses lines in the files. A label in the left-hand        corner        of the main window displays the progress. After the processing is finished, the label shows        <span class="control">All files were successfully processed</span>.    </p>    <p id="a1ed5fc2">Imagine the following scenario: When testing the application, you find out that text files are processed not as        fast as you        expected. Moreover, in some cases you experience minor lags during file processing.    </p>    <p id="c2992b39">Let's use timeline profiling to analyze these performance drawbacks!</p>    </div>    <div class="chapter"><h2 id="run_profiler" data-toc="Optimize_App_Performance_and_Memory_Traffic#run_profiler">Step 1. Running the profiler and getting a snapshot</h2>    <ol class="list _decimal"><li class="list__item" id="e5b03071"><p>            Open the <span class="filepath">MassFileProcessing.sln</span> solution in Visual Studio.        </p></li><li class="list__item" id="0d41d3d0"><p>            Run the profiler by choosing            <span data-skip-index="skip" class="menupath">ReSharper | Profile | Run Startup Configuration Performance Profiling...</span>.        </p></li><li class="list__item" id="2a336a70"><p>            In <span class="control">Profiling type</span>, select            <span class="control">Timeline</span>.            <figure><img alt="t2 profiling config" title="t2 profiling config" src="/help/img/dotnet/2019.2/t2_profiling_config.png" id="9c155cf2" width="685" height="472"></figure>        </p></li><li class="list__item" id="14316ace"><p>            Click <span class="control">Run</span>. dotTrace will run our application and display a special controller window            used to control the profiling process.            <figure><img alt="t1 profiling controller" title="t1 profiling controller" src="/help/img/dotnet/2019.2/t1_profiling_controller.png" id="954e5478" width="550" height="83"></figure>            Now, let's try to reproduce a performance issue in our app.        </p></li><li class="list__item" id="7a75cf0b"><p>            Click            <span class="control">Select Files</span>            and choose five text files that come with the application in the            <span class="filepath">Text Files</span>            folder.            <figure><img alt="t1 app" title="t1 app" src="/help/img/dotnet/2019.2/t1_app.png" id="e0ee0b30" width="478" height="125"></figure>        </p></li><li class="list__item" id="23a1f193"><p>            Click <span class="control">Process Files</span> to start file processing.        </p></li><li class="list__item" id="7d27c42b"><p>            Once the processing is over, collect a timeline profiling snapshot by clicking            <span class="control">Get Snapshot and Wait</span>            in the controller window. The snapshot will be opened in separate            <span class="control">Performance Profiler</span>            tool window in Visual Studio.        </p></li><li class="list__item" id="98995d81"><p>Close the application. This will also close the controller window.</p></li></ol>    </div>    <div class="chapter"><h2 id="step-2-starting-analysis" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-2-starting-analysis">Step 2. Starting analysis</h2>    <ol class="list _decimal"><li class="list__item" id="c4a24191">            In the <span class="control">Performance Profiler</span> tool window, click <span class="control">Show Threads</span>.            This will open a list of application threads in a separate <span class="control">Threads</span> tool window.            <figure><img alt="t2 performance profiler window" title="t2 performance profiler window" src="/help/img/dotnet/2019.2/t2_performance_profiler_window.png" id="d3990992" width="620" height="708"></figure>            You can see that dotTrace has detected several managed threads. These are the            <span class="control">Main</span>            thread, the            <span class="control">Garbage Collection</span>            thread that is used to perform background GC, and the            <span class="control">FileProcessing</span>            thread* used            to process files. In addition, there are two threads that do no work: the            <span class="control">Finalizer</span>            thread and an auxiliary            <span class="control">Thread Pool</span>.            <aside class="note " data-title="" rel="f33116ce" id="55b9c1d1"><p>                *Named threads are highlighted bold on the diagram.            </p></aside>        </li><li class="list__item" id="28740c16"><p>            As we are concerned with slow file processing, let's zoom into the period where the            <span class="control">FileProcessing</span>            thread            processes files.            To do this, use            Mouse Wheel            on the            <span class="control">Threads</span>            diagram.            <figure><img alt="t2 threads zoomed" title="t2 threads zoomed" src="/help/img/dotnet/2019.2/t2_threads_zoomed.png" id="3b89257a" width="610" height="243"></figure>            This automatically adds the filter by the visible time interval (<span class="control">1950 ms</span>).            Note how this filter affects others: all values are            recalculated            for the visible time range. The filter now applied to the snapshot data is            <i id="b3a73267">"Select all time intervals within                the visible time range for all threads"</i>.            Let's remember 2 seconds as the approximate time required for processing files.        </p></li><li class="list__item" id="cee3410d">            <p id="1816d29c">On the process overview diagram (in the top of the <span class="control">Threads</span>window),                look at the                <span class="control">GC</span>                bar. It appears that many blocking GCs are                performed during file processing. This indicates large memory traffic that, without any doubts, impacts                application performance.            </p>            <p id="b39ec1ea">                Now, let's find out what's really behind this traffic. There are two ways* this can be done:            </p>            <ul class="list _ul"><li class="list__item" id="648d08b9"><p>                    Identify the threads and methods that are running during the GCs. These must be the threads and                    methods that toggled these collections.                </p></li><li class="list__item" id="892757c7"><p>Identify the methods that allocate the major part of memory. The logic is simple: the main reason                    for                    toggling GCs is resizing a heap due to memory allocation. Thus, if a method allocates memory a lot,                    it triggers GCs a lot as well.                </p></li></ul>            <aside class="note " data-title="" rel="023535b2" id="f50d8ef9"><p>                * Note that both ways are indirect, though quite reliable. The problem is that in theory, there could be                cases when a thread running during a GC didn't toggle it. Also, GCs could be toggled for a number of                reasons, and resizing the heap is only one of them.            </p></aside>        </li></ol>    <p id="16e51e66">        Looking ahead, we can tell that the second way is much easier and slightly more reliable. Nevertheless, for        educational purposes, let's try both.    </p>    </div>    <div class="chapter"><h2 id="step-3-where-does-memory-traffic-come-from-analyzing-garbage-collections" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-3-where-does-memory-traffic-come-from-analyzing-garbage-collections">Step 3. Where does memory traffic come from? Analyzing garbage collections</h2>    <ol class="list _decimal"><li class="list__item" id="ad54f414"><p>            In the list of filters on the top of the <span class="control">Threads</span> window (or the            <span class="control">Performance Profiler</span>            window), select the            <span class="control">Blocking GC</span>            value in the            <span class="control">Blocking GC</span>            filter. The resulting filter will be            <i id="38bc946c">"Select all time intervals within the visible time range for all shown threads where                blocking GCs take place"</i>.            <figure><img alt="t2 blocking gc filter" title="t2 blocking gc filter" src="/help/img/dotnet/2019.2/t2_blocking_gc_filter.png" id="69d2f12e" width="258" height="100"></figure>        </p></li><li class="list__item" id="c93a0009">            <p id="87ca0583">Now, let's identify the thread where the GCs happen.* For example, we can suppose that this was the                <span class="control">Main</span>                thread.            </p>            <p id="ac63fb19">                Select the                <span class="control">Main</span>                thread on the                <span class="control">Threads</span>                diagram. The resulting filter is now                <i id="0eaa4b25">"Select all time intervals                    within the visible time range on the Main thread where blocking GCs take place"</i>.            </p>            <aside class="note " data-title="" rel="ac63fb19" id="0d9b49eb"><p>                * In a small application like ours, the answer lies on the surface.                On large solutions it won't be so obvious.            </p></aside>            <figure><img alt="t2 main thread filter" title="t2 main thread filter" src="/help/img/dotnet/2019.2/t2_main_thread_filter.png" id="b0ae7a32" width="612" height="241"></figure>        </li><li class="list__item" id="085235bd"><p>            Open and take a look at the            <span class="control">Thread States</span>            filter.            Now, it shows what the main thread did during all those GCs. Most of the time (<span class="control">97.3%</span>)            it was <span class="control">Waiting</span>. This means that GC took place on some other thread            (obviously on the <span class="control">FileProcessing</span> thread) and the main thread had to wait            until the GCs were finished.            <figure><img alt="t2 thread state filter" title="t2 thread state filter" src="/help/img/dotnet/2019.2/t2_thread_state_filter.png" id="afbb3895" width="184" height="123"></figure>            Now, let's find out what method in the            <span class="control">FileProcessing</span>            thread is to blame for all those GCs.        </p></li><li class="list__item" id="c45194b0"><p>            Remove the filter by Main thread. To do this, clear the corresponding check box in the list of threads.        </p></li><li class="list__item" id="4ba5ee95"><p>            Instead, select the            <span class="control">FileProcessing</span>            thread in the list. The resulting filter is now            <i id="4f24c0f6">"Select all time intervals within the visible                time range for the FileProcessing thread where blocking GCs take place"</i>.            <figure><img alt="t2 threadpool filter" title="t2 threadpool filter" src="/help/img/dotnet/2019.2/t2_threadpool_filter.png" id="4cbb2d3a" width="612" height="248"></figure>        </p></li><li class="list__item" id="d3d222cf"><p>            Look at the <span class="control">Thread State</span> filter.            It shows that 99.1% of the GC time the FileProccessing            thread was <span class="control">Running</span>.            This confirms that this thread is responsible for these GCs.            <figure><img alt="t2 running filter" title="t2 running filter" src="/help/img/dotnet/2019.2/t2_running_filter.png" id="1f19b8e4" width="183" height="123"></figure>        </p></li><li class="list__item" id="5be8879f"><p>            Select <span class="control">Running</span> in            <span class="control">Thread State</span>.        </p></li><li class="list__item" id="9c8fbc07">            In the <span class="control">Performance Profiler</span> tool window, click            <span class="control">Top Methods</span>            to see the list of user methods with the highest own time.            <figure><img alt="t2 top methods filter" title="t2 top methods filter" src="/help/img/dotnet/2019.2/t2_top_methods_filter.png" id="3b79342c" width="613" height="71"></figure>            Taking into account all applied filters,            <span class="control">Top Methods</span>            now shows the top methods* that triggered the GCs.            As you can see,            <code class="code">StringReverser.Reverse</code>            is the method that probably generates most of the memory traffic in            the application.            <aside class="note " data-title="" rel="003d8edf" id="3e3e1d18"><p>                * By execution time. The execution time of user methods is calculated as a sum of the own user method                time and the own time of all system methods it calls (down to the next user method in the stack).            </p></aside>        </li></ol>    </div>    <div class="chapter"><h2 id="step-3-where-does-memory-traffic-come-from-analyzing-memory-allocations" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-3-where-does-memory-traffic-come-from-analyzing-memory-allocations">Step 3. Where does memory traffic come from? Analyzing memory allocations</h2>    <p id="99de7480">        Now let's try a simpler way of analyzing memory traffic. As we mentioned earlier, the idea is to identify        methods        that allocate the largest amounts of memory.    </p>    <ol class="list _decimal"><li class="list__item" id="853e8163"><p>Remove all filters by clicking the            <img alt="t2 clear all filters" title="t2 clear all filters" src="/help/img/dotnet/2019.2/t2_clear_all_filters.png" id="59cc2665" width="18" height="18" class="inline-icon-18">            button            either in the <span class="control">Performance Profiler</span> or <span class="control">Threads</span> tool window.        </p></li><li class="list__item" id="38177127">            In the <span class="control">Events</span> filter, select            <span class="control">Memory Allocation</span>*.            <aside class="note " data-title="" rel="e49fd310" id="7d7d0e9f"><p>                * In addition to event tracing data (like states and times of operations, call stack data, so on),                dotTrace also collects data about memory allocation. This data can be selected as a separate subject for                analysis.            </p></aside>            <figure><img alt="t2 memory allocation filter" title="t2 memory allocation filter" src="/help/img/dotnet/2019.2/t2_memory_allocation_filter.png" id="bd4d2003" width="209" height="147"></figure>        </li><li class="list__item" id="a156ac96"><p>            Look at the            <span class="control">Threads</span>            diagram. The <span class="control">FileProcessing</span> thread allocates enormous amounts of            memory – 5882 MB. There is no doubt it's to blame for high memory traffic in our app.        </p></li><li class="list__item" id="c0e1f49d"><p>            Look at <span class="control">Top Methods</span>. Now, it sorts methods by the amount of allocated memory.            The <code class="code">StringReverser.Reverse</code> method is far behind with 5496 MB.            <figure><img alt="t2 top methods filter allocations" title="t2 top methods filter allocations" src="/help/img/dotnet/2019.2/t2_top_methods_filter_allocations.png" id="4897a38e" width="608" height="115"></figure>        </p></li></ol>    </div>    <div class="chapter"><h2 id="step-4-improving-the-code" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-4-improving-the-code">Step 4. Improving the code</h2>    <p id="aa49973d">Let's look at method's code and try to find out what is wrong with it.</p>    <ol class="list _decimal"><li class="list__item" id="29eeb1f7"><p>            Right click the <code class="code">StringReverser.Reverse</code> method in            <span class="control">Top Methods</span> and select <span class="control">Navigate to Code</span> in the context menu.            <figure><img alt="t2 top methods filter navigate to code" title="t2 top methods filter navigate to code" src="/help/img/dotnet/2019.2/t2_top_methods_filter_navigate_to_code.png" id="ed57531d" width="610" height="123"></figure>        </p></li><li class="list__item" id="4e7b4d60"><p>            Look at the code. It appears that this method is used to reverse lines from a text files.            It takes a string on input and returns the reversed string.            <div class="code-block" data-lang="csharp">
public string Reverse(string line)
{
    char[] charArray = line.ToCharArray();
    string stringResult = null;

    for (int i = charArray.Length; i &gt; 0; i--)
    {
        stringResult += charArray[i - 1];
    }
    return stringResult;
}
            </div>            Apparently, the problem is in the way it reverses a string. The thing is that string is an immutable type –            its contents cannot be changed after it is created. This means that each time we add a character to            <code class="code">stringResult</code> with the <code class="code">+=</code> operation, a new string is allocated in memory.            It would be much more effective to employ a special <code class="code">StringBuilder</code>            class or handle the string as an array of            <code class="code">char</code> and use the <code class="code">Reverse</code>method. Let's try the second option.        </p></li><li class="list__item" id="fe53c250"><p>            Correct the <code class="code">StringReverser.Reverse</code> method as shown below.            <div class="code-block" data-lang="csharp">
public string Reverse(string line)
{
    char[] charArray = line.ToCharArray();

    Array.Reverse(charArray);
    return new string(charArray);
}
            </div>        </p></li></ol>    </div>    <div class="chapter"><h2 id="1cfda6e5" data-toc="Optimize_App_Performance_and_Memory_Traffic#1cfda6e5">Step 5. Verifying the fix</h2>    <ol class="list _decimal"><li class="list__item" id="146e1664"><p>Rebuild the solution and perform profiling one more time as described in            <a href="#run_profiler">Step 1</a>.        </p></li><li class="list__item" id="e6b7a28a"><p>            After the snapshot is opened, switch            <span class="control">Events</span> to            <span class="control">Memory Allocation</span>.</p></li><li class="list__item" id="646225f3"><p>            Look at the            <span class="control">Threads</span>            diagram. Our improvement works! Memory traffic has reduced from almost 6 GB to 166 MB for the            <span class="control">FileProcessing</span> thread.            <figure><img alt="t2 performance profiler window fixed" title="t2 performance profiler window fixed" src="/help/img/dotnet/2019.2/t2_performance_profiler_window_fixed.png" id="38f13591" width="621" height="641"></figure>        </p></li><li class="list__item" id="66fd41c7"><p>            If you zoom into the time interval where            <span class="control">FileProcessing</span> processed files, you'll see that file processing has sped            up significantly. Now, it takes only about 300 ms to process all files, compared to 2 s before the fix.        </p></li></ol></div><div class="last-modified" data-skip-index="skip">Last modified: 19 September 2019 </div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Get_Started_with_Timeline_Viewer.html">Find the Cause of a UI Freeze</a><a class="navigation-links__next" href="Profile_Standalone_Application.html">Profile Standalone Application</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="//resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>