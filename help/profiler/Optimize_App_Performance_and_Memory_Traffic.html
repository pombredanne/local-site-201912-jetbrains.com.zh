<html lang="en-US" ><head><meta charset="UTF-8"><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                        '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                        })(window,document,'script','dataLayer','GTM-5P98');
                    </script><script src="/resources.jetbrains.com/storage/help-app/v3/analytics.js"></script><meta name="description" content="
        dotTrace how to, dotTrace tutorial, .NET performance tutorial, .NET memory management,
        .NET memory performance
    " data-skip-index="skip"><title>优化应用程序性能和内存流量-帮助|帮助dotTrace</title><link rel="stylesheet" href="/resources.jetbrains.com/storage/help-app/v3/app.css"></head><body  data-id="Optimize_App_Performance_and_Memory_Traffic" data-disqus-id="Optimize_App_Performance_and_Memory_Traffic_dt"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P98" height="0" width="0" style="display:none"></iframe></noscript><div class="wrapper"><section class="panel _nav" data-skip-index="skip"><header class="panel__header"><div class="container"><form class="search-box"><label class="search-box__label" for="search-box__input"><input type="text" class="search-box__input" id="search-box__input" placeholder="搜索dotTrace帮助"></label><div class="search-box__clear" title="明确"></div></form></div></header><nav class="panel__content"><div class="container _nav"><menu class="nav-tree"></menu></div><div class="container _footer panel__footer"><p><a href="#">发送反馈</a></p></div></nav></section><main class="panel _main"><header class="panel__header" data-skip-index="skip"><div class="container"><h3>dotTrace 2019.2帮助</h3><div class="shortcuts-switcher" data-skip-index="skip"><label for="switch-shortcuts">按键图：</label><select id="switch-shortcuts" class="select _shortcuts" height="1"><option value="rs" data-group="secondary">ReSharper 2.x / IntelliJ IDEA</option><option value="vs" data-group="primary">视觉工作室</option></select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 id="Optimize_App_Performance_and_Memory_Traffic.xml" data-toc="Optimize_App_Performance_and_Memory_Traffic">优化应用程序性能和内存流量</h1>        <p id="82eca913">警告！本教程是为dotTrace 2016.2编写的。请注意，dotTrace 2016.3中对一些UI控件（例如过滤器）进行了重新设计。例如，“ <span class="control">分析主题”</span>过滤器中的所有控件都移到“ <span class="control">事件”</span>过滤器下。</p>    <p id="8430df8d">众所周知，内存流量会严重影响应用程序性能：流量越高，应用程序速度越慢。问题不在于您的应用程序分配内存的频率（就性能而言几乎是免费的），而在于您的应用程序如何收集不再需要的内存。不幸的是，执行此操作的垃圾收集（GC）机制的便利性具有成本。</p>    <p id="691e406b">首先，GC本身需要一些CPU时间。例如，其阶段之一是检测未使用的对象，这是涉及构建对象参考图的复杂操作。其次，要执行Gen0和Gen1 GC *，垃圾收集器必须获得对一部分托管堆的互斥访问。反过来，这会挂起除触发“阻塞GC”的线程以外的所有托管线程。由于用户界面线程也被挂起，因此用户可能会在这些时候遇到UI冻结的情况。</p>    <p id="48851ece">因此，您应该始终尝试优化应用程序以减少内存流量，并最大程度地降低GC对应用程序响应速度的影响。</p>    <p id="36261d10">在本教程中，我们将学习如何使用时间轴分析来检测过多的GC及其原因。</p>    <aside class="note " rel="36261d10" id="d3e90d0d" data-title=""><p>*默认情况下，为桌面应用程序启用了所谓的后台垃圾收集。后台GC由单独的GC线程执行，并且在“最繁重的” Gen2收集期间不会挂起托管线程。但是，在Gen0和Gen1收集期间，必须暂停托管线程。因此，后台GC包含较短的“阻塞GC”间隔。</p></aside>    <div class="chapter"><h2 id="sample-application" data-toc="Optimize_App_Performance_and_Memory_Traffic#sample-application">样品申请</h2>    <p id="b57ae8cf">我们使用<a href="Get_Started_with_Timeline_Viewer.html">与“时间轴分析入门”</a>教程中相同的基本示例应用程序。此应用程序用于反转文本文件中的行，例如<code class="code">ABC</code> => <code class="code">CBA</code> 。</p>    <p id="a0edeb2d">该应用程序的源代码位于<a href="https://github.com/DarthWeirdo/dotTrace_Improving_Performance" rel="noopener noreferrer" data-external="true" target="_blank">github上</a> 。</p>    <figure><img alt="t2工作应用" title="t2工作应用" src="/help/img/dotnet/2019.2/t2_working_app.png" id="79941f18" width="478" height="125"></figure>    <p id="92963cdb">使用“ <span class="control">选择文件”</span>按钮，用户可以选择要处理的文本文件。“ <span class="control">处理文件”</span>按钮单独运行<code class="code">BackgroundWorker</code>线程（名为<span class="control">FileProcessing</span> ），它反转文件中的行。主窗口左上角的标签显示进度。处理完成后，标签显示“ <span class="control">所有文件已成功处理”</span> 。</p>    <p id="a1ed5fc2">想象以下情形：测试应用程序时，您发现处理文本文件的速度不如预期的快。此外，在某些情况下，文件处理期间会出现较小的延迟。</p>    <p id="c2992b39">让我们使用时间轴分析来分析这些性能缺陷！</p>    </div>    <div class="chapter"><h2 id="run_profiler" data-toc="Optimize_App_Performance_and_Memory_Traffic#run_profiler">步骤1。运行探查器并获取快照</h2>    <ol class="list _decimal"><li class="list__item" id="e5b03071"><p>在Visual Studio中打开<span class="filepath">MassFileProcessing.sln</span>解决方案。</p></li><li class="list__item" id="0d41d3d0"><p>通过选择<span class="menupath" data-skip-index="skip">ReSharper |</span>运行分析器<span class="menupath" data-skip-index="skip">。简介|运行启动配置性能分析...。</span></p></li><li class="list__item" id="2a336a70"><p>在“ <span class="control">分析”类型中</span> ，选择“ <span class="control">时间轴”</span> 。</p><figure><img alt="t2配置文件配置" title="t2配置文件配置" src="/help/img/dotnet/2019.2/t2_profiling_config.png" id="9c155cf2" width="685" height="472"></figure>        <p></p></li><li class="list__item" id="14316ace"><p>点击<span class="control">运行</span> 。 dotTrace将运行我们的应用程序，并显示一个用于控制配置过程的特殊控制器窗口。</p><figure><img alt="t1分析控制器" title="t1分析控制器" src="/help/img/dotnet/2019.2/t1_profiling_controller.png" id="954e5478" width="550" height="83"></figure>现在，让我们尝试在我们的应用程序中重现性能问题。<p></p></li><li class="list__item" id="7a75cf0b"><p>单击“ <span class="control">选择文件”，</span>然后在“ <span class="filepath">文本文件”文件</span>夹中选择应用程序随附的五个文本文件。</p><figure><img alt="t1应用" title="t1应用" src="/help/img/dotnet/2019.2/t1_app.png" id="e0ee0b30" width="478" height="125"></figure>        <p></p></li><li class="list__item" id="23a1f193"><p>单击“ <span class="control">处理文件”</span>以开始文件处理。</p></li><li class="list__item" id="7d27c42b"><p>处理结束后，通过单击控制器窗口中的“ <span class="control">获取快照并等待”</span>来收集时间轴概要分析快照。快照将在Visual Studio的单独<span class="control">Performance Profiler</span>工具窗口中打开。</p></li><li class="list__item" id="98995d81"><p>关闭应用程序。这也将关闭控制器窗口。</p></li></ol>    </div>    <div class="chapter"><h2 id="step-2-starting-analysis" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-2-starting-analysis">第2步。开始分析</h2>    <ol class="list _decimal"><li class="list__item" id="c4a24191">在<span class="control">Performance Profiler</span>工具窗口中，单击<span class="control">Show Threads</span> 。这将在单独的“ <span class="control">线程”</span>工具窗口中打开应用程序线程列表。<figure><img alt="t2性能分析器窗口" title="t2性能分析器窗口" src="/help/img/dotnet/2019.2/t2_performance_profiler_window.png" id="d3990992" width="620" height="708"></figure>您可以看到dotTrace已检测到多个托管线程。它们是<span class="control">Main</span>线程，用于执行后台GC的<span class="control">Garbage Collection</span>线程以及用于处理文件的<span class="control">FileProcessing</span>线程*。另外，有两个线程不起作用： <span class="control">终结器</span>线程和辅助<span class="control">线程池</span> 。<aside class="note " rel="f33116ce" id="55b9c1d1" data-title=""><p>*命名的线程在图中以黑体突出显示。</p></aside>        </li><li class="list__item" id="28740c16"><p>由于我们担心文件处理缓慢，因此让我们放大一下<span class="control">FileProcessing</span>线程处理文件的时间。为此，请在“ <span class="control">线程”</span>图上使用鼠标滚轮。</p><figure><img alt="t2线程已缩放" title="t2线程已缩放" src="/help/img/dotnet/2019.2/t2_threads_zoomed.png" id="3b89257a" width="610" height="243"></figure>这会按可见时间间隔（ <span class="control">1950 ms</span> ）自动添加过滤器。注意此过滤器如何影响其他过滤器：将重新计算可见时间范围内的所有值。现在应用于快照数据的过滤器是<i id="b3a73267">“为所有线程选择可见时间范围内的所有时间间隔”</i> 。让我们记住2秒是处理文件所需的大概时间。<p></p></li><li class="list__item" id="cee3410d">            <p id="1816d29c">在过程概述图上（在“ <span class="control">线程”</span>窗口的顶部），查看<span class="control">GC</span>栏。似乎在文件处理期间执行了许多阻止GC。这表明大量的内存流量毫无疑问会影响应用程序性能。</p>            <p id="b39ec1ea">现在，让我们找出此流量背后的真正原因。有两种方法可以完成此操作：</p>            <ul class="list _ul"><li class="list__item" id="648d08b9"><p>标识在GC中运行的线程和方法。这些必须是切换这些集合的线程和方法。</p></li><li class="list__item" id="892757c7"><p>确定分配内存主要部分的方法。逻辑很简单：切换GC的主要原因是由于内存分配而调整了堆大小。因此，如果一个方法分配大量内存，那么它也会触发很多GC。</p></li></ul>            <aside class="note " rel="023535b2" id="f50d8ef9" data-title=""><p>*请注意，尽管相当可靠，但这两种方式都是间接的。问题在于，从理论上讲，在GC中运行的线程可能无法切换它。同样，可以出于多种原因切换GC，并且调整堆大小只是其中之一。</p></aside>        </li></ol>    <p id="16e51e66">展望未来，我们可以说第二种方法更容易，更可靠。不过，出于教育目的，让我们尝试两者。</p>    </div>    <div class="chapter"><h2 id="step-3-where-does-memory-traffic-come-from-analyzing-garbage-collections" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-3-where-does-memory-traffic-come-from-analyzing-garbage-collections">第三步内存流量来自哪里？分析垃圾收集</h2>    <ol class="list _decimal"><li class="list__item" id="ad54f414"><p>在“ <span class="control">线程”</span>窗口（或“ <span class="control">性能分析器”</span>窗口）顶部的过滤器列表中，在“ <span class="control">阻止GC”</span>过滤器中选择“ <span class="control">阻止GC”</span>值。最终的过滤器将是<i id="38bc946c">“为发生阻塞的GC的所有显示线程选择可见时间范围内的所有时间间隔”</i> 。</p><figure><img alt="t2阻止gc过滤器" title="t2阻止gc过滤器" src="/help/img/dotnet/2019.2/t2_blocking_gc_filter.png" id="69d2f12e" width="258" height="100"></figure>        <p></p></li><li class="list__item" id="c93a0009">            <p id="87ca0583">现在，让我们确定发生GC的线程。*例如，我们可以假设这是<span class="control">Main</span>线程。</p>            <p id="ac63fb19">在“ <span class="control">线程”</span>图上选择“ <span class="control">主</span>线程”。现在生成的过滤器为<i id="0eaa4b25">“在发生阻塞GC的主线程上的可见时间范围内选择所有时间间隔”</i> 。</p>            <aside class="note " rel="ac63fb19" id="0d9b49eb" data-title=""><p>*在像我们这样的小型应用程序中，答案在于表面。在大型解决方案上，它不会那么明显。</p></aside>            <figure><img alt="t2主螺纹过滤器" title="t2主螺纹过滤器" src="/help/img/dotnet/2019.2/t2_main_thread_filter.png" id="b0ae7a32" width="612" height="241"></figure>        </li><li class="list__item" id="085235bd"><p>打开并查看“ <span class="control">线程状态”</span>过滤器。现在，它显示了所有这些GC期间主线程的操作。大多数时候（ <span class="control">97.3％</span> ）为<span class="control">等待中</span> 。这意味着GC在其他线程上发生（显然是在<span class="control">FileProcessing</span>线程上），并且主线程必须等待，直到GC完成。</p><figure><img alt="t2线程状态过滤器" title="t2线程状态过滤器" src="/help/img/dotnet/2019.2/t2_thread_state_filter.png" id="afbb3895" width="184" height="123"></figure>现在，让我们找出所有这些GC <span class="control">都应</span>归咎于<span class="control">FileProcessing</span>线程中的哪种方法。<p></p></li><li class="list__item" id="c45194b0"><p>用主螺纹卸下过滤器。为此，请清除线程列表中的相应复选框。</p></li><li class="list__item" id="4ba5ee95"><p>而是在列表中选择<span class="control">FileProcessing</span>线程。现在生成的过滤器是<i id="4f24c0f6">“为发生阻塞GC的FileProcessing线程选择可见时间范围内的所有时间间隔”</i> 。</p><figure><img alt="t2线程池过滤器" title="t2线程池过滤器" src="/help/img/dotnet/2019.2/t2_threadpool_filter.png" id="4cbb2d3a" width="612" height="248"></figure>        <p></p></li><li class="list__item" id="d3d222cf"><p>查看<span class="control">线程状态</span>过滤器。它显示FileProccessing线程正在<span class="control">运行</span> GC的时间的99.1％。这确认此线程负责这些GC。</p><figure><img alt="t2运行过滤器" title="t2运行过滤器" src="/help/img/dotnet/2019.2/t2_running_filter.png" id="1f19b8e4" width="183" height="123"></figure>        <p></p></li><li class="list__item" id="5be8879f"><p>选择<span class="control">“</span>在<span class="control">线程状态下</span> <span class="control">运行”</span> 。</p></li><li class="list__item" id="9c8fbc07">在“ <span class="control">性能分析器”</span>工具窗口中，单击“ <span class="control">最常用的方法”</span>以查看拥有最多使用时间的用户方法的列表。<figure><img alt="t2顶级方法过滤器" title="t2顶级方法过滤器" src="/help/img/dotnet/2019.2/t2_top_methods_filter.png" id="3b79342c" width="613" height="71"></figure>考虑到所有应用的过滤器后，“ <span class="control">Top Methods”</span>现在显示触发GC的top方法*。如你看到的， <code class="code">StringReverser.Reverse</code>是可能在应用程序中生成大部分内存流量的方法。<aside class="note " rel="003d8edf" id="3e3e1d18" data-title=""><p>*按执行时间。用户方法的执行时间是根据自己的用户方法时间和其调用的所有系统方法的时间（直到堆栈中的下一个用户方法）之和计算得出的。</p></aside>        </li></ol>    </div>    <div class="chapter"><h2 id="step-3-where-does-memory-traffic-come-from-analyzing-memory-allocations" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-3-where-does-memory-traffic-come-from-analyzing-memory-allocations">第三步内存流量来自哪里？分析内存分配</h2>    <p id="99de7480">现在让我们尝试一种更简单的分析内存流量的方法。如前所述，我们的想法是确定分配最大内存量的方法。</p>    <ol class="list _decimal"><li class="list__item" id="853e8163"><p>通过单击删除所有过滤器<img alt="t2清除所有过滤器" title="t2清除所有过滤器" src="/help/img/dotnet/2019.2/t2_clear_all_filters.png" id="59cc2665" width="18" height="18" class="inline-icon-18"> <span class="control">Performance Profiler</span>或<span class="control">Threads</span>工具窗口中的按钮。</p></li><li class="list__item" id="38177127">在“ <span class="control">事件”</span>过滤器中，选择“ <span class="control">内存分配</span> *”。<aside class="note " rel="e49fd310" id="7d7d0e9f" data-title=""><p>*除了事件跟踪数据（如状态和操作时间，调用堆栈数据等）之外，dotTrace还收集有关内存分配的数据。可以选择此数据作为单独的主题进行分析。</p></aside>            <figure><img alt="t2内存分配过滤器" title="t2内存分配过滤器" src="/help/img/dotnet/2019.2/t2_memory_allocation_filter.png" id="bd4d2003" width="209" height="147"></figure>        </li><li class="list__item" id="a156ac96"><p>查看<span class="control">线程</span>图。<span class="control">FileProcessing</span>线程分配大量内存– 5882 MB。毫无疑问，这归咎于我们应用程序中的高内存流量。</p></li><li class="list__item" id="c0e1f49d"><p>看看<span class="control">顶级方法</span> 。现在，它按分配的内存量对方法进行排序。的<code class="code">StringReverser.Reverse</code>方法远远落后于5496 MB。</p><figure><img alt="t2顶级方法过滤器分配" title="t2顶级方法过滤器分配" src="/help/img/dotnet/2019.2/t2_top_methods_filter_allocations.png" id="4897a38e" width="608" height="115"></figure>        <p></p></li></ol>    </div>    <div class="chapter"><h2 id="step-4-improving-the-code" data-toc="Optimize_App_Performance_and_Memory_Traffic#step-4-improving-the-code">第四步。改进代码</h2>    <p id="aa49973d">让我们看一下方法的代码，并尝试找出问题所在。</p>    <ol class="list _decimal"><li class="list__item" id="29eeb1f7"><p>右键点击<code class="code">StringReverser.Reverse</code> <span class="control">顶部方法中的方法，</span>然后在上下文菜单中选择<span class="control">导航到代码</span> 。</p><figure><img alt="t2顶级方法过滤器导航到代码" title="t2顶级方法过滤器导航到代码" src="/help/img/dotnet/2019.2/t2_top_methods_filter_navigate_to_code.png" id="ed57531d" width="610" height="123"></figure>        <p></p></li><li class="list__item" id="4e7b4d60"><p>看代码。看来，此方法用于反转文本文件中的行。它在输入时使用字符串，然后返回反转的字符串。</p><div class="code-block" data-lang="csharp">公共字符串反向（字符串行）{char [] charArray = line。ToCharArray（）;字符串stringResult = null;为（int i = charArray。长度; i> 0; i--）{stringResult + = charArray [i-1]; } return stringResult; }</div>显然，问题在于它反转字符串的方式。事实是，字符串是不可变的类型–创建后，其内容无法更改。这意味着每次我们向<code class="code">stringResult</code>与<code class="code">+=</code>操作时，将在内存中分配新的字符串。雇用一个特殊的人会更有效<code class="code">StringBuilder</code>类或将字符串作为数组处理<code class="code">char</code>并使用<code class="code">Reverse</code>方法。让我们尝试第二个选项。<p></p></li><li class="list__item" id="fe53c250"><p>纠正<code class="code">StringReverser.Reverse</code>方法如下图所示。</p><div class="code-block" data-lang="csharp">公共字符串反向（字符串行）{char [] charArray = line。ToCharArray（）;数组。反向（charArray）;返回新的字符串（charArray）; }</div>        <p></p></li></ol>    </div>    <div class="chapter"><h2 id="1cfda6e5" data-toc="Optimize_App_Performance_and_Memory_Traffic#1cfda6e5">步骤五验证修复</h2>    <ol class="list _decimal"><li class="list__item" id="146e1664"><p>重建解决方案，并按<a href="#run_profiler">步骤1</a>所述再进行一次配置。</p></li><li class="list__item" id="e6b7a28a"><p>打开快照后，将“ <span class="control">事件”</span>切换到“ <span class="control">内存分配”</span> 。</p></li><li class="list__item" id="646225f3"><p>查看<span class="control">线程</span>图。我们的改善工程！<span class="control">FileProcessing</span>线程的内存流量已从近6 GB减少到166 MB。</p><figure><img alt="T2性能分析器窗口已修复" title="T2性能分析器窗口已修复" src="/help/img/dotnet/2019.2/t2_performance_profiler_window_fixed.png" id="38f13591" width="621" height="641"></figure>        <p></p></li><li class="list__item" id="66fd41c7"><p>如果放大到<span class="control">FileProcessing</span>处理文件的时间间隔，则会看到文件处理显着加快。现在，处理所有文件只需要300毫秒，而修复前为2 s。</p></li></ol></div><div class="last-modified" data-skip-index="skip">上次修改时间：2019年9月19日</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom" data-skip-index="skip"><a class="navigation-links__prev" href="Get_Started_with_Timeline_Viewer.html">查找UI冻结</a> <a class="navigation-links__next" href="Profile_Standalone_Application.html">配置文件独立应用程序</a> <a class="navigation-links__prev" href="Get_Started_with_Timeline_Viewer.html">的原因</a></div></article><div id="disqus_thread" data-skip-index="skip"></div></div></section></main></div><script src="/resources.jetbrains.com/storage/help-app/v3/app.js"></script></body></html>